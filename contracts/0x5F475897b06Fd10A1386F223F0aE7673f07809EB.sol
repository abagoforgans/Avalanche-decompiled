contract main {




// =====================  Runtime code  =====================


#
#  - sub_1781d399(?)
#  - sub_276f8dd4(?)
#  - sub_3ec6cb08(?)
#  - _getNodesRewardAvailable(address arg1)
#  - sub_599a4e52(?)
#  - _getNodeRewardAmountOf(address arg1, uint256 arg2)
#  - _cashoutNodeReward(address arg1, uint256 arg2)
#  - sub_9bc7d477(?)
#  - _getRewardAmountOf(address arg1, uint256 arg2)
#  - sub_e0f2cfd8(?)
#  - sub_e18c4487(?)
#
uint8 stor0; offset 160
address stor0;
uint256 stor0;
mapping of uint8 stor1;
uint256 stor2;
uint256 stor3;
address zeusAddress;
address sub_85c2d7b2Address;
array of struct stor10;
mapping of address _referrals;
mapping of uint256 sub_e27e434a;
mapping of uint256 sub_666755bb;
array of struct sub_989baf69;
uint256 nodePrice;
uint256 rewardPerNode;
uint256 claimTime;
address gateKeeperAddress;
address tokenAddress;
uint256 totalNodesCreated;
uint256 totalRewardStaked;
uint256 referralBonusPercent;

function claimTime() payable {
    return claimTime
}

function gateKeeper() payable {
    return gateKeeperAddress
}

function rewardPerNode() payable {
    return rewardPerNode
}

function sub_666755bb(?) payable {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    return sub_666755bb[arg1]
}

function Zeus() payable {
    return zeusAddress
}

function sub_85c2d7b2(?) payable {
    return sub_85c2d7b2Address
}

function _referrals(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    return _referrals[arg1]
}

function totalRewardStaked() payable {
    return totalRewardStaked
}

function sub_989baf69(?) payable {
    require calldata.size - 4 >= 64
    require arg1 == address(arg1)
    require arg2 < sub_989baf69[arg1].field_0
    return sub_989baf69[arg1][arg2].field_0
}

function totalNodesCreated() payable {
    return totalNodesCreated
}

function sub_ba370651(?) payable {
    require calldata.size - 4 >= 64
    require arg1 == address(arg1)
    return bool(uint8(stor1[arg1][arg2]))
}

function sub_e27e434a(?) payable {
    require calldata.size - 4 >= 64
    require arg1 == address(arg1)
    require arg2 == address(arg2)
    return sub_e27e434a[arg1][arg2]
}

function referralBonusPercent() payable {
    return referralBonusPercent
}

function nodePrice() payable {
    return nodePrice
}

function token() payable {
    return tokenAddress
}

function _fallback() payable {
    revert
}

function sub_14b80630(?) payable {
    if uint8(stor0.field_160):
        revert with 0, 'ALREADY INITIALIZED'
    uint256(stor0.field_0) = msg.sender or Mask(96, 160, uint256(stor0.field_0))
}

function _changeNodePrice(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if tokenAddress != msg.sender:
        if gateKeeperAddress != msg.sender:
            if address(stor0.field_0) != msg.sender:
                revert with 0, 'NodeManagerV2: NOT AUTHORIZED'
    nodePrice = arg1
}

function _changeClaimTime(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if tokenAddress != msg.sender:
        if gateKeeperAddress != msg.sender:
            if address(stor0.field_0) != msg.sender:
                revert with 0, 'NodeManagerV2: NOT AUTHORIZED'
    claimTime = arg1
}

function _changeRewardPerNode(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if tokenAddress != msg.sender:
        if gateKeeperAddress != msg.sender:
            if address(stor0.field_0) != msg.sender:
                revert with 0, 'NodeManagerV2: NOT AUTHORIZED'
    rewardPerNode = arg1
}

function setReferralBonus(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if tokenAddress != msg.sender:
        if gateKeeperAddress != msg.sender:
            if address(stor0.field_0) != msg.sender:
                revert with 0, 'NodeManagerV2: NOT AUTHORIZED'
    referralBonusPercent = arg1
}

function sub_f4887f15(?) payable {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    if tokenAddress != msg.sender:
        if gateKeeperAddress != msg.sender:
            if address(stor0.field_0) != msg.sender:
                revert with 0, 'NodeManagerV2: NOT AUTHORIZED'
    gateKeeperAddress = address(arg1)
}

function sub_b8c7a1a2(?) payable {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    if tokenAddress != msg.sender:
        if gateKeeperAddress != msg.sender:
            if address(stor0.field_0) != msg.sender:
                revert with 0, 'NodeManagerV2: NOT AUTHORIZED'
    return sub_666755bb[address(arg1)]
}

function sub_f3a769e3(?) payable {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    if tokenAddress != msg.sender:
        if gateKeeperAddress != msg.sender:
            if address(stor0.field_0) != msg.sender:
                revert with 0, 'NodeManagerV2: NOT AUTHORIZED'
    sub_85c2d7b2Address = address(arg1)
}

function setToken(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if tokenAddress != msg.sender:
        if gateKeeperAddress != msg.sender:
            if address(stor0.field_0) != msg.sender:
                revert with 0, 'NodeManagerV2: NOT AUTHORIZED'
    zeusAddress = arg1
    tokenAddress = arg1
}

function sub_d2b6fc4c(?) payable {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    if tokenAddress != msg.sender:
        if gateKeeperAddress != msg.sender:
            if address(stor0.field_0) != msg.sender:
                revert with 0, 'NodeManagerV2: NOT AUTHORIZED'
    sub_666755bb[address(arg1)] = 0
    return sub_666755bb[address(arg1)]
}

function _getNodeNumberOf(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    delegate 0x4b7a346b17572634bdbd85b98abae32c5fa837bb.0x732a2ccf with:
         gas gas_remaining wei
        args 6, arg1
    if not delegate.return_code:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    return delegate.return_data[0]
}

function _isNodeOwner(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    delegate 0x4b7a346b17572634bdbd85b98abae32c5fa837bb.0x732a2ccf with:
         gas gas_remaining wei
        args 6, arg1
    if not delegate.return_code:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    return (delegate.return_data[0] > 0)
}

function sub_58045442(?) payable {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    if tokenAddress != msg.sender:
        if gateKeeperAddress != msg.sender:
            if address(stor0.field_0) != msg.sender:
                revert with 0, 'NodeManagerV2: NOT AUTHORIZED'
    require ext_code.size(zeusAddress)
    call zeusAddress.0xf2fde38b with:
         gas gas_remaining wei
        args address(arg1)
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
}

function sub_980bfe27(?) payable {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    if tokenAddress != msg.sender:
        if gateKeeperAddress != msg.sender:
            if address(stor0.field_0) != msg.sender:
                revert with 0, 'NodeManagerV2: NOT AUTHORIZED'
    if stor10[stor11[address(arg1)]].field_0:
        if not -referralBonusPercent:
            sub_e27e434a[stor11[address(arg1)]][address(arg1)] = 0
            if sub_666755bb[stor11[address(arg1)]] > -1:
                revert with 0, 17
        else:
            if referralBonusPercent and nodePrice > -1 / referralBonusPercent:
                revert with 0, 17
            if not referralBonusPercent:
                revert with 0, 18
            if referralBonusPercent * nodePrice / referralBonusPercent != nodePrice:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
            sub_e27e434a[stor11[address(arg1)]][address(arg1)] = referralBonusPercent * nodePrice / 100
            if sub_666755bb[stor11[address(arg1)]] > !(referralBonusPercent * nodePrice / 100):
                revert with 0, 17
            sub_666755bb[stor11[address(arg1)]] += referralBonusPercent * nodePrice / 100
}

function init() payable {
    if uint8(stor0.field_160):
        revert with 0, 'ALREADY INITIALIZED'
    uint256(stor0.field_0) = msg.sender or Mask(96, 160, uint256(stor0.field_0))
    uint8(stor0.field_160) = 1
    call sub_85c2d7b2Address.0xf1fec2b8 with:
         gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    nodePrice = ext_call.return_data[0]
    rewardPerNode = 5787037037037
    claimTime = 1
    call sub_85c2d7b2Address.0x45d61ded with:
         gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    gateKeeperAddress = ext_call.return_data[12 len 20]
    call sub_85c2d7b2Address.0xfc0c546a with:
         gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    tokenAddress = ext_call.return_data[12 len 20]
    zeusAddress = ext_call.return_data[12 len 20]
    call sub_85c2d7b2Address.0xb8527aef with:
         gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    totalNodesCreated = ext_call.return_data[0]
    call sub_85c2d7b2Address.0x8a327eaa with:
         gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    totalRewardStaked = ext_call.return_data[0]
}

function getReferrals(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if tokenAddress != msg.sender:
        if gateKeeperAddress != msg.sender:
            if address(stor0.field_0) != msg.sender:
                revert with 0, 'NodeManagerV2: NOT AUTHORIZED'
    mem[64] = (32 * sub_989baf69[address(arg1)].field_0) + 128
    mem[96] = sub_989baf69[address(arg1)].field_0
    if not sub_989baf69[address(arg1)].field_0:
        mem[(32 * sub_989baf69[address(arg1)].field_0) + 128] = 32
        mem[(32 * sub_989baf69[address(arg1)].field_0) + 160] = sub_989baf69[address(arg1)].field_0
        idx = 0
        s = (32 * sub_989baf69[address(arg1)].field_0) + 192
        t = 128
        while idx < sub_989baf69[address(arg1)].field_0:
            mem[s] = mem[t + 12 len 20]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        return memory
          from (32 * sub_989baf69[address(arg1)].field_0) + 128
           len (96 * sub_989baf69[address(arg1)].field_0) + 64
    mem[128] = sub_989baf69[address(arg1)].field_0
    idx = 128
    s = 0
    while (32 * sub_989baf69[address(arg1)].field_0) + 96 > idx:
        mem[idx + 32] = sub_989baf69[address(arg1)][s].field_256
        idx = idx + 32
        s = s + 1
        continue 
    mem[(32 * sub_989baf69[address(arg1)].field_0) + 128] = 32
    mem[(32 * sub_989baf69[address(arg1)].field_0) + 160] = sub_989baf69[address(arg1)].field_0
    idx = 0
    s = mem[64] + 64
    t = 128
    while idx < sub_989baf69[address(arg1)].field_0:
        mem[s] = mem[t + 12 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    return memory
      from mem[64]
       len (64 * sub_989baf69[address(arg1)].field_0) + -mem[64] + 192
}

function finalizeMigration() payable {
    if tokenAddress != msg.sender:
        if gateKeeperAddress != msg.sender:
            if address(stor0.field_0) != msg.sender:
                revert with 0, 'NodeManagerV2: NOT AUTHORIZED'
    require ext_code.size(zeusAddress)
    call zeusAddress.0x8013858b with:
         gas gas_remaining wei
        args -1
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require ext_code.size(zeusAddress)
    call zeusAddress.0x7b770392 with:
         gas gas_remaining wei
        args 0
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require ext_code.size(zeusAddress)
    call zeusAddress.0x9c82751c with:
         gas gas_remaining wei
        args -1
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    call zeusAddress.0xa0a8fe65 with:
         gas gas_remaining wei
    require return_data.size >= 32
    totalNodesCreated = ext_call.return_data[0]
    call zeusAddress.0x48e5642b with:
         gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    totalRewardStaked = ext_call.return_data[0]
    require ext_code.size(zeusAddress)
    call zeusAddress.0xfb0a7494 with:
         gas gas_remaining wei
        args this.address
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    staticcall zeusAddress.0x7628b3d7 with:
            gas gas_remaining wei
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    if ext_call.return_data[12 len 20] != this.address:
        revert with 0, 'UPDATING NODE MANAGER FAILED!'
    require ext_code.size(zeusAddress)
    call zeusAddress.0xf2fde38b with:
         gas gas_remaining wei
        args gateKeeperAddress
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    staticcall zeusAddress.0x8da5cb5b with:
            gas gas_remaining wei
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    if ext_call.return_data[12 len 20] != 0xb223d4e661ecf6ced8bb6c99edb87b3331cbd7e3:
        revert with 0, 'UPDATING OWNER FAILED!'
    stor2 = block.timestamp
    stor3 = block.number
}

function _nodesOfUser(address arg1, uint256 arg2) payable {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require arg2 < stor10[arg1].field_0
    if stor10[arg1][arg2].field_0:
        if not stor10[arg1][arg2].field_0 - (uint255(stor10[arg1][arg2].field_0) * 0.5 < 32):
            revert with 0, 34
        if stor10[arg1][arg2].field_0:
            if not stor10[arg1][arg2].field_0 - (uint255(stor10[arg1][arg2].field_0) * 0.5 < 32):
                revert with 0, 34
            if Mask(256, -1, stor10[arg1][arg2].field_0):
                if 31 >= uint255(stor10[arg1][arg2].field_0) * 0.5:
                    mem[128] = 256 * stor10[arg1][arg2].field_8
                else:
                    mem[128] = stor10[arg1][arg2].field_0
                    idx = 128
                    s = 0
                    while (uint255(stor10[arg1][arg2].field_0) * 0.5) + 96 > idx:
                        mem[idx + 32] = stor10[arg1][(4 * arg2) + s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
        else:
            if not stor10[arg1][arg2].field_0 - (stor10[arg1][arg2].field_1 < 32):
                revert with 0, 34
            if stor10[arg1][arg2].field_1:
                if 31 >= stor10[arg1][arg2].field_1:
                    mem[128] = 256 * stor10[arg1][arg2].field_8
                else:
                    mem[128] = stor10[arg1][arg2].field_0
                    idx = 128
                    s = 0
                    while stor10[arg1][arg2].field_1 + 96 > idx:
                        mem[idx + 32] = stor10[arg1][(4 * arg2) + s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
        return Array(len=2 * Mask(256, -1, stor10[arg1][arg2].field_0), data=mem[128 len ceil32(uint255(stor10[arg1][arg2].field_0) * 0.5)]), 
               stor10[arg1][arg2].field_256,
               stor10[arg1][arg2].field_512,
               stor10[arg1][arg2].field_768
    if not stor10[arg1][arg2].field_0 - (stor10[arg1][arg2].field_1 < 32):
        revert with 0, 34
    if stor10[arg1][arg2].field_0:
        if not stor10[arg1][arg2].field_0 - (uint255(stor10[arg1][arg2].field_0) * 0.5 < 32):
            revert with 0, 34
        if Mask(256, -1, stor10[arg1][arg2].field_0):
            if 31 >= uint255(stor10[arg1][arg2].field_0) * 0.5:
                mem[128] = 256 * stor10[arg1][arg2].field_8
            else:
                mem[128] = stor10[arg1][arg2].field_0
                idx = 128
                s = 0
                while (uint255(stor10[arg1][arg2].field_0) * 0.5) + 96 > idx:
                    mem[idx + 32] = stor10[arg1][(4 * arg2) + s].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
    else:
        if not stor10[arg1][arg2].field_0 - (stor10[arg1][arg2].field_1 < 32):
            revert with 0, 34
        if stor10[arg1][arg2].field_1:
            if 31 >= stor10[arg1][arg2].field_1:
                mem[128] = 256 * stor10[arg1][arg2].field_8
            else:
                mem[128] = stor10[arg1][arg2].field_0
                idx = 128
                s = 0
                while stor10[arg1][arg2].field_1 + 96 > idx:
                    mem[idx + 32] = stor10[arg1][(4 * arg2) + s].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
    return Array(len=stor10[arg1][arg2].field_0, data=mem[128 len ceil32(stor10[arg1][arg2].field_1)]), 
           stor10[arg1][arg2].field_256,
           stor10[arg1][arg2].field_512,
           stor10[arg1][arg2].field_768
}

function _getNodesNames(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    mem[0] = arg1
    mem[32] = 10
    mem[64] = (32 * stor10[address(arg1)].field_0) + 128
    mem[96] = stor10[address(arg1)].field_0
    s = 128
    idx = 0
    while idx < stor10[address(arg1)].field_0:
        mem[0] = sha3(address(arg1), 10)
        _51 = mem[64]
        mem[64] = mem[64] + 128
        if stor10[address(arg1)][idx].field_0:
            if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                revert with 0, 34
            _57 = mem[64]
            mem[64] = mem[64] + ceil32(uint255(stor10[address(arg1)][idx].field_0) * 0.5) + 32
            mem[_57] = uint255(stor10[address(arg1)][idx].field_0) * 0.5
            if stor10[address(arg1)][idx].field_0:
                if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                    revert with 0, 34
                if Mask(256, -1, stor10[address(arg1)][idx].field_0):
                    if 31 >= uint255(stor10[address(arg1)][idx].field_0) * 0.5:
                        mem[_57 + 32] = 256 * stor10[address(arg1)][idx].field_8
                    else:
                        mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                        mem[_57 + 32] = stor10[address(arg1)][idx].field_0
                        t = _57 + 32
                        u = sha3(mem[0])
                        while _57 + (uint255(stor10[address(arg1)][idx].field_0) * 0.5) > t:
                            mem[t + 32] = uint256(stor1[u])
                            t = t + 32
                            u = u + 1
                            continue 
                mem[_51] = _57
                mem[_51 + 32] = stor10[address(arg1)][idx].field_256
                mem[_51 + 64] = stor10[address(arg1)][idx].field_512
                mem[_51 + 96] = stor10[address(arg1)][idx].field_768
                mem[s] = _51
                s = s + 32
                idx = idx + 1
                continue 
            if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                revert with 0, 34
            if not stor10[address(arg1)][idx].field_1:
                mem[_51] = _57
                mem[_51 + 32] = stor10[address(arg1)][idx].field_256
                mem[_51 + 64] = stor10[address(arg1)][idx].field_512
                mem[_51 + 96] = stor10[address(arg1)][idx].field_768
                mem[s] = _51
                s = s + 32
                idx = idx + 1
                continue 
            if 31 >= stor10[address(arg1)][idx].field_1:
                mem[_57 + 32] = 256 * stor10[address(arg1)][idx].field_8
                mem[_51] = _57
                mem[_51 + 32] = stor10[address(arg1)][idx].field_256
                mem[_51 + 64] = stor10[address(arg1)][idx].field_512
                mem[_51 + 96] = stor10[address(arg1)][idx].field_768
                mem[s] = _51
                s = s + 32
                idx = idx + 1
                continue 
            mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
            mem[_57 + 32] = stor10[address(arg1)][idx].field_0
            t = _57 + 32
            u = sha3(mem[0])
            while _57 + stor10[address(arg1)][u].field_1 > t:
                mem[t + 32] = uint256(stor1[u])
                t = t + 32
                u = u + 1
                continue 
            mem[_51] = _57
            mem[_51 + 32] = stor10[address(arg1)][u].field_256
            mem[_51 + 64] = stor10[address(arg1)][u].field_512
            mem[_51 + 96] = stor10[address(arg1)][u].field_768
            mem[t] = _51
            t = t + 32
            u = u + 1
            continue 
        if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
            revert with 0, 34
        _62 = mem[64]
        mem[64] = mem[64] + ceil32(stor10[address(arg1)][idx].field_1) + 32
        mem[_62] = stor10[address(arg1)][idx].field_1
        if stor10[address(arg1)][idx].field_0:
            if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                revert with 0, 34
            if not Mask(256, -1, stor10[address(arg1)][idx].field_0):
                mem[_51] = _62
                mem[_51 + 32] = stor10[address(arg1)][idx].field_256
                mem[_51 + 64] = stor10[address(arg1)][idx].field_512
                mem[_51 + 96] = stor10[address(arg1)][idx].field_768
                mem[s] = _51
                s = s + 32
                idx = idx + 1
                continue 
            if 31 >= uint255(stor10[address(arg1)][idx].field_0) * 0.5:
                mem[_62 + 32] = 256 * stor10[address(arg1)][idx].field_8
                mem[_51] = _62
                mem[_51 + 32] = stor10[address(arg1)][idx].field_256
                mem[_51 + 64] = stor10[address(arg1)][idx].field_512
                mem[_51 + 96] = stor10[address(arg1)][idx].field_768
                mem[s] = _51
                s = s + 32
                idx = idx + 1
                continue 
            mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
            mem[_62 + 32] = stor10[address(arg1)][idx].field_0
            t = _62 + 32
            u = sha3(mem[0])
            while _62 + (uint255(stor10[address(arg1)][u].field_0) * 0.5) > t:
                mem[t + 32] = uint256(stor1[u])
                t = t + 32
                u = u + 1
                continue 
            mem[_51] = _62
            mem[_51 + 32] = stor10[address(arg1)][u].field_256
            mem[_51 + 64] = stor10[address(arg1)][u].field_512
            mem[_51 + 96] = stor10[address(arg1)][u].field_768
            mem[t] = _51
            t = t + 32
            u = u + 1
            continue 
        if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
            revert with 0, 34
        if stor10[address(arg1)][idx].field_1:
            if 31 >= stor10[address(arg1)][idx].field_1:
                mem[_62 + 32] = 256 * stor10[address(arg1)][idx].field_8
            else:
                mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                mem[_62 + 32] = stor10[address(arg1)][idx].field_0
                t = _62 + 32
                u = sha3(mem[0])
                while _62 + stor10[address(arg1)][idx].field_1 > t:
                    mem[t + 32] = uint256(stor1[u])
                    t = t + 32
                    u = u + 1
                    continue 
        mem[_51] = _62
        mem[_51 + 32] = stor10[address(arg1)][idx].field_256
        mem[_51 + 64] = stor10[address(arg1)][idx].field_512
        mem[_51 + 96] = stor10[address(arg1)][idx].field_768
        mem[s] = _51
        s = s + 32
        idx = idx + 1
        continue 
    _48 = mem[96]
    _49 = mem[64]
    mem[64] = mem[64] + 128
    mem[_49] = 96
    mem[_49 + 32] = 0
    mem[_49 + 64] = 0
    mem[_49 + 96] = 0
    if 0 >= mem[96]:
        revert with 0, 50
    _54 = mem[mem[128]]
    _55 = mem[64]
    mem[64] = mem[64] + 64
    mem[_55] = 1
    mem[_55 + 32] = 0x2300000000000000000000000000000000000000000000000000000000000000
    idx = 1
    s = _54
    t = _49
    while idx < _48:
        if idx >= mem[96]:
            revert with 0, 50
        _95 = mem[(32 * idx) + 128]
        _96 = mem[mem[(32 * idx) + 128]]
        _97 = mem[64]
        _98 = mem[s]
        t = 0
        while t < _98:
            mem[t + _97 + 32] = mem[t + s + 32]
            t = t + 32
            continue 
        if ceil32(_98) <= _98:
            _126 = mem[_55]
            s = 0
            while s < _126:
                mem[s + _97 + _98 + 32] = mem[s + _55 + 32]
                s = s + 32
                continue 
            if ceil32(_126) <= _126:
                _150 = mem[_96]
                s = 0
                while s < _150:
                    mem[s + _97 + _98 + _126 + 32] = mem[s + _96 + 32]
                    s = s + 32
                    continue 
                if ceil32(_150) <= _150:
                    _170 = mem[64]
                    mem[mem[64]] = _150 + _97 + _98 + _126 - mem[64]
                    mem[64] = _150 + _97 + _98 + _126 + 32
                    if not idx + 1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _170
                    t = _95
                    continue 
                mem[_150 + _97 + _98 + _126 + 32] = 0
                _171 = mem[64]
                mem[mem[64]] = _150 + _97 + _98 + _126 - mem[64]
                mem[64] = _150 + _97 + _98 + _126 + 32
                if not idx + 1:
                    revert with 0, 17
                idx = idx + 1
                s = _171
                t = _95
                continue 
            mem[_126 + _97 + _98 + 32] = 0
            _151 = mem[_96]
            s = 0
            while s < _151:
                mem[s + _97 + _98 + _126 + 32] = mem[s + _96 + 32]
                s = s + 32
                continue 
            if ceil32(_151) <= _151:
                _172 = mem[64]
                mem[mem[64]] = _151 + _97 + _98 + _126 - mem[64]
                mem[64] = _151 + _97 + _98 + _126 + 32
                if not idx + 1:
                    revert with 0, 17
                idx = idx + 1
                s = _172
                t = _95
                continue 
            mem[_151 + _97 + _98 + _126 + 32] = 0
            _173 = mem[64]
            mem[mem[64]] = _151 + _97 + _98 + _126 - mem[64]
            mem[64] = _151 + _97 + _98 + _126 + 32
            if not idx + 1:
                revert with 0, 17
            idx = idx + 1
            s = _173
            t = _95
            continue 
        mem[_98 + _97 + 32] = 0
        _127 = mem[_55]
        s = 0
        while s < _127:
            mem[s + _97 + _98 + 32] = mem[s + _55 + 32]
            s = s + 32
            continue 
        if ceil32(_127) <= _127:
            _152 = mem[_96]
            s = 0
            while s < _152:
                mem[s + _97 + _98 + _127 + 32] = mem[s + _96 + 32]
                s = s + 32
                continue 
            if ceil32(_152) <= _152:
                _174 = mem[64]
                mem[mem[64]] = _152 + _97 + _98 + _127 - mem[64]
                mem[64] = _152 + _97 + _98 + _127 + 32
                if not idx + 1:
                    revert with 0, 17
                idx = idx + 1
                s = _174
                t = _95
                continue 
            mem[_152 + _97 + _98 + _127 + 32] = 0
            _175 = mem[64]
            mem[mem[64]] = _152 + _97 + _98 + _127 - mem[64]
            mem[64] = _152 + _97 + _98 + _127 + 32
            if not idx + 1:
                revert with 0, 17
            idx = idx + 1
            s = _175
            t = _95
            continue 
        mem[_127 + _97 + _98 + 32] = 0
        _153 = mem[_96]
        s = 0
        while s < _153:
            mem[s + _97 + _98 + _127 + 32] = mem[s + _96 + 32]
            s = s + 32
            continue 
        if ceil32(_153) <= _153:
            _176 = mem[64]
            mem[mem[64]] = _153 + _97 + _98 + _127 - mem[64]
            mem[64] = _153 + _97 + _98 + _127 + 32
            if not idx + 1:
                revert with 0, 17
            idx = idx + 1
            s = _176
            t = _95
            continue 
        mem[_153 + _97 + _98 + _127 + 32] = 0
        _177 = mem[64]
        mem[mem[64]] = _153 + _97 + _98 + _127 - mem[64]
        mem[64] = _153 + _97 + _98 + _127 + 32
        if not idx + 1:
            revert with 0, 17
        idx = idx + 1
        s = _177
        t = _95
        continue 
    _94 = mem[64]
    mem[mem[64]] = 32
    _99 = mem[s]
    mem[mem[64] + 32] = mem[s]
    mem[mem[64] + 64 len ceil32(_99)] = mem[s + 32 len ceil32(_99)]
    if ceil32(_99) <= _99:
        return 32, mem[mem[64] + 32 len ceil32(_99) + 32]
    mem[_99 + mem[64] + 64] = 0
    return memory
      from mem[64]
       len ceil32(_99) + _94 + -mem[64] + 64
}

function sub_26a92494(?) payable {
    require calldata.size - 4 >= 64
    require arg1 == address(arg1)
    require arg2 == address(arg2)
    if msg.sender == tokenAddress:
        mem[0] = address(arg1)
        mem[64] = (32 * stor10[address(arg1)].field_0) + 128
        mem[96] = stor10[address(arg1)].field_0
        s = 128
        idx = 0
        while idx < stor10[address(arg1)].field_0:
            mem[0] = sha3(address(arg1), 10)
            _312 = mem[64]
            mem[64] = mem[64] + 128
            if stor10[address(arg1)][idx].field_0:
                if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                    revert with 0, 34
                _330 = mem[64]
                mem[64] = mem[64] + ceil32(uint255(stor10[address(arg1)][idx].field_0) * 0.5) + 32
                mem[_330] = uint255(stor10[address(arg1)][idx].field_0) * 0.5
                if stor10[address(arg1)][idx].field_0:
                    if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                        revert with 0, 34
                    if Mask(256, -1, stor10[address(arg1)][idx].field_0):
                        if 31 >= uint255(stor10[address(arg1)][idx].field_0) * 0.5:
                            mem[_330 + 32] = 256 * stor10[address(arg1)][idx].field_8
                        else:
                            mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                            mem[_330 + 32] = stor10[address(arg1)][idx].field_0
                            t = _330 + 32
                            u = sha3(mem[0])
                            while _330 + (uint255(stor10[address(arg1)][idx].field_0) * 0.5) > t:
                                mem[t + 32] = uint256(stor1[u])
                                t = t + 32
                                u = u + 1
                                continue 
                    mem[_312] = _330
                    mem[_312 + 32] = stor10[address(arg1)][idx].field_256
                    mem[_312 + 64] = stor10[address(arg1)][idx].field_512
                    mem[_312 + 96] = stor10[address(arg1)][idx].field_768
                    mem[s] = _312
                    s = s + 32
                    idx = idx + 1
                    continue 
                if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                    revert with 0, 34
                if not stor10[address(arg1)][idx].field_1:
                    mem[_312] = _330
                    mem[_312 + 32] = stor10[address(arg1)][idx].field_256
                    mem[_312 + 64] = stor10[address(arg1)][idx].field_512
                    mem[_312 + 96] = stor10[address(arg1)][idx].field_768
                    mem[s] = _312
                    s = s + 32
                    idx = idx + 1
                    continue 
                if 31 >= stor10[address(arg1)][idx].field_1:
                    mem[_330 + 32] = 256 * stor10[address(arg1)][idx].field_8
                    mem[_312] = _330
                    mem[_312 + 32] = stor10[address(arg1)][idx].field_256
                    mem[_312 + 64] = stor10[address(arg1)][idx].field_512
                    mem[_312 + 96] = stor10[address(arg1)][idx].field_768
                    mem[s] = _312
                    s = s + 32
                    idx = idx + 1
                    continue 
                mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                mem[_330 + 32] = stor10[address(arg1)][idx].field_0
                t = _330 + 32
                u = sha3(mem[0])
                while _330 + stor10[address(arg1)][u].field_1 > t:
                    mem[t + 32] = uint256(stor1[u])
                    t = t + 32
                    u = u + 1
                    continue 
                mem[_312] = _330
                mem[_312 + 32] = stor10[address(arg1)][u].field_256
                mem[_312 + 64] = stor10[address(arg1)][u].field_512
                mem[_312 + 96] = stor10[address(arg1)][u].field_768
                mem[t] = _312
                t = t + 32
                u = u + 1
                continue 
            if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                revert with 0, 34
            _334 = mem[64]
            mem[64] = mem[64] + ceil32(stor10[address(arg1)][idx].field_1) + 32
            mem[_334] = stor10[address(arg1)][idx].field_1
            if stor10[address(arg1)][idx].field_0:
                if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                    revert with 0, 34
                if not Mask(256, -1, stor10[address(arg1)][idx].field_0):
                    mem[_312] = _334
                    mem[_312 + 32] = stor10[address(arg1)][idx].field_256
                    mem[_312 + 64] = stor10[address(arg1)][idx].field_512
                    mem[_312 + 96] = stor10[address(arg1)][idx].field_768
                    mem[s] = _312
                    s = s + 32
                    idx = idx + 1
                    continue 
                if 31 >= uint255(stor10[address(arg1)][idx].field_0) * 0.5:
                    mem[_334 + 32] = 256 * stor10[address(arg1)][idx].field_8
                    mem[_312] = _334
                    mem[_312 + 32] = stor10[address(arg1)][idx].field_256
                    mem[_312 + 64] = stor10[address(arg1)][idx].field_512
                    mem[_312 + 96] = stor10[address(arg1)][idx].field_768
                    mem[s] = _312
                    s = s + 32
                    idx = idx + 1
                    continue 
                mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                mem[_334 + 32] = stor10[address(arg1)][idx].field_0
                t = _334 + 32
                u = sha3(mem[0])
                while _334 + (uint255(stor10[address(arg1)][u].field_0) * 0.5) > t:
                    mem[t + 32] = uint256(stor1[u])
                    t = t + 32
                    u = u + 1
                    continue 
                mem[_312] = _334
                mem[_312 + 32] = stor10[address(arg1)][u].field_256
                mem[_312 + 64] = stor10[address(arg1)][u].field_512
                mem[_312 + 96] = stor10[address(arg1)][u].field_768
                mem[t] = _312
                t = t + 32
                u = u + 1
                continue 
            if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                revert with 0, 34
            if stor10[address(arg1)][idx].field_1:
                if 31 >= stor10[address(arg1)][idx].field_1:
                    mem[_334 + 32] = 256 * stor10[address(arg1)][idx].field_8
                else:
                    mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                    mem[_334 + 32] = stor10[address(arg1)][idx].field_0
                    t = _334 + 32
                    u = sha3(mem[0])
                    while _334 + stor10[address(arg1)][idx].field_1 > t:
                        mem[t + 32] = uint256(stor1[u])
                        t = t + 32
                        u = u + 1
                        continue 
            mem[_312] = _334
            mem[_312 + 32] = stor10[address(arg1)][idx].field_256
            mem[_312 + 64] = stor10[address(arg1)][idx].field_512
            mem[_312 + 96] = stor10[address(arg1)][idx].field_768
            mem[s] = _312
            s = s + 32
            idx = idx + 1
            continue 
        mem[0] = address(arg2)
        mem[32] = 10
        _310 = mem[64]
        mem[64] = mem[64] + (32 * stor10[address(arg2)].field_0) + 32
        mem[_310] = stor10[address(arg2)].field_0
        s = _310 + 32
        idx = 0
        while idx < stor10[address(arg2)].field_0:
            mem[0] = sha3(address(arg2), 10)
            _610 = mem[64]
            mem[64] = mem[64] + 128
            if stor10[address(arg2)][idx].field_0:
                if not stor10[address(arg2)][idx].field_0 - (uint255(stor10[address(arg2)][idx].field_0) * 0.5 < 32):
                    revert with 0, 34
                _621 = mem[64]
                mem[64] = mem[64] + ceil32(uint255(stor10[address(arg2)][idx].field_0) * 0.5) + 32
                mem[_621] = uint255(stor10[address(arg2)][idx].field_0) * 0.5
                if stor10[address(arg2)][idx].field_0:
                    if not stor10[address(arg2)][idx].field_0 - (uint255(stor10[address(arg2)][idx].field_0) * 0.5 < 32):
                        revert with 0, 34
                    if Mask(256, -1, stor10[address(arg2)][idx].field_0):
                        if 31 >= uint255(stor10[address(arg2)][idx].field_0) * 0.5:
                            mem[_621 + 32] = 256 * stor10[address(arg2)][idx].field_8
                        else:
                            mem[0] = (4 * idx) + sha3(sha3(address(arg2), 10))
                            mem[_621 + 32] = stor10[address(arg2)][idx].field_0
                            t = _621 + 32
                            u = sha3(mem[0])
                            while _621 + (uint255(stor10[address(arg2)][idx].field_0) * 0.5) > t:
                                mem[t + 32] = uint256(stor1[u])
                                t = t + 32
                                u = u + 1
                                continue 
                    mem[_610] = _621
                    mem[_610 + 32] = stor10[address(arg2)][idx].field_256
                    mem[_610 + 64] = stor10[address(arg2)][idx].field_512
                    mem[_610 + 96] = stor10[address(arg2)][idx].field_768
                    mem[s] = _610
                    s = s + 32
                    idx = idx + 1
                    continue 
                if not stor10[address(arg2)][idx].field_0 - (stor10[address(arg2)][idx].field_1 < 32):
                    revert with 0, 34
                if not stor10[address(arg2)][idx].field_1:
                    mem[_610] = _621
                    mem[_610 + 32] = stor10[address(arg2)][idx].field_256
                    mem[_610 + 64] = stor10[address(arg2)][idx].field_512
                    mem[_610 + 96] = stor10[address(arg2)][idx].field_768
                    mem[s] = _610
                    s = s + 32
                    idx = idx + 1
                    continue 
                if 31 >= stor10[address(arg2)][idx].field_1:
                    mem[_621 + 32] = 256 * stor10[address(arg2)][idx].field_8
                    mem[_610] = _621
                    mem[_610 + 32] = stor10[address(arg2)][idx].field_256
                    mem[_610 + 64] = stor10[address(arg2)][idx].field_512
                    mem[_610 + 96] = stor10[address(arg2)][idx].field_768
                    mem[s] = _610
                    s = s + 32
                    idx = idx + 1
                    continue 
                mem[0] = (4 * idx) + sha3(sha3(address(arg2), 10))
                mem[_621 + 32] = stor10[address(arg2)][idx].field_0
                t = _621 + 32
                u = sha3(mem[0])
                while _621 + stor10[address(arg2)][u].field_1 > t:
                    mem[t + 32] = uint256(stor1[u])
                    t = t + 32
                    u = u + 1
                    continue 
                mem[_610] = _621
                mem[_610 + 32] = stor10[address(arg2)][u].field_256
                mem[_610 + 64] = stor10[address(arg2)][u].field_512
                mem[_610 + 96] = stor10[address(arg2)][u].field_768
                mem[t] = _610
                t = t + 32
                u = u + 1
                continue 
            if not stor10[address(arg2)][idx].field_0 - (stor10[address(arg2)][idx].field_1 < 32):
                revert with 0, 34
            _625 = mem[64]
            mem[64] = mem[64] + ceil32(stor10[address(arg2)][idx].field_1) + 32
            mem[_625] = stor10[address(arg2)][idx].field_1
            if stor10[address(arg2)][idx].field_0:
                if not stor10[address(arg2)][idx].field_0 - (uint255(stor10[address(arg2)][idx].field_0) * 0.5 < 32):
                    revert with 0, 34
                if not Mask(256, -1, stor10[address(arg2)][idx].field_0):
                    mem[_610] = _625
                    mem[_610 + 32] = stor10[address(arg2)][idx].field_256
                    mem[_610 + 64] = stor10[address(arg2)][idx].field_512
                    mem[_610 + 96] = stor10[address(arg2)][idx].field_768
                    mem[s] = _610
                    s = s + 32
                    idx = idx + 1
                    continue 
                if 31 >= uint255(stor10[address(arg2)][idx].field_0) * 0.5:
                    mem[_625 + 32] = 256 * stor10[address(arg2)][idx].field_8
                    mem[_610] = _625
                    mem[_610 + 32] = stor10[address(arg2)][idx].field_256
                    mem[_610 + 64] = stor10[address(arg2)][idx].field_512
                    mem[_610 + 96] = stor10[address(arg2)][idx].field_768
                    mem[s] = _610
                    s = s + 32
                    idx = idx + 1
                    continue 
                mem[0] = (4 * idx) + sha3(sha3(address(arg2), 10))
                mem[_625 + 32] = stor10[address(arg2)][idx].field_0
                t = _625 + 32
                u = sha3(mem[0])
                while _625 + (uint255(stor10[address(arg2)][u].field_0) * 0.5) > t:
                    mem[t + 32] = uint256(stor1[u])
                    t = t + 32
                    u = u + 1
                    continue 
                mem[_610] = _625
                mem[_610 + 32] = stor10[address(arg2)][u].field_256
                mem[_610 + 64] = stor10[address(arg2)][u].field_512
                mem[_610 + 96] = stor10[address(arg2)][u].field_768
                mem[t] = _610
                t = t + 32
                u = u + 1
                continue 
            if not stor10[address(arg2)][idx].field_0 - (stor10[address(arg2)][idx].field_1 < 32):
                revert with 0, 34
            if stor10[address(arg2)][idx].field_1:
                if 31 >= stor10[address(arg2)][idx].field_1:
                    mem[_625 + 32] = 256 * stor10[address(arg2)][idx].field_8
                else:
                    mem[0] = (4 * idx) + sha3(sha3(address(arg2), 10))
                    mem[_625 + 32] = stor10[address(arg2)][idx].field_0
                    t = _625 + 32
                    u = sha3(mem[0])
                    while _625 + stor10[address(arg2)][idx].field_1 > t:
                        mem[t + 32] = uint256(stor1[u])
                        t = t + 32
                        u = u + 1
                        continue 
            mem[_610] = _625
            mem[_610 + 32] = stor10[address(arg2)][idx].field_256
            mem[_610 + 64] = stor10[address(arg2)][idx].field_512
            mem[_610 + 96] = stor10[address(arg2)][idx].field_768
            mem[s] = _610
            s = s + 32
            idx = idx + 1
            continue 
        if address(arg1) != address(arg2):
            if mem[96] <= 1:
                if mem[_310] > 0:
                    if _referrals[address(arg1)] != address(arg2):
                        _referrals[address(arg1)] = address(arg2)
                        sub_989baf69[address(arg2)].field_0++
                        sub_989baf69[address(arg2)][sub_989baf69[address(arg2)].field_0].field_0 = address(arg1)
                    if tokenAddress != msg.sender:
                        if gateKeeperAddress != msg.sender:
                            if address(stor0.field_0) != msg.sender:
                                revert with 0, 'NodeManagerV2: NOT AUTHORIZED'
                    if stor10[stor11[address(arg1)]].field_0:
                        if not -referralBonusPercent:
                            sub_e27e434a[stor11[address(arg1)]][address(arg1)] = 0
                            if sub_666755bb[stor11[address(arg1)]] > -1:
                                revert with 0, 17
                        else:
                            if referralBonusPercent and nodePrice > -1 / referralBonusPercent:
                                revert with 0, 17
                            if not referralBonusPercent:
                                revert with 0, 18
                            if referralBonusPercent * nodePrice / referralBonusPercent != nodePrice:
                                revert with 0, 'SafeMath: multiplication overflow'
                            sub_e27e434a[stor11[address(arg1)]][address(arg1)] = referralBonusPercent * nodePrice / 100
                            if sub_666755bb[stor11[address(arg1)]] > !(referralBonusPercent * nodePrice / 100):
                                revert with 0, 17
                            sub_666755bb[stor11[address(arg1)]] += referralBonusPercent * nodePrice / 100
    else:
        if msg.sender == gateKeeperAddress:
            mem[0] = address(arg1)
            mem[64] = (32 * stor10[address(arg1)].field_0) + 128
            mem[96] = stor10[address(arg1)].field_0
            s = 128
            idx = 0
            while idx < stor10[address(arg1)].field_0:
                mem[0] = sha3(address(arg1), 10)
                _316 = mem[64]
                mem[64] = mem[64] + 128
                if stor10[address(arg1)][idx].field_0:
                    if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                        revert with 0, 34
                    _331 = mem[64]
                    mem[64] = mem[64] + ceil32(uint255(stor10[address(arg1)][idx].field_0) * 0.5) + 32
                    mem[_331] = uint255(stor10[address(arg1)][idx].field_0) * 0.5
                    if stor10[address(arg1)][idx].field_0:
                        if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                            revert with 0, 34
                        if Mask(256, -1, stor10[address(arg1)][idx].field_0):
                            if 31 >= uint255(stor10[address(arg1)][idx].field_0) * 0.5:
                                mem[_331 + 32] = 256 * stor10[address(arg1)][idx].field_8
                            else:
                                mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                mem[_331 + 32] = stor10[address(arg1)][idx].field_0
                                t = _331 + 32
                                u = sha3(mem[0])
                                while _331 + (uint255(stor10[address(arg1)][idx].field_0) * 0.5) > t:
                                    mem[t + 32] = uint256(stor1[u])
                                    t = t + 32
                                    u = u + 1
                                    continue 
                        mem[_316] = _331
                        mem[_316 + 32] = stor10[address(arg1)][idx].field_256
                        mem[_316 + 64] = stor10[address(arg1)][idx].field_512
                        mem[_316 + 96] = stor10[address(arg1)][idx].field_768
                        mem[s] = _316
                        s = s + 32
                        idx = idx + 1
                        continue 
                    if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                        revert with 0, 34
                    if not stor10[address(arg1)][idx].field_1:
                        mem[_316] = _331
                        mem[_316 + 32] = stor10[address(arg1)][idx].field_256
                        mem[_316 + 64] = stor10[address(arg1)][idx].field_512
                        mem[_316 + 96] = stor10[address(arg1)][idx].field_768
                        mem[s] = _316
                        s = s + 32
                        idx = idx + 1
                        continue 
                    if 31 >= stor10[address(arg1)][idx].field_1:
                        mem[_331 + 32] = 256 * stor10[address(arg1)][idx].field_8
                        mem[_316] = _331
                        mem[_316 + 32] = stor10[address(arg1)][idx].field_256
                        mem[_316 + 64] = stor10[address(arg1)][idx].field_512
                        mem[_316 + 96] = stor10[address(arg1)][idx].field_768
                        mem[s] = _316
                        s = s + 32
                        idx = idx + 1
                        continue 
                    mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                    mem[_331 + 32] = stor10[address(arg1)][idx].field_0
                    t = _331 + 32
                    u = sha3(mem[0])
                    while _331 + stor10[address(arg1)][u].field_1 > t:
                        mem[t + 32] = uint256(stor1[u])
                        t = t + 32
                        u = u + 1
                        continue 
                    mem[_316] = _331
                    mem[_316 + 32] = stor10[address(arg1)][u].field_256
                    mem[_316 + 64] = stor10[address(arg1)][u].field_512
                    mem[_316 + 96] = stor10[address(arg1)][u].field_768
                    mem[t] = _316
                    t = t + 32
                    u = u + 1
                    continue 
                if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                    revert with 0, 34
                _336 = mem[64]
                mem[64] = mem[64] + ceil32(stor10[address(arg1)][idx].field_1) + 32
                mem[_336] = stor10[address(arg1)][idx].field_1
                if stor10[address(arg1)][idx].field_0:
                    if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                        revert with 0, 34
                    if not Mask(256, -1, stor10[address(arg1)][idx].field_0):
                        mem[_316] = _336
                        mem[_316 + 32] = stor10[address(arg1)][idx].field_256
                        mem[_316 + 64] = stor10[address(arg1)][idx].field_512
                        mem[_316 + 96] = stor10[address(arg1)][idx].field_768
                        mem[s] = _316
                        s = s + 32
                        idx = idx + 1
                        continue 
                    if 31 >= uint255(stor10[address(arg1)][idx].field_0) * 0.5:
                        mem[_336 + 32] = 256 * stor10[address(arg1)][idx].field_8
                        mem[_316] = _336
                        mem[_316 + 32] = stor10[address(arg1)][idx].field_256
                        mem[_316 + 64] = stor10[address(arg1)][idx].field_512
                        mem[_316 + 96] = stor10[address(arg1)][idx].field_768
                        mem[s] = _316
                        s = s + 32
                        idx = idx + 1
                        continue 
                    mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                    mem[_336 + 32] = stor10[address(arg1)][idx].field_0
                    t = _336 + 32
                    u = sha3(mem[0])
                    while _336 + (uint255(stor10[address(arg1)][u].field_0) * 0.5) > t:
                        mem[t + 32] = uint256(stor1[u])
                        t = t + 32
                        u = u + 1
                        continue 
                    mem[_316] = _336
                    mem[_316 + 32] = stor10[address(arg1)][u].field_256
                    mem[_316 + 64] = stor10[address(arg1)][u].field_512
                    mem[_316 + 96] = stor10[address(arg1)][u].field_768
                    mem[t] = _316
                    t = t + 32
                    u = u + 1
                    continue 
                if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                    revert with 0, 34
                if stor10[address(arg1)][idx].field_1:
                    if 31 >= stor10[address(arg1)][idx].field_1:
                        mem[_336 + 32] = 256 * stor10[address(arg1)][idx].field_8
                    else:
                        mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                        mem[_336 + 32] = stor10[address(arg1)][idx].field_0
                        t = _336 + 32
                        u = sha3(mem[0])
                        while _336 + stor10[address(arg1)][idx].field_1 > t:
                            mem[t + 32] = uint256(stor1[u])
                            t = t + 32
                            u = u + 1
                            continue 
                mem[_316] = _336
                mem[_316 + 32] = stor10[address(arg1)][idx].field_256
                mem[_316 + 64] = stor10[address(arg1)][idx].field_512
                mem[_316 + 96] = stor10[address(arg1)][idx].field_768
                mem[s] = _316
                s = s + 32
                idx = idx + 1
                continue 
            mem[0] = address(arg2)
            mem[32] = 10
            _314 = mem[64]
            mem[64] = mem[64] + (32 * stor10[address(arg2)].field_0) + 32
            mem[_314] = stor10[address(arg2)].field_0
            s = _314 + 32
            idx = 0
            while idx < stor10[address(arg2)].field_0:
                mem[0] = sha3(address(arg2), 10)
                _612 = mem[64]
                mem[64] = mem[64] + 128
                if stor10[address(arg2)][idx].field_0:
                    if not stor10[address(arg2)][idx].field_0 - (uint255(stor10[address(arg2)][idx].field_0) * 0.5 < 32):
                        revert with 0, 34
                    _622 = mem[64]
                    mem[64] = mem[64] + ceil32(uint255(stor10[address(arg2)][idx].field_0) * 0.5) + 32
                    mem[_622] = uint255(stor10[address(arg2)][idx].field_0) * 0.5
                    if stor10[address(arg2)][idx].field_0:
                        if not stor10[address(arg2)][idx].field_0 - (uint255(stor10[address(arg2)][idx].field_0) * 0.5 < 32):
                            revert with 0, 34
                        if Mask(256, -1, stor10[address(arg2)][idx].field_0):
                            if 31 >= uint255(stor10[address(arg2)][idx].field_0) * 0.5:
                                mem[_622 + 32] = 256 * stor10[address(arg2)][idx].field_8
                            else:
                                mem[0] = (4 * idx) + sha3(sha3(address(arg2), 10))
                                mem[_622 + 32] = stor10[address(arg2)][idx].field_0
                                t = _622 + 32
                                u = sha3(mem[0])
                                while _622 + (uint255(stor10[address(arg2)][idx].field_0) * 0.5) > t:
                                    mem[t + 32] = uint256(stor1[u])
                                    t = t + 32
                                    u = u + 1
                                    continue 
                        mem[_612] = _622
                        mem[_612 + 32] = stor10[address(arg2)][idx].field_256
                        mem[_612 + 64] = stor10[address(arg2)][idx].field_512
                        mem[_612 + 96] = stor10[address(arg2)][idx].field_768
                        mem[s] = _612
                        s = s + 32
                        idx = idx + 1
                        continue 
                    if not stor10[address(arg2)][idx].field_0 - (stor10[address(arg2)][idx].field_1 < 32):
                        revert with 0, 34
                    if not stor10[address(arg2)][idx].field_1:
                        mem[_612] = _622
                        mem[_612 + 32] = stor10[address(arg2)][idx].field_256
                        mem[_612 + 64] = stor10[address(arg2)][idx].field_512
                        mem[_612 + 96] = stor10[address(arg2)][idx].field_768
                        mem[s] = _612
                        s = s + 32
                        idx = idx + 1
                        continue 
                    if 31 >= stor10[address(arg2)][idx].field_1:
                        mem[_622 + 32] = 256 * stor10[address(arg2)][idx].field_8
                        mem[_612] = _622
                        mem[_612 + 32] = stor10[address(arg2)][idx].field_256
                        mem[_612 + 64] = stor10[address(arg2)][idx].field_512
                        mem[_612 + 96] = stor10[address(arg2)][idx].field_768
                        mem[s] = _612
                        s = s + 32
                        idx = idx + 1
                        continue 
                    mem[0] = (4 * idx) + sha3(sha3(address(arg2), 10))
                    mem[_622 + 32] = stor10[address(arg2)][idx].field_0
                    t = _622 + 32
                    u = sha3(mem[0])
                    while _622 + stor10[address(arg2)][u].field_1 > t:
                        mem[t + 32] = uint256(stor1[u])
                        t = t + 32
                        u = u + 1
                        continue 
                    mem[_612] = _622
                    mem[_612 + 32] = stor10[address(arg2)][u].field_256
                    mem[_612 + 64] = stor10[address(arg2)][u].field_512
                    mem[_612 + 96] = stor10[address(arg2)][u].field_768
                    mem[t] = _612
                    t = t + 32
                    u = u + 1
                    continue 
                if not stor10[address(arg2)][idx].field_0 - (stor10[address(arg2)][idx].field_1 < 32):
                    revert with 0, 34
                _627 = mem[64]
                mem[64] = mem[64] + ceil32(stor10[address(arg2)][idx].field_1) + 32
                mem[_627] = stor10[address(arg2)][idx].field_1
                if stor10[address(arg2)][idx].field_0:
                    if not stor10[address(arg2)][idx].field_0 - (uint255(stor10[address(arg2)][idx].field_0) * 0.5 < 32):
                        revert with 0, 34
                    if not Mask(256, -1, stor10[address(arg2)][idx].field_0):
                        mem[_612] = _627
                        mem[_612 + 32] = stor10[address(arg2)][idx].field_256
                        mem[_612 + 64] = stor10[address(arg2)][idx].field_512
                        mem[_612 + 96] = stor10[address(arg2)][idx].field_768
                        mem[s] = _612
                        s = s + 32
                        idx = idx + 1
                        continue 
                    if 31 >= uint255(stor10[address(arg2)][idx].field_0) * 0.5:
                        mem[_627 + 32] = 256 * stor10[address(arg2)][idx].field_8
                        mem[_612] = _627
                        mem[_612 + 32] = stor10[address(arg2)][idx].field_256
                        mem[_612 + 64] = stor10[address(arg2)][idx].field_512
                        mem[_612 + 96] = stor10[address(arg2)][idx].field_768
                        mem[s] = _612
                        s = s + 32
                        idx = idx + 1
                        continue 
                    mem[0] = (4 * idx) + sha3(sha3(address(arg2), 10))
                    mem[_627 + 32] = stor10[address(arg2)][idx].field_0
                    t = _627 + 32
                    u = sha3(mem[0])
                    while _627 + (uint255(stor10[address(arg2)][u].field_0) * 0.5) > t:
                        mem[t + 32] = uint256(stor1[u])
                        t = t + 32
                        u = u + 1
                        continue 
                    mem[_612] = _627
                    mem[_612 + 32] = stor10[address(arg2)][u].field_256
                    mem[_612 + 64] = stor10[address(arg2)][u].field_512
                    mem[_612 + 96] = stor10[address(arg2)][u].field_768
                    mem[t] = _612
                    t = t + 32
                    u = u + 1
                    continue 
                if not stor10[address(arg2)][idx].field_0 - (stor10[address(arg2)][idx].field_1 < 32):
                    revert with 0, 34
                if stor10[address(arg2)][idx].field_1:
                    if 31 >= stor10[address(arg2)][idx].field_1:
                        mem[_627 + 32] = 256 * stor10[address(arg2)][idx].field_8
                    else:
                        mem[0] = (4 * idx) + sha3(sha3(address(arg2), 10))
                        mem[_627 + 32] = stor10[address(arg2)][idx].field_0
                        t = _627 + 32
                        u = sha3(mem[0])
                        while _627 + stor10[address(arg2)][idx].field_1 > t:
                            mem[t + 32] = uint256(stor1[u])
                            t = t + 32
                            u = u + 1
                            continue 
                mem[_612] = _627
                mem[_612 + 32] = stor10[address(arg2)][idx].field_256
                mem[_612 + 64] = stor10[address(arg2)][idx].field_512
                mem[_612 + 96] = stor10[address(arg2)][idx].field_768
                mem[s] = _612
                s = s + 32
                idx = idx + 1
                continue 
            if address(arg1) != address(arg2):
                if mem[96] <= 1:
                    if mem[_314] > 0:
                        if _referrals[address(arg1)] != address(arg2):
                            _referrals[address(arg1)] = address(arg2)
                            sub_989baf69[address(arg2)].field_0++
                            sub_989baf69[address(arg2)][sub_989baf69[address(arg2)].field_0].field_0 = address(arg1)
                        if tokenAddress != msg.sender:
                            if gateKeeperAddress != msg.sender:
                                if address(stor0.field_0) != msg.sender:
                                    revert with 0, 'NodeManagerV2: NOT AUTHORIZED'
                        if stor10[stor11[address(arg1)]].field_0:
                            if not -referralBonusPercent:
                                sub_e27e434a[stor11[address(arg1)]][address(arg1)] = 0
                                if sub_666755bb[stor11[address(arg1)]] > -1:
                                    revert with 0, 17
                            else:
                                if referralBonusPercent and nodePrice > -1 / referralBonusPercent:
                                    revert with 0, 17
                                if not referralBonusPercent:
                                    revert with 0, 18
                                if referralBonusPercent * nodePrice / referralBonusPercent != nodePrice:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                sub_e27e434a[stor11[address(arg1)]][address(arg1)] = referralBonusPercent * nodePrice / 100
                                if sub_666755bb[stor11[address(arg1)]] > !(referralBonusPercent * nodePrice / 100):
                                    revert with 0, 17
                                sub_666755bb[stor11[address(arg1)]] += referralBonusPercent * nodePrice / 100
        else:
            if address(stor0.field_0) != msg.sender:
                revert with 0, 'NodeManagerV2: NOT AUTHORIZED'
            mem[0] = address(arg1)
            mem[64] = (32 * stor10[address(arg1)].field_0) + 128
            mem[96] = stor10[address(arg1)].field_0
            s = 128
            idx = 0
            while idx < stor10[address(arg1)].field_0:
                mem[0] = sha3(address(arg1), 10)
                _320 = mem[64]
                mem[64] = mem[64] + 128
                if stor10[address(arg1)][idx].field_0:
                    if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                        revert with 0, 34
                    _332 = mem[64]
                    mem[64] = mem[64] + ceil32(uint255(stor10[address(arg1)][idx].field_0) * 0.5) + 32
                    mem[_332] = uint255(stor10[address(arg1)][idx].field_0) * 0.5
                    if stor10[address(arg1)][idx].field_0:
                        if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                            revert with 0, 34
                        if Mask(256, -1, stor10[address(arg1)][idx].field_0):
                            if 31 >= uint255(stor10[address(arg1)][idx].field_0) * 0.5:
                                mem[_332 + 32] = 256 * stor10[address(arg1)][idx].field_8
                            else:
                                mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                mem[_332 + 32] = stor10[address(arg1)][idx].field_0
                                t = _332 + 32
                                u = sha3(mem[0])
                                while _332 + (uint255(stor10[address(arg1)][idx].field_0) * 0.5) > t:
                                    mem[t + 32] = uint256(stor1[u])
                                    t = t + 32
                                    u = u + 1
                                    continue 
                        mem[_320] = _332
                        mem[_320 + 32] = stor10[address(arg1)][idx].field_256
                        mem[_320 + 64] = stor10[address(arg1)][idx].field_512
                        mem[_320 + 96] = stor10[address(arg1)][idx].field_768
                        mem[s] = _320
                        s = s + 32
                        idx = idx + 1
                        continue 
                    if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                        revert with 0, 34
                    if not stor10[address(arg1)][idx].field_1:
                        mem[_320] = _332
                        mem[_320 + 32] = stor10[address(arg1)][idx].field_256
                        mem[_320 + 64] = stor10[address(arg1)][idx].field_512
                        mem[_320 + 96] = stor10[address(arg1)][idx].field_768
                        mem[s] = _320
                        s = s + 32
                        idx = idx + 1
                        continue 
                    if 31 >= stor10[address(arg1)][idx].field_1:
                        mem[_332 + 32] = 256 * stor10[address(arg1)][idx].field_8
                        mem[_320] = _332
                        mem[_320 + 32] = stor10[address(arg1)][idx].field_256
                        mem[_320 + 64] = stor10[address(arg1)][idx].field_512
                        mem[_320 + 96] = stor10[address(arg1)][idx].field_768
                        mem[s] = _320
                        s = s + 32
                        idx = idx + 1
                        continue 
                    mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                    mem[_332 + 32] = stor10[address(arg1)][idx].field_0
                    t = _332 + 32
                    u = sha3(mem[0])
                    while _332 + stor10[address(arg1)][u].field_1 > t:
                        mem[t + 32] = uint256(stor1[u])
                        t = t + 32
                        u = u + 1
                        continue 
                    mem[_320] = _332
                    mem[_320 + 32] = stor10[address(arg1)][u].field_256
                    mem[_320 + 64] = stor10[address(arg1)][u].field_512
                    mem[_320 + 96] = stor10[address(arg1)][u].field_768
                    mem[t] = _320
                    t = t + 32
                    u = u + 1
                    continue 
                if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                    revert with 0, 34
                _338 = mem[64]
                mem[64] = mem[64] + ceil32(stor10[address(arg1)][idx].field_1) + 32
                mem[_338] = stor10[address(arg1)][idx].field_1
                if stor10[address(arg1)][idx].field_0:
                    if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                        revert with 0, 34
                    if not Mask(256, -1, stor10[address(arg1)][idx].field_0):
                        mem[_320] = _338
                        mem[_320 + 32] = stor10[address(arg1)][idx].field_256
                        mem[_320 + 64] = stor10[address(arg1)][idx].field_512
                        mem[_320 + 96] = stor10[address(arg1)][idx].field_768
                        mem[s] = _320
                        s = s + 32
                        idx = idx + 1
                        continue 
                    if 31 >= uint255(stor10[address(arg1)][idx].field_0) * 0.5:
                        mem[_338 + 32] = 256 * stor10[address(arg1)][idx].field_8
                        mem[_320] = _338
                        mem[_320 + 32] = stor10[address(arg1)][idx].field_256
                        mem[_320 + 64] = stor10[address(arg1)][idx].field_512
                        mem[_320 + 96] = stor10[address(arg1)][idx].field_768
                        mem[s] = _320
                        s = s + 32
                        idx = idx + 1
                        continue 
                    mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                    mem[_338 + 32] = stor10[address(arg1)][idx].field_0
                    t = _338 + 32
                    u = sha3(mem[0])
                    while _338 + (uint255(stor10[address(arg1)][u].field_0) * 0.5) > t:
                        mem[t + 32] = uint256(stor1[u])
                        t = t + 32
                        u = u + 1
                        continue 
                    mem[_320] = _338
                    mem[_320 + 32] = stor10[address(arg1)][u].field_256
                    mem[_320 + 64] = stor10[address(arg1)][u].field_512
                    mem[_320 + 96] = stor10[address(arg1)][u].field_768
                    mem[t] = _320
                    t = t + 32
                    u = u + 1
                    continue 
                if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                    revert with 0, 34
                if stor10[address(arg1)][idx].field_1:
                    if 31 >= stor10[address(arg1)][idx].field_1:
                        mem[_338 + 32] = 256 * stor10[address(arg1)][idx].field_8
                    else:
                        mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                        mem[_338 + 32] = stor10[address(arg1)][idx].field_0
                        t = _338 + 32
                        u = sha3(mem[0])
                        while _338 + stor10[address(arg1)][idx].field_1 > t:
                            mem[t + 32] = uint256(stor1[u])
                            t = t + 32
                            u = u + 1
                            continue 
                mem[_320] = _338
                mem[_320 + 32] = stor10[address(arg1)][idx].field_256
                mem[_320 + 64] = stor10[address(arg1)][idx].field_512
                mem[_320 + 96] = stor10[address(arg1)][idx].field_768
                mem[s] = _320
                s = s + 32
                idx = idx + 1
                continue 
            mem[0] = address(arg2)
            mem[32] = 10
            _318 = mem[64]
            mem[64] = mem[64] + (32 * stor10[address(arg2)].field_0) + 32
            mem[_318] = stor10[address(arg2)].field_0
            s = _318 + 32
            idx = 0
            while idx < stor10[address(arg2)].field_0:
                mem[0] = sha3(address(arg2), 10)
                _614 = mem[64]
                mem[64] = mem[64] + 128
                if stor10[address(arg2)][idx].field_0:
                    if not stor10[address(arg2)][idx].field_0 - (uint255(stor10[address(arg2)][idx].field_0) * 0.5 < 32):
                        revert with 0, 34
                    _623 = mem[64]
                    mem[64] = mem[64] + ceil32(uint255(stor10[address(arg2)][idx].field_0) * 0.5) + 32
                    mem[_623] = uint255(stor10[address(arg2)][idx].field_0) * 0.5
                    if stor10[address(arg2)][idx].field_0:
                        if not stor10[address(arg2)][idx].field_0 - (uint255(stor10[address(arg2)][idx].field_0) * 0.5 < 32):
                            revert with 0, 34
                        if Mask(256, -1, stor10[address(arg2)][idx].field_0):
                            if 31 >= uint255(stor10[address(arg2)][idx].field_0) * 0.5:
                                mem[_623 + 32] = 256 * stor10[address(arg2)][idx].field_8
                            else:
                                mem[0] = (4 * idx) + sha3(sha3(address(arg2), 10))
                                mem[_623 + 32] = stor10[address(arg2)][idx].field_0
                                t = _623 + 32
                                u = sha3(mem[0])
                                while _623 + (uint255(stor10[address(arg2)][idx].field_0) * 0.5) > t:
                                    mem[t + 32] = uint256(stor1[u])
                                    t = t + 32
                                    u = u + 1
                                    continue 
                        mem[_614] = _623
                        mem[_614 + 32] = stor10[address(arg2)][idx].field_256
                        mem[_614 + 64] = stor10[address(arg2)][idx].field_512
                        mem[_614 + 96] = stor10[address(arg2)][idx].field_768
                        mem[s] = _614
                        s = s + 32
                        idx = idx + 1
                        continue 
                    if not stor10[address(arg2)][idx].field_0 - (stor10[address(arg2)][idx].field_1 < 32):
                        revert with 0, 34
                    if not stor10[address(arg2)][idx].field_1:
                        mem[_614] = _623
                        mem[_614 + 32] = stor10[address(arg2)][idx].field_256
                        mem[_614 + 64] = stor10[address(arg2)][idx].field_512
                        mem[_614 + 96] = stor10[address(arg2)][idx].field_768
                        mem[s] = _614
                        s = s + 32
                        idx = idx + 1
                        continue 
                    if 31 >= stor10[address(arg2)][idx].field_1:
                        mem[_623 + 32] = 256 * stor10[address(arg2)][idx].field_8
                        mem[_614] = _623
                        mem[_614 + 32] = stor10[address(arg2)][idx].field_256
                        mem[_614 + 64] = stor10[address(arg2)][idx].field_512
                        mem[_614 + 96] = stor10[address(arg2)][idx].field_768
                        mem[s] = _614
                        s = s + 32
                        idx = idx + 1
                        continue 
                    mem[0] = (4 * idx) + sha3(sha3(address(arg2), 10))
                    mem[_623 + 32] = stor10[address(arg2)][idx].field_0
                    t = _623 + 32
                    u = sha3(mem[0])
                    while _623 + stor10[address(arg2)][u].field_1 > t:
                        mem[t + 32] = uint256(stor1[u])
                        t = t + 32
                        u = u + 1
                        continue 
                    mem[_614] = _623
                    mem[_614 + 32] = stor10[address(arg2)][u].field_256
                    mem[_614 + 64] = stor10[address(arg2)][u].field_512
                    mem[_614 + 96] = stor10[address(arg2)][u].field_768
                    mem[t] = _614
                    t = t + 32
                    u = u + 1
                    continue 
                if not stor10[address(arg2)][idx].field_0 - (stor10[address(arg2)][idx].field_1 < 32):
                    revert with 0, 34
                _629 = mem[64]
                mem[64] = mem[64] + ceil32(stor10[address(arg2)][idx].field_1) + 32
                mem[_629] = stor10[address(arg2)][idx].field_1
                if stor10[address(arg2)][idx].field_0:
                    if not stor10[address(arg2)][idx].field_0 - (uint255(stor10[address(arg2)][idx].field_0) * 0.5 < 32):
                        revert with 0, 34
                    if not Mask(256, -1, stor10[address(arg2)][idx].field_0):
                        mem[_614] = _629
                        mem[_614 + 32] = stor10[address(arg2)][idx].field_256
                        mem[_614 + 64] = stor10[address(arg2)][idx].field_512
                        mem[_614 + 96] = stor10[address(arg2)][idx].field_768
                        mem[s] = _614
                        s = s + 32
                        idx = idx + 1
                        continue 
                    if 31 >= uint255(stor10[address(arg2)][idx].field_0) * 0.5:
                        mem[_629 + 32] = 256 * stor10[address(arg2)][idx].field_8
                        mem[_614] = _629
                        mem[_614 + 32] = stor10[address(arg2)][idx].field_256
                        mem[_614 + 64] = stor10[address(arg2)][idx].field_512
                        mem[_614 + 96] = stor10[address(arg2)][idx].field_768
                        mem[s] = _614
                        s = s + 32
                        idx = idx + 1
                        continue 
                    mem[0] = (4 * idx) + sha3(sha3(address(arg2), 10))
                    mem[_629 + 32] = stor10[address(arg2)][idx].field_0
                    t = _629 + 32
                    u = sha3(mem[0])
                    while _629 + (uint255(stor10[address(arg2)][u].field_0) * 0.5) > t:
                        mem[t + 32] = uint256(stor1[u])
                        t = t + 32
                        u = u + 1
                        continue 
                    mem[_614] = _629
                    mem[_614 + 32] = stor10[address(arg2)][u].field_256
                    mem[_614 + 64] = stor10[address(arg2)][u].field_512
                    mem[_614 + 96] = stor10[address(arg2)][u].field_768
                    mem[t] = _614
                    t = t + 32
                    u = u + 1
                    continue 
                if not stor10[address(arg2)][idx].field_0 - (stor10[address(arg2)][idx].field_1 < 32):
                    revert with 0, 34
                if stor10[address(arg2)][idx].field_1:
                    if 31 >= stor10[address(arg2)][idx].field_1:
                        mem[_629 + 32] = 256 * stor10[address(arg2)][idx].field_8
                    else:
                        mem[0] = (4 * idx) + sha3(sha3(address(arg2), 10))
                        mem[_629 + 32] = stor10[address(arg2)][idx].field_0
                        t = _629 + 32
                        u = sha3(mem[0])
                        while _629 + stor10[address(arg2)][idx].field_1 > t:
                            mem[t + 32] = uint256(stor1[u])
                            t = t + 32
                            u = u + 1
                            continue 
                mem[_614] = _629
                mem[_614 + 32] = stor10[address(arg2)][idx].field_256
                mem[_614 + 64] = stor10[address(arg2)][idx].field_512
                mem[_614 + 96] = stor10[address(arg2)][idx].field_768
                mem[s] = _614
                s = s + 32
                idx = idx + 1
                continue 
            if address(arg1) != address(arg2):
                if mem[96] <= 1:
                    if mem[_318] > 0:
                        if _referrals[address(arg1)] != address(arg2):
                            _referrals[address(arg1)] = address(arg2)
                            sub_989baf69[address(arg2)].field_0++
                            sub_989baf69[address(arg2)][sub_989baf69[address(arg2)].field_0].field_0 = address(arg1)
                        if tokenAddress != msg.sender:
                            if gateKeeperAddress != msg.sender:
                                if address(stor0.field_0) != msg.sender:
                                    revert with 0, 'NodeManagerV2: NOT AUTHORIZED'
                        if stor10[stor11[address(arg1)]].field_0:
                            if not -referralBonusPercent:
                                sub_e27e434a[stor11[address(arg1)]][address(arg1)] = 0
                                if sub_666755bb[stor11[address(arg1)]] > -1:
                                    revert with 0, 17
                            else:
                                if referralBonusPercent and nodePrice > -1 / referralBonusPercent:
                                    revert with 0, 17
                                if not referralBonusPercent:
                                    revert with 0, 18
                                if referralBonusPercent * nodePrice / referralBonusPercent != nodePrice:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                sub_e27e434a[stor11[address(arg1)]][address(arg1)] = referralBonusPercent * nodePrice / 100
                                if sub_666755bb[stor11[address(arg1)]] > !(referralBonusPercent * nodePrice / 100):
                                    revert with 0, 17
                                sub_666755bb[stor11[address(arg1)]] += referralBonusPercent * nodePrice / 100
}

function _getNodesCreationTime(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    mem[0] = arg1
    mem[32] = 10
    mem[64] = (32 * stor10[address(arg1)].field_0) + 128
    mem[96] = stor10[address(arg1)].field_0
    s = 128
    idx = 0
    while idx < stor10[address(arg1)].field_0:
        mem[0] = sha3(address(arg1), 10)
        _135 = mem[64]
        mem[64] = mem[64] + 128
        if stor10[address(arg1)][idx].field_0:
            if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                revert with 0, 34
            _140 = mem[64]
            mem[64] = mem[64] + ceil32(uint255(stor10[address(arg1)][idx].field_0) * 0.5) + 32
            mem[_140] = uint255(stor10[address(arg1)][idx].field_0) * 0.5
            if stor10[address(arg1)][idx].field_0:
                if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                    revert with 0, 34
                if Mask(256, -1, stor10[address(arg1)][idx].field_0):
                    if 31 >= uint255(stor10[address(arg1)][idx].field_0) * 0.5:
                        mem[_140 + 32] = 256 * stor10[address(arg1)][idx].field_8
                    else:
                        mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                        mem[_140 + 32] = stor10[address(arg1)][idx].field_0
                        t = _140 + 32
                        u = sha3(mem[0])
                        while _140 + (uint255(stor10[address(arg1)][idx].field_0) * 0.5) > t:
                            mem[t + 32] = uint256(stor1[u])
                            t = t + 32
                            u = u + 1
                            continue 
                mem[_135] = _140
                mem[_135 + 32] = stor10[address(arg1)][idx].field_256
                mem[_135 + 64] = stor10[address(arg1)][idx].field_512
                mem[_135 + 96] = stor10[address(arg1)][idx].field_768
                mem[s] = _135
                s = s + 32
                idx = idx + 1
                continue 
            if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                revert with 0, 34
            if not stor10[address(arg1)][idx].field_1:
                mem[_135] = _140
                mem[_135 + 32] = stor10[address(arg1)][idx].field_256
                mem[_135 + 64] = stor10[address(arg1)][idx].field_512
                mem[_135 + 96] = stor10[address(arg1)][idx].field_768
                mem[s] = _135
                s = s + 32
                idx = idx + 1
                continue 
            if 31 >= stor10[address(arg1)][idx].field_1:
                mem[_140 + 32] = 256 * stor10[address(arg1)][idx].field_8
                mem[_135] = _140
                mem[_135 + 32] = stor10[address(arg1)][idx].field_256
                mem[_135 + 64] = stor10[address(arg1)][idx].field_512
                mem[_135 + 96] = stor10[address(arg1)][idx].field_768
                mem[s] = _135
                s = s + 32
                idx = idx + 1
                continue 
            mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
            mem[_140 + 32] = stor10[address(arg1)][idx].field_0
            t = _140 + 32
            u = sha3(mem[0])
            while _140 + stor10[address(arg1)][u].field_1 > t:
                mem[t + 32] = uint256(stor1[u])
                t = t + 32
                u = u + 1
                continue 
            mem[_135] = _140
            mem[_135 + 32] = stor10[address(arg1)][u].field_256
            mem[_135 + 64] = stor10[address(arg1)][u].field_512
            mem[_135 + 96] = stor10[address(arg1)][u].field_768
            mem[t] = _135
            t = t + 32
            u = u + 1
            continue 
        if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
            revert with 0, 34
        _142 = mem[64]
        mem[64] = mem[64] + ceil32(stor10[address(arg1)][idx].field_1) + 32
        mem[_142] = stor10[address(arg1)][idx].field_1
        if stor10[address(arg1)][idx].field_0:
            if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                revert with 0, 34
            if not Mask(256, -1, stor10[address(arg1)][idx].field_0):
                mem[_135] = _142
                mem[_135 + 32] = stor10[address(arg1)][idx].field_256
                mem[_135 + 64] = stor10[address(arg1)][idx].field_512
                mem[_135 + 96] = stor10[address(arg1)][idx].field_768
                mem[s] = _135
                s = s + 32
                idx = idx + 1
                continue 
            if 31 >= uint255(stor10[address(arg1)][idx].field_0) * 0.5:
                mem[_142 + 32] = 256 * stor10[address(arg1)][idx].field_8
                mem[_135] = _142
                mem[_135 + 32] = stor10[address(arg1)][idx].field_256
                mem[_135 + 64] = stor10[address(arg1)][idx].field_512
                mem[_135 + 96] = stor10[address(arg1)][idx].field_768
                mem[s] = _135
                s = s + 32
                idx = idx + 1
                continue 
            mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
            mem[_142 + 32] = stor10[address(arg1)][idx].field_0
            t = _142 + 32
            u = sha3(mem[0])
            while _142 + (uint255(stor10[address(arg1)][u].field_0) * 0.5) > t:
                mem[t + 32] = uint256(stor1[u])
                t = t + 32
                u = u + 1
                continue 
            mem[_135] = _142
            mem[_135 + 32] = stor10[address(arg1)][u].field_256
            mem[_135 + 64] = stor10[address(arg1)][u].field_512
            mem[_135 + 96] = stor10[address(arg1)][u].field_768
            mem[t] = _135
            t = t + 32
            u = u + 1
            continue 
        if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
            revert with 0, 34
        if stor10[address(arg1)][idx].field_1:
            if 31 >= stor10[address(arg1)][idx].field_1:
                mem[_142 + 32] = 256 * stor10[address(arg1)][idx].field_8
            else:
                mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                mem[_142 + 32] = stor10[address(arg1)][idx].field_0
                t = _142 + 32
                u = sha3(mem[0])
                while _142 + stor10[address(arg1)][idx].field_1 > t:
                    mem[t + 32] = uint256(stor1[u])
                    t = t + 32
                    u = u + 1
                    continue 
        mem[_135] = _142
        mem[_135 + 32] = stor10[address(arg1)][idx].field_256
        mem[_135 + 64] = stor10[address(arg1)][idx].field_512
        mem[_135 + 96] = stor10[address(arg1)][idx].field_768
        mem[s] = _135
        s = s + 32
        idx = idx + 1
        continue 
    _132 = mem[96]
    _133 = mem[64]
    mem[64] = mem[64] + 128
    mem[_133] = 96
    mem[_133 + 32] = 0
    mem[_133 + 64] = 0
    mem[_133 + 96] = 0
    if 0 >= mem[96]:
        revert with 0, 50
    _138 = mem[mem[128] + 32]
    if not -mem[mem[128] + 32]:
        _139 = mem[64]
        mem[64] = mem[64] + 64
        mem[_139] = 1
        mem[_139 + 32] = 0x3000000000000000000000000000000000000000000000000000000000000000
        _141 = mem[64]
        mem[64] = mem[64] + 64
        mem[_141] = 1
        mem[_141 + 32] = 0x2300000000000000000000000000000000000000000000000000000000000000
        idx = 1
        s = _139
        t = _133
        while idx < _132:
            if idx >= mem[96]:
                revert with 0, 50
            _264 = mem[(32 * idx) + 128]
            _265 = mem[mem[(32 * idx) + 128] + 32]
            if not -mem[mem[(32 * idx) + 128] + 32]:
                _267 = mem[64]
                mem[64] = mem[64] + 64
                mem[_267] = 1
                mem[_267 + 32] = 0x3000000000000000000000000000000000000000000000000000000000000000
                _268 = mem[64]
                _270 = mem[s]
                t = 0
                while t < _270:
                    mem[t + _268 + 32] = mem[t + s + 32]
                    t = t + 32
                    continue 
                if ceil32(_270) <= _270:
                    _439 = mem[_141]
                    s = 0
                    while s < _439:
                        mem[s + _268 + _270 + 32] = mem[s + _141 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_439) <= _439:
                        _637 = mem[_267]
                        s = 0
                        while s < _637:
                            mem[s + _268 + _270 + _439 + 32] = mem[s + _267 + 32]
                            s = s + 32
                            continue 
                        if ceil32(_637) <= _637:
                            _821 = mem[64]
                            mem[mem[64]] = _637 + _268 + _270 + _439 - mem[64]
                            mem[64] = _637 + _268 + _270 + _439 + 32
                            if not idx + 1:
                                revert with 0, 17
                            idx = idx + 1
                            s = _821
                            t = _264
                            continue 
                        mem[_637 + _268 + _270 + _439 + 32] = 0
                        _822 = mem[64]
                        mem[mem[64]] = _637 + _268 + _270 + _439 - mem[64]
                        mem[64] = _637 + _268 + _270 + _439 + 32
                        if not idx + 1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _822
                        t = _264
                        continue 
                    mem[_439 + _268 + _270 + 32] = 0
                    _638 = mem[_267]
                    s = 0
                    while s < _638:
                        mem[s + _268 + _270 + _439 + 32] = mem[s + _267 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_638) <= _638:
                        _823 = mem[64]
                        mem[mem[64]] = _638 + _268 + _270 + _439 - mem[64]
                        mem[64] = _638 + _268 + _270 + _439 + 32
                        if not idx + 1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _823
                        t = _264
                        continue 
                    mem[_638 + _268 + _270 + _439 + 32] = 0
                    _824 = mem[64]
                    mem[mem[64]] = _638 + _268 + _270 + _439 - mem[64]
                    mem[64] = _638 + _268 + _270 + _439 + 32
                    if not idx + 1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _824
                    t = _264
                    continue 
                mem[_270 + _268 + 32] = 0
                _440 = mem[_141]
                s = 0
                while s < _440:
                    mem[s + _268 + _270 + 32] = mem[s + _141 + 32]
                    s = s + 32
                    continue 
                if ceil32(_440) <= _440:
                    _639 = mem[_267]
                    s = 0
                    while s < _639:
                        mem[s + _268 + _270 + _440 + 32] = mem[s + _267 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_639) <= _639:
                        _825 = mem[64]
                        mem[mem[64]] = _639 + _268 + _270 + _440 - mem[64]
                        mem[64] = _639 + _268 + _270 + _440 + 32
                        if not idx + 1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _825
                        t = _264
                        continue 
                    mem[_639 + _268 + _270 + _440 + 32] = 0
                    _826 = mem[64]
                    mem[mem[64]] = _639 + _268 + _270 + _440 - mem[64]
                    mem[64] = _639 + _268 + _270 + _440 + 32
                    if not idx + 1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _826
                    t = _264
                    continue 
                mem[_440 + _268 + _270 + 32] = 0
                _640 = mem[_267]
                s = 0
                while s < _640:
                    mem[s + _268 + _270 + _440 + 32] = mem[s + _267 + 32]
                    s = s + 32
                    continue 
                if ceil32(_640) <= _640:
                    _827 = mem[64]
                    mem[mem[64]] = _640 + _268 + _270 + _440 - mem[64]
                    mem[64] = _640 + _268 + _270 + _440 + 32
                    if not idx + 1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _827
                    t = _264
                    continue 
                mem[_640 + _268 + _270 + _440 + 32] = 0
                _828 = mem[64]
                mem[mem[64]] = _640 + _268 + _270 + _440 - mem[64]
                mem[64] = _640 + _268 + _270 + _440 + 32
                if not idx + 1:
                    revert with 0, 17
                idx = idx + 1
                s = _828
                t = _264
                continue 
            u = 0
            t = mem[mem[(32 * idx) + 128] + 32]
            while t:
                if not u + 1:
                    revert with 0, 17
                u = u + 1
                t = t / 10
                continue 
            if u > test266151307():
                revert with 0, 65
            _438 = mem[64]
            mem[mem[64]] = u
            mem[64] = mem[64] + ceil32(u) + 32
            if not u:
                v = u
                t = _265
                while t:
                    if v < 1:
                        revert with 0, 17
                    if t / 10 > 0x1999999999999999999999999999999999999999999999999999999999999999:
                        revert with 0, 17
                    if t < 10 * t / 10:
                        revert with 0, 17
                    if 48 > -uint8(t - (10 * t / 10)) + 255:
                        revert with 0, 17
                    if v - 1 >= mem[_438]:
                        revert with 0, 50
                    mem[v + _438 + 31 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) - 256
                    v = v - 1
                    t = t / 10
                    continue 
                _633 = mem[64]
                _635 = mem[s]
                t = 0
                while t < _635:
                    mem[t + _633 + 32] = mem[t + s + 32]
                    t = t + 32
                    continue 
                if ceil32(_635) <= _635:
                    _817 = mem[_141]
                    s = 0
                    while s < _817:
                        mem[s + _633 + _635 + 32] = mem[s + _141 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_817) <= _817:
                        _1025 = mem[_438]
                        s = 0
                        while s < _1025:
                            mem[s + _633 + _635 + _817 + 32] = mem[s + _438 + 32]
                            s = s + 32
                            continue 
                        if ceil32(_1025) <= _1025:
                            _1213 = mem[64]
                            mem[mem[64]] = _1025 + _633 + _635 + _817 - mem[64]
                            mem[64] = _1025 + _633 + _635 + _817 + 32
                            if not idx + 1:
                                revert with 0, 17
                            idx = idx + 1
                            s = _1213
                            t = _264
                            continue 
                        mem[_1025 + _633 + _635 + _817 + 32] = 0
                        _1214 = mem[64]
                        mem[mem[64]] = _1025 + _633 + _635 + _817 - mem[64]
                        mem[64] = _1025 + _633 + _635 + _817 + 32
                        if not idx + 1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _1214
                        t = _264
                        continue 
                    mem[_817 + _633 + _635 + 32] = 0
                    _1026 = mem[_438]
                    s = 0
                    while s < _1026:
                        mem[s + _633 + _635 + _817 + 32] = mem[s + _438 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_1026) <= _1026:
                        _1215 = mem[64]
                        mem[mem[64]] = _1026 + _633 + _635 + _817 - mem[64]
                        mem[64] = _1026 + _633 + _635 + _817 + 32
                        if not idx + 1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _1215
                        t = _264
                        continue 
                    mem[_1026 + _633 + _635 + _817 + 32] = 0
                    _1216 = mem[64]
                    mem[mem[64]] = _1026 + _633 + _635 + _817 - mem[64]
                    mem[64] = _1026 + _633 + _635 + _817 + 32
                    if not idx + 1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _1216
                    t = _264
                    continue 
                mem[_635 + _633 + 32] = 0
                _818 = mem[_141]
                s = 0
                while s < _818:
                    mem[s + _633 + _635 + 32] = mem[s + _141 + 32]
                    s = s + 32
                    continue 
                if ceil32(_818) <= _818:
                    _1027 = mem[_438]
                    s = 0
                    while s < _1027:
                        mem[s + _633 + _635 + _818 + 32] = mem[s + _438 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_1027) <= _1027:
                        _1217 = mem[64]
                        mem[mem[64]] = _1027 + _633 + _635 + _818 - mem[64]
                        mem[64] = _1027 + _633 + _635 + _818 + 32
                        if not idx + 1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _1217
                        t = _264
                        continue 
                    mem[_1027 + _633 + _635 + _818 + 32] = 0
                    _1218 = mem[64]
                    mem[mem[64]] = _1027 + _633 + _635 + _818 - mem[64]
                    mem[64] = _1027 + _633 + _635 + _818 + 32
                    if not idx + 1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _1218
                    t = _264
                    continue 
                mem[_818 + _633 + _635 + 32] = 0
                _1028 = mem[_438]
                s = 0
                while s < _1028:
                    mem[s + _633 + _635 + _818 + 32] = mem[s + _438 + 32]
                    s = s + 32
                    continue 
                if ceil32(_1028) <= _1028:
                    _1219 = mem[64]
                    mem[mem[64]] = _1028 + _633 + _635 + _818 - mem[64]
                    mem[64] = _1028 + _633 + _635 + _818 + 32
                    if not idx + 1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _1219
                    t = _264
                    continue 
                mem[_1028 + _633 + _635 + _818 + 32] = 0
                _1220 = mem[64]
                mem[mem[64]] = _1028 + _633 + _635 + _818 - mem[64]
                mem[64] = _1028 + _633 + _635 + _818 + 32
                if not idx + 1:
                    revert with 0, 17
                idx = idx + 1
                s = _1220
                t = _264
                continue 
            mem[_438 + 32 len u] = call.data[calldata.size len u]
            v = u
            t = _265
            while t:
                if v < 1:
                    revert with 0, 17
                if t / 10 > 0x1999999999999999999999999999999999999999999999999999999999999999:
                    revert with 0, 17
                if t < 10 * t / 10:
                    revert with 0, 17
                if 48 > -uint8(t - (10 * t / 10)) + 255:
                    revert with 0, 17
                if v - 1 >= mem[_438]:
                    revert with 0, 50
                mem[v + _438 + 31 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) - 256
                v = v - 1
                t = t / 10
                continue 
            _634 = mem[64]
            _636 = mem[s]
            t = 0
            while t < _636:
                mem[t + _634 + 32] = mem[t + s + 32]
                t = t + 32
                continue 
            if ceil32(_636) <= _636:
                _819 = mem[_141]
                s = 0
                while s < _819:
                    mem[s + _634 + _636 + 32] = mem[s + _141 + 32]
                    s = s + 32
                    continue 
                if ceil32(_819) <= _819:
                    _1029 = mem[_438]
                    idx = 0
                    while idx < _1029:
                        mem[idx + _634 + _636 + _819 + 32] = mem[idx + _438 + 32]
                        idx = idx + 32
                        continue 
                    if ceil32(_1029) <= _1029:
                        _1221 = mem[64]
                        mem[mem[64]] = _1029 + _634 + _636 + _819 - mem[64]
                        mem[64] = _1029 + _634 + _636 + _819 + 32
                        if not ceil32(_819) + 1:
                            revert with 0, 17
                        s = ceil32(_819) + 1
                        s = _1221
                        t = _264
                        continue 
                    mem[_1029 + _634 + _636 + _819 + 32] = 0
                    _1222 = mem[64]
                    mem[mem[64]] = _1029 + _634 + _636 + _819 - mem[64]
                    mem[64] = _1029 + _634 + _636 + _819 + 32
                    if not ceil32(_819) + 1:
                        revert with 0, 17
                    s = ceil32(_819) + 1
                    s = _1222
                    t = _264
                    continue 
                mem[_819 + _634 + _636 + 32] = 0
                _1030 = mem[_438]
                idx = 0
                while idx < _1030:
                    mem[idx + _634 + _636 + _819 + 32] = mem[idx + _438 + 32]
                    idx = idx + 32
                    continue 
                if ceil32(_1030) <= _1030:
                    _1223 = mem[64]
                    mem[mem[64]] = _1030 + _634 + _636 + _819 - mem[64]
                    mem[64] = _1030 + _634 + _636 + _819 + 32
                    if not ceil32(_819) + 1:
                        revert with 0, 17
                    s = ceil32(_819) + 1
                    s = _1223
                    t = _264
                    continue 
                mem[_1030 + _634 + _636 + _819 + 32] = 0
                _1224 = mem[64]
                mem[mem[64]] = _1030 + _634 + _636 + _819 - mem[64]
                mem[64] = _1030 + _634 + _636 + _819 + 32
                if not ceil32(_819) + 1:
                    revert with 0, 17
                s = ceil32(_819) + 1
                s = _1224
                t = _264
                continue 
            mem[_636 + _634 + 32] = 0
            _820 = mem[_141]
            s = 0
            while s < _820:
                mem[s + _634 + _636 + 32] = mem[s + _141 + 32]
                s = s + 32
                continue 
            if ceil32(_820) <= _820:
                _1031 = mem[_438]
                idx = 0
                while idx < _1031:
                    mem[idx + _634 + _636 + _820 + 32] = mem[idx + _438 + 32]
                    idx = idx + 32
                    continue 
                if ceil32(_1031) <= _1031:
                    _1225 = mem[64]
                    mem[mem[64]] = _1031 + _634 + _636 + _820 - mem[64]
                    mem[64] = _1031 + _634 + _636 + _820 + 32
                    if not ceil32(_820) + 1:
                        revert with 0, 17
                    s = ceil32(_820) + 1
                    s = _1225
                    t = _264
                    continue 
                mem[_1031 + _634 + _636 + _820 + 32] = 0
                _1226 = mem[64]
                mem[mem[64]] = _1031 + _634 + _636 + _820 - mem[64]
                mem[64] = _1031 + _634 + _636 + _820 + 32
                if not ceil32(_820) + 1:
                    revert with 0, 17
                s = ceil32(_820) + 1
                s = _1226
                t = _264
                continue 
            mem[_820 + _634 + _636 + 32] = 0
            _1032 = mem[_438]
            idx = 0
            while idx < _1032:
                mem[idx + _634 + _636 + _820 + 32] = mem[idx + _438 + 32]
                idx = idx + 32
                continue 
            if ceil32(_1032) <= _1032:
                _1227 = mem[64]
                mem[mem[64]] = _1032 + _634 + _636 + _820 - mem[64]
                mem[64] = _1032 + _634 + _636 + _820 + 32
                if not ceil32(_820) + 1:
                    revert with 0, 17
                s = ceil32(_820) + 1
                s = _1227
                t = _264
                continue 
            mem[_1032 + _634 + _636 + _820 + 32] = 0
            _1228 = mem[64]
            mem[mem[64]] = _1032 + _634 + _636 + _820 - mem[64]
            mem[64] = _1032 + _634 + _636 + _820 + 32
            if not ceil32(_820) + 1:
                revert with 0, 17
            s = ceil32(_820) + 1
            s = _1228
            t = _264
            continue 
        _263 = mem[64]
        mem[mem[64]] = 32
        _266 = mem[s]
        mem[mem[64] + 32] = mem[s]
        mem[mem[64] + 64 len ceil32(_266)] = mem[s + 32 len ceil32(_266)]
        if ceil32(_266) <= _266:
            return 32, mem[mem[64] + 32 len ceil32(_266) + 32]
        mem[_266 + mem[64] + 64] = 0
        return memory
          from mem[64]
           len ceil32(_266) + _263 + -mem[64] + 64
    u = 0
    t = mem[mem[128] + 32]
    while t:
        if not u + 1:
            revert with 0, 17
        u = u + 1
        t = t / 10
        continue 
    if u > test266151307():
        revert with 0, 65
    _262 = mem[64]
    mem[mem[64]] = u
    mem[64] = mem[64] + ceil32(u) + 32
    if not u:
        s = u
        idx = _138
        while idx:
            if s < 1:
                revert with 0, 17
            if idx / 10 > 0x1999999999999999999999999999999999999999999999999999999999999999:
                revert with 0, 17
            if idx < 10 * idx / 10:
                revert with 0, 17
            if 48 > -uint8(idx - (10 * idx / 10)) + 255:
                revert with 0, 17
            if s - 1 >= mem[_262]:
                revert with 0, 50
            mem[s + _262 + 31 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 0), ('mul', -10, ('div', ('var', 0), 10)))))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 0), ('mul', -10, ('div', ('var', 0), 10)))))), 0) - 256
            s = s - 1
            idx = idx / 10
            continue 
        _436 = mem[64]
        mem[64] = mem[64] + 64
        mem[_436] = 1
        mem[_436 + 32] = 0x2300000000000000000000000000000000000000000000000000000000000000
        idx = 1
        t = _262
        u = _133
        while idx < _132:
            if idx >= mem[96]:
                revert with 0, 50
            _628 = mem[(32 * idx) + 128]
            _629 = mem[mem[(32 * idx) + 128] + 32]
            if not -mem[mem[(32 * idx) + 128] + 32]:
                _642 = mem[64]
                mem[64] = mem[64] + 64
                mem[_642] = 1
                mem[_642 + 32] = 0x3000000000000000000000000000000000000000000000000000000000000000
                _645 = mem[64]
                _647 = mem[t]
                u = 0
                while u < _647:
                    mem[u + _645 + 32] = mem[u + t + 32]
                    u = u + 32
                    continue 
                if ceil32(_647) <= _647:
                    _813 = mem[_436]
                    t = 0
                    while t < _813:
                        mem[t + _645 + _647 + 32] = mem[t + _436 + 32]
                        t = t + 32
                        continue 
                    if ceil32(_813) <= _813:
                        _1015 = mem[_642]
                        s = 0
                        while s < _1015:
                            mem[s + _645 + _647 + _813 + 32] = mem[s + _642 + 32]
                            s = s + 32
                            continue 
                        if ceil32(_1015) <= _1015:
                            _1197 = mem[64]
                            mem[mem[64]] = _1015 + _645 + _647 + _813 - mem[64]
                            mem[64] = _1015 + _645 + _647 + _813 + 32
                            if not idx + 1:
                                revert with 0, 17
                            idx = idx + 1
                            t = _1197
                            u = _628
                            continue 
                        mem[_1015 + _645 + _647 + _813 + 32] = 0
                        _1198 = mem[64]
                        mem[mem[64]] = _1015 + _645 + _647 + _813 - mem[64]
                        mem[64] = _1015 + _645 + _647 + _813 + 32
                        if not idx + 1:
                            revert with 0, 17
                        idx = idx + 1
                        t = _1198
                        u = _628
                        continue 
                    mem[_813 + _645 + _647 + 32] = 0
                    _1016 = mem[_642]
                    s = 0
                    while s < _1016:
                        mem[s + _645 + _647 + _813 + 32] = mem[s + _642 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_1016) <= _1016:
                        _1199 = mem[64]
                        mem[mem[64]] = _1016 + _645 + _647 + _813 - mem[64]
                        mem[64] = _1016 + _645 + _647 + _813 + 32
                        if not idx + 1:
                            revert with 0, 17
                        idx = idx + 1
                        t = _1199
                        u = _628
                        continue 
                    mem[_1016 + _645 + _647 + _813 + 32] = 0
                    _1200 = mem[64]
                    mem[mem[64]] = _1016 + _645 + _647 + _813 - mem[64]
                    mem[64] = _1016 + _645 + _647 + _813 + 32
                    if not idx + 1:
                        revert with 0, 17
                    idx = idx + 1
                    t = _1200
                    u = _628
                    continue 
                mem[_647 + _645 + 32] = 0
                _814 = mem[_436]
                t = 0
                while t < _814:
                    mem[t + _645 + _647 + 32] = mem[t + _436 + 32]
                    t = t + 32
                    continue 
                if ceil32(_814) <= _814:
                    _1017 = mem[_642]
                    s = 0
                    while s < _1017:
                        mem[s + _645 + _647 + _814 + 32] = mem[s + _642 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_1017) <= _1017:
                        _1201 = mem[64]
                        mem[mem[64]] = _1017 + _645 + _647 + _814 - mem[64]
                        mem[64] = _1017 + _645 + _647 + _814 + 32
                        if not idx + 1:
                            revert with 0, 17
                        idx = idx + 1
                        t = _1201
                        u = _628
                        continue 
                    mem[_1017 + _645 + _647 + _814 + 32] = 0
                    _1202 = mem[64]
                    mem[mem[64]] = _1017 + _645 + _647 + _814 - mem[64]
                    mem[64] = _1017 + _645 + _647 + _814 + 32
                    if not idx + 1:
                        revert with 0, 17
                    idx = idx + 1
                    t = _1202
                    u = _628
                    continue 
                mem[_814 + _645 + _647 + 32] = 0
                _1018 = mem[_642]
                s = 0
                while s < _1018:
                    mem[s + _645 + _647 + _814 + 32] = mem[s + _642 + 32]
                    s = s + 32
                    continue 
                if ceil32(_1018) <= _1018:
                    _1203 = mem[64]
                    mem[mem[64]] = _1018 + _645 + _647 + _814 - mem[64]
                    mem[64] = _1018 + _645 + _647 + _814 + 32
                    if not idx + 1:
                        revert with 0, 17
                    idx = idx + 1
                    t = _1203
                    u = _628
                    continue 
                mem[_1018 + _645 + _647 + _814 + 32] = 0
                _1204 = mem[64]
                mem[mem[64]] = _1018 + _645 + _647 + _814 - mem[64]
                mem[64] = _1018 + _645 + _647 + _814 + 32
                if not idx + 1:
                    revert with 0, 17
                idx = idx + 1
                t = _1204
                u = _628
                continue 
            u = 0
            s = mem[mem[(32 * idx) + 128] + 32]
            while s:
                if not u + 1:
                    revert with 0, 17
                u = u + 1
                s = s / 10
                continue 
            if u > test266151307():
                revert with 0, 65
            _811 = mem[64]
            mem[mem[64]] = u
            mem[64] = mem[64] + ceil32(u) + 32
            if not u:
                v = u
                s = _629
                while s:
                    if v < 1:
                        revert with 0, 17
                    if s / 10 > 0x1999999999999999999999999999999999999999999999999999999999999999:
                        revert with 0, 17
                    if s < 10 * s / 10:
                        revert with 0, 17
                    if 48 > -uint8(s - (10 * s / 10)) + 255:
                        revert with 0, 17
                    if v - 1 >= mem[_811]:
                        revert with 0, 50
                    mem[v + _811 + 31 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 1), ('mul', -10, ('div', ('var', 1), 10)))))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 1), ('mul', -10, ('div', ('var', 1), 10)))))), 0) - 256
                    v = v - 1
                    s = s / 10
                    continue 
                _1009 = mem[64]
                _1013 = mem[t]
                s = 0
                while s < _1013:
                    mem[s + _1009 + 32] = mem[s + t + 32]
                    s = s + 32
                    continue 
                if ceil32(_1013) <= _1013:
                    _1189 = mem[_436]
                    s = 0
                    while s < _1189:
                        mem[s + _1009 + _1013 + 32] = mem[s + _436 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_1189) <= _1189:
                        _1309 = mem[_811]
                        s = 0
                        while s < _1309:
                            mem[s + _1009 + _1013 + _1189 + 32] = mem[s + _811 + 32]
                            s = s + 32
                            continue 
                        if ceil32(_1309) <= _1309:
                            _1389 = mem[64]
                            mem[mem[64]] = _1309 + _1009 + _1013 + _1189 - mem[64]
                            mem[64] = _1309 + _1009 + _1013 + _1189 + 32
                            if not idx + 1:
                                revert with 0, 17
                            idx = idx + 1
                            t = _1389
                            u = _628
                            continue 
                        mem[_1309 + _1009 + _1013 + _1189 + 32] = 0
                        _1390 = mem[64]
                        mem[mem[64]] = _1309 + _1009 + _1013 + _1189 - mem[64]
                        mem[64] = _1309 + _1009 + _1013 + _1189 + 32
                        if not idx + 1:
                            revert with 0, 17
                        idx = idx + 1
                        t = _1390
                        u = _628
                        continue 
                    mem[_1189 + _1009 + _1013 + 32] = 0
                    _1310 = mem[_811]
                    s = 0
                    while s < _1310:
                        mem[s + _1009 + _1013 + _1189 + 32] = mem[s + _811 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_1310) <= _1310:
                        _1391 = mem[64]
                        mem[mem[64]] = _1310 + _1009 + _1013 + _1189 - mem[64]
                        mem[64] = _1310 + _1009 + _1013 + _1189 + 32
                        if not idx + 1:
                            revert with 0, 17
                        idx = idx + 1
                        t = _1391
                        u = _628
                        continue 
                    mem[_1310 + _1009 + _1013 + _1189 + 32] = 0
                    _1392 = mem[64]
                    mem[mem[64]] = _1310 + _1009 + _1013 + _1189 - mem[64]
                    mem[64] = _1310 + _1009 + _1013 + _1189 + 32
                    if not idx + 1:
                        revert with 0, 17
                    idx = idx + 1
                    t = _1392
                    u = _628
                    continue 
                mem[_1013 + _1009 + 32] = 0
                _1190 = mem[_436]
                s = 0
                while s < _1190:
                    mem[s + _1009 + _1013 + 32] = mem[s + _436 + 32]
                    s = s + 32
                    continue 
                if ceil32(_1190) <= _1190:
                    _1311 = mem[_811]
                    s = 0
                    while s < _1311:
                        mem[s + _1009 + _1013 + _1190 + 32] = mem[s + _811 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_1311) <= _1311:
                        _1393 = mem[64]
                        mem[mem[64]] = _1311 + _1009 + _1013 + _1190 - mem[64]
                        mem[64] = _1311 + _1009 + _1013 + _1190 + 32
                        if not idx + 1:
                            revert with 0, 17
                        idx = idx + 1
                        t = _1393
                        u = _628
                        continue 
                    mem[_1311 + _1009 + _1013 + _1190 + 32] = 0
                    _1394 = mem[64]
                    mem[mem[64]] = _1311 + _1009 + _1013 + _1190 - mem[64]
                    mem[64] = _1311 + _1009 + _1013 + _1190 + 32
                    if not idx + 1:
                        revert with 0, 17
                    idx = idx + 1
                    t = _1394
                    u = _628
                    continue 
                mem[_1190 + _1009 + _1013 + 32] = 0
                _1312 = mem[_811]
                s = 0
                while s < _1312:
                    mem[s + _1009 + _1013 + _1190 + 32] = mem[s + _811 + 32]
                    s = s + 32
                    continue 
                if ceil32(_1312) <= _1312:
                    _1395 = mem[64]
                    mem[mem[64]] = _1312 + _1009 + _1013 + _1190 - mem[64]
                    mem[64] = _1312 + _1009 + _1013 + _1190 + 32
                    if not idx + 1:
                        revert with 0, 17
                    idx = idx + 1
                    t = _1395
                    u = _628
                    continue 
                mem[_1312 + _1009 + _1013 + _1190 + 32] = 0
                _1396 = mem[64]
                mem[mem[64]] = _1312 + _1009 + _1013 + _1190 - mem[64]
                mem[64] = _1312 + _1009 + _1013 + _1190 + 32
                if not idx + 1:
                    revert with 0, 17
                idx = idx + 1
                t = _1396
                u = _628
                continue 
            mem[_811 + 32 len u] = call.data[calldata.size len u]
            v = u
            s = _629
            while s:
                if v < 1:
                    revert with 0, 17
                if s / 10 > 0x1999999999999999999999999999999999999999999999999999999999999999:
                    revert with 0, 17
                if s < 10 * s / 10:
                    revert with 0, 17
                if 48 > -uint8(s - (10 * s / 10)) + 255:
                    revert with 0, 17
                if v - 1 >= mem[_811]:
                    revert with 0, 50
                mem[v + _811 + 31 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 1), ('mul', -10, ('div', ('var', 1), 10)))))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 1), ('mul', -10, ('div', ('var', 1), 10)))))), 0) - 256
                v = v - 1
                s = s / 10
                continue 
            _1010 = mem[64]
            _1014 = mem[t]
            s = 0
            while s < _1014:
                mem[s + _1010 + 32] = mem[s + t + 32]
                s = s + 32
                continue 
            if ceil32(_1014) <= _1014:
                _1191 = mem[_436]
                s = 0
                while s < _1191:
                    mem[s + _1010 + _1014 + 32] = mem[s + _436 + 32]
                    s = s + 32
                    continue 
                if ceil32(_1191) <= _1191:
                    _1313 = mem[_811]
                    idx = 0
                    while idx < _1313:
                        mem[idx + _1010 + _1014 + _1191 + 32] = mem[idx + _811 + 32]
                        idx = idx + 32
                        continue 
                    if ceil32(_1313) <= _1313:
                        _1397 = mem[64]
                        mem[mem[64]] = _1313 + _1010 + _1014 + _1191 - mem[64]
                        mem[64] = _1313 + _1010 + _1014 + _1191 + 32
                        if not ceil32(_1191) + 1:
                            revert with 0, 17
                        s = ceil32(_1191) + 1
                        t = _1397
                        u = _628
                        continue 
                    mem[_1313 + _1010 + _1014 + _1191 + 32] = 0
                    _1398 = mem[64]
                    mem[mem[64]] = _1313 + _1010 + _1014 + _1191 - mem[64]
                    mem[64] = _1313 + _1010 + _1014 + _1191 + 32
                    if not ceil32(_1191) + 1:
                        revert with 0, 17
                    s = ceil32(_1191) + 1
                    t = _1398
                    u = _628
                    continue 
                mem[_1191 + _1010 + _1014 + 32] = 0
                _1314 = mem[_811]
                idx = 0
                while idx < _1314:
                    mem[idx + _1010 + _1014 + _1191 + 32] = mem[idx + _811 + 32]
                    idx = idx + 32
                    continue 
                if ceil32(_1314) <= _1314:
                    _1399 = mem[64]
                    mem[mem[64]] = _1314 + _1010 + _1014 + _1191 - mem[64]
                    mem[64] = _1314 + _1010 + _1014 + _1191 + 32
                    if not ceil32(_1191) + 1:
                        revert with 0, 17
                    s = ceil32(_1191) + 1
                    t = _1399
                    u = _628
                    continue 
                mem[_1314 + _1010 + _1014 + _1191 + 32] = 0
                _1400 = mem[64]
                mem[mem[64]] = _1314 + _1010 + _1014 + _1191 - mem[64]
                mem[64] = _1314 + _1010 + _1014 + _1191 + 32
                if not ceil32(_1191) + 1:
                    revert with 0, 17
                s = ceil32(_1191) + 1
                t = _1400
                u = _628
                continue 
            mem[_1014 + _1010 + 32] = 0
            _1192 = mem[_436]
            s = 0
            while s < _1192:
                mem[s + _1010 + _1014 + 32] = mem[s + _436 + 32]
                s = s + 32
                continue 
            if ceil32(_1192) <= _1192:
                _1315 = mem[_811]
                idx = 0
                while idx < _1315:
                    mem[idx + _1010 + _1014 + _1192 + 32] = mem[idx + _811 + 32]
                    idx = idx + 32
                    continue 
                if ceil32(_1315) <= _1315:
                    _1401 = mem[64]
                    mem[mem[64]] = _1315 + _1010 + _1014 + _1192 - mem[64]
                    mem[64] = _1315 + _1010 + _1014 + _1192 + 32
                    if not ceil32(_1192) + 1:
                        revert with 0, 17
                    s = ceil32(_1192) + 1
                    t = _1401
                    u = _628
                    continue 
                mem[_1315 + _1010 + _1014 + _1192 + 32] = 0
                _1402 = mem[64]
                mem[mem[64]] = _1315 + _1010 + _1014 + _1192 - mem[64]
                mem[64] = _1315 + _1010 + _1014 + _1192 + 32
                if not ceil32(_1192) + 1:
                    revert with 0, 17
                s = ceil32(_1192) + 1
                t = _1402
                u = _628
                continue 
            mem[_1192 + _1010 + _1014 + 32] = 0
            _1316 = mem[_811]
            idx = 0
            while idx < _1316:
                mem[idx + _1010 + _1014 + _1192 + 32] = mem[idx + _811 + 32]
                idx = idx + 32
                continue 
            if ceil32(_1316) <= _1316:
                _1403 = mem[64]
                mem[mem[64]] = _1316 + _1010 + _1014 + _1192 - mem[64]
                mem[64] = _1316 + _1010 + _1014 + _1192 + 32
                if not ceil32(_1192) + 1:
                    revert with 0, 17
                s = ceil32(_1192) + 1
                t = _1403
                u = _628
                continue 
            mem[_1316 + _1010 + _1014 + _1192 + 32] = 0
            _1404 = mem[64]
            mem[mem[64]] = _1316 + _1010 + _1014 + _1192 - mem[64]
            mem[64] = _1316 + _1010 + _1014 + _1192 + 32
            if not ceil32(_1192) + 1:
                revert with 0, 17
            s = ceil32(_1192) + 1
            t = _1404
            u = _628
            continue 
        _627 = mem[64]
        mem[mem[64]] = 32
        _641 = mem[t]
        mem[mem[64] + 32] = mem[t]
        mem[mem[64] + 64 len ceil32(_641)] = mem[t + 32 len ceil32(_641)]
        if ceil32(_641) <= _641:
            return 32, mem[mem[64] + 32 len ceil32(_641) + 32]
        mem[_641 + mem[64] + 64] = 0
        return memory
          from mem[64]
           len ceil32(_641) + _627 + -mem[64] + 64
    mem[_262 + 32 len u] = call.data[calldata.size len u]
    s = u
    idx = _138
    while idx:
        if s < 1:
            revert with 0, 17
        if idx / 10 > 0x1999999999999999999999999999999999999999999999999999999999999999:
            revert with 0, 17
        if idx < 10 * idx / 10:
            revert with 0, 17
        if 48 > -uint8(idx - (10 * idx / 10)) + 255:
            revert with 0, 17
        if s - 1 >= mem[_262]:
            revert with 0, 50
        mem[s + _262 + 31 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 0), ('mul', -10, ('div', ('var', 0), 10)))))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 0), ('mul', -10, ('div', ('var', 0), 10)))))), 0) - 256
        s = s - 1
        idx = idx / 10
        continue 
    _437 = mem[64]
    mem[64] = mem[64] + 64
    mem[_437] = 1
    mem[_437 + 32] = 0x2300000000000000000000000000000000000000000000000000000000000000
    idx = 1
    t = _262
    u = _133
    while idx < _132:
        if idx >= mem[96]:
            revert with 0, 50
        _631 = mem[(32 * idx) + 128]
        _632 = mem[mem[(32 * idx) + 128] + 32]
        if not -mem[mem[(32 * idx) + 128] + 32]:
            _644 = mem[64]
            mem[64] = mem[64] + 64
            mem[_644] = 1
            mem[_644 + 32] = 0x3000000000000000000000000000000000000000000000000000000000000000
            _646 = mem[64]
            _648 = mem[t]
            u = 0
            while u < _648:
                mem[u + _646 + 32] = mem[u + t + 32]
                u = u + 32
                continue 
            if ceil32(_648) <= _648:
                _815 = mem[_437]
                t = 0
                while t < _815:
                    mem[t + _646 + _648 + 32] = mem[t + _437 + 32]
                    t = t + 32
                    continue 
                if ceil32(_815) <= _815:
                    _1021 = mem[_644]
                    s = 0
                    while s < _1021:
                        mem[s + _646 + _648 + _815 + 32] = mem[s + _644 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_1021) <= _1021:
                        _1205 = mem[64]
                        mem[mem[64]] = _1021 + _646 + _648 + _815 - mem[64]
                        mem[64] = _1021 + _646 + _648 + _815 + 32
                        if not idx + 1:
                            revert with 0, 17
                        idx = idx + 1
                        t = _1205
                        u = _631
                        continue 
                    mem[_1021 + _646 + _648 + _815 + 32] = 0
                    _1206 = mem[64]
                    mem[mem[64]] = _1021 + _646 + _648 + _815 - mem[64]
                    mem[64] = _1021 + _646 + _648 + _815 + 32
                    if not idx + 1:
                        revert with 0, 17
                    idx = idx + 1
                    t = _1206
                    u = _631
                    continue 
                mem[_815 + _646 + _648 + 32] = 0
                _1022 = mem[_644]
                s = 0
                while s < _1022:
                    mem[s + _646 + _648 + _815 + 32] = mem[s + _644 + 32]
                    s = s + 32
                    continue 
                if ceil32(_1022) <= _1022:
                    _1207 = mem[64]
                    mem[mem[64]] = _1022 + _646 + _648 + _815 - mem[64]
                    mem[64] = _1022 + _646 + _648 + _815 + 32
                    if not idx + 1:
                        revert with 0, 17
                    idx = idx + 1
                    t = _1207
                    u = _631
                    continue 
                mem[_1022 + _646 + _648 + _815 + 32] = 0
                _1208 = mem[64]
                mem[mem[64]] = _1022 + _646 + _648 + _815 - mem[64]
                mem[64] = _1022 + _646 + _648 + _815 + 32
                if not idx + 1:
                    revert with 0, 17
                idx = idx + 1
                t = _1208
                u = _631
                continue 
            mem[_648 + _646 + 32] = 0
            _816 = mem[_437]
            t = 0
            while t < _816:
                mem[t + _646 + _648 + 32] = mem[t + _437 + 32]
                t = t + 32
                continue 
            if ceil32(_816) <= _816:
                _1023 = mem[_644]
                s = 0
                while s < _1023:
                    mem[s + _646 + _648 + _816 + 32] = mem[s + _644 + 32]
                    s = s + 32
                    continue 
                if ceil32(_1023) <= _1023:
                    _1209 = mem[64]
                    mem[mem[64]] = _1023 + _646 + _648 + _816 - mem[64]
                    mem[64] = _1023 + _646 + _648 + _816 + 32
                    if not idx + 1:
                        revert with 0, 17
                    idx = idx + 1
                    t = _1209
                    u = _631
                    continue 
                mem[_1023 + _646 + _648 + _816 + 32] = 0
                _1210 = mem[64]
                mem[mem[64]] = _1023 + _646 + _648 + _816 - mem[64]
                mem[64] = _1023 + _646 + _648 + _816 + 32
                if not idx + 1:
                    revert with 0, 17
                idx = idx + 1
                t = _1210
                u = _631
                continue 
            mem[_816 + _646 + _648 + 32] = 0
            _1024 = mem[_644]
            s = 0
            while s < _1024:
                mem[s + _646 + _648 + _816 + 32] = mem[s + _644 + 32]
                s = s + 32
                continue 
            if ceil32(_1024) <= _1024:
                _1211 = mem[64]
                mem[mem[64]] = _1024 + _646 + _648 + _816 - mem[64]
                mem[64] = _1024 + _646 + _648 + _816 + 32
                if not idx + 1:
                    revert with 0, 17
                idx = idx + 1
                t = _1211
                u = _631
                continue 
            mem[_1024 + _646 + _648 + _816 + 32] = 0
            _1212 = mem[64]
            mem[mem[64]] = _1024 + _646 + _648 + _816 - mem[64]
            mem[64] = _1024 + _646 + _648 + _816 + 32
            if not idx + 1:
                revert with 0, 17
            idx = idx + 1
            t = _1212
            u = _631
            continue 
        u = 0
        s = mem[mem[(32 * idx) + 128] + 32]
        while s:
            if not u + 1:
                revert with 0, 17
            u = u + 1
            s = s / 10
            continue 
        if u > test266151307():
            revert with 0, 65
        _812 = mem[64]
        mem[mem[64]] = u
        mem[64] = mem[64] + ceil32(u) + 32
        if not u:
            v = u
            s = _632
            while s:
                if v < 1:
                    revert with 0, 17
                if s / 10 > 0x1999999999999999999999999999999999999999999999999999999999999999:
                    revert with 0, 17
                if s < 10 * s / 10:
                    revert with 0, 17
                if 48 > -uint8(s - (10 * s / 10)) + 255:
                    revert with 0, 17
                if v - 1 >= mem[_812]:
                    revert with 0, 50
                mem[v + _812 + 31 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 1), ('mul', -10, ('div', ('var', 1), 10)))))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 1), ('mul', -10, ('div', ('var', 1), 10)))))), 0) - 256
                v = v - 1
                s = s / 10
                continue 
            _1011 = mem[64]
            _1019 = mem[t]
            s = 0
            while s < _1019:
                mem[s + _1011 + 32] = mem[s + t + 32]
                s = s + 32
                continue 
            if ceil32(_1019) <= _1019:
                _1193 = mem[_437]
                s = 0
                while s < _1193:
                    mem[s + _1011 + _1019 + 32] = mem[s + _437 + 32]
                    s = s + 32
                    continue 
                if ceil32(_1193) <= _1193:
                    _1317 = mem[_812]
                    s = 0
                    while s < _1317:
                        mem[s + _1011 + _1019 + _1193 + 32] = mem[s + _812 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_1317) <= _1317:
                        _1405 = mem[64]
                        mem[mem[64]] = _1317 + _1011 + _1019 + _1193 - mem[64]
                        mem[64] = _1317 + _1011 + _1019 + _1193 + 32
                        if not idx + 1:
                            revert with 0, 17
                        idx = idx + 1
                        t = _1405
                        u = _631
                        continue 
                    mem[_1317 + _1011 + _1019 + _1193 + 32] = 0
                    _1406 = mem[64]
                    mem[mem[64]] = _1317 + _1011 + _1019 + _1193 - mem[64]
                    mem[64] = _1317 + _1011 + _1019 + _1193 + 32
                    if not idx + 1:
                        revert with 0, 17
                    idx = idx + 1
                    t = _1406
                    u = _631
                    continue 
                mem[_1193 + _1011 + _1019 + 32] = 0
                _1318 = mem[_812]
                s = 0
                while s < _1318:
                    mem[s + _1011 + _1019 + _1193 + 32] = mem[s + _812 + 32]
                    s = s + 32
                    continue 
                if ceil32(_1318) <= _1318:
                    _1407 = mem[64]
                    mem[mem[64]] = _1318 + _1011 + _1019 + _1193 - mem[64]
                    mem[64] = _1318 + _1011 + _1019 + _1193 + 32
                    if not idx + 1:
                        revert with 0, 17
                    idx = idx + 1
                    t = _1407
                    u = _631
                    continue 
                mem[_1318 + _1011 + _1019 + _1193 + 32] = 0
                _1408 = mem[64]
                mem[mem[64]] = _1318 + _1011 + _1019 + _1193 - mem[64]
                mem[64] = _1318 + _1011 + _1019 + _1193 + 32
                if not idx + 1:
                    revert with 0, 17
                idx = idx + 1
                t = _1408
                u = _631
                continue 
            mem[_1019 + _1011 + 32] = 0
            _1194 = mem[_437]
            s = 0
            while s < _1194:
                mem[s + _1011 + _1019 + 32] = mem[s + _437 + 32]
                s = s + 32
                continue 
            if ceil32(_1194) <= _1194:
                _1319 = mem[_812]
                s = 0
                while s < _1319:
                    mem[s + _1011 + _1019 + _1194 + 32] = mem[s + _812 + 32]
                    s = s + 32
                    continue 
                if ceil32(_1319) <= _1319:
                    _1409 = mem[64]
                    mem[mem[64]] = _1319 + _1011 + _1019 + _1194 - mem[64]
                    mem[64] = _1319 + _1011 + _1019 + _1194 + 32
                    if not idx + 1:
                        revert with 0, 17
                    idx = idx + 1
                    t = _1409
                    u = _631
                    continue 
                mem[_1319 + _1011 + _1019 + _1194 + 32] = 0
                _1410 = mem[64]
                mem[mem[64]] = _1319 + _1011 + _1019 + _1194 - mem[64]
                mem[64] = _1319 + _1011 + _1019 + _1194 + 32
                if not idx + 1:
                    revert with 0, 17
                idx = idx + 1
                t = _1410
                u = _631
                continue 
            mem[_1194 + _1011 + _1019 + 32] = 0
            _1320 = mem[_812]
            s = 0
            while s < _1320:
                mem[s + _1011 + _1019 + _1194 + 32] = mem[s + _812 + 32]
                s = s + 32
                continue 
            if ceil32(_1320) <= _1320:
                _1411 = mem[64]
                mem[mem[64]] = _1320 + _1011 + _1019 + _1194 - mem[64]
                mem[64] = _1320 + _1011 + _1019 + _1194 + 32
                if not idx + 1:
                    revert with 0, 17
                idx = idx + 1
                t = _1411
                u = _631
                continue 
            mem[_1320 + _1011 + _1019 + _1194 + 32] = 0
            _1412 = mem[64]
            mem[mem[64]] = _1320 + _1011 + _1019 + _1194 - mem[64]
            mem[64] = _1320 + _1011 + _1019 + _1194 + 32
            if not idx + 1:
                revert with 0, 17
            idx = idx + 1
            t = _1412
            u = _631
            continue 
        mem[_812 + 32 len u] = call.data[calldata.size len u]
        v = u
        s = _632
        while s:
            if v < 1:
                revert with 0, 17
            if s / 10 > 0x1999999999999999999999999999999999999999999999999999999999999999:
                revert with 0, 17
            if s < 10 * s / 10:
                revert with 0, 17
            if 48 > -uint8(s - (10 * s / 10)) + 255:
                revert with 0, 17
            if v - 1 >= mem[_812]:
                revert with 0, 50
            mem[v + _812 + 31 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 1), ('mul', -10, ('div', ('var', 1), 10)))))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 1), ('mul', -10, ('div', ('var', 1), 10)))))), 0) - 256
            v = v - 1
            s = s / 10
            continue 
        _1012 = mem[64]
        _1020 = mem[t]
        s = 0
        while s < _1020:
            mem[s + _1012 + 32] = mem[s + t + 32]
            s = s + 32
            continue 
        if ceil32(_1020) <= _1020:
            _1195 = mem[_437]
            s = 0
            while s < _1195:
                mem[s + _1012 + _1020 + 32] = mem[s + _437 + 32]
                s = s + 32
                continue 
            if ceil32(_1195) <= _1195:
                _1321 = mem[_812]
                idx = 0
                while idx < _1321:
                    mem[idx + _1012 + _1020 + _1195 + 32] = mem[idx + _812 + 32]
                    idx = idx + 32
                    continue 
                if ceil32(_1321) <= _1321:
                    _1413 = mem[64]
                    mem[mem[64]] = _1321 + _1012 + _1020 + _1195 - mem[64]
                    mem[64] = _1321 + _1012 + _1020 + _1195 + 32
                    if not ceil32(_1195) + 1:
                        revert with 0, 17
                    s = ceil32(_1195) + 1
                    t = _1413
                    u = _631
                    continue 
                mem[_1321 + _1012 + _1020 + _1195 + 32] = 0
                _1414 = mem[64]
                mem[mem[64]] = _1321 + _1012 + _1020 + _1195 - mem[64]
                mem[64] = _1321 + _1012 + _1020 + _1195 + 32
                if not ceil32(_1195) + 1:
                    revert with 0, 17
                s = ceil32(_1195) + 1
                t = _1414
                u = _631
                continue 
            mem[_1195 + _1012 + _1020 + 32] = 0
            _1322 = mem[_812]
            idx = 0
            while idx < _1322:
                mem[idx + _1012 + _1020 + _1195 + 32] = mem[idx + _812 + 32]
                idx = idx + 32
                continue 
            if ceil32(_1322) <= _1322:
                _1415 = mem[64]
                mem[mem[64]] = _1322 + _1012 + _1020 + _1195 - mem[64]
                mem[64] = _1322 + _1012 + _1020 + _1195 + 32
                if not ceil32(_1195) + 1:
                    revert with 0, 17
                s = ceil32(_1195) + 1
                t = _1415
                u = _631
                continue 
            mem[_1322 + _1012 + _1020 + _1195 + 32] = 0
            _1416 = mem[64]
            mem[mem[64]] = _1322 + _1012 + _1020 + _1195 - mem[64]
            mem[64] = _1322 + _1012 + _1020 + _1195 + 32
            if not ceil32(_1195) + 1:
                revert with 0, 17
            s = ceil32(_1195) + 1
            t = _1416
            u = _631
            continue 
        mem[_1020 + _1012 + 32] = 0
        _1196 = mem[_437]
        s = 0
        while s < _1196:
            mem[s + _1012 + _1020 + 32] = mem[s + _437 + 32]
            s = s + 32
            continue 
        if ceil32(_1196) <= _1196:
            _1323 = mem[_812]
            idx = 0
            while idx < _1323:
                mem[idx + _1012 + _1020 + _1196 + 32] = mem[idx + _812 + 32]
                idx = idx + 32
                continue 
            if ceil32(_1323) <= _1323:
                _1417 = mem[64]
                mem[mem[64]] = _1323 + _1012 + _1020 + _1196 - mem[64]
                mem[64] = _1323 + _1012 + _1020 + _1196 + 32
                if not ceil32(_1196) + 1:
                    revert with 0, 17
                s = ceil32(_1196) + 1
                t = _1417
                u = _631
                continue 
            mem[_1323 + _1012 + _1020 + _1196 + 32] = 0
            _1418 = mem[64]
            mem[mem[64]] = _1323 + _1012 + _1020 + _1196 - mem[64]
            mem[64] = _1323 + _1012 + _1020 + _1196 + 32
            if not ceil32(_1196) + 1:
                revert with 0, 17
            s = ceil32(_1196) + 1
            t = _1418
            u = _631
            continue 
        mem[_1196 + _1012 + _1020 + 32] = 0
        _1324 = mem[_812]
        idx = 0
        while idx < _1324:
            mem[idx + _1012 + _1020 + _1196 + 32] = mem[idx + _812 + 32]
            idx = idx + 32
            continue 
        if ceil32(_1324) <= _1324:
            _1419 = mem[64]
            mem[mem[64]] = _1324 + _1012 + _1020 + _1196 - mem[64]
            mem[64] = _1324 + _1012 + _1020 + _1196 + 32
            if not ceil32(_1196) + 1:
                revert with 0, 17
            s = ceil32(_1196) + 1
            t = _1419
            u = _631
            continue 
        mem[_1324 + _1012 + _1020 + _1196 + 32] = 0
        _1420 = mem[64]
        mem[mem[64]] = _1324 + _1012 + _1020 + _1196 - mem[64]
        mem[64] = _1324 + _1012 + _1020 + _1196 + 32
        if not ceil32(_1196) + 1:
            revert with 0, 17
        s = ceil32(_1196) + 1
        t = _1420
        u = _631
        continue 
    _630 = mem[64]
    mem[mem[64]] = 32
    _643 = mem[t]
    mem[mem[64] + 32] = mem[t]
    mem[mem[64] + 64 len ceil32(_643)] = mem[t + 32 len ceil32(_643)]
    if ceil32(_643) <= _643:
        return 32, mem[mem[64] + 32 len ceil32(_643) + 32]
    mem[_643 + mem[64] + 64] = 0
    return memory
      from mem[64]
       len ceil32(_643) + _630 + -mem[64] + 64
}

function _getNodesLastClaimTime(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    mem[0] = arg1
    mem[32] = 10
    mem[64] = (32 * stor10[address(arg1)].field_0) + 128
    mem[96] = stor10[address(arg1)].field_0
    s = 128
    idx = 0
    while idx < stor10[address(arg1)].field_0:
        mem[0] = sha3(address(arg1), 10)
        _135 = mem[64]
        mem[64] = mem[64] + 128
        if stor10[address(arg1)][idx].field_0:
            if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                revert with 0, 34
            _140 = mem[64]
            mem[64] = mem[64] + ceil32(uint255(stor10[address(arg1)][idx].field_0) * 0.5) + 32
            mem[_140] = uint255(stor10[address(arg1)][idx].field_0) * 0.5
            if stor10[address(arg1)][idx].field_0:
                if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                    revert with 0, 34
                if Mask(256, -1, stor10[address(arg1)][idx].field_0):
                    if 31 >= uint255(stor10[address(arg1)][idx].field_0) * 0.5:
                        mem[_140 + 32] = 256 * stor10[address(arg1)][idx].field_8
                    else:
                        mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                        mem[_140 + 32] = stor10[address(arg1)][idx].field_0
                        t = _140 + 32
                        u = sha3(mem[0])
                        while _140 + (uint255(stor10[address(arg1)][idx].field_0) * 0.5) > t:
                            mem[t + 32] = uint256(stor1[u])
                            t = t + 32
                            u = u + 1
                            continue 
                mem[_135] = _140
                mem[_135 + 32] = stor10[address(arg1)][idx].field_256
                mem[_135 + 64] = stor10[address(arg1)][idx].field_512
                mem[_135 + 96] = stor10[address(arg1)][idx].field_768
                mem[s] = _135
                s = s + 32
                idx = idx + 1
                continue 
            if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                revert with 0, 34
            if not stor10[address(arg1)][idx].field_1:
                mem[_135] = _140
                mem[_135 + 32] = stor10[address(arg1)][idx].field_256
                mem[_135 + 64] = stor10[address(arg1)][idx].field_512
                mem[_135 + 96] = stor10[address(arg1)][idx].field_768
                mem[s] = _135
                s = s + 32
                idx = idx + 1
                continue 
            if 31 >= stor10[address(arg1)][idx].field_1:
                mem[_140 + 32] = 256 * stor10[address(arg1)][idx].field_8
                mem[_135] = _140
                mem[_135 + 32] = stor10[address(arg1)][idx].field_256
                mem[_135 + 64] = stor10[address(arg1)][idx].field_512
                mem[_135 + 96] = stor10[address(arg1)][idx].field_768
                mem[s] = _135
                s = s + 32
                idx = idx + 1
                continue 
            mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
            mem[_140 + 32] = stor10[address(arg1)][idx].field_0
            t = _140 + 32
            u = sha3(mem[0])
            while _140 + stor10[address(arg1)][u].field_1 > t:
                mem[t + 32] = uint256(stor1[u])
                t = t + 32
                u = u + 1
                continue 
            mem[_135] = _140
            mem[_135 + 32] = stor10[address(arg1)][u].field_256
            mem[_135 + 64] = stor10[address(arg1)][u].field_512
            mem[_135 + 96] = stor10[address(arg1)][u].field_768
            mem[t] = _135
            t = t + 32
            u = u + 1
            continue 
        if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
            revert with 0, 34
        _142 = mem[64]
        mem[64] = mem[64] + ceil32(stor10[address(arg1)][idx].field_1) + 32
        mem[_142] = stor10[address(arg1)][idx].field_1
        if stor10[address(arg1)][idx].field_0:
            if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                revert with 0, 34
            if not Mask(256, -1, stor10[address(arg1)][idx].field_0):
                mem[_135] = _142
                mem[_135 + 32] = stor10[address(arg1)][idx].field_256
                mem[_135 + 64] = stor10[address(arg1)][idx].field_512
                mem[_135 + 96] = stor10[address(arg1)][idx].field_768
                mem[s] = _135
                s = s + 32
                idx = idx + 1
                continue 
            if 31 >= uint255(stor10[address(arg1)][idx].field_0) * 0.5:
                mem[_142 + 32] = 256 * stor10[address(arg1)][idx].field_8
                mem[_135] = _142
                mem[_135 + 32] = stor10[address(arg1)][idx].field_256
                mem[_135 + 64] = stor10[address(arg1)][idx].field_512
                mem[_135 + 96] = stor10[address(arg1)][idx].field_768
                mem[s] = _135
                s = s + 32
                idx = idx + 1
                continue 
            mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
            mem[_142 + 32] = stor10[address(arg1)][idx].field_0
            t = _142 + 32
            u = sha3(mem[0])
            while _142 + (uint255(stor10[address(arg1)][u].field_0) * 0.5) > t:
                mem[t + 32] = uint256(stor1[u])
                t = t + 32
                u = u + 1
                continue 
            mem[_135] = _142
            mem[_135 + 32] = stor10[address(arg1)][u].field_256
            mem[_135 + 64] = stor10[address(arg1)][u].field_512
            mem[_135 + 96] = stor10[address(arg1)][u].field_768
            mem[t] = _135
            t = t + 32
            u = u + 1
            continue 
        if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
            revert with 0, 34
        if stor10[address(arg1)][idx].field_1:
            if 31 >= stor10[address(arg1)][idx].field_1:
                mem[_142 + 32] = 256 * stor10[address(arg1)][idx].field_8
            else:
                mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                mem[_142 + 32] = stor10[address(arg1)][idx].field_0
                t = _142 + 32
                u = sha3(mem[0])
                while _142 + stor10[address(arg1)][idx].field_1 > t:
                    mem[t + 32] = uint256(stor1[u])
                    t = t + 32
                    u = u + 1
                    continue 
        mem[_135] = _142
        mem[_135 + 32] = stor10[address(arg1)][idx].field_256
        mem[_135 + 64] = stor10[address(arg1)][idx].field_512
        mem[_135 + 96] = stor10[address(arg1)][idx].field_768
        mem[s] = _135
        s = s + 32
        idx = idx + 1
        continue 
    _132 = mem[96]
    _133 = mem[64]
    mem[64] = mem[64] + 128
    mem[_133] = 96
    mem[_133 + 32] = 0
    mem[_133 + 64] = 0
    mem[_133 + 96] = 0
    if 0 >= mem[96]:
        revert with 0, 50
    _138 = mem[mem[128] + 64]
    if not -mem[mem[128] + 64]:
        _139 = mem[64]
        mem[64] = mem[64] + 64
        mem[_139] = 1
        mem[_139 + 32] = 0x3000000000000000000000000000000000000000000000000000000000000000
        _141 = mem[64]
        mem[64] = mem[64] + 64
        mem[_141] = 1
        mem[_141 + 32] = 0x2300000000000000000000000000000000000000000000000000000000000000
        idx = 1
        s = _139
        t = _133
        while idx < _132:
            if idx >= mem[96]:
                revert with 0, 50
            _264 = mem[(32 * idx) + 128]
            _265 = mem[mem[(32 * idx) + 128] + 64]
            if not -mem[mem[(32 * idx) + 128] + 64]:
                _267 = mem[64]
                mem[64] = mem[64] + 64
                mem[_267] = 1
                mem[_267 + 32] = 0x3000000000000000000000000000000000000000000000000000000000000000
                _268 = mem[64]
                _270 = mem[s]
                t = 0
                while t < _270:
                    mem[t + _268 + 32] = mem[t + s + 32]
                    t = t + 32
                    continue 
                if ceil32(_270) <= _270:
                    _439 = mem[_141]
                    s = 0
                    while s < _439:
                        mem[s + _268 + _270 + 32] = mem[s + _141 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_439) <= _439:
                        _637 = mem[_267]
                        s = 0
                        while s < _637:
                            mem[s + _268 + _270 + _439 + 32] = mem[s + _267 + 32]
                            s = s + 32
                            continue 
                        if ceil32(_637) <= _637:
                            _821 = mem[64]
                            mem[mem[64]] = _637 + _268 + _270 + _439 - mem[64]
                            mem[64] = _637 + _268 + _270 + _439 + 32
                            if not idx + 1:
                                revert with 0, 17
                            idx = idx + 1
                            s = _821
                            t = _264
                            continue 
                        mem[_637 + _268 + _270 + _439 + 32] = 0
                        _822 = mem[64]
                        mem[mem[64]] = _637 + _268 + _270 + _439 - mem[64]
                        mem[64] = _637 + _268 + _270 + _439 + 32
                        if not idx + 1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _822
                        t = _264
                        continue 
                    mem[_439 + _268 + _270 + 32] = 0
                    _638 = mem[_267]
                    s = 0
                    while s < _638:
                        mem[s + _268 + _270 + _439 + 32] = mem[s + _267 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_638) <= _638:
                        _823 = mem[64]
                        mem[mem[64]] = _638 + _268 + _270 + _439 - mem[64]
                        mem[64] = _638 + _268 + _270 + _439 + 32
                        if not idx + 1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _823
                        t = _264
                        continue 
                    mem[_638 + _268 + _270 + _439 + 32] = 0
                    _824 = mem[64]
                    mem[mem[64]] = _638 + _268 + _270 + _439 - mem[64]
                    mem[64] = _638 + _268 + _270 + _439 + 32
                    if not idx + 1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _824
                    t = _264
                    continue 
                mem[_270 + _268 + 32] = 0
                _440 = mem[_141]
                s = 0
                while s < _440:
                    mem[s + _268 + _270 + 32] = mem[s + _141 + 32]
                    s = s + 32
                    continue 
                if ceil32(_440) <= _440:
                    _639 = mem[_267]
                    s = 0
                    while s < _639:
                        mem[s + _268 + _270 + _440 + 32] = mem[s + _267 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_639) <= _639:
                        _825 = mem[64]
                        mem[mem[64]] = _639 + _268 + _270 + _440 - mem[64]
                        mem[64] = _639 + _268 + _270 + _440 + 32
                        if not idx + 1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _825
                        t = _264
                        continue 
                    mem[_639 + _268 + _270 + _440 + 32] = 0
                    _826 = mem[64]
                    mem[mem[64]] = _639 + _268 + _270 + _440 - mem[64]
                    mem[64] = _639 + _268 + _270 + _440 + 32
                    if not idx + 1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _826
                    t = _264
                    continue 
                mem[_440 + _268 + _270 + 32] = 0
                _640 = mem[_267]
                s = 0
                while s < _640:
                    mem[s + _268 + _270 + _440 + 32] = mem[s + _267 + 32]
                    s = s + 32
                    continue 
                if ceil32(_640) <= _640:
                    _827 = mem[64]
                    mem[mem[64]] = _640 + _268 + _270 + _440 - mem[64]
                    mem[64] = _640 + _268 + _270 + _440 + 32
                    if not idx + 1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _827
                    t = _264
                    continue 
                mem[_640 + _268 + _270 + _440 + 32] = 0
                _828 = mem[64]
                mem[mem[64]] = _640 + _268 + _270 + _440 - mem[64]
                mem[64] = _640 + _268 + _270 + _440 + 32
                if not idx + 1:
                    revert with 0, 17
                idx = idx + 1
                s = _828
                t = _264
                continue 
            u = 0
            t = mem[mem[(32 * idx) + 128] + 64]
            while t:
                if not u + 1:
                    revert with 0, 17
                u = u + 1
                t = t / 10
                continue 
            if u > test266151307():
                revert with 0, 65
            _438 = mem[64]
            mem[mem[64]] = u
            mem[64] = mem[64] + ceil32(u) + 32
            if not u:
                v = u
                t = _265
                while t:
                    if v < 1:
                        revert with 0, 17
                    if t / 10 > 0x1999999999999999999999999999999999999999999999999999999999999999:
                        revert with 0, 17
                    if t < 10 * t / 10:
                        revert with 0, 17
                    if 48 > -uint8(t - (10 * t / 10)) + 255:
                        revert with 0, 17
                    if v - 1 >= mem[_438]:
                        revert with 0, 50
                    mem[v + _438 + 31 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) - 256
                    v = v - 1
                    t = t / 10
                    continue 
                _633 = mem[64]
                _635 = mem[s]
                t = 0
                while t < _635:
                    mem[t + _633 + 32] = mem[t + s + 32]
                    t = t + 32
                    continue 
                if ceil32(_635) <= _635:
                    _817 = mem[_141]
                    s = 0
                    while s < _817:
                        mem[s + _633 + _635 + 32] = mem[s + _141 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_817) <= _817:
                        _1025 = mem[_438]
                        s = 0
                        while s < _1025:
                            mem[s + _633 + _635 + _817 + 32] = mem[s + _438 + 32]
                            s = s + 32
                            continue 
                        if ceil32(_1025) <= _1025:
                            _1213 = mem[64]
                            mem[mem[64]] = _1025 + _633 + _635 + _817 - mem[64]
                            mem[64] = _1025 + _633 + _635 + _817 + 32
                            if not idx + 1:
                                revert with 0, 17
                            idx = idx + 1
                            s = _1213
                            t = _264
                            continue 
                        mem[_1025 + _633 + _635 + _817 + 32] = 0
                        _1214 = mem[64]
                        mem[mem[64]] = _1025 + _633 + _635 + _817 - mem[64]
                        mem[64] = _1025 + _633 + _635 + _817 + 32
                        if not idx + 1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _1214
                        t = _264
                        continue 
                    mem[_817 + _633 + _635 + 32] = 0
                    _1026 = mem[_438]
                    s = 0
                    while s < _1026:
                        mem[s + _633 + _635 + _817 + 32] = mem[s + _438 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_1026) <= _1026:
                        _1215 = mem[64]
                        mem[mem[64]] = _1026 + _633 + _635 + _817 - mem[64]
                        mem[64] = _1026 + _633 + _635 + _817 + 32
                        if not idx + 1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _1215
                        t = _264
                        continue 
                    mem[_1026 + _633 + _635 + _817 + 32] = 0
                    _1216 = mem[64]
                    mem[mem[64]] = _1026 + _633 + _635 + _817 - mem[64]
                    mem[64] = _1026 + _633 + _635 + _817 + 32
                    if not idx + 1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _1216
                    t = _264
                    continue 
                mem[_635 + _633 + 32] = 0
                _818 = mem[_141]
                s = 0
                while s < _818:
                    mem[s + _633 + _635 + 32] = mem[s + _141 + 32]
                    s = s + 32
                    continue 
                if ceil32(_818) <= _818:
                    _1027 = mem[_438]
                    s = 0
                    while s < _1027:
                        mem[s + _633 + _635 + _818 + 32] = mem[s + _438 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_1027) <= _1027:
                        _1217 = mem[64]
                        mem[mem[64]] = _1027 + _633 + _635 + _818 - mem[64]
                        mem[64] = _1027 + _633 + _635 + _818 + 32
                        if not idx + 1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _1217
                        t = _264
                        continue 
                    mem[_1027 + _633 + _635 + _818 + 32] = 0
                    _1218 = mem[64]
                    mem[mem[64]] = _1027 + _633 + _635 + _818 - mem[64]
                    mem[64] = _1027 + _633 + _635 + _818 + 32
                    if not idx + 1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _1218
                    t = _264
                    continue 
                mem[_818 + _633 + _635 + 32] = 0
                _1028 = mem[_438]
                s = 0
                while s < _1028:
                    mem[s + _633 + _635 + _818 + 32] = mem[s + _438 + 32]
                    s = s + 32
                    continue 
                if ceil32(_1028) <= _1028:
                    _1219 = mem[64]
                    mem[mem[64]] = _1028 + _633 + _635 + _818 - mem[64]
                    mem[64] = _1028 + _633 + _635 + _818 + 32
                    if not idx + 1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _1219
                    t = _264
                    continue 
                mem[_1028 + _633 + _635 + _818 + 32] = 0
                _1220 = mem[64]
                mem[mem[64]] = _1028 + _633 + _635 + _818 - mem[64]
                mem[64] = _1028 + _633 + _635 + _818 + 32
                if not idx + 1:
                    revert with 0, 17
                idx = idx + 1
                s = _1220
                t = _264
                continue 
            mem[_438 + 32 len u] = call.data[calldata.size len u]
            v = u
            t = _265
            while t:
                if v < 1:
                    revert with 0, 17
                if t / 10 > 0x1999999999999999999999999999999999999999999999999999999999999999:
                    revert with 0, 17
                if t < 10 * t / 10:
                    revert with 0, 17
                if 48 > -uint8(t - (10 * t / 10)) + 255:
                    revert with 0, 17
                if v - 1 >= mem[_438]:
                    revert with 0, 50
                mem[v + _438 + 31 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) - 256
                v = v - 1
                t = t / 10
                continue 
            _634 = mem[64]
            _636 = mem[s]
            t = 0
            while t < _636:
                mem[t + _634 + 32] = mem[t + s + 32]
                t = t + 32
                continue 
            if ceil32(_636) <= _636:
                _819 = mem[_141]
                s = 0
                while s < _819:
                    mem[s + _634 + _636 + 32] = mem[s + _141 + 32]
                    s = s + 32
                    continue 
                if ceil32(_819) <= _819:
                    _1029 = mem[_438]
                    idx = 0
                    while idx < _1029:
                        mem[idx + _634 + _636 + _819 + 32] = mem[idx + _438 + 32]
                        idx = idx + 32
                        continue 
                    if ceil32(_1029) <= _1029:
                        _1221 = mem[64]
                        mem[mem[64]] = _1029 + _634 + _636 + _819 - mem[64]
                        mem[64] = _1029 + _634 + _636 + _819 + 32
                        if not ceil32(_819) + 1:
                            revert with 0, 17
                        s = ceil32(_819) + 1
                        s = _1221
                        t = _264
                        continue 
                    mem[_1029 + _634 + _636 + _819 + 32] = 0
                    _1222 = mem[64]
                    mem[mem[64]] = _1029 + _634 + _636 + _819 - mem[64]
                    mem[64] = _1029 + _634 + _636 + _819 + 32
                    if not ceil32(_819) + 1:
                        revert with 0, 17
                    s = ceil32(_819) + 1
                    s = _1222
                    t = _264
                    continue 
                mem[_819 + _634 + _636 + 32] = 0
                _1030 = mem[_438]
                idx = 0
                while idx < _1030:
                    mem[idx + _634 + _636 + _819 + 32] = mem[idx + _438 + 32]
                    idx = idx + 32
                    continue 
                if ceil32(_1030) <= _1030:
                    _1223 = mem[64]
                    mem[mem[64]] = _1030 + _634 + _636 + _819 - mem[64]
                    mem[64] = _1030 + _634 + _636 + _819 + 32
                    if not ceil32(_819) + 1:
                        revert with 0, 17
                    s = ceil32(_819) + 1
                    s = _1223
                    t = _264
                    continue 
                mem[_1030 + _634 + _636 + _819 + 32] = 0
                _1224 = mem[64]
                mem[mem[64]] = _1030 + _634 + _636 + _819 - mem[64]
                mem[64] = _1030 + _634 + _636 + _819 + 32
                if not ceil32(_819) + 1:
                    revert with 0, 17
                s = ceil32(_819) + 1
                s = _1224
                t = _264
                continue 
            mem[_636 + _634 + 32] = 0
            _820 = mem[_141]
            s = 0
            while s < _820:
                mem[s + _634 + _636 + 32] = mem[s + _141 + 32]
                s = s + 32
                continue 
            if ceil32(_820) <= _820:
                _1031 = mem[_438]
                idx = 0
                while idx < _1031:
                    mem[idx + _634 + _636 + _820 + 32] = mem[idx + _438 + 32]
                    idx = idx + 32
                    continue 
                if ceil32(_1031) <= _1031:
                    _1225 = mem[64]
                    mem[mem[64]] = _1031 + _634 + _636 + _820 - mem[64]
                    mem[64] = _1031 + _634 + _636 + _820 + 32
                    if not ceil32(_820) + 1:
                        revert with 0, 17
                    s = ceil32(_820) + 1
                    s = _1225
                    t = _264
                    continue 
                mem[_1031 + _634 + _636 + _820 + 32] = 0
                _1226 = mem[64]
                mem[mem[64]] = _1031 + _634 + _636 + _820 - mem[64]
                mem[64] = _1031 + _634 + _636 + _820 + 32
                if not ceil32(_820) + 1:
                    revert with 0, 17
                s = ceil32(_820) + 1
                s = _1226
                t = _264
                continue 
            mem[_820 + _634 + _636 + 32] = 0
            _1032 = mem[_438]
            idx = 0
            while idx < _1032:
                mem[idx + _634 + _636 + _820 + 32] = mem[idx + _438 + 32]
                idx = idx + 32
                continue 
            if ceil32(_1032) <= _1032:
                _1227 = mem[64]
                mem[mem[64]] = _1032 + _634 + _636 + _820 - mem[64]
                mem[64] = _1032 + _634 + _636 + _820 + 32
                if not ceil32(_820) + 1:
                    revert with 0, 17
                s = ceil32(_820) + 1
                s = _1227
                t = _264
                continue 
            mem[_1032 + _634 + _636 + _820 + 32] = 0
            _1228 = mem[64]
            mem[mem[64]] = _1032 + _634 + _636 + _820 - mem[64]
            mem[64] = _1032 + _634 + _636 + _820 + 32
            if not ceil32(_820) + 1:
                revert with 0, 17
            s = ceil32(_820) + 1
            s = _1228
            t = _264
            continue 
        _263 = mem[64]
        mem[mem[64]] = 32
        _266 = mem[s]
        mem[mem[64] + 32] = mem[s]
        mem[mem[64] + 64 len ceil32(_266)] = mem[s + 32 len ceil32(_266)]
        if ceil32(_266) <= _266:
            return 32, mem[mem[64] + 32 len ceil32(_266) + 32]
        mem[_266 + mem[64] + 64] = 0
        return memory
          from mem[64]
           len ceil32(_266) + _263 + -mem[64] + 64
    u = 0
    t = mem[mem[128] + 64]
    while t:
        if not u + 1:
            revert with 0, 17
        u = u + 1
        t = t / 10
        continue 
    if u > test266151307():
        revert with 0, 65
    _262 = mem[64]
    mem[mem[64]] = u
    mem[64] = mem[64] + ceil32(u) + 32
    if not u:
        s = u
        idx = _138
        while idx:
            if s < 1:
                revert with 0, 17
            if idx / 10 > 0x1999999999999999999999999999999999999999999999999999999999999999:
                revert with 0, 17
            if idx < 10 * idx / 10:
                revert with 0, 17
            if 48 > -uint8(idx - (10 * idx / 10)) + 255:
                revert with 0, 17
            if s - 1 >= mem[_262]:
                revert with 0, 50
            mem[s + _262 + 31 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 0), ('mul', -10, ('div', ('var', 0), 10)))))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 0), ('mul', -10, ('div', ('var', 0), 10)))))), 0) - 256
            s = s - 1
            idx = idx / 10
            continue 
        _436 = mem[64]
        mem[64] = mem[64] + 64
        mem[_436] = 1
        mem[_436 + 32] = 0x2300000000000000000000000000000000000000000000000000000000000000
        idx = 1
        t = _262
        u = _133
        while idx < _132:
            if idx >= mem[96]:
                revert with 0, 50
            _628 = mem[(32 * idx) + 128]
            _629 = mem[mem[(32 * idx) + 128] + 64]
            if not -mem[mem[(32 * idx) + 128] + 64]:
                _642 = mem[64]
                mem[64] = mem[64] + 64
                mem[_642] = 1
                mem[_642 + 32] = 0x3000000000000000000000000000000000000000000000000000000000000000
                _645 = mem[64]
                _647 = mem[t]
                u = 0
                while u < _647:
                    mem[u + _645 + 32] = mem[u + t + 32]
                    u = u + 32
                    continue 
                if ceil32(_647) <= _647:
                    _813 = mem[_436]
                    t = 0
                    while t < _813:
                        mem[t + _645 + _647 + 32] = mem[t + _436 + 32]
                        t = t + 32
                        continue 
                    if ceil32(_813) <= _813:
                        _1015 = mem[_642]
                        s = 0
                        while s < _1015:
                            mem[s + _645 + _647 + _813 + 32] = mem[s + _642 + 32]
                            s = s + 32
                            continue 
                        if ceil32(_1015) <= _1015:
                            _1197 = mem[64]
                            mem[mem[64]] = _1015 + _645 + _647 + _813 - mem[64]
                            mem[64] = _1015 + _645 + _647 + _813 + 32
                            if not idx + 1:
                                revert with 0, 17
                            idx = idx + 1
                            t = _1197
                            u = _628
                            continue 
                        mem[_1015 + _645 + _647 + _813 + 32] = 0
                        _1198 = mem[64]
                        mem[mem[64]] = _1015 + _645 + _647 + _813 - mem[64]
                        mem[64] = _1015 + _645 + _647 + _813 + 32
                        if not idx + 1:
                            revert with 0, 17
                        idx = idx + 1
                        t = _1198
                        u = _628
                        continue 
                    mem[_813 + _645 + _647 + 32] = 0
                    _1016 = mem[_642]
                    s = 0
                    while s < _1016:
                        mem[s + _645 + _647 + _813 + 32] = mem[s + _642 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_1016) <= _1016:
                        _1199 = mem[64]
                        mem[mem[64]] = _1016 + _645 + _647 + _813 - mem[64]
                        mem[64] = _1016 + _645 + _647 + _813 + 32
                        if not idx + 1:
                            revert with 0, 17
                        idx = idx + 1
                        t = _1199
                        u = _628
                        continue 
                    mem[_1016 + _645 + _647 + _813 + 32] = 0
                    _1200 = mem[64]
                    mem[mem[64]] = _1016 + _645 + _647 + _813 - mem[64]
                    mem[64] = _1016 + _645 + _647 + _813 + 32
                    if not idx + 1:
                        revert with 0, 17
                    idx = idx + 1
                    t = _1200
                    u = _628
                    continue 
                mem[_647 + _645 + 32] = 0
                _814 = mem[_436]
                t = 0
                while t < _814:
                    mem[t + _645 + _647 + 32] = mem[t + _436 + 32]
                    t = t + 32
                    continue 
                if ceil32(_814) <= _814:
                    _1017 = mem[_642]
                    s = 0
                    while s < _1017:
                        mem[s + _645 + _647 + _814 + 32] = mem[s + _642 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_1017) <= _1017:
                        _1201 = mem[64]
                        mem[mem[64]] = _1017 + _645 + _647 + _814 - mem[64]
                        mem[64] = _1017 + _645 + _647 + _814 + 32
                        if not idx + 1:
                            revert with 0, 17
                        idx = idx + 1
                        t = _1201
                        u = _628
                        continue 
                    mem[_1017 + _645 + _647 + _814 + 32] = 0
                    _1202 = mem[64]
                    mem[mem[64]] = _1017 + _645 + _647 + _814 - mem[64]
                    mem[64] = _1017 + _645 + _647 + _814 + 32
                    if not idx + 1:
                        revert with 0, 17
                    idx = idx + 1
                    t = _1202
                    u = _628
                    continue 
                mem[_814 + _645 + _647 + 32] = 0
                _1018 = mem[_642]
                s = 0
                while s < _1018:
                    mem[s + _645 + _647 + _814 + 32] = mem[s + _642 + 32]
                    s = s + 32
                    continue 
                if ceil32(_1018) <= _1018:
                    _1203 = mem[64]
                    mem[mem[64]] = _1018 + _645 + _647 + _814 - mem[64]
                    mem[64] = _1018 + _645 + _647 + _814 + 32
                    if not idx + 1:
                        revert with 0, 17
                    idx = idx + 1
                    t = _1203
                    u = _628
                    continue 
                mem[_1018 + _645 + _647 + _814 + 32] = 0
                _1204 = mem[64]
                mem[mem[64]] = _1018 + _645 + _647 + _814 - mem[64]
                mem[64] = _1018 + _645 + _647 + _814 + 32
                if not idx + 1:
                    revert with 0, 17
                idx = idx + 1
                t = _1204
                u = _628
                continue 
            u = 0
            s = mem[mem[(32 * idx) + 128] + 64]
            while s:
                if not u + 1:
                    revert with 0, 17
                u = u + 1
                s = s / 10
                continue 
            if u > test266151307():
                revert with 0, 65
            _811 = mem[64]
            mem[mem[64]] = u
            mem[64] = mem[64] + ceil32(u) + 32
            if not u:
                v = u
                s = _629
                while s:
                    if v < 1:
                        revert with 0, 17
                    if s / 10 > 0x1999999999999999999999999999999999999999999999999999999999999999:
                        revert with 0, 17
                    if s < 10 * s / 10:
                        revert with 0, 17
                    if 48 > -uint8(s - (10 * s / 10)) + 255:
                        revert with 0, 17
                    if v - 1 >= mem[_811]:
                        revert with 0, 50
                    mem[v + _811 + 31 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 1), ('mul', -10, ('div', ('var', 1), 10)))))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 1), ('mul', -10, ('div', ('var', 1), 10)))))), 0) - 256
                    v = v - 1
                    s = s / 10
                    continue 
                _1009 = mem[64]
                _1013 = mem[t]
                s = 0
                while s < _1013:
                    mem[s + _1009 + 32] = mem[s + t + 32]
                    s = s + 32
                    continue 
                if ceil32(_1013) <= _1013:
                    _1189 = mem[_436]
                    s = 0
                    while s < _1189:
                        mem[s + _1009 + _1013 + 32] = mem[s + _436 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_1189) <= _1189:
                        _1309 = mem[_811]
                        s = 0
                        while s < _1309:
                            mem[s + _1009 + _1013 + _1189 + 32] = mem[s + _811 + 32]
                            s = s + 32
                            continue 
                        if ceil32(_1309) <= _1309:
                            _1389 = mem[64]
                            mem[mem[64]] = _1309 + _1009 + _1013 + _1189 - mem[64]
                            mem[64] = _1309 + _1009 + _1013 + _1189 + 32
                            if not idx + 1:
                                revert with 0, 17
                            idx = idx + 1
                            t = _1389
                            u = _628
                            continue 
                        mem[_1309 + _1009 + _1013 + _1189 + 32] = 0
                        _1390 = mem[64]
                        mem[mem[64]] = _1309 + _1009 + _1013 + _1189 - mem[64]
                        mem[64] = _1309 + _1009 + _1013 + _1189 + 32
                        if not idx + 1:
                            revert with 0, 17
                        idx = idx + 1
                        t = _1390
                        u = _628
                        continue 
                    mem[_1189 + _1009 + _1013 + 32] = 0
                    _1310 = mem[_811]
                    s = 0
                    while s < _1310:
                        mem[s + _1009 + _1013 + _1189 + 32] = mem[s + _811 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_1310) <= _1310:
                        _1391 = mem[64]
                        mem[mem[64]] = _1310 + _1009 + _1013 + _1189 - mem[64]
                        mem[64] = _1310 + _1009 + _1013 + _1189 + 32
                        if not idx + 1:
                            revert with 0, 17
                        idx = idx + 1
                        t = _1391
                        u = _628
                        continue 
                    mem[_1310 + _1009 + _1013 + _1189 + 32] = 0
                    _1392 = mem[64]
                    mem[mem[64]] = _1310 + _1009 + _1013 + _1189 - mem[64]
                    mem[64] = _1310 + _1009 + _1013 + _1189 + 32
                    if not idx + 1:
                        revert with 0, 17
                    idx = idx + 1
                    t = _1392
                    u = _628
                    continue 
                mem[_1013 + _1009 + 32] = 0
                _1190 = mem[_436]
                s = 0
                while s < _1190:
                    mem[s + _1009 + _1013 + 32] = mem[s + _436 + 32]
                    s = s + 32
                    continue 
                if ceil32(_1190) <= _1190:
                    _1311 = mem[_811]
                    s = 0
                    while s < _1311:
                        mem[s + _1009 + _1013 + _1190 + 32] = mem[s + _811 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_1311) <= _1311:
                        _1393 = mem[64]
                        mem[mem[64]] = _1311 + _1009 + _1013 + _1190 - mem[64]
                        mem[64] = _1311 + _1009 + _1013 + _1190 + 32
                        if not idx + 1:
                            revert with 0, 17
                        idx = idx + 1
                        t = _1393
                        u = _628
                        continue 
                    mem[_1311 + _1009 + _1013 + _1190 + 32] = 0
                    _1394 = mem[64]
                    mem[mem[64]] = _1311 + _1009 + _1013 + _1190 - mem[64]
                    mem[64] = _1311 + _1009 + _1013 + _1190 + 32
                    if not idx + 1:
                        revert with 0, 17
                    idx = idx + 1
                    t = _1394
                    u = _628
                    continue 
                mem[_1190 + _1009 + _1013 + 32] = 0
                _1312 = mem[_811]
                s = 0
                while s < _1312:
                    mem[s + _1009 + _1013 + _1190 + 32] = mem[s + _811 + 32]
                    s = s + 32
                    continue 
                if ceil32(_1312) <= _1312:
                    _1395 = mem[64]
                    mem[mem[64]] = _1312 + _1009 + _1013 + _1190 - mem[64]
                    mem[64] = _1312 + _1009 + _1013 + _1190 + 32
                    if not idx + 1:
                        revert with 0, 17
                    idx = idx + 1
                    t = _1395
                    u = _628
                    continue 
                mem[_1312 + _1009 + _1013 + _1190 + 32] = 0
                _1396 = mem[64]
                mem[mem[64]] = _1312 + _1009 + _1013 + _1190 - mem[64]
                mem[64] = _1312 + _1009 + _1013 + _1190 + 32
                if not idx + 1:
                    revert with 0, 17
                idx = idx + 1
                t = _1396
                u = _628
                continue 
            mem[_811 + 32 len u] = call.data[calldata.size len u]
            v = u
            s = _629
            while s:
                if v < 1:
                    revert with 0, 17
                if s / 10 > 0x1999999999999999999999999999999999999999999999999999999999999999:
                    revert with 0, 17
                if s < 10 * s / 10:
                    revert with 0, 17
                if 48 > -uint8(s - (10 * s / 10)) + 255:
                    revert with 0, 17
                if v - 1 >= mem[_811]:
                    revert with 0, 50
                mem[v + _811 + 31 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 1), ('mul', -10, ('div', ('var', 1), 10)))))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 1), ('mul', -10, ('div', ('var', 1), 10)))))), 0) - 256
                v = v - 1
                s = s / 10
                continue 
            _1010 = mem[64]
            _1014 = mem[t]
            s = 0
            while s < _1014:
                mem[s + _1010 + 32] = mem[s + t + 32]
                s = s + 32
                continue 
            if ceil32(_1014) <= _1014:
                _1191 = mem[_436]
                s = 0
                while s < _1191:
                    mem[s + _1010 + _1014 + 32] = mem[s + _436 + 32]
                    s = s + 32
                    continue 
                if ceil32(_1191) <= _1191:
                    _1313 = mem[_811]
                    idx = 0
                    while idx < _1313:
                        mem[idx + _1010 + _1014 + _1191 + 32] = mem[idx + _811 + 32]
                        idx = idx + 32
                        continue 
                    if ceil32(_1313) <= _1313:
                        _1397 = mem[64]
                        mem[mem[64]] = _1313 + _1010 + _1014 + _1191 - mem[64]
                        mem[64] = _1313 + _1010 + _1014 + _1191 + 32
                        if not ceil32(_1191) + 1:
                            revert with 0, 17
                        s = ceil32(_1191) + 1
                        t = _1397
                        u = _628
                        continue 
                    mem[_1313 + _1010 + _1014 + _1191 + 32] = 0
                    _1398 = mem[64]
                    mem[mem[64]] = _1313 + _1010 + _1014 + _1191 - mem[64]
                    mem[64] = _1313 + _1010 + _1014 + _1191 + 32
                    if not ceil32(_1191) + 1:
                        revert with 0, 17
                    s = ceil32(_1191) + 1
                    t = _1398
                    u = _628
                    continue 
                mem[_1191 + _1010 + _1014 + 32] = 0
                _1314 = mem[_811]
                idx = 0
                while idx < _1314:
                    mem[idx + _1010 + _1014 + _1191 + 32] = mem[idx + _811 + 32]
                    idx = idx + 32
                    continue 
                if ceil32(_1314) <= _1314:
                    _1399 = mem[64]
                    mem[mem[64]] = _1314 + _1010 + _1014 + _1191 - mem[64]
                    mem[64] = _1314 + _1010 + _1014 + _1191 + 32
                    if not ceil32(_1191) + 1:
                        revert with 0, 17
                    s = ceil32(_1191) + 1
                    t = _1399
                    u = _628
                    continue 
                mem[_1314 + _1010 + _1014 + _1191 + 32] = 0
                _1400 = mem[64]
                mem[mem[64]] = _1314 + _1010 + _1014 + _1191 - mem[64]
                mem[64] = _1314 + _1010 + _1014 + _1191 + 32
                if not ceil32(_1191) + 1:
                    revert with 0, 17
                s = ceil32(_1191) + 1
                t = _1400
                u = _628
                continue 
            mem[_1014 + _1010 + 32] = 0
            _1192 = mem[_436]
            s = 0
            while s < _1192:
                mem[s + _1010 + _1014 + 32] = mem[s + _436 + 32]
                s = s + 32
                continue 
            if ceil32(_1192) <= _1192:
                _1315 = mem[_811]
                idx = 0
                while idx < _1315:
                    mem[idx + _1010 + _1014 + _1192 + 32] = mem[idx + _811 + 32]
                    idx = idx + 32
                    continue 
                if ceil32(_1315) <= _1315:
                    _1401 = mem[64]
                    mem[mem[64]] = _1315 + _1010 + _1014 + _1192 - mem[64]
                    mem[64] = _1315 + _1010 + _1014 + _1192 + 32
                    if not ceil32(_1192) + 1:
                        revert with 0, 17
                    s = ceil32(_1192) + 1
                    t = _1401
                    u = _628
                    continue 
                mem[_1315 + _1010 + _1014 + _1192 + 32] = 0
                _1402 = mem[64]
                mem[mem[64]] = _1315 + _1010 + _1014 + _1192 - mem[64]
                mem[64] = _1315 + _1010 + _1014 + _1192 + 32
                if not ceil32(_1192) + 1:
                    revert with 0, 17
                s = ceil32(_1192) + 1
                t = _1402
                u = _628
                continue 
            mem[_1192 + _1010 + _1014 + 32] = 0
            _1316 = mem[_811]
            idx = 0
            while idx < _1316:
                mem[idx + _1010 + _1014 + _1192 + 32] = mem[idx + _811 + 32]
                idx = idx + 32
                continue 
            if ceil32(_1316) <= _1316:
                _1403 = mem[64]
                mem[mem[64]] = _1316 + _1010 + _1014 + _1192 - mem[64]
                mem[64] = _1316 + _1010 + _1014 + _1192 + 32
                if not ceil32(_1192) + 1:
                    revert with 0, 17
                s = ceil32(_1192) + 1
                t = _1403
                u = _628
                continue 
            mem[_1316 + _1010 + _1014 + _1192 + 32] = 0
            _1404 = mem[64]
            mem[mem[64]] = _1316 + _1010 + _1014 + _1192 - mem[64]
            mem[64] = _1316 + _1010 + _1014 + _1192 + 32
            if not ceil32(_1192) + 1:
                revert with 0, 17
            s = ceil32(_1192) + 1
            t = _1404
            u = _628
            continue 
        _627 = mem[64]
        mem[mem[64]] = 32
        _641 = mem[t]
        mem[mem[64] + 32] = mem[t]
        mem[mem[64] + 64 len ceil32(_641)] = mem[t + 32 len ceil32(_641)]
        if ceil32(_641) <= _641:
            return 32, mem[mem[64] + 32 len ceil32(_641) + 32]
        mem[_641 + mem[64] + 64] = 0
        return memory
          from mem[64]
           len ceil32(_641) + _627 + -mem[64] + 64
    mem[_262 + 32 len u] = call.data[calldata.size len u]
    s = u
    idx = _138
    while idx:
        if s < 1:
            revert with 0, 17
        if idx / 10 > 0x1999999999999999999999999999999999999999999999999999999999999999:
            revert with 0, 17
        if idx < 10 * idx / 10:
            revert with 0, 17
        if 48 > -uint8(idx - (10 * idx / 10)) + 255:
            revert with 0, 17
        if s - 1 >= mem[_262]:
            revert with 0, 50
        mem[s + _262 + 31 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 0), ('mul', -10, ('div', ('var', 0), 10)))))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 0), ('mul', -10, ('div', ('var', 0), 10)))))), 0) - 256
        s = s - 1
        idx = idx / 10
        continue 
    _437 = mem[64]
    mem[64] = mem[64] + 64
    mem[_437] = 1
    mem[_437 + 32] = 0x2300000000000000000000000000000000000000000000000000000000000000
    idx = 1
    t = _262
    u = _133
    while idx < _132:
        if idx >= mem[96]:
            revert with 0, 50
        _631 = mem[(32 * idx) + 128]
        _632 = mem[mem[(32 * idx) + 128] + 64]
        if not -mem[mem[(32 * idx) + 128] + 64]:
            _644 = mem[64]
            mem[64] = mem[64] + 64
            mem[_644] = 1
            mem[_644 + 32] = 0x3000000000000000000000000000000000000000000000000000000000000000
            _646 = mem[64]
            _648 = mem[t]
            u = 0
            while u < _648:
                mem[u + _646 + 32] = mem[u + t + 32]
                u = u + 32
                continue 
            if ceil32(_648) <= _648:
                _815 = mem[_437]
                t = 0
                while t < _815:
                    mem[t + _646 + _648 + 32] = mem[t + _437 + 32]
                    t = t + 32
                    continue 
                if ceil32(_815) <= _815:
                    _1021 = mem[_644]
                    s = 0
                    while s < _1021:
                        mem[s + _646 + _648 + _815 + 32] = mem[s + _644 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_1021) <= _1021:
                        _1205 = mem[64]
                        mem[mem[64]] = _1021 + _646 + _648 + _815 - mem[64]
                        mem[64] = _1021 + _646 + _648 + _815 + 32
                        if not idx + 1:
                            revert with 0, 17
                        idx = idx + 1
                        t = _1205
                        u = _631
                        continue 
                    mem[_1021 + _646 + _648 + _815 + 32] = 0
                    _1206 = mem[64]
                    mem[mem[64]] = _1021 + _646 + _648 + _815 - mem[64]
                    mem[64] = _1021 + _646 + _648 + _815 + 32
                    if not idx + 1:
                        revert with 0, 17
                    idx = idx + 1
                    t = _1206
                    u = _631
                    continue 
                mem[_815 + _646 + _648 + 32] = 0
                _1022 = mem[_644]
                s = 0
                while s < _1022:
                    mem[s + _646 + _648 + _815 + 32] = mem[s + _644 + 32]
                    s = s + 32
                    continue 
                if ceil32(_1022) <= _1022:
                    _1207 = mem[64]
                    mem[mem[64]] = _1022 + _646 + _648 + _815 - mem[64]
                    mem[64] = _1022 + _646 + _648 + _815 + 32
                    if not idx + 1:
                        revert with 0, 17
                    idx = idx + 1
                    t = _1207
                    u = _631
                    continue 
                mem[_1022 + _646 + _648 + _815 + 32] = 0
                _1208 = mem[64]
                mem[mem[64]] = _1022 + _646 + _648 + _815 - mem[64]
                mem[64] = _1022 + _646 + _648 + _815 + 32
                if not idx + 1:
                    revert with 0, 17
                idx = idx + 1
                t = _1208
                u = _631
                continue 
            mem[_648 + _646 + 32] = 0
            _816 = mem[_437]
            t = 0
            while t < _816:
                mem[t + _646 + _648 + 32] = mem[t + _437 + 32]
                t = t + 32
                continue 
            if ceil32(_816) <= _816:
                _1023 = mem[_644]
                s = 0
                while s < _1023:
                    mem[s + _646 + _648 + _816 + 32] = mem[s + _644 + 32]
                    s = s + 32
                    continue 
                if ceil32(_1023) <= _1023:
                    _1209 = mem[64]
                    mem[mem[64]] = _1023 + _646 + _648 + _816 - mem[64]
                    mem[64] = _1023 + _646 + _648 + _816 + 32
                    if not idx + 1:
                        revert with 0, 17
                    idx = idx + 1
                    t = _1209
                    u = _631
                    continue 
                mem[_1023 + _646 + _648 + _816 + 32] = 0
                _1210 = mem[64]
                mem[mem[64]] = _1023 + _646 + _648 + _816 - mem[64]
                mem[64] = _1023 + _646 + _648 + _816 + 32
                if not idx + 1:
                    revert with 0, 17
                idx = idx + 1
                t = _1210
                u = _631
                continue 
            mem[_816 + _646 + _648 + 32] = 0
            _1024 = mem[_644]
            s = 0
            while s < _1024:
                mem[s + _646 + _648 + _816 + 32] = mem[s + _644 + 32]
                s = s + 32
                continue 
            if ceil32(_1024) <= _1024:
                _1211 = mem[64]
                mem[mem[64]] = _1024 + _646 + _648 + _816 - mem[64]
                mem[64] = _1024 + _646 + _648 + _816 + 32
                if not idx + 1:
                    revert with 0, 17
                idx = idx + 1
                t = _1211
                u = _631
                continue 
            mem[_1024 + _646 + _648 + _816 + 32] = 0
            _1212 = mem[64]
            mem[mem[64]] = _1024 + _646 + _648 + _816 - mem[64]
            mem[64] = _1024 + _646 + _648 + _816 + 32
            if not idx + 1:
                revert with 0, 17
            idx = idx + 1
            t = _1212
            u = _631
            continue 
        u = 0
        s = mem[mem[(32 * idx) + 128] + 64]
        while s:
            if not u + 1:
                revert with 0, 17
            u = u + 1
            s = s / 10
            continue 
        if u > test266151307():
            revert with 0, 65
        _812 = mem[64]
        mem[mem[64]] = u
        mem[64] = mem[64] + ceil32(u) + 32
        if not u:
            v = u
            s = _632
            while s:
                if v < 1:
                    revert with 0, 17
                if s / 10 > 0x1999999999999999999999999999999999999999999999999999999999999999:
                    revert with 0, 17
                if s < 10 * s / 10:
                    revert with 0, 17
                if 48 > -uint8(s - (10 * s / 10)) + 255:
                    revert with 0, 17
                if v - 1 >= mem[_812]:
                    revert with 0, 50
                mem[v + _812 + 31 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 1), ('mul', -10, ('div', ('var', 1), 10)))))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 1), ('mul', -10, ('div', ('var', 1), 10)))))), 0) - 256
                v = v - 1
                s = s / 10
                continue 
            _1011 = mem[64]
            _1019 = mem[t]
            s = 0
            while s < _1019:
                mem[s + _1011 + 32] = mem[s + t + 32]
                s = s + 32
                continue 
            if ceil32(_1019) <= _1019:
                _1193 = mem[_437]
                s = 0
                while s < _1193:
                    mem[s + _1011 + _1019 + 32] = mem[s + _437 + 32]
                    s = s + 32
                    continue 
                if ceil32(_1193) <= _1193:
                    _1317 = mem[_812]
                    s = 0
                    while s < _1317:
                        mem[s + _1011 + _1019 + _1193 + 32] = mem[s + _812 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_1317) <= _1317:
                        _1405 = mem[64]
                        mem[mem[64]] = _1317 + _1011 + _1019 + _1193 - mem[64]
                        mem[64] = _1317 + _1011 + _1019 + _1193 + 32
                        if not idx + 1:
                            revert with 0, 17
                        idx = idx + 1
                        t = _1405
                        u = _631
                        continue 
                    mem[_1317 + _1011 + _1019 + _1193 + 32] = 0
                    _1406 = mem[64]
                    mem[mem[64]] = _1317 + _1011 + _1019 + _1193 - mem[64]
                    mem[64] = _1317 + _1011 + _1019 + _1193 + 32
                    if not idx + 1:
                        revert with 0, 17
                    idx = idx + 1
                    t = _1406
                    u = _631
                    continue 
                mem[_1193 + _1011 + _1019 + 32] = 0
                _1318 = mem[_812]
                s = 0
                while s < _1318:
                    mem[s + _1011 + _1019 + _1193 + 32] = mem[s + _812 + 32]
                    s = s + 32
                    continue 
                if ceil32(_1318) <= _1318:
                    _1407 = mem[64]
                    mem[mem[64]] = _1318 + _1011 + _1019 + _1193 - mem[64]
                    mem[64] = _1318 + _1011 + _1019 + _1193 + 32
                    if not idx + 1:
                        revert with 0, 17
                    idx = idx + 1
                    t = _1407
                    u = _631
                    continue 
                mem[_1318 + _1011 + _1019 + _1193 + 32] = 0
                _1408 = mem[64]
                mem[mem[64]] = _1318 + _1011 + _1019 + _1193 - mem[64]
                mem[64] = _1318 + _1011 + _1019 + _1193 + 32
                if not idx + 1:
                    revert with 0, 17
                idx = idx + 1
                t = _1408
                u = _631
                continue 
            mem[_1019 + _1011 + 32] = 0
            _1194 = mem[_437]
            s = 0
            while s < _1194:
                mem[s + _1011 + _1019 + 32] = mem[s + _437 + 32]
                s = s + 32
                continue 
            if ceil32(_1194) <= _1194:
                _1319 = mem[_812]
                s = 0
                while s < _1319:
                    mem[s + _1011 + _1019 + _1194 + 32] = mem[s + _812 + 32]
                    s = s + 32
                    continue 
                if ceil32(_1319) <= _1319:
                    _1409 = mem[64]
                    mem[mem[64]] = _1319 + _1011 + _1019 + _1194 - mem[64]
                    mem[64] = _1319 + _1011 + _1019 + _1194 + 32
                    if not idx + 1:
                        revert with 0, 17
                    idx = idx + 1
                    t = _1409
                    u = _631
                    continue 
                mem[_1319 + _1011 + _1019 + _1194 + 32] = 0
                _1410 = mem[64]
                mem[mem[64]] = _1319 + _1011 + _1019 + _1194 - mem[64]
                mem[64] = _1319 + _1011 + _1019 + _1194 + 32
                if not idx + 1:
                    revert with 0, 17
                idx = idx + 1
                t = _1410
                u = _631
                continue 
            mem[_1194 + _1011 + _1019 + 32] = 0
            _1320 = mem[_812]
            s = 0
            while s < _1320:
                mem[s + _1011 + _1019 + _1194 + 32] = mem[s + _812 + 32]
                s = s + 32
                continue 
            if ceil32(_1320) <= _1320:
                _1411 = mem[64]
                mem[mem[64]] = _1320 + _1011 + _1019 + _1194 - mem[64]
                mem[64] = _1320 + _1011 + _1019 + _1194 + 32
                if not idx + 1:
                    revert with 0, 17
                idx = idx + 1
                t = _1411
                u = _631
                continue 
            mem[_1320 + _1011 + _1019 + _1194 + 32] = 0
            _1412 = mem[64]
            mem[mem[64]] = _1320 + _1011 + _1019 + _1194 - mem[64]
            mem[64] = _1320 + _1011 + _1019 + _1194 + 32
            if not idx + 1:
                revert with 0, 17
            idx = idx + 1
            t = _1412
            u = _631
            continue 
        mem[_812 + 32 len u] = call.data[calldata.size len u]
        v = u
        s = _632
        while s:
            if v < 1:
                revert with 0, 17
            if s / 10 > 0x1999999999999999999999999999999999999999999999999999999999999999:
                revert with 0, 17
            if s < 10 * s / 10:
                revert with 0, 17
            if 48 > -uint8(s - (10 * s / 10)) + 255:
                revert with 0, 17
            if v - 1 >= mem[_812]:
                revert with 0, 50
            mem[v + _812 + 31 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 1), ('mul', -10, ('div', ('var', 1), 10)))))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 1), ('mul', -10, ('div', ('var', 1), 10)))))), 0) - 256
            v = v - 1
            s = s / 10
            continue 
        _1012 = mem[64]
        _1020 = mem[t]
        s = 0
        while s < _1020:
            mem[s + _1012 + 32] = mem[s + t + 32]
            s = s + 32
            continue 
        if ceil32(_1020) <= _1020:
            _1195 = mem[_437]
            s = 0
            while s < _1195:
                mem[s + _1012 + _1020 + 32] = mem[s + _437 + 32]
                s = s + 32
                continue 
            if ceil32(_1195) <= _1195:
                _1321 = mem[_812]
                idx = 0
                while idx < _1321:
                    mem[idx + _1012 + _1020 + _1195 + 32] = mem[idx + _812 + 32]
                    idx = idx + 32
                    continue 
                if ceil32(_1321) <= _1321:
                    _1413 = mem[64]
                    mem[mem[64]] = _1321 + _1012 + _1020 + _1195 - mem[64]
                    mem[64] = _1321 + _1012 + _1020 + _1195 + 32
                    if not ceil32(_1195) + 1:
                        revert with 0, 17
                    s = ceil32(_1195) + 1
                    t = _1413
                    u = _631
                    continue 
                mem[_1321 + _1012 + _1020 + _1195 + 32] = 0
                _1414 = mem[64]
                mem[mem[64]] = _1321 + _1012 + _1020 + _1195 - mem[64]
                mem[64] = _1321 + _1012 + _1020 + _1195 + 32
                if not ceil32(_1195) + 1:
                    revert with 0, 17
                s = ceil32(_1195) + 1
                t = _1414
                u = _631
                continue 
            mem[_1195 + _1012 + _1020 + 32] = 0
            _1322 = mem[_812]
            idx = 0
            while idx < _1322:
                mem[idx + _1012 + _1020 + _1195 + 32] = mem[idx + _812 + 32]
                idx = idx + 32
                continue 
            if ceil32(_1322) <= _1322:
                _1415 = mem[64]
                mem[mem[64]] = _1322 + _1012 + _1020 + _1195 - mem[64]
                mem[64] = _1322 + _1012 + _1020 + _1195 + 32
                if not ceil32(_1195) + 1:
                    revert with 0, 17
                s = ceil32(_1195) + 1
                t = _1415
                u = _631
                continue 
            mem[_1322 + _1012 + _1020 + _1195 + 32] = 0
            _1416 = mem[64]
            mem[mem[64]] = _1322 + _1012 + _1020 + _1195 - mem[64]
            mem[64] = _1322 + _1012 + _1020 + _1195 + 32
            if not ceil32(_1195) + 1:
                revert with 0, 17
            s = ceil32(_1195) + 1
            t = _1416
            u = _631
            continue 
        mem[_1020 + _1012 + 32] = 0
        _1196 = mem[_437]
        s = 0
        while s < _1196:
            mem[s + _1012 + _1020 + 32] = mem[s + _437 + 32]
            s = s + 32
            continue 
        if ceil32(_1196) <= _1196:
            _1323 = mem[_812]
            idx = 0
            while idx < _1323:
                mem[idx + _1012 + _1020 + _1196 + 32] = mem[idx + _812 + 32]
                idx = idx + 32
                continue 
            if ceil32(_1323) <= _1323:
                _1417 = mem[64]
                mem[mem[64]] = _1323 + _1012 + _1020 + _1196 - mem[64]
                mem[64] = _1323 + _1012 + _1020 + _1196 + 32
                if not ceil32(_1196) + 1:
                    revert with 0, 17
                s = ceil32(_1196) + 1
                t = _1417
                u = _631
                continue 
            mem[_1323 + _1012 + _1020 + _1196 + 32] = 0
            _1418 = mem[64]
            mem[mem[64]] = _1323 + _1012 + _1020 + _1196 - mem[64]
            mem[64] = _1323 + _1012 + _1020 + _1196 + 32
            if not ceil32(_1196) + 1:
                revert with 0, 17
            s = ceil32(_1196) + 1
            t = _1418
            u = _631
            continue 
        mem[_1196 + _1012 + _1020 + 32] = 0
        _1324 = mem[_812]
        idx = 0
        while idx < _1324:
            mem[idx + _1012 + _1020 + _1196 + 32] = mem[idx + _812 + 32]
            idx = idx + 32
            continue 
        if ceil32(_1324) <= _1324:
            _1419 = mem[64]
            mem[mem[64]] = _1324 + _1012 + _1020 + _1196 - mem[64]
            mem[64] = _1324 + _1012 + _1020 + _1196 + 32
            if not ceil32(_1196) + 1:
                revert with 0, 17
            s = ceil32(_1196) + 1
            t = _1419
            u = _631
            continue 
        mem[_1324 + _1012 + _1020 + _1196 + 32] = 0
        _1420 = mem[64]
        mem[mem[64]] = _1324 + _1012 + _1020 + _1196 - mem[64]
        mem[64] = _1324 + _1012 + _1020 + _1196 + 32
        if not ceil32(_1196) + 1:
            revert with 0, 17
        s = ceil32(_1196) + 1
        t = _1420
        u = _631
        continue 
    _630 = mem[64]
    mem[mem[64]] = 32
    _643 = mem[t]
    mem[mem[64] + 32] = mem[t]
    mem[mem[64] + 64 len ceil32(_643)] = mem[t + 32 len ceil32(_643)]
    if ceil32(_643) <= _643:
        return 32, mem[mem[64] + 32 len ceil32(_643) + 32]
    mem[_643 + mem[64] + 64] = 0
    return memory
      from mem[64]
       len ceil32(_643) + _630 + -mem[64] + 64
}

function _getRewardAmountOf(address arg1) payable {
    mem[64] = 96
    require calldata.size - 4 >= 32
    require arg1 == arg1
    mem[0] = arg1
    mem[32] = 10
    idx = 0
    s = 0
    while idx < stor10[address(arg1)].field_0:
        mem[0] = sha3(address(arg1), 10)
        _521 = mem[64]
        mem[64] = mem[64] + 128
        if stor10[address(arg1)][idx].field_0:
            if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                revert with 0, 34
            _522 = mem[64]
            mem[64] = mem[64] + ceil32(uint255(stor10[address(arg1)][idx].field_0) * 0.5) + 32
            mem[_522] = uint255(stor10[address(arg1)][idx].field_0) * 0.5
            if stor10[address(arg1)][idx].field_0:
                if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                    revert with 0, 34
                if not Mask(256, -1, stor10[address(arg1)][idx].field_0):
                    mem[_521] = _522
                    mem[_521 + 32] = stor10[address(arg1)][idx].field_256
                    mem[_521 + 64] = stor10[address(arg1)][idx].field_512
                    mem[_521 + 96] = stor10[address(arg1)][idx].field_768
                    if -stor10[address(arg1)][idx].field_512:
                        _530 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_530] = 30
                        mem[_530 + 32] = 'SafeMath: subtraction overflow'
                        if stor10[address(arg1)][idx].field_512 > block.timestamp:
                            _538 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _538 + 68] = mem[idx + _530 + 32]
                                idx = idx + 32
                                continue 
                            mem[_538 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _538 + -mem[64] + 100
                        if block.timestamp < stor10[address(arg1)][idx].field_512:
                            revert with 0, 17
                        _577 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_577] = 26
                        mem[_577 + 32] = 'SafeMath: division by zero'
                        if not claimTime:
                            _598 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _598 + 68] = mem[idx + _577 + 32]
                                idx = idx + 32
                                continue 
                            mem[_598 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _598 + -mem[64] + 100
                        if 0 > !(block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime):
                            revert with 0, 17
                        if block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime < 0:
                            revert with 0, 'SafeMath: addition overflow'
                        if not -rewardPerNode:
                            if 0 > !stor10[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if stor10[address(arg1)][idx].field_768 < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !stor10[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if not idx + 1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + stor10[address(arg1)][idx].field_768
                            continue 
                        if rewardPerNode and block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                            revert with 0, 17
                        if not rewardPerNode:
                            revert with 0, 18
                        if rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime > !stor10[address(arg1)][idx].field_768:
                            revert with 0, 17
                        if (rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime:
                            revert with 0, 'SafeMath: addition overflow'
                        if s > !((rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768):
                            revert with 0, 17
                        if not idx + 1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + (rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768
                        continue 
                    _570 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_570] = 30
                    mem[_570 + 32] = 'SafeMath: subtraction overflow'
                    if stor10[address(arg1)][idx].field_256 > block.timestamp:
                        _587 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _587 + 68] = mem[idx + _570 + 32]
                            idx = idx + 32
                            continue 
                        mem[_587 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _587 + -mem[64] + 100
                    if block.timestamp < stor10[address(arg1)][idx].field_256:
                        revert with 0, 17
                    _672 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_672] = 26
                    mem[_672 + 32] = 'SafeMath: division by zero'
                    if not claimTime:
                        _701 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _701 + 68] = mem[idx + _672 + 32]
                            idx = idx + 32
                            continue 
                        mem[_701 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _701 + -mem[64] + 100
                else:
                    if 31 >= uint255(stor10[address(arg1)][idx].field_0) * 0.5:
                        mem[_522 + 32] = 256 * stor10[address(arg1)][idx].field_8
                        mem[_521] = _522
                        mem[_521 + 32] = stor10[address(arg1)][idx].field_256
                        mem[_521 + 64] = stor10[address(arg1)][idx].field_512
                        mem[_521 + 96] = stor10[address(arg1)][idx].field_768
                        if -stor10[address(arg1)][idx].field_512:
                            _540 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_540] = 30
                            mem[_540 + 32] = 'SafeMath: subtraction overflow'
                            if stor10[address(arg1)][idx].field_512 > block.timestamp:
                                _551 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _551 + 68] = mem[idx + _540 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_551 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _551 + -mem[64] + 100
                            if block.timestamp < stor10[address(arg1)][idx].field_512:
                                revert with 0, 17
                            _599 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_599] = 26
                            mem[_599 + 32] = 'SafeMath: division by zero'
                            if not claimTime:
                                _626 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _626 + 68] = mem[idx + _599 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_626 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _626 + -mem[64] + 100
                            if 0 > !(block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime):
                                revert with 0, 17
                            if block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if not -rewardPerNode:
                                if 0 > !stor10[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if stor10[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !stor10[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if not idx + 1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + stor10[address(arg1)][idx].field_768
                                continue 
                            if rewardPerNode and block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime > !stor10[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if (rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !((rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768):
                                revert with 0, 17
                            if not idx + 1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + (rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768
                            continue 
                        _590 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_590] = 30
                        mem[_590 + 32] = 'SafeMath: subtraction overflow'
                        if stor10[address(arg1)][idx].field_256 > block.timestamp:
                            _615 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _615 + 68] = mem[idx + _590 + 32]
                                idx = idx + 32
                                continue 
                            mem[_615 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _615 + -mem[64] + 100
                        if block.timestamp < stor10[address(arg1)][idx].field_256:
                            revert with 0, 17
                        _703 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_703] = 26
                        mem[_703 + 32] = 'SafeMath: division by zero'
                        if not claimTime:
                            _729 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _729 + 68] = mem[idx + _703 + 32]
                                idx = idx + 32
                                continue 
                            mem[_729 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _729 + -mem[64] + 100
                    else:
                        mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                        mem[_522 + 32] = stor10[address(arg1)][idx].field_0
                        t = _522 + 32
                        u = sha3(mem[0])
                        while _522 + (uint255(stor10[address(arg1)][idx].field_0) * 0.5) > t:
                            mem[t + 32] = uint256(stor1[u])
                            t = t + 32
                            u = u + 1
                            continue 
                        mem[_521] = _522
                        mem[_521 + 32] = stor10[address(arg1)][idx].field_256
                        mem[_521 + 64] = stor10[address(arg1)][idx].field_512
                        mem[_521 + 96] = stor10[address(arg1)][idx].field_768
                        if -stor10[address(arg1)][idx].field_512:
                            _1076 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1076] = 30
                            mem[_1076 + 32] = 'SafeMath: subtraction overflow'
                            if stor10[address(arg1)][idx].field_512 > block.timestamp:
                                _1136 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _1136 + 68] = mem[idx + _1076 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_1136 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _1136 + -mem[64] + 100
                            if block.timestamp < stor10[address(arg1)][idx].field_512:
                                revert with 0, 17
                            _1156 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1156] = 26
                            mem[_1156 + 32] = 'SafeMath: division by zero'
                            if not claimTime:
                                _1164 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _1164 + 68] = mem[idx + _1156 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_1164 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _1164 + -mem[64] + 100
                            if 0 > !(block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime):
                                revert with 0, 17
                            if block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if not -rewardPerNode:
                                if 0 > !stor10[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if stor10[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !stor10[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if not idx + 1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + stor10[address(arg1)][idx].field_768
                                continue 
                            if rewardPerNode and block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime > !stor10[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if (rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !((rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768):
                                revert with 0, 17
                            if not idx + 1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + (rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768
                            continue 
                        _1149 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1149] = 30
                        mem[_1149 + 32] = 'SafeMath: subtraction overflow'
                        if stor10[address(arg1)][idx].field_256 > block.timestamp:
                            _1160 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _1160 + 68] = mem[idx + _1149 + 32]
                                idx = idx + 32
                                continue 
                            mem[_1160 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _1160 + -mem[64] + 100
                        if block.timestamp < stor10[address(arg1)][idx].field_256:
                            revert with 0, 17
                        _1189 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1189] = 26
                        mem[_1189 + 32] = 'SafeMath: division by zero'
                        if not claimTime:
                            _1196 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _1196 + 68] = mem[idx + _1189 + 32]
                                idx = idx + 32
                                continue 
                            mem[_1196 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _1196 + -mem[64] + 100
            else:
                if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                    revert with 0, 34
                if not stor10[address(arg1)][idx].field_1:
                    mem[_521] = _522
                    mem[_521 + 32] = stor10[address(arg1)][idx].field_256
                    mem[_521 + 64] = stor10[address(arg1)][idx].field_512
                    mem[_521 + 96] = stor10[address(arg1)][idx].field_768
                    if -stor10[address(arg1)][idx].field_512:
                        _534 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_534] = 30
                        mem[_534 + 32] = 'SafeMath: subtraction overflow'
                        if stor10[address(arg1)][idx].field_512 > block.timestamp:
                            _543 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _543 + 68] = mem[idx + _534 + 32]
                                idx = idx + 32
                                continue 
                            mem[_543 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _543 + -mem[64] + 100
                        if block.timestamp < stor10[address(arg1)][idx].field_512:
                            revert with 0, 17
                        _591 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_591] = 26
                        mem[_591 + 32] = 'SafeMath: division by zero'
                        if not claimTime:
                            _616 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _616 + 68] = mem[idx + _591 + 32]
                                idx = idx + 32
                                continue 
                            mem[_616 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _616 + -mem[64] + 100
                        if 0 > !(block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime):
                            revert with 0, 17
                        if block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime < 0:
                            revert with 0, 'SafeMath: addition overflow'
                        if not -rewardPerNode:
                            if 0 > !stor10[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if stor10[address(arg1)][idx].field_768 < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !stor10[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if not idx + 1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + stor10[address(arg1)][idx].field_768
                            continue 
                        if rewardPerNode and block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                            revert with 0, 17
                        if not rewardPerNode:
                            revert with 0, 18
                        if rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime > !stor10[address(arg1)][idx].field_768:
                            revert with 0, 17
                        if (rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime:
                            revert with 0, 'SafeMath: addition overflow'
                        if s > !((rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768):
                            revert with 0, 17
                        if not idx + 1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + (rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768
                        continue 
                    _580 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_580] = 30
                    mem[_580 + 32] = 'SafeMath: subtraction overflow'
                    if stor10[address(arg1)][idx].field_256 > block.timestamp:
                        _600 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _600 + 68] = mem[idx + _580 + 32]
                            idx = idx + 32
                            continue 
                        mem[_600 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _600 + -mem[64] + 100
                    if block.timestamp < stor10[address(arg1)][idx].field_256:
                        revert with 0, 17
                    _689 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_689] = 26
                    mem[_689 + 32] = 'SafeMath: division by zero'
                    if not claimTime:
                        _716 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _716 + 68] = mem[idx + _689 + 32]
                            idx = idx + 32
                            continue 
                        mem[_716 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _716 + -mem[64] + 100
                else:
                    if 31 >= stor10[address(arg1)][idx].field_1:
                        mem[_522 + 32] = 256 * stor10[address(arg1)][idx].field_8
                        mem[_521] = _522
                        mem[_521 + 32] = stor10[address(arg1)][idx].field_256
                        mem[_521 + 64] = stor10[address(arg1)][idx].field_512
                        mem[_521 + 96] = stor10[address(arg1)][idx].field_768
                        if -stor10[address(arg1)][idx].field_512:
                            _545 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_545] = 30
                            mem[_545 + 32] = 'SafeMath: subtraction overflow'
                            if stor10[address(arg1)][idx].field_512 > block.timestamp:
                                _558 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _558 + 68] = mem[idx + _545 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_558 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _558 + -mem[64] + 100
                            if block.timestamp < stor10[address(arg1)][idx].field_512:
                                revert with 0, 17
                            _617 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_617] = 26
                            mem[_617 + 32] = 'SafeMath: division by zero'
                            if not claimTime:
                                _647 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _647 + 68] = mem[idx + _617 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_647 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _647 + -mem[64] + 100
                            if 0 > !(block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime):
                                revert with 0, 17
                            if block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if not -rewardPerNode:
                                if 0 > !stor10[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if stor10[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !stor10[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if not idx + 1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + stor10[address(arg1)][idx].field_768
                                continue 
                            if rewardPerNode and block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime > !stor10[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if (rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !((rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768):
                                revert with 0, 17
                            if not idx + 1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + (rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768
                            continue 
                        _603 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_603] = 30
                        mem[_603 + 32] = 'SafeMath: subtraction overflow'
                        if stor10[address(arg1)][idx].field_256 > block.timestamp:
                            _632 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _632 + 68] = mem[idx + _603 + 32]
                                idx = idx + 32
                                continue 
                            mem[_632 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _632 + -mem[64] + 100
                        if block.timestamp < stor10[address(arg1)][idx].field_256:
                            revert with 0, 17
                        _718 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_718] = 26
                        mem[_718 + 32] = 'SafeMath: division by zero'
                        if not claimTime:
                            _747 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _747 + 68] = mem[idx + _718 + 32]
                                idx = idx + 32
                                continue 
                            mem[_747 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _747 + -mem[64] + 100
                    else:
                        mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                        mem[_522 + 32] = stor10[address(arg1)][idx].field_0
                        t = _522 + 32
                        u = sha3(mem[0])
                        while _522 + stor10[address(arg1)][idx].field_1 > t:
                            mem[t + 32] = uint256(stor1[u])
                            t = t + 32
                            u = u + 1
                            continue 
                        mem[_521] = _522
                        mem[_521 + 32] = stor10[address(arg1)][idx].field_256
                        mem[_521 + 64] = stor10[address(arg1)][idx].field_512
                        mem[_521 + 96] = stor10[address(arg1)][idx].field_768
                        if -stor10[address(arg1)][idx].field_512:
                            _1093 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1093] = 30
                            mem[_1093 + 32] = 'SafeMath: subtraction overflow'
                            if stor10[address(arg1)][idx].field_512 > block.timestamp:
                                _1137 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _1137 + 68] = mem[idx + _1093 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_1137 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _1137 + -mem[64] + 100
                            if block.timestamp < stor10[address(arg1)][idx].field_512:
                                revert with 0, 17
                            _1157 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1157] = 26
                            mem[_1157 + 32] = 'SafeMath: division by zero'
                            if not claimTime:
                                _1165 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _1165 + 68] = mem[idx + _1157 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_1165 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _1165 + -mem[64] + 100
                            if 0 > !(block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime):
                                revert with 0, 17
                            if block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if not -rewardPerNode:
                                if 0 > !stor10[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if stor10[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !stor10[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if not idx + 1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + stor10[address(arg1)][idx].field_768
                                continue 
                            if rewardPerNode and block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime > !stor10[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if (rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !((rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768):
                                revert with 0, 17
                            if not idx + 1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + (rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768
                            continue 
                        _1151 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1151] = 30
                        mem[_1151 + 32] = 'SafeMath: subtraction overflow'
                        if stor10[address(arg1)][idx].field_256 > block.timestamp:
                            _1161 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _1161 + 68] = mem[idx + _1151 + 32]
                                idx = idx + 32
                                continue 
                            mem[_1161 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _1161 + -mem[64] + 100
                        if block.timestamp < stor10[address(arg1)][idx].field_256:
                            revert with 0, 17
                        _1191 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1191] = 26
                        mem[_1191 + 32] = 'SafeMath: division by zero'
                        if not claimTime:
                            _1197 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _1197 + 68] = mem[idx + _1191 + 32]
                                idx = idx + 32
                                continue 
                            mem[_1197 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _1197 + -mem[64] + 100
        else:
            if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                revert with 0, 34
            _523 = mem[64]
            mem[64] = mem[64] + ceil32(stor10[address(arg1)][idx].field_1) + 32
            mem[_523] = stor10[address(arg1)][idx].field_1
            if stor10[address(arg1)][idx].field_0:
                if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                    revert with 0, 34
                if not Mask(256, -1, stor10[address(arg1)][idx].field_0):
                    mem[_521] = _523
                    mem[_521 + 32] = stor10[address(arg1)][idx].field_256
                    mem[_521 + 64] = stor10[address(arg1)][idx].field_512
                    mem[_521 + 96] = stor10[address(arg1)][idx].field_768
                    if -stor10[address(arg1)][idx].field_512:
                        _536 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_536] = 30
                        mem[_536 + 32] = 'SafeMath: subtraction overflow'
                        if stor10[address(arg1)][idx].field_512 > block.timestamp:
                            _546 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _546 + 68] = mem[idx + _536 + 32]
                                idx = idx + 32
                                continue 
                            mem[_546 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _546 + -mem[64] + 100
                        if block.timestamp < stor10[address(arg1)][idx].field_512:
                            revert with 0, 17
                        _593 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_593] = 26
                        mem[_593 + 32] = 'SafeMath: division by zero'
                        if not claimTime:
                            _618 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _618 + 68] = mem[idx + _593 + 32]
                                idx = idx + 32
                                continue 
                            mem[_618 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _618 + -mem[64] + 100
                        if 0 > !(block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime):
                            revert with 0, 17
                        if block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime < 0:
                            revert with 0, 'SafeMath: addition overflow'
                        if not -rewardPerNode:
                            if 0 > !stor10[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if stor10[address(arg1)][idx].field_768 < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !stor10[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if not idx + 1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + stor10[address(arg1)][idx].field_768
                            continue 
                        if rewardPerNode and block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                            revert with 0, 17
                        if not rewardPerNode:
                            revert with 0, 18
                        if rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime > !stor10[address(arg1)][idx].field_768:
                            revert with 0, 17
                        if (rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime:
                            revert with 0, 'SafeMath: addition overflow'
                        if s > !((rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768):
                            revert with 0, 17
                        if not idx + 1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + (rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768
                        continue 
                    _583 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_583] = 30
                    mem[_583 + 32] = 'SafeMath: subtraction overflow'
                    if stor10[address(arg1)][idx].field_256 > block.timestamp:
                        _604 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _604 + 68] = mem[idx + _583 + 32]
                            idx = idx + 32
                            continue 
                        mem[_604 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _604 + -mem[64] + 100
                    if block.timestamp < stor10[address(arg1)][idx].field_256:
                        revert with 0, 17
                    _694 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_694] = 26
                    mem[_694 + 32] = 'SafeMath: division by zero'
                    if not claimTime:
                        _719 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _719 + 68] = mem[idx + _694 + 32]
                            idx = idx + 32
                            continue 
                        mem[_719 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _719 + -mem[64] + 100
                else:
                    if 31 >= uint255(stor10[address(arg1)][idx].field_0) * 0.5:
                        mem[_523 + 32] = 256 * stor10[address(arg1)][idx].field_8
                        mem[_521] = _523
                        mem[_521 + 32] = stor10[address(arg1)][idx].field_256
                        mem[_521 + 64] = stor10[address(arg1)][idx].field_512
                        mem[_521 + 96] = stor10[address(arg1)][idx].field_768
                        if -stor10[address(arg1)][idx].field_512:
                            _548 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_548] = 30
                            mem[_548 + 32] = 'SafeMath: subtraction overflow'
                            if stor10[address(arg1)][idx].field_512 > block.timestamp:
                                _561 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _561 + 68] = mem[idx + _548 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_561 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _561 + -mem[64] + 100
                            if block.timestamp < stor10[address(arg1)][idx].field_512:
                                revert with 0, 17
                            _619 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_619] = 26
                            mem[_619 + 32] = 'SafeMath: division by zero'
                            if not claimTime:
                                _650 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _650 + 68] = mem[idx + _619 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_650 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _650 + -mem[64] + 100
                            if 0 > !(block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime):
                                revert with 0, 17
                            if block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if not -rewardPerNode:
                                if 0 > !stor10[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if stor10[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !stor10[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if not idx + 1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + stor10[address(arg1)][idx].field_768
                                continue 
                            if rewardPerNode and block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime > !stor10[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if (rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !((rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768):
                                revert with 0, 17
                            if not idx + 1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + (rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768
                            continue 
                        _607 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_607] = 30
                        mem[_607 + 32] = 'SafeMath: subtraction overflow'
                        if stor10[address(arg1)][idx].field_256 > block.timestamp:
                            _638 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _638 + 68] = mem[idx + _607 + 32]
                                idx = idx + 32
                                continue 
                            mem[_638 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _638 + -mem[64] + 100
                        if block.timestamp < stor10[address(arg1)][idx].field_256:
                            revert with 0, 17
                        _721 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_721] = 26
                        mem[_721 + 32] = 'SafeMath: division by zero'
                        if not claimTime:
                            _753 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _753 + 68] = mem[idx + _721 + 32]
                                idx = idx + 32
                                continue 
                            mem[_753 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _753 + -mem[64] + 100
                    else:
                        mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                        mem[_523 + 32] = stor10[address(arg1)][idx].field_0
                        t = _523 + 32
                        u = sha3(mem[0])
                        while _523 + (uint255(stor10[address(arg1)][idx].field_0) * 0.5) > t:
                            mem[t + 32] = uint256(stor1[u])
                            t = t + 32
                            u = u + 1
                            continue 
                        mem[_521] = _523
                        mem[_521 + 32] = stor10[address(arg1)][idx].field_256
                        mem[_521 + 64] = stor10[address(arg1)][idx].field_512
                        mem[_521 + 96] = stor10[address(arg1)][idx].field_768
                        if -stor10[address(arg1)][idx].field_512:
                            _1110 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1110] = 30
                            mem[_1110 + 32] = 'SafeMath: subtraction overflow'
                            if stor10[address(arg1)][idx].field_512 > block.timestamp:
                                _1138 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _1138 + 68] = mem[idx + _1110 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_1138 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _1138 + -mem[64] + 100
                            if block.timestamp < stor10[address(arg1)][idx].field_512:
                                revert with 0, 17
                            _1158 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1158] = 26
                            mem[_1158 + 32] = 'SafeMath: division by zero'
                            if not claimTime:
                                _1166 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _1166 + 68] = mem[idx + _1158 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_1166 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _1166 + -mem[64] + 100
                            if 0 > !(block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime):
                                revert with 0, 17
                            if block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if not -rewardPerNode:
                                if 0 > !stor10[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if stor10[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !stor10[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if not idx + 1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + stor10[address(arg1)][idx].field_768
                                continue 
                            if rewardPerNode and block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime > !stor10[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if (rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !((rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768):
                                revert with 0, 17
                            if not idx + 1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + (rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768
                            continue 
                        _1153 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1153] = 30
                        mem[_1153 + 32] = 'SafeMath: subtraction overflow'
                        if stor10[address(arg1)][idx].field_256 > block.timestamp:
                            _1162 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _1162 + 68] = mem[idx + _1153 + 32]
                                idx = idx + 32
                                continue 
                            mem[_1162 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _1162 + -mem[64] + 100
                        if block.timestamp < stor10[address(arg1)][idx].field_256:
                            revert with 0, 17
                        _1193 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1193] = 26
                        mem[_1193 + 32] = 'SafeMath: division by zero'
                        if not claimTime:
                            _1198 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _1198 + 68] = mem[idx + _1193 + 32]
                                idx = idx + 32
                                continue 
                            mem[_1198 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _1198 + -mem[64] + 100
            else:
                if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                    revert with 0, 34
                if not stor10[address(arg1)][idx].field_1:
                    mem[_521] = _523
                    mem[_521 + 32] = stor10[address(arg1)][idx].field_256
                    mem[_521 + 64] = stor10[address(arg1)][idx].field_512
                    mem[_521 + 96] = stor10[address(arg1)][idx].field_768
                    if -stor10[address(arg1)][idx].field_512:
                        _541 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_541] = 30
                        mem[_541 + 32] = 'SafeMath: subtraction overflow'
                        if stor10[address(arg1)][idx].field_512 > block.timestamp:
                            _552 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _552 + 68] = mem[idx + _541 + 32]
                                idx = idx + 32
                                continue 
                            mem[_552 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _552 + -mem[64] + 100
                        if block.timestamp < stor10[address(arg1)][idx].field_512:
                            revert with 0, 17
                        _608 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_608] = 26
                        mem[_608 + 32] = 'SafeMath: division by zero'
                        if not claimTime:
                            _639 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _639 + 68] = mem[idx + _608 + 32]
                                idx = idx + 32
                                continue 
                            mem[_639 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _639 + -mem[64] + 100
                        if 0 > !(block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime):
                            revert with 0, 17
                        if block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime < 0:
                            revert with 0, 'SafeMath: addition overflow'
                        if not -rewardPerNode:
                            if 0 > !stor10[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if stor10[address(arg1)][idx].field_768 < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !stor10[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if not idx + 1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + stor10[address(arg1)][idx].field_768
                            continue 
                        if rewardPerNode and block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                            revert with 0, 17
                        if not rewardPerNode:
                            revert with 0, 18
                        if rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime > !stor10[address(arg1)][idx].field_768:
                            revert with 0, 17
                        if (rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime:
                            revert with 0, 'SafeMath: addition overflow'
                        if s > !((rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768):
                            revert with 0, 17
                        if not idx + 1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + (rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768
                        continue 
                    _596 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_596] = 30
                    mem[_596 + 32] = 'SafeMath: subtraction overflow'
                    if stor10[address(arg1)][idx].field_256 > block.timestamp:
                        _620 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _620 + 68] = mem[idx + _596 + 32]
                            idx = idx + 32
                            continue 
                        mem[_620 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _620 + -mem[64] + 100
                    if block.timestamp < stor10[address(arg1)][idx].field_256:
                        revert with 0, 17
                    _709 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_709] = 26
                    mem[_709 + 32] = 'SafeMath: division by zero'
                    if not claimTime:
                        _736 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _736 + 68] = mem[idx + _709 + 32]
                            idx = idx + 32
                            continue 
                        mem[_736 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _736 + -mem[64] + 100
                else:
                    if 31 >= stor10[address(arg1)][idx].field_1:
                        mem[_523 + 32] = 256 * stor10[address(arg1)][idx].field_8
                        mem[_521] = _523
                        mem[_521 + 32] = stor10[address(arg1)][idx].field_256
                        mem[_521 + 64] = stor10[address(arg1)][idx].field_512
                        mem[_521 + 96] = stor10[address(arg1)][idx].field_768
                        if -stor10[address(arg1)][idx].field_512:
                            _554 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_554] = 30
                            mem[_554 + 32] = 'SafeMath: subtraction overflow'
                            if stor10[address(arg1)][idx].field_512 > block.timestamp:
                                _568 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _568 + 68] = mem[idx + _554 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_568 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _568 + -mem[64] + 100
                            if block.timestamp < stor10[address(arg1)][idx].field_512:
                                revert with 0, 17
                            _640 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_640] = 26
                            mem[_640 + 32] = 'SafeMath: division by zero'
                            if not claimTime:
                                _670 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _670 + 68] = mem[idx + _640 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_670 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _670 + -mem[64] + 100
                            if 0 > !(block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime):
                                revert with 0, 17
                            if block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if not -rewardPerNode:
                                if 0 > !stor10[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if stor10[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !stor10[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if not idx + 1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + stor10[address(arg1)][idx].field_768
                                continue 
                            if rewardPerNode and block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime > !stor10[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if (rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !((rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768):
                                revert with 0, 17
                            if not idx + 1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + (rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768
                            continue 
                        _623 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_623] = 30
                        mem[_623 + 32] = 'SafeMath: subtraction overflow'
                        if stor10[address(arg1)][idx].field_256 > block.timestamp:
                            _656 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _656 + 68] = mem[idx + _623 + 32]
                                idx = idx + 32
                                continue 
                            mem[_656 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _656 + -mem[64] + 100
                        if block.timestamp < stor10[address(arg1)][idx].field_256:
                            revert with 0, 17
                        _738 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_738] = 26
                        mem[_738 + 32] = 'SafeMath: division by zero'
                        if not claimTime:
                            _773 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _773 + 68] = mem[idx + _738 + 32]
                                idx = idx + 32
                                continue 
                            mem[_773 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _773 + -mem[64] + 100
                    else:
                        mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                        mem[_523 + 32] = stor10[address(arg1)][idx].field_0
                        t = _523 + 32
                        u = sha3(mem[0])
                        while _523 + stor10[address(arg1)][idx].field_1 > t:
                            mem[t + 32] = uint256(stor1[u])
                            t = t + 32
                            u = u + 1
                            continue 
                        mem[_521] = _523
                        mem[_521 + 32] = stor10[address(arg1)][idx].field_256
                        mem[_521 + 64] = stor10[address(arg1)][idx].field_512
                        mem[_521 + 96] = stor10[address(arg1)][idx].field_768
                        if -stor10[address(arg1)][idx].field_512:
                            _1127 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1127] = 30
                            mem[_1127 + 32] = 'SafeMath: subtraction overflow'
                            if stor10[address(arg1)][idx].field_512 > block.timestamp:
                                _1139 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _1139 + 68] = mem[idx + _1127 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_1139 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _1139 + -mem[64] + 100
                            if block.timestamp < stor10[address(arg1)][idx].field_512:
                                revert with 0, 17
                            _1159 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1159] = 26
                            mem[_1159 + 32] = 'SafeMath: division by zero'
                            if not claimTime:
                                _1167 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _1167 + 68] = mem[idx + _1159 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_1167 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _1167 + -mem[64] + 100
                            if 0 > !(block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime):
                                revert with 0, 17
                            if block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if not -rewardPerNode:
                                if 0 > !stor10[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if stor10[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !stor10[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if not idx + 1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + stor10[address(arg1)][idx].field_768
                                continue 
                            if rewardPerNode and block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime > !stor10[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if (rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !((rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768):
                                revert with 0, 17
                            if not idx + 1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + (rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768
                            continue 
                        _1155 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1155] = 30
                        mem[_1155 + 32] = 'SafeMath: subtraction overflow'
                        if stor10[address(arg1)][idx].field_256 > block.timestamp:
                            _1163 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _1163 + 68] = mem[idx + _1155 + 32]
                                idx = idx + 32
                                continue 
                            mem[_1163 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _1163 + -mem[64] + 100
                        if block.timestamp < stor10[address(arg1)][idx].field_256:
                            revert with 0, 17
                        _1195 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1195] = 26
                        mem[_1195 + 32] = 'SafeMath: division by zero'
                        if not claimTime:
                            _1199 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _1199 + 68] = mem[idx + _1195 + 32]
                                idx = idx + 32
                                continue 
                            mem[_1199 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _1199 + -mem[64] + 100
        ('stor', ('name', 'claimTime', 17))
        if 1 > !(block.timestamp - stor10[address(arg1)][idx].field_256 / claimTime):
            revert with 0, 17
        if (block.timestamp - stor10[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
            revert with 0, 'SafeMath: addition overflow'
        if not -rewardPerNode:
            if 0 > !stor10[address(arg1)][idx].field_768:
                revert with 0, 17
            if stor10[address(arg1)][idx].field_768 < 0:
                revert with 0, 'SafeMath: addition overflow'
            if s > !stor10[address(arg1)][idx].field_768:
                revert with 0, 17
            if not idx + 1:
                revert with 0, 17
            idx = idx + 1
            s = s + stor10[address(arg1)][idx].field_768
            continue 
        if rewardPerNode and (block.timestamp - stor10[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
            revert with 0, 17
        if not rewardPerNode:
            revert with 0, 18
        if rewardPerNode + (block.timestamp - stor10[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - stor10[address(arg1)][idx].field_256 / claimTime) + 1:
            revert with 0, 'SafeMath: multiplication overflow'
        if rewardPerNode + (block.timestamp - stor10[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !stor10[address(arg1)][idx].field_768:
            revert with 0, 17
        if stor10[address(arg1)][idx].field_768 < 0:
            revert with 0, 'SafeMath: addition overflow'
        if s > !(rewardPerNode + (block.timestamp - stor10[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + stor10[address(arg1)][idx].field_768):
            revert with 0, 17
        if not idx + 1:
            revert with 0, 17
        idx = idx + 1
        s = s + rewardPerNode + (block.timestamp - stor10[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + stor10[address(arg1)][idx].field_768
        continue 
    return s
}

function _cashoutAllNodesReward(address arg1) payable {
    mem[64] = 96
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if msg.sender == tokenAddress:
        mem[0] = arg1
        mem[32] = 10
        idx = 0
        s = 0
        while idx < stor10[address(arg1)].field_0:
            mem[0] = sha3(address(arg1), 10)
            _1847 = mem[64]
            mem[64] = mem[64] + 128
            if stor10[address(arg1)][idx].field_0:
                if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                    revert with 0, 34
                _1854 = mem[64]
                mem[64] = mem[64] + ceil32(uint255(stor10[address(arg1)][idx].field_0) * 0.5) + 32
                mem[_1854] = uint255(stor10[address(arg1)][idx].field_0) * 0.5
                if stor10[address(arg1)][idx].field_0:
                    if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                        revert with 0, 34
                    if not Mask(256, -1, stor10[address(arg1)][idx].field_0):
                        mem[_1847] = _1854
                        mem[_1847 + 32] = stor10[address(arg1)][idx].field_256
                        mem[_1847 + 64] = stor10[address(arg1)][idx].field_512
                        mem[_1847 + 96] = stor10[address(arg1)][idx].field_768
                        if -stor10[address(arg1)][idx].field_512:
                            _1878 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1878] = 30
                            mem[_1878 + 32] = 'SafeMath: subtraction overflow'
                            if stor10[address(arg1)][idx].field_512 > block.timestamp:
                                _1902 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _1902 + 68] = mem[idx + _1878 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_1902 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _1902 + -mem[64] + 100
                            if block.timestamp < stor10[address(arg1)][idx].field_512:
                                revert with 0, 17
                            _2019 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2019] = 26
                            mem[_2019 + 32] = 'SafeMath: division by zero'
                            if not claimTime:
                                _2082 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _2082 + 68] = mem[idx + _2019 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2082 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _2082 + -mem[64] + 100
                            if 0 > !(block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime):
                                revert with 0, 17
                            if block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if not -rewardPerNode:
                                if 0 > !stor10[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if stor10[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !stor10[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if idx >= stor10[address(arg1)].field_0:
                                    revert with 0, 50
                                stor10[address(arg1)][idx].field_512 = block.timestamp
                                mem[0] = sha3(address(arg1), 10)
                                stor10[address(arg1)][idx].field_768 = 0
                                if not idx + 1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + stor10[address(arg1)][idx].field_768
                                continue 
                            if rewardPerNode and block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime > !stor10[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if (rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !((rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768):
                                revert with 0, 17
                            if idx >= stor10[address(arg1)].field_0:
                                revert with 0, 50
                            stor10[address(arg1)][idx].field_512 = block.timestamp
                            mem[0] = sha3(address(arg1), 10)
                            stor10[address(arg1)][idx].field_768 = 0
                            if not idx + 1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + (rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768
                            continue 
                        _1996 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1996] = 30
                        mem[_1996 + 32] = 'SafeMath: subtraction overflow'
                        if stor10[address(arg1)][idx].field_256 > block.timestamp:
                            _2049 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _2049 + 68] = mem[idx + _1996 + 32]
                                idx = idx + 32
                                continue 
                            mem[_2049 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _2049 + -mem[64] + 100
                        if block.timestamp < stor10[address(arg1)][idx].field_256:
                            revert with 0, 17
                        _2302 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2302] = 26
                        mem[_2302 + 32] = 'SafeMath: division by zero'
                        if not claimTime:
                            _2391 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _2391 + 68] = mem[idx + _2302 + 32]
                                idx = idx + 32
                                continue 
                            mem[_2391 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2391 + -mem[64] + 100
                    else:
                        if 31 >= uint255(stor10[address(arg1)][idx].field_0) * 0.5:
                            mem[_1854 + 32] = 256 * stor10[address(arg1)][idx].field_8
                            mem[_1847] = _1854
                            mem[_1847 + 32] = stor10[address(arg1)][idx].field_256
                            mem[_1847 + 64] = stor10[address(arg1)][idx].field_512
                            mem[_1847 + 96] = stor10[address(arg1)][idx].field_768
                            if -stor10[address(arg1)][idx].field_512:
                                _1904 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1904] = 30
                                mem[_1904 + 32] = 'SafeMath: subtraction overflow'
                                if stor10[address(arg1)][idx].field_512 > block.timestamp:
                                    _1937 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _1937 + 68] = mem[idx + _1904 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_1937 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _1937 + -mem[64] + 100
                                if block.timestamp < stor10[address(arg1)][idx].field_512:
                                    revert with 0, 17
                                _2083 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2083] = 26
                                mem[_2083 + 32] = 'SafeMath: division by zero'
                                if not claimTime:
                                    _2162 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _2162 + 68] = mem[idx + _2083 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2162 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2162 + -mem[64] + 100
                                if 0 > !(block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime):
                                    revert with 0, 17
                                if block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not -rewardPerNode:
                                    if 0 > !stor10[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if stor10[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !stor10[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if idx >= stor10[address(arg1)].field_0:
                                        revert with 0, 50
                                    stor10[address(arg1)][idx].field_512 = block.timestamp
                                    mem[0] = sha3(address(arg1), 10)
                                    stor10[address(arg1)][idx].field_768 = 0
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + stor10[address(arg1)][idx].field_768
                                    continue 
                                if rewardPerNode and block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime > !stor10[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if (rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !((rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768):
                                    revert with 0, 17
                                if idx >= stor10[address(arg1)].field_0:
                                    revert with 0, 50
                                stor10[address(arg1)][idx].field_512 = block.timestamp
                                mem[0] = sha3(address(arg1), 10)
                                stor10[address(arg1)][idx].field_768 = 0
                                if not idx + 1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + (rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768
                                continue 
                            _2052 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2052] = 30
                            mem[_2052 + 32] = 'SafeMath: subtraction overflow'
                            if stor10[address(arg1)][idx].field_256 > block.timestamp:
                                _2123 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _2123 + 68] = mem[idx + _2052 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2123 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _2123 + -mem[64] + 100
                            if block.timestamp < stor10[address(arg1)][idx].field_256:
                                revert with 0, 17
                            _2393 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2393] = 26
                            mem[_2393 + 32] = 'SafeMath: division by zero'
                            if not claimTime:
                                _2465 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _2465 + 68] = mem[idx + _2393 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2465 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _2465 + -mem[64] + 100
                        else:
                            mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                            mem[_1854 + 32] = stor10[address(arg1)][idx].field_0
                            t = _1854 + 32
                            u = sha3(mem[0])
                            while _1854 + (uint255(stor10[address(arg1)][idx].field_0) * 0.5) > t:
                                mem[t + 32] = uint256(stor1[u])
                                t = t + 32
                                u = u + 1
                                continue 
                            mem[_1847] = _1854
                            mem[_1847 + 32] = stor10[address(arg1)][idx].field_256
                            mem[_1847 + 64] = stor10[address(arg1)][idx].field_512
                            mem[_1847 + 96] = stor10[address(arg1)][idx].field_768
                            if -stor10[address(arg1)][idx].field_512:
                                _3788 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3788] = 30
                                mem[_3788 + 32] = 'SafeMath: subtraction overflow'
                                if stor10[address(arg1)][idx].field_512 > block.timestamp:
                                    _3984 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _3984 + 68] = mem[idx + _3788 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_3984 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _3984 + -mem[64] + 100
                                if block.timestamp < stor10[address(arg1)][idx].field_512:
                                    revert with 0, 17
                                _4044 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4044] = 26
                                mem[_4044 + 32] = 'SafeMath: division by zero'
                                if not claimTime:
                                    _4068 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _4068 + 68] = mem[idx + _4044 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4068 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4068 + -mem[64] + 100
                                if 0 > !(block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime):
                                    revert with 0, 17
                                if block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not -rewardPerNode:
                                    if 0 > !stor10[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if stor10[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !stor10[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if idx >= stor10[address(arg1)].field_0:
                                        revert with 0, 50
                                    stor10[address(arg1)][idx].field_512 = block.timestamp
                                    mem[0] = sha3(address(arg1), 10)
                                    stor10[address(arg1)][idx].field_768 = 0
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + stor10[address(arg1)][idx].field_768
                                    continue 
                                if rewardPerNode and block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime > !stor10[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if (rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !((rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768):
                                    revert with 0, 17
                                if idx >= stor10[address(arg1)].field_0:
                                    revert with 0, 50
                                stor10[address(arg1)][idx].field_512 = block.timestamp
                                mem[0] = sha3(address(arg1), 10)
                                stor10[address(arg1)][idx].field_768 = 0
                                if not idx + 1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + (rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768
                                continue 
                            _4021 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4021] = 30
                            mem[_4021 + 32] = 'SafeMath: subtraction overflow'
                            if stor10[address(arg1)][idx].field_256 > block.timestamp:
                                _4056 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _4056 + 68] = mem[idx + _4021 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4056 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _4056 + -mem[64] + 100
                            if block.timestamp < stor10[address(arg1)][idx].field_256:
                                revert with 0, 17
                            _4141 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4141] = 26
                            mem[_4141 + 32] = 'SafeMath: division by zero'
                            if not claimTime:
                                _4164 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _4164 + 68] = mem[idx + _4141 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4164 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _4164 + -mem[64] + 100
                else:
                    if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                        revert with 0, 34
                    if not stor10[address(arg1)][idx].field_1:
                        mem[_1847] = _1854
                        mem[_1847 + 32] = stor10[address(arg1)][idx].field_256
                        mem[_1847 + 64] = stor10[address(arg1)][idx].field_512
                        mem[_1847 + 96] = stor10[address(arg1)][idx].field_768
                        if -stor10[address(arg1)][idx].field_512:
                            _1890 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1890] = 30
                            mem[_1890 + 32] = 'SafeMath: subtraction overflow'
                            if stor10[address(arg1)][idx].field_512 > block.timestamp:
                                _1917 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _1917 + 68] = mem[idx + _1890 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_1917 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _1917 + -mem[64] + 100
                            if block.timestamp < stor10[address(arg1)][idx].field_512:
                                revert with 0, 17
                            _2053 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2053] = 26
                            mem[_2053 + 32] = 'SafeMath: division by zero'
                            if not claimTime:
                                _2124 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _2124 + 68] = mem[idx + _2053 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2124 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _2124 + -mem[64] + 100
                            if 0 > !(block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime):
                                revert with 0, 17
                            if block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if not -rewardPerNode:
                                if 0 > !stor10[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if stor10[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !stor10[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if idx >= stor10[address(arg1)].field_0:
                                    revert with 0, 50
                                stor10[address(arg1)][idx].field_512 = block.timestamp
                                mem[0] = sha3(address(arg1), 10)
                                stor10[address(arg1)][idx].field_768 = 0
                                if not idx + 1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + stor10[address(arg1)][idx].field_768
                                continue 
                            if rewardPerNode and block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime > !stor10[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if (rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !((rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768):
                                revert with 0, 17
                            if idx >= stor10[address(arg1)].field_0:
                                revert with 0, 50
                            stor10[address(arg1)][idx].field_512 = block.timestamp
                            mem[0] = sha3(address(arg1), 10)
                            stor10[address(arg1)][idx].field_768 = 0
                            if not idx + 1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + (rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768
                            continue 
                        _2022 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2022] = 30
                        mem[_2022 + 32] = 'SafeMath: subtraction overflow'
                        if stor10[address(arg1)][idx].field_256 > block.timestamp:
                            _2084 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _2084 + 68] = mem[idx + _2022 + 32]
                                idx = idx + 32
                                continue 
                            mem[_2084 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _2084 + -mem[64] + 100
                        if block.timestamp < stor10[address(arg1)][idx].field_256:
                            revert with 0, 17
                        _2349 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2349] = 26
                        mem[_2349 + 32] = 'SafeMath: division by zero'
                        if not claimTime:
                            _2430 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _2430 + 68] = mem[idx + _2349 + 32]
                                idx = idx + 32
                                continue 
                            mem[_2430 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2430 + -mem[64] + 100
                    else:
                        if 31 >= stor10[address(arg1)][idx].field_1:
                            mem[_1854 + 32] = 256 * stor10[address(arg1)][idx].field_8
                            mem[_1847] = _1854
                            mem[_1847 + 32] = stor10[address(arg1)][idx].field_256
                            mem[_1847 + 64] = stor10[address(arg1)][idx].field_512
                            mem[_1847 + 96] = stor10[address(arg1)][idx].field_768
                            if -stor10[address(arg1)][idx].field_512:
                                _1919 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1919] = 30
                                mem[_1919 + 32] = 'SafeMath: subtraction overflow'
                                if stor10[address(arg1)][idx].field_512 > block.timestamp:
                                    _1956 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _1956 + 68] = mem[idx + _1919 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_1956 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _1956 + -mem[64] + 100
                                if block.timestamp < stor10[address(arg1)][idx].field_512:
                                    revert with 0, 17
                                _2125 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2125] = 26
                                mem[_2125 + 32] = 'SafeMath: division by zero'
                                if not claimTime:
                                    _2217 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _2217 + 68] = mem[idx + _2125 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2217 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2217 + -mem[64] + 100
                                if 0 > !(block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime):
                                    revert with 0, 17
                                if block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not -rewardPerNode:
                                    if 0 > !stor10[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if stor10[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !stor10[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if idx >= stor10[address(arg1)].field_0:
                                        revert with 0, 50
                                    stor10[address(arg1)][idx].field_512 = block.timestamp
                                    mem[0] = sha3(address(arg1), 10)
                                    stor10[address(arg1)][idx].field_768 = 0
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + stor10[address(arg1)][idx].field_768
                                    continue 
                                if rewardPerNode and block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime > !stor10[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if (rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !((rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768):
                                    revert with 0, 17
                                if idx >= stor10[address(arg1)].field_0:
                                    revert with 0, 50
                                stor10[address(arg1)][idx].field_512 = block.timestamp
                                mem[0] = sha3(address(arg1), 10)
                                stor10[address(arg1)][idx].field_768 = 0
                                if not idx + 1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + (rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768
                                continue 
                            _2087 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2087] = 30
                            mem[_2087 + 32] = 'SafeMath: subtraction overflow'
                            if stor10[address(arg1)][idx].field_256 > block.timestamp:
                                _2168 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _2168 + 68] = mem[idx + _2087 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2168 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _2168 + -mem[64] + 100
                            if block.timestamp < stor10[address(arg1)][idx].field_256:
                                revert with 0, 17
                            _2432 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2432] = 26
                            mem[_2432 + 32] = 'SafeMath: division by zero'
                            if not claimTime:
                                _2513 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _2513 + 68] = mem[idx + _2432 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2513 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _2513 + -mem[64] + 100
                        else:
                            mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                            mem[_1854 + 32] = stor10[address(arg1)][idx].field_0
                            t = _1854 + 32
                            u = sha3(mem[0])
                            while _1854 + stor10[address(arg1)][idx].field_1 > t:
                                mem[t + 32] = uint256(stor1[u])
                                t = t + 32
                                u = u + 1
                                continue 
                            mem[_1847] = _1854
                            mem[_1847 + 32] = stor10[address(arg1)][idx].field_256
                            mem[_1847 + 64] = stor10[address(arg1)][idx].field_512
                            mem[_1847 + 96] = stor10[address(arg1)][idx].field_768
                            if -stor10[address(arg1)][idx].field_512:
                                _3805 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3805] = 30
                                mem[_3805 + 32] = 'SafeMath: subtraction overflow'
                                if stor10[address(arg1)][idx].field_512 > block.timestamp:
                                    _3985 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _3985 + 68] = mem[idx + _3805 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_3985 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _3985 + -mem[64] + 100
                                if block.timestamp < stor10[address(arg1)][idx].field_512:
                                    revert with 0, 17
                                _4045 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4045] = 26
                                mem[_4045 + 32] = 'SafeMath: division by zero'
                                if not claimTime:
                                    _4069 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _4069 + 68] = mem[idx + _4045 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4069 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4069 + -mem[64] + 100
                                if 0 > !(block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime):
                                    revert with 0, 17
                                if block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not -rewardPerNode:
                                    if 0 > !stor10[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if stor10[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !stor10[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if idx >= stor10[address(arg1)].field_0:
                                        revert with 0, 50
                                    stor10[address(arg1)][idx].field_512 = block.timestamp
                                    mem[0] = sha3(address(arg1), 10)
                                    stor10[address(arg1)][idx].field_768 = 0
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + stor10[address(arg1)][idx].field_768
                                    continue 
                                if rewardPerNode and block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime > !stor10[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if (rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !((rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768):
                                    revert with 0, 17
                                if idx >= stor10[address(arg1)].field_0:
                                    revert with 0, 50
                                stor10[address(arg1)][idx].field_512 = block.timestamp
                                mem[0] = sha3(address(arg1), 10)
                                stor10[address(arg1)][idx].field_768 = 0
                                if not idx + 1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + (rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768
                                continue 
                            _4023 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4023] = 30
                            mem[_4023 + 32] = 'SafeMath: subtraction overflow'
                            if stor10[address(arg1)][idx].field_256 > block.timestamp:
                                _4057 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _4057 + 68] = mem[idx + _4023 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4057 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _4057 + -mem[64] + 100
                            if block.timestamp < stor10[address(arg1)][idx].field_256:
                                revert with 0, 17
                            _4143 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4143] = 26
                            mem[_4143 + 32] = 'SafeMath: division by zero'
                            if not claimTime:
                                _4165 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _4165 + 68] = mem[idx + _4143 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4165 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _4165 + -mem[64] + 100
            else:
                if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                    revert with 0, 34
                _1857 = mem[64]
                mem[64] = mem[64] + ceil32(stor10[address(arg1)][idx].field_1) + 32
                mem[_1857] = stor10[address(arg1)][idx].field_1
                if stor10[address(arg1)][idx].field_0:
                    if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                        revert with 0, 34
                    if not Mask(256, -1, stor10[address(arg1)][idx].field_0):
                        mem[_1847] = _1857
                        mem[_1847 + 32] = stor10[address(arg1)][idx].field_256
                        mem[_1847 + 64] = stor10[address(arg1)][idx].field_512
                        mem[_1847 + 96] = stor10[address(arg1)][idx].field_768
                        if -stor10[address(arg1)][idx].field_512:
                            _1892 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1892] = 30
                            mem[_1892 + 32] = 'SafeMath: subtraction overflow'
                            if stor10[address(arg1)][idx].field_512 > block.timestamp:
                                _1920 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _1920 + 68] = mem[idx + _1892 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_1920 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _1920 + -mem[64] + 100
                            if block.timestamp < stor10[address(arg1)][idx].field_512:
                                revert with 0, 17
                            _2055 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2055] = 26
                            mem[_2055 + 32] = 'SafeMath: division by zero'
                            if not claimTime:
                                _2126 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _2126 + 68] = mem[idx + _2055 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2126 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _2126 + -mem[64] + 100
                            if 0 > !(block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime):
                                revert with 0, 17
                            if block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if not -rewardPerNode:
                                if 0 > !stor10[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if stor10[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !stor10[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if idx >= stor10[address(arg1)].field_0:
                                    revert with 0, 50
                                stor10[address(arg1)][idx].field_512 = block.timestamp
                                mem[0] = sha3(address(arg1), 10)
                                stor10[address(arg1)][idx].field_768 = 0
                                if not idx + 1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + stor10[address(arg1)][idx].field_768
                                continue 
                            if rewardPerNode and block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime > !stor10[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if (rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !((rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768):
                                revert with 0, 17
                            if idx >= stor10[address(arg1)].field_0:
                                revert with 0, 50
                            stor10[address(arg1)][idx].field_512 = block.timestamp
                            mem[0] = sha3(address(arg1), 10)
                            stor10[address(arg1)][idx].field_768 = 0
                            if not idx + 1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + (rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768
                            continue 
                        _2025 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2025] = 30
                        mem[_2025 + 32] = 'SafeMath: subtraction overflow'
                        if stor10[address(arg1)][idx].field_256 > block.timestamp:
                            _2088 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _2088 + 68] = mem[idx + _2025 + 32]
                                idx = idx + 32
                                continue 
                            mem[_2088 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _2088 + -mem[64] + 100
                        if block.timestamp < stor10[address(arg1)][idx].field_256:
                            revert with 0, 17
                        _2354 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2354] = 26
                        mem[_2354 + 32] = 'SafeMath: division by zero'
                        if not claimTime:
                            _2433 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _2433 + 68] = mem[idx + _2354 + 32]
                                idx = idx + 32
                                continue 
                            mem[_2433 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2433 + -mem[64] + 100
                    else:
                        if 31 >= uint255(stor10[address(arg1)][idx].field_0) * 0.5:
                            mem[_1857 + 32] = 256 * stor10[address(arg1)][idx].field_8
                            mem[_1847] = _1857
                            mem[_1847 + 32] = stor10[address(arg1)][idx].field_256
                            mem[_1847 + 64] = stor10[address(arg1)][idx].field_512
                            mem[_1847 + 96] = stor10[address(arg1)][idx].field_768
                            if -stor10[address(arg1)][idx].field_512:
                                _1922 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1922] = 30
                                mem[_1922 + 32] = 'SafeMath: subtraction overflow'
                                if stor10[address(arg1)][idx].field_512 > block.timestamp:
                                    _1959 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _1959 + 68] = mem[idx + _1922 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_1959 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _1959 + -mem[64] + 100
                                if block.timestamp < stor10[address(arg1)][idx].field_512:
                                    revert with 0, 17
                                _2127 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2127] = 26
                                mem[_2127 + 32] = 'SafeMath: division by zero'
                                if not claimTime:
                                    _2220 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _2220 + 68] = mem[idx + _2127 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2220 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2220 + -mem[64] + 100
                                if 0 > !(block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime):
                                    revert with 0, 17
                                if block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not -rewardPerNode:
                                    if 0 > !stor10[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if stor10[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !stor10[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if idx >= stor10[address(arg1)].field_0:
                                        revert with 0, 50
                                    stor10[address(arg1)][idx].field_512 = block.timestamp
                                    mem[0] = sha3(address(arg1), 10)
                                    stor10[address(arg1)][idx].field_768 = 0
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + stor10[address(arg1)][idx].field_768
                                    continue 
                                if rewardPerNode and block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime > !stor10[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if (rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !((rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768):
                                    revert with 0, 17
                                if idx >= stor10[address(arg1)].field_0:
                                    revert with 0, 50
                                stor10[address(arg1)][idx].field_512 = block.timestamp
                                mem[0] = sha3(address(arg1), 10)
                                stor10[address(arg1)][idx].field_768 = 0
                                if not idx + 1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + (rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768
                                continue 
                            _2091 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2091] = 30
                            mem[_2091 + 32] = 'SafeMath: subtraction overflow'
                            if stor10[address(arg1)][idx].field_256 > block.timestamp:
                                _2174 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _2174 + 68] = mem[idx + _2091 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2174 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _2174 + -mem[64] + 100
                            if block.timestamp < stor10[address(arg1)][idx].field_256:
                                revert with 0, 17
                            _2435 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2435] = 26
                            mem[_2435 + 32] = 'SafeMath: division by zero'
                            if not claimTime:
                                _2519 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _2519 + 68] = mem[idx + _2435 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2519 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _2519 + -mem[64] + 100
                        else:
                            mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                            mem[_1857 + 32] = stor10[address(arg1)][idx].field_0
                            t = _1857 + 32
                            u = sha3(mem[0])
                            while _1857 + (uint255(stor10[address(arg1)][idx].field_0) * 0.5) > t:
                                mem[t + 32] = uint256(stor1[u])
                                t = t + 32
                                u = u + 1
                                continue 
                            mem[_1847] = _1857
                            mem[_1847 + 32] = stor10[address(arg1)][idx].field_256
                            mem[_1847 + 64] = stor10[address(arg1)][idx].field_512
                            mem[_1847 + 96] = stor10[address(arg1)][idx].field_768
                            if -stor10[address(arg1)][idx].field_512:
                                _3822 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3822] = 30
                                mem[_3822 + 32] = 'SafeMath: subtraction overflow'
                                if stor10[address(arg1)][idx].field_512 > block.timestamp:
                                    _3986 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _3986 + 68] = mem[idx + _3822 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_3986 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _3986 + -mem[64] + 100
                                if block.timestamp < stor10[address(arg1)][idx].field_512:
                                    revert with 0, 17
                                _4046 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4046] = 26
                                mem[_4046 + 32] = 'SafeMath: division by zero'
                                if not claimTime:
                                    _4070 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _4070 + 68] = mem[idx + _4046 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4070 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4070 + -mem[64] + 100
                                if 0 > !(block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime):
                                    revert with 0, 17
                                if block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not -rewardPerNode:
                                    if 0 > !stor10[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if stor10[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !stor10[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if idx >= stor10[address(arg1)].field_0:
                                        revert with 0, 50
                                    stor10[address(arg1)][idx].field_512 = block.timestamp
                                    mem[0] = sha3(address(arg1), 10)
                                    stor10[address(arg1)][idx].field_768 = 0
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + stor10[address(arg1)][idx].field_768
                                    continue 
                                if rewardPerNode and block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime > !stor10[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if (rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !((rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768):
                                    revert with 0, 17
                                if idx >= stor10[address(arg1)].field_0:
                                    revert with 0, 50
                                stor10[address(arg1)][idx].field_512 = block.timestamp
                                mem[0] = sha3(address(arg1), 10)
                                stor10[address(arg1)][idx].field_768 = 0
                                if not idx + 1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + (rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768
                                continue 
                            _4025 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4025] = 30
                            mem[_4025 + 32] = 'SafeMath: subtraction overflow'
                            if stor10[address(arg1)][idx].field_256 > block.timestamp:
                                _4058 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _4058 + 68] = mem[idx + _4025 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4058 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _4058 + -mem[64] + 100
                            if block.timestamp < stor10[address(arg1)][idx].field_256:
                                revert with 0, 17
                            _4145 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4145] = 26
                            mem[_4145 + 32] = 'SafeMath: division by zero'
                            if not claimTime:
                                _4166 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _4166 + 68] = mem[idx + _4145 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4166 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _4166 + -mem[64] + 100
                else:
                    if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                        revert with 0, 34
                    if not stor10[address(arg1)][idx].field_1:
                        mem[_1847] = _1857
                        mem[_1847 + 32] = stor10[address(arg1)][idx].field_256
                        mem[_1847 + 64] = stor10[address(arg1)][idx].field_512
                        mem[_1847 + 96] = stor10[address(arg1)][idx].field_768
                        if -stor10[address(arg1)][idx].field_512:
                            _1905 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1905] = 30
                            mem[_1905 + 32] = 'SafeMath: subtraction overflow'
                            if stor10[address(arg1)][idx].field_512 > block.timestamp:
                                _1938 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _1938 + 68] = mem[idx + _1905 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_1938 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _1938 + -mem[64] + 100
                            if block.timestamp < stor10[address(arg1)][idx].field_512:
                                revert with 0, 17
                            _2092 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2092] = 26
                            mem[_2092 + 32] = 'SafeMath: division by zero'
                            if not claimTime:
                                _2175 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _2175 + 68] = mem[idx + _2092 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2175 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _2175 + -mem[64] + 100
                            if 0 > !(block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime):
                                revert with 0, 17
                            if block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if not -rewardPerNode:
                                if 0 > !stor10[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if stor10[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !stor10[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if idx >= stor10[address(arg1)].field_0:
                                    revert with 0, 50
                                stor10[address(arg1)][idx].field_512 = block.timestamp
                                mem[0] = sha3(address(arg1), 10)
                                stor10[address(arg1)][idx].field_768 = 0
                                if not idx + 1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + stor10[address(arg1)][idx].field_768
                                continue 
                            if rewardPerNode and block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime > !stor10[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if (rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !((rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768):
                                revert with 0, 17
                            if idx >= stor10[address(arg1)].field_0:
                                revert with 0, 50
                            stor10[address(arg1)][idx].field_512 = block.timestamp
                            mem[0] = sha3(address(arg1), 10)
                            stor10[address(arg1)][idx].field_768 = 0
                            if not idx + 1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + (rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768
                            continue 
                        _2058 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2058] = 30
                        mem[_2058 + 32] = 'SafeMath: subtraction overflow'
                        if stor10[address(arg1)][idx].field_256 > block.timestamp:
                            _2128 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _2128 + 68] = mem[idx + _2058 + 32]
                                idx = idx + 32
                                continue 
                            mem[_2128 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _2128 + -mem[64] + 100
                        if block.timestamp < stor10[address(arg1)][idx].field_256:
                            revert with 0, 17
                        _2399 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2399] = 26
                        mem[_2399 + 32] = 'SafeMath: division by zero'
                        if not claimTime:
                            _2472 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _2472 + 68] = mem[idx + _2399 + 32]
                                idx = idx + 32
                                continue 
                            mem[_2472 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2472 + -mem[64] + 100
                    else:
                        if 31 >= stor10[address(arg1)][idx].field_1:
                            mem[_1857 + 32] = 256 * stor10[address(arg1)][idx].field_8
                            mem[_1847] = _1857
                            mem[_1847 + 32] = stor10[address(arg1)][idx].field_256
                            mem[_1847 + 64] = stor10[address(arg1)][idx].field_512
                            mem[_1847 + 96] = stor10[address(arg1)][idx].field_768
                            if -stor10[address(arg1)][idx].field_512:
                                _1940 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1940] = 30
                                mem[_1940 + 32] = 'SafeMath: subtraction overflow'
                                if stor10[address(arg1)][idx].field_512 > block.timestamp:
                                    _1980 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _1980 + 68] = mem[idx + _1940 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_1980 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _1980 + -mem[64] + 100
                                if block.timestamp < stor10[address(arg1)][idx].field_512:
                                    revert with 0, 17
                                _2176 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2176] = 26
                                mem[_2176 + 32] = 'SafeMath: division by zero'
                                if not claimTime:
                                    _2272 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _2272 + 68] = mem[idx + _2176 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2272 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2272 + -mem[64] + 100
                                if 0 > !(block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime):
                                    revert with 0, 17
                                if block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not -rewardPerNode:
                                    if 0 > !stor10[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if stor10[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !stor10[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if idx >= stor10[address(arg1)].field_0:
                                        revert with 0, 50
                                    stor10[address(arg1)][idx].field_512 = block.timestamp
                                    mem[0] = sha3(address(arg1), 10)
                                    stor10[address(arg1)][idx].field_768 = 0
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + stor10[address(arg1)][idx].field_768
                                    continue 
                                if rewardPerNode and block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime > !stor10[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if (rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !((rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768):
                                    revert with 0, 17
                                if idx >= stor10[address(arg1)].field_0:
                                    revert with 0, 50
                                stor10[address(arg1)][idx].field_512 = block.timestamp
                                mem[0] = sha3(address(arg1), 10)
                                stor10[address(arg1)][idx].field_768 = 0
                                if not idx + 1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + (rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768
                                continue 
                            _2131 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2131] = 30
                            mem[_2131 + 32] = 'SafeMath: subtraction overflow'
                            if stor10[address(arg1)][idx].field_256 > block.timestamp:
                                _2226 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _2226 + 68] = mem[idx + _2131 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2226 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _2226 + -mem[64] + 100
                            if block.timestamp < stor10[address(arg1)][idx].field_256:
                                revert with 0, 17
                            _2474 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2474] = 26
                            mem[_2474 + 32] = 'SafeMath: division by zero'
                            if not claimTime:
                                _2575 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _2575 + 68] = mem[idx + _2474 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2575 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _2575 + -mem[64] + 100
                        else:
                            mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                            mem[_1857 + 32] = stor10[address(arg1)][idx].field_0
                            t = _1857 + 32
                            u = sha3(mem[0])
                            while _1857 + stor10[address(arg1)][idx].field_1 > t:
                                mem[t + 32] = uint256(stor1[u])
                                t = t + 32
                                u = u + 1
                                continue 
                            mem[_1847] = _1857
                            mem[_1847 + 32] = stor10[address(arg1)][idx].field_256
                            mem[_1847 + 64] = stor10[address(arg1)][idx].field_512
                            mem[_1847 + 96] = stor10[address(arg1)][idx].field_768
                            if -stor10[address(arg1)][idx].field_512:
                                _3839 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3839] = 30
                                mem[_3839 + 32] = 'SafeMath: subtraction overflow'
                                if stor10[address(arg1)][idx].field_512 > block.timestamp:
                                    _3987 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _3987 + 68] = mem[idx + _3839 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_3987 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _3987 + -mem[64] + 100
                                if block.timestamp < stor10[address(arg1)][idx].field_512:
                                    revert with 0, 17
                                _4047 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4047] = 26
                                mem[_4047 + 32] = 'SafeMath: division by zero'
                                if not claimTime:
                                    _4071 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _4071 + 68] = mem[idx + _4047 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4071 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4071 + -mem[64] + 100
                                if 0 > !(block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime):
                                    revert with 0, 17
                                if block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not -rewardPerNode:
                                    if 0 > !stor10[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if stor10[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !stor10[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if idx >= stor10[address(arg1)].field_0:
                                        revert with 0, 50
                                    stor10[address(arg1)][idx].field_512 = block.timestamp
                                    mem[0] = sha3(address(arg1), 10)
                                    stor10[address(arg1)][idx].field_768 = 0
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + stor10[address(arg1)][idx].field_768
                                    continue 
                                if rewardPerNode and block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime > !stor10[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if (rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !((rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768):
                                    revert with 0, 17
                                if idx >= stor10[address(arg1)].field_0:
                                    revert with 0, 50
                                stor10[address(arg1)][idx].field_512 = block.timestamp
                                mem[0] = sha3(address(arg1), 10)
                                stor10[address(arg1)][idx].field_768 = 0
                                if not idx + 1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + (rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768
                                continue 
                            _4027 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4027] = 30
                            mem[_4027 + 32] = 'SafeMath: subtraction overflow'
                            if stor10[address(arg1)][idx].field_256 > block.timestamp:
                                _4059 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _4059 + 68] = mem[idx + _4027 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4059 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _4059 + -mem[64] + 100
                            if block.timestamp < stor10[address(arg1)][idx].field_256:
                                revert with 0, 17
                            _4147 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4147] = 26
                            mem[_4147 + 32] = 'SafeMath: division by zero'
                            if not claimTime:
                                _4167 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _4167 + 68] = mem[idx + _4147 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4167 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _4167 + -mem[64] + 100
            ('stor', ('name', 'claimTime', 17))
            if 1 > !(block.timestamp - stor10[address(arg1)][idx].field_256 / claimTime):
                revert with 0, 17
            if (block.timestamp - stor10[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                revert with 0, 'SafeMath: addition overflow'
            if not -rewardPerNode:
                if 0 > !stor10[address(arg1)][idx].field_768:
                    revert with 0, 17
                if stor10[address(arg1)][idx].field_768 < 0:
                    revert with 0, 'SafeMath: addition overflow'
                if s > !stor10[address(arg1)][idx].field_768:
                    revert with 0, 17
                if idx >= stor10[address(arg1)].field_0:
                    revert with 0, 50
                stor10[address(arg1)][idx].field_512 = block.timestamp
                mem[0] = sha3(address(arg1), 10)
                stor10[address(arg1)][idx].field_768 = 0
                if not idx + 1:
                    revert with 0, 17
                idx = idx + 1
                s = s + stor10[address(arg1)][idx].field_768
                continue 
            if rewardPerNode and (block.timestamp - stor10[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                revert with 0, 17
            if not rewardPerNode:
                revert with 0, 18
            if rewardPerNode + (block.timestamp - stor10[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - stor10[address(arg1)][idx].field_256 / claimTime) + 1:
                revert with 0, 'SafeMath: multiplication overflow'
            if rewardPerNode + (block.timestamp - stor10[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !stor10[address(arg1)][idx].field_768:
                revert with 0, 17
            if stor10[address(arg1)][idx].field_768 < 0:
                revert with 0, 'SafeMath: addition overflow'
            if s > !(rewardPerNode + (block.timestamp - stor10[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + stor10[address(arg1)][idx].field_768):
                revert with 0, 17
            if idx >= stor10[address(arg1)].field_0:
                revert with 0, 50
            stor10[address(arg1)][idx].field_512 = block.timestamp
            mem[0] = sha3(address(arg1), 10)
            stor10[address(arg1)][idx].field_768 = 0
            if not idx + 1:
                revert with 0, 17
            idx = idx + 1
            s = s + rewardPerNode + (block.timestamp - stor10[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + stor10[address(arg1)][idx].field_768
            continue 
    else:
        if msg.sender == gateKeeperAddress:
            mem[0] = arg1
            mem[32] = 10
            idx = 0
            s = 0
            while idx < stor10[address(arg1)].field_0:
                mem[0] = sha3(address(arg1), 10)
                _1850 = mem[64]
                mem[64] = mem[64] + 128
                if stor10[address(arg1)][idx].field_0:
                    if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                        revert with 0, 34
                    _1855 = mem[64]
                    mem[64] = mem[64] + ceil32(uint255(stor10[address(arg1)][idx].field_0) * 0.5) + 32
                    mem[_1855] = uint255(stor10[address(arg1)][idx].field_0) * 0.5
                    if stor10[address(arg1)][idx].field_0:
                        if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                            revert with 0, 34
                        if not Mask(256, -1, stor10[address(arg1)][idx].field_0):
                            mem[_1850] = _1855
                            mem[_1850 + 32] = stor10[address(arg1)][idx].field_256
                            mem[_1850 + 64] = stor10[address(arg1)][idx].field_512
                            mem[_1850 + 96] = stor10[address(arg1)][idx].field_768
                            if -stor10[address(arg1)][idx].field_512:
                                _1882 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1882] = 30
                                mem[_1882 + 32] = 'SafeMath: subtraction overflow'
                                if stor10[address(arg1)][idx].field_512 > block.timestamp:
                                    _1907 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _1907 + 68] = mem[idx + _1882 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_1907 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _1907 + -mem[64] + 100
                                if block.timestamp < stor10[address(arg1)][idx].field_512:
                                    revert with 0, 17
                                _2029 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2029] = 26
                                mem[_2029 + 32] = 'SafeMath: division by zero'
                                if not claimTime:
                                    _2094 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _2094 + 68] = mem[idx + _2029 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2094 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2094 + -mem[64] + 100
                                if 0 > !(block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime):
                                    revert with 0, 17
                                if block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not -rewardPerNode:
                                    if 0 > !stor10[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if stor10[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !stor10[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if idx >= stor10[address(arg1)].field_0:
                                        revert with 0, 50
                                    stor10[address(arg1)][idx].field_512 = block.timestamp
                                    mem[0] = sha3(address(arg1), 10)
                                    stor10[address(arg1)][idx].field_768 = 0
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + stor10[address(arg1)][idx].field_768
                                    continue 
                                if rewardPerNode and block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime > !stor10[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if (rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !((rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768):
                                    revert with 0, 17
                                if idx >= stor10[address(arg1)].field_0:
                                    revert with 0, 50
                                stor10[address(arg1)][idx].field_512 = block.timestamp
                                mem[0] = sha3(address(arg1), 10)
                                stor10[address(arg1)][idx].field_768 = 0
                                if not idx + 1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + (rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768
                                continue 
                            _2004 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2004] = 30
                            mem[_2004 + 32] = 'SafeMath: subtraction overflow'
                            if stor10[address(arg1)][idx].field_256 > block.timestamp:
                                _2060 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _2060 + 68] = mem[idx + _2004 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2060 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _2060 + -mem[64] + 100
                            if block.timestamp < stor10[address(arg1)][idx].field_256:
                                revert with 0, 17
                            _2317 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2317] = 26
                            mem[_2317 + 32] = 'SafeMath: division by zero'
                            if not claimTime:
                                _2403 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _2403 + 68] = mem[idx + _2317 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2403 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _2403 + -mem[64] + 100
                        else:
                            if 31 >= uint255(stor10[address(arg1)][idx].field_0) * 0.5:
                                mem[_1855 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                mem[_1850] = _1855
                                mem[_1850 + 32] = stor10[address(arg1)][idx].field_256
                                mem[_1850 + 64] = stor10[address(arg1)][idx].field_512
                                mem[_1850 + 96] = stor10[address(arg1)][idx].field_768
                                if -stor10[address(arg1)][idx].field_512:
                                    _1909 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_1909] = 30
                                    mem[_1909 + 32] = 'SafeMath: subtraction overflow'
                                    if stor10[address(arg1)][idx].field_512 > block.timestamp:
                                        _1943 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _1943 + 68] = mem[idx + _1909 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_1943 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _1943 + -mem[64] + 100
                                    if block.timestamp < stor10[address(arg1)][idx].field_512:
                                        revert with 0, 17
                                    _2095 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_2095] = 26
                                    mem[_2095 + 32] = 'SafeMath: division by zero'
                                    if not claimTime:
                                        _2179 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _2179 + 68] = mem[idx + _2095 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_2179 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _2179 + -mem[64] + 100
                                    if 0 > !(block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime):
                                        revert with 0, 17
                                    if block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not -rewardPerNode:
                                        if 0 > !stor10[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if stor10[address(arg1)][idx].field_768 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if s > !stor10[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if idx >= stor10[address(arg1)].field_0:
                                            revert with 0, 50
                                        stor10[address(arg1)][idx].field_512 = block.timestamp
                                        mem[0] = sha3(address(arg1), 10)
                                        stor10[address(arg1)][idx].field_768 = 0
                                        if not idx + 1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + stor10[address(arg1)][idx].field_768
                                        continue 
                                    if rewardPerNode and block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                        revert with 0, 17
                                    if not rewardPerNode:
                                        revert with 0, 18
                                    if rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime > !stor10[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if (rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !((rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768):
                                        revert with 0, 17
                                    if idx >= stor10[address(arg1)].field_0:
                                        revert with 0, 50
                                    stor10[address(arg1)][idx].field_512 = block.timestamp
                                    mem[0] = sha3(address(arg1), 10)
                                    stor10[address(arg1)][idx].field_768 = 0
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + (rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768
                                    continue 
                                _2063 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2063] = 30
                                mem[_2063 + 32] = 'SafeMath: subtraction overflow'
                                if stor10[address(arg1)][idx].field_256 > block.timestamp:
                                    _2137 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _2137 + 68] = mem[idx + _2063 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2137 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2137 + -mem[64] + 100
                                if block.timestamp < stor10[address(arg1)][idx].field_256:
                                    revert with 0, 17
                                _2405 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2405] = 26
                                mem[_2405 + 32] = 'SafeMath: division by zero'
                                if not claimTime:
                                    _2480 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _2480 + 68] = mem[idx + _2405 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2480 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2480 + -mem[64] + 100
                            else:
                                mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                mem[_1855 + 32] = stor10[address(arg1)][idx].field_0
                                t = _1855 + 32
                                u = sha3(mem[0])
                                while _1855 + (uint255(stor10[address(arg1)][idx].field_0) * 0.5) > t:
                                    mem[t + 32] = uint256(stor1[u])
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                mem[_1850] = _1855
                                mem[_1850 + 32] = stor10[address(arg1)][idx].field_256
                                mem[_1850 + 64] = stor10[address(arg1)][idx].field_512
                                mem[_1850 + 96] = stor10[address(arg1)][idx].field_768
                                if -stor10[address(arg1)][idx].field_512:
                                    _3856 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3856] = 30
                                    mem[_3856 + 32] = 'SafeMath: subtraction overflow'
                                    if stor10[address(arg1)][idx].field_512 > block.timestamp:
                                        _3988 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _3988 + 68] = mem[idx + _3856 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_3988 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _3988 + -mem[64] + 100
                                    if block.timestamp < stor10[address(arg1)][idx].field_512:
                                        revert with 0, 17
                                    _4048 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4048] = 26
                                    mem[_4048 + 32] = 'SafeMath: division by zero'
                                    if not claimTime:
                                        _4072 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _4072 + 68] = mem[idx + _4048 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_4072 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _4072 + -mem[64] + 100
                                    if 0 > !(block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime):
                                        revert with 0, 17
                                    if block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not -rewardPerNode:
                                        if 0 > !stor10[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if stor10[address(arg1)][idx].field_768 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if s > !stor10[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if idx >= stor10[address(arg1)].field_0:
                                            revert with 0, 50
                                        stor10[address(arg1)][idx].field_512 = block.timestamp
                                        mem[0] = sha3(address(arg1), 10)
                                        stor10[address(arg1)][idx].field_768 = 0
                                        if not idx + 1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + stor10[address(arg1)][idx].field_768
                                        continue 
                                    if rewardPerNode and block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                        revert with 0, 17
                                    if not rewardPerNode:
                                        revert with 0, 18
                                    if rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime > !stor10[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if (rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !((rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768):
                                        revert with 0, 17
                                    if idx >= stor10[address(arg1)].field_0:
                                        revert with 0, 50
                                    stor10[address(arg1)][idx].field_512 = block.timestamp
                                    mem[0] = sha3(address(arg1), 10)
                                    stor10[address(arg1)][idx].field_768 = 0
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + (rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768
                                    continue 
                                _4029 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4029] = 30
                                mem[_4029 + 32] = 'SafeMath: subtraction overflow'
                                if stor10[address(arg1)][idx].field_256 > block.timestamp:
                                    _4060 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _4060 + 68] = mem[idx + _4029 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4060 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4060 + -mem[64] + 100
                                if block.timestamp < stor10[address(arg1)][idx].field_256:
                                    revert with 0, 17
                                _4149 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4149] = 26
                                mem[_4149 + 32] = 'SafeMath: division by zero'
                                if not claimTime:
                                    _4168 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _4168 + 68] = mem[idx + _4149 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4168 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4168 + -mem[64] + 100
                    else:
                        if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                            revert with 0, 34
                        if not stor10[address(arg1)][idx].field_1:
                            mem[_1850] = _1855
                            mem[_1850 + 32] = stor10[address(arg1)][idx].field_256
                            mem[_1850 + 64] = stor10[address(arg1)][idx].field_512
                            mem[_1850 + 96] = stor10[address(arg1)][idx].field_768
                            if -stor10[address(arg1)][idx].field_512:
                                _1894 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1894] = 30
                                mem[_1894 + 32] = 'SafeMath: subtraction overflow'
                                if stor10[address(arg1)][idx].field_512 > block.timestamp:
                                    _1923 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _1923 + 68] = mem[idx + _1894 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_1923 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _1923 + -mem[64] + 100
                                if block.timestamp < stor10[address(arg1)][idx].field_512:
                                    revert with 0, 17
                                _2064 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2064] = 26
                                mem[_2064 + 32] = 'SafeMath: division by zero'
                                if not claimTime:
                                    _2138 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _2138 + 68] = mem[idx + _2064 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2138 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2138 + -mem[64] + 100
                                if 0 > !(block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime):
                                    revert with 0, 17
                                if block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not -rewardPerNode:
                                    if 0 > !stor10[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if stor10[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !stor10[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if idx >= stor10[address(arg1)].field_0:
                                        revert with 0, 50
                                    stor10[address(arg1)][idx].field_512 = block.timestamp
                                    mem[0] = sha3(address(arg1), 10)
                                    stor10[address(arg1)][idx].field_768 = 0
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + stor10[address(arg1)][idx].field_768
                                    continue 
                                if rewardPerNode and block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime > !stor10[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if (rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !((rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768):
                                    revert with 0, 17
                                if idx >= stor10[address(arg1)].field_0:
                                    revert with 0, 50
                                stor10[address(arg1)][idx].field_512 = block.timestamp
                                mem[0] = sha3(address(arg1), 10)
                                stor10[address(arg1)][idx].field_768 = 0
                                if not idx + 1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + (rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768
                                continue 
                            _2032 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2032] = 30
                            mem[_2032 + 32] = 'SafeMath: subtraction overflow'
                            if stor10[address(arg1)][idx].field_256 > block.timestamp:
                                _2096 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _2096 + 68] = mem[idx + _2032 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2096 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _2096 + -mem[64] + 100
                            if block.timestamp < stor10[address(arg1)][idx].field_256:
                                revert with 0, 17
                            _2364 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2364] = 26
                            mem[_2364 + 32] = 'SafeMath: division by zero'
                            if not claimTime:
                                _2441 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _2441 + 68] = mem[idx + _2364 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2441 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _2441 + -mem[64] + 100
                        else:
                            if 31 >= stor10[address(arg1)][idx].field_1:
                                mem[_1855 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                mem[_1850] = _1855
                                mem[_1850 + 32] = stor10[address(arg1)][idx].field_256
                                mem[_1850 + 64] = stor10[address(arg1)][idx].field_512
                                mem[_1850 + 96] = stor10[address(arg1)][idx].field_768
                                if -stor10[address(arg1)][idx].field_512:
                                    _1925 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_1925] = 30
                                    mem[_1925 + 32] = 'SafeMath: subtraction overflow'
                                    if stor10[address(arg1)][idx].field_512 > block.timestamp:
                                        _1963 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _1963 + 68] = mem[idx + _1925 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_1963 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _1963 + -mem[64] + 100
                                    if block.timestamp < stor10[address(arg1)][idx].field_512:
                                        revert with 0, 17
                                    _2139 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_2139] = 26
                                    mem[_2139 + 32] = 'SafeMath: division by zero'
                                    if not claimTime:
                                        _2233 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _2233 + 68] = mem[idx + _2139 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_2233 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _2233 + -mem[64] + 100
                                    if 0 > !(block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime):
                                        revert with 0, 17
                                    if block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not -rewardPerNode:
                                        if 0 > !stor10[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if stor10[address(arg1)][idx].field_768 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if s > !stor10[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if idx >= stor10[address(arg1)].field_0:
                                            revert with 0, 50
                                        stor10[address(arg1)][idx].field_512 = block.timestamp
                                        mem[0] = sha3(address(arg1), 10)
                                        stor10[address(arg1)][idx].field_768 = 0
                                        if not idx + 1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + stor10[address(arg1)][idx].field_768
                                        continue 
                                    if rewardPerNode and block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                        revert with 0, 17
                                    if not rewardPerNode:
                                        revert with 0, 18
                                    if rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime > !stor10[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if (rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !((rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768):
                                        revert with 0, 17
                                    if idx >= stor10[address(arg1)].field_0:
                                        revert with 0, 50
                                    stor10[address(arg1)][idx].field_512 = block.timestamp
                                    mem[0] = sha3(address(arg1), 10)
                                    stor10[address(arg1)][idx].field_768 = 0
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + (rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768
                                    continue 
                                _2099 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2099] = 30
                                mem[_2099 + 32] = 'SafeMath: subtraction overflow'
                                if stor10[address(arg1)][idx].field_256 > block.timestamp:
                                    _2185 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _2185 + 68] = mem[idx + _2099 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2185 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2185 + -mem[64] + 100
                                if block.timestamp < stor10[address(arg1)][idx].field_256:
                                    revert with 0, 17
                                _2443 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2443] = 26
                                mem[_2443 + 32] = 'SafeMath: division by zero'
                                if not claimTime:
                                    _2531 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _2531 + 68] = mem[idx + _2443 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2531 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2531 + -mem[64] + 100
                            else:
                                mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                mem[_1855 + 32] = stor10[address(arg1)][idx].field_0
                                t = _1855 + 32
                                u = sha3(mem[0])
                                while _1855 + stor10[address(arg1)][idx].field_1 > t:
                                    mem[t + 32] = uint256(stor1[u])
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                mem[_1850] = _1855
                                mem[_1850 + 32] = stor10[address(arg1)][idx].field_256
                                mem[_1850 + 64] = stor10[address(arg1)][idx].field_512
                                mem[_1850 + 96] = stor10[address(arg1)][idx].field_768
                                if -stor10[address(arg1)][idx].field_512:
                                    _3873 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3873] = 30
                                    mem[_3873 + 32] = 'SafeMath: subtraction overflow'
                                    if stor10[address(arg1)][idx].field_512 > block.timestamp:
                                        _3989 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _3989 + 68] = mem[idx + _3873 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_3989 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _3989 + -mem[64] + 100
                                    if block.timestamp < stor10[address(arg1)][idx].field_512:
                                        revert with 0, 17
                                    _4049 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4049] = 26
                                    mem[_4049 + 32] = 'SafeMath: division by zero'
                                    if not claimTime:
                                        _4073 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _4073 + 68] = mem[idx + _4049 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_4073 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _4073 + -mem[64] + 100
                                    if 0 > !(block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime):
                                        revert with 0, 17
                                    if block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not -rewardPerNode:
                                        if 0 > !stor10[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if stor10[address(arg1)][idx].field_768 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if s > !stor10[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if idx >= stor10[address(arg1)].field_0:
                                            revert with 0, 50
                                        stor10[address(arg1)][idx].field_512 = block.timestamp
                                        mem[0] = sha3(address(arg1), 10)
                                        stor10[address(arg1)][idx].field_768 = 0
                                        if not idx + 1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + stor10[address(arg1)][idx].field_768
                                        continue 
                                    if rewardPerNode and block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                        revert with 0, 17
                                    if not rewardPerNode:
                                        revert with 0, 18
                                    if rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime > !stor10[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if (rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !((rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768):
                                        revert with 0, 17
                                    if idx >= stor10[address(arg1)].field_0:
                                        revert with 0, 50
                                    stor10[address(arg1)][idx].field_512 = block.timestamp
                                    mem[0] = sha3(address(arg1), 10)
                                    stor10[address(arg1)][idx].field_768 = 0
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + (rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768
                                    continue 
                                _4031 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4031] = 30
                                mem[_4031 + 32] = 'SafeMath: subtraction overflow'
                                if stor10[address(arg1)][idx].field_256 > block.timestamp:
                                    _4061 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _4061 + 68] = mem[idx + _4031 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4061 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4061 + -mem[64] + 100
                                if block.timestamp < stor10[address(arg1)][idx].field_256:
                                    revert with 0, 17
                                _4151 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4151] = 26
                                mem[_4151 + 32] = 'SafeMath: division by zero'
                                if not claimTime:
                                    _4169 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _4169 + 68] = mem[idx + _4151 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4169 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4169 + -mem[64] + 100
                else:
                    if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                        revert with 0, 34
                    _1858 = mem[64]
                    mem[64] = mem[64] + ceil32(stor10[address(arg1)][idx].field_1) + 32
                    mem[_1858] = stor10[address(arg1)][idx].field_1
                    if stor10[address(arg1)][idx].field_0:
                        if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                            revert with 0, 34
                        if not Mask(256, -1, stor10[address(arg1)][idx].field_0):
                            mem[_1850] = _1858
                            mem[_1850 + 32] = stor10[address(arg1)][idx].field_256
                            mem[_1850 + 64] = stor10[address(arg1)][idx].field_512
                            mem[_1850 + 96] = stor10[address(arg1)][idx].field_768
                            if -stor10[address(arg1)][idx].field_512:
                                _1896 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1896] = 30
                                mem[_1896 + 32] = 'SafeMath: subtraction overflow'
                                if stor10[address(arg1)][idx].field_512 > block.timestamp:
                                    _1926 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _1926 + 68] = mem[idx + _1896 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_1926 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _1926 + -mem[64] + 100
                                if block.timestamp < stor10[address(arg1)][idx].field_512:
                                    revert with 0, 17
                                _2066 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2066] = 26
                                mem[_2066 + 32] = 'SafeMath: division by zero'
                                if not claimTime:
                                    _2140 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _2140 + 68] = mem[idx + _2066 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2140 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2140 + -mem[64] + 100
                                if 0 > !(block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime):
                                    revert with 0, 17
                                if block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not -rewardPerNode:
                                    if 0 > !stor10[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if stor10[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !stor10[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if idx >= stor10[address(arg1)].field_0:
                                        revert with 0, 50
                                    stor10[address(arg1)][idx].field_512 = block.timestamp
                                    mem[0] = sha3(address(arg1), 10)
                                    stor10[address(arg1)][idx].field_768 = 0
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + stor10[address(arg1)][idx].field_768
                                    continue 
                                if rewardPerNode and block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime > !stor10[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if (rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !((rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768):
                                    revert with 0, 17
                                if idx >= stor10[address(arg1)].field_0:
                                    revert with 0, 50
                                stor10[address(arg1)][idx].field_512 = block.timestamp
                                mem[0] = sha3(address(arg1), 10)
                                stor10[address(arg1)][idx].field_768 = 0
                                if not idx + 1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + (rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768
                                continue 
                            _2035 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2035] = 30
                            mem[_2035 + 32] = 'SafeMath: subtraction overflow'
                            if stor10[address(arg1)][idx].field_256 > block.timestamp:
                                _2100 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _2100 + 68] = mem[idx + _2035 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2100 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _2100 + -mem[64] + 100
                            if block.timestamp < stor10[address(arg1)][idx].field_256:
                                revert with 0, 17
                            _2369 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2369] = 26
                            mem[_2369 + 32] = 'SafeMath: division by zero'
                            if not claimTime:
                                _2444 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _2444 + 68] = mem[idx + _2369 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2444 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _2444 + -mem[64] + 100
                        else:
                            if 31 >= uint255(stor10[address(arg1)][idx].field_0) * 0.5:
                                mem[_1858 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                mem[_1850] = _1858
                                mem[_1850 + 32] = stor10[address(arg1)][idx].field_256
                                mem[_1850 + 64] = stor10[address(arg1)][idx].field_512
                                mem[_1850 + 96] = stor10[address(arg1)][idx].field_768
                                if -stor10[address(arg1)][idx].field_512:
                                    _1928 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_1928] = 30
                                    mem[_1928 + 32] = 'SafeMath: subtraction overflow'
                                    if stor10[address(arg1)][idx].field_512 > block.timestamp:
                                        _1966 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _1966 + 68] = mem[idx + _1928 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_1966 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _1966 + -mem[64] + 100
                                    if block.timestamp < stor10[address(arg1)][idx].field_512:
                                        revert with 0, 17
                                    _2141 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_2141] = 26
                                    mem[_2141 + 32] = 'SafeMath: division by zero'
                                    if not claimTime:
                                        _2236 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _2236 + 68] = mem[idx + _2141 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_2236 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _2236 + -mem[64] + 100
                                    if 0 > !(block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime):
                                        revert with 0, 17
                                    if block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not -rewardPerNode:
                                        if 0 > !stor10[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if stor10[address(arg1)][idx].field_768 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if s > !stor10[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if idx >= stor10[address(arg1)].field_0:
                                            revert with 0, 50
                                        stor10[address(arg1)][idx].field_512 = block.timestamp
                                        mem[0] = sha3(address(arg1), 10)
                                        stor10[address(arg1)][idx].field_768 = 0
                                        if not idx + 1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + stor10[address(arg1)][idx].field_768
                                        continue 
                                    if rewardPerNode and block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                        revert with 0, 17
                                    if not rewardPerNode:
                                        revert with 0, 18
                                    if rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime > !stor10[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if (rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !((rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768):
                                        revert with 0, 17
                                    if idx >= stor10[address(arg1)].field_0:
                                        revert with 0, 50
                                    stor10[address(arg1)][idx].field_512 = block.timestamp
                                    mem[0] = sha3(address(arg1), 10)
                                    stor10[address(arg1)][idx].field_768 = 0
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + (rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768
                                    continue 
                                _2103 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2103] = 30
                                mem[_2103 + 32] = 'SafeMath: subtraction overflow'
                                if stor10[address(arg1)][idx].field_256 > block.timestamp:
                                    _2191 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _2191 + 68] = mem[idx + _2103 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2191 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2191 + -mem[64] + 100
                                if block.timestamp < stor10[address(arg1)][idx].field_256:
                                    revert with 0, 17
                                _2446 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2446] = 26
                                mem[_2446 + 32] = 'SafeMath: division by zero'
                                if not claimTime:
                                    _2537 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _2537 + 68] = mem[idx + _2446 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2537 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2537 + -mem[64] + 100
                            else:
                                mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                mem[_1858 + 32] = stor10[address(arg1)][idx].field_0
                                t = _1858 + 32
                                u = sha3(mem[0])
                                while _1858 + (uint255(stor10[address(arg1)][idx].field_0) * 0.5) > t:
                                    mem[t + 32] = uint256(stor1[u])
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                mem[_1850] = _1858
                                mem[_1850 + 32] = stor10[address(arg1)][idx].field_256
                                mem[_1850 + 64] = stor10[address(arg1)][idx].field_512
                                mem[_1850 + 96] = stor10[address(arg1)][idx].field_768
                                if -stor10[address(arg1)][idx].field_512:
                                    _3890 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3890] = 30
                                    mem[_3890 + 32] = 'SafeMath: subtraction overflow'
                                    if stor10[address(arg1)][idx].field_512 > block.timestamp:
                                        _3990 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _3990 + 68] = mem[idx + _3890 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_3990 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _3990 + -mem[64] + 100
                                    if block.timestamp < stor10[address(arg1)][idx].field_512:
                                        revert with 0, 17
                                    _4050 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4050] = 26
                                    mem[_4050 + 32] = 'SafeMath: division by zero'
                                    if not claimTime:
                                        _4074 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _4074 + 68] = mem[idx + _4050 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_4074 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _4074 + -mem[64] + 100
                                    if 0 > !(block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime):
                                        revert with 0, 17
                                    if block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not -rewardPerNode:
                                        if 0 > !stor10[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if stor10[address(arg1)][idx].field_768 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if s > !stor10[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if idx >= stor10[address(arg1)].field_0:
                                            revert with 0, 50
                                        stor10[address(arg1)][idx].field_512 = block.timestamp
                                        mem[0] = sha3(address(arg1), 10)
                                        stor10[address(arg1)][idx].field_768 = 0
                                        if not idx + 1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + stor10[address(arg1)][idx].field_768
                                        continue 
                                    if rewardPerNode and block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                        revert with 0, 17
                                    if not rewardPerNode:
                                        revert with 0, 18
                                    if rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime > !stor10[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if (rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !((rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768):
                                        revert with 0, 17
                                    if idx >= stor10[address(arg1)].field_0:
                                        revert with 0, 50
                                    stor10[address(arg1)][idx].field_512 = block.timestamp
                                    mem[0] = sha3(address(arg1), 10)
                                    stor10[address(arg1)][idx].field_768 = 0
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + (rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768
                                    continue 
                                _4033 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4033] = 30
                                mem[_4033 + 32] = 'SafeMath: subtraction overflow'
                                if stor10[address(arg1)][idx].field_256 > block.timestamp:
                                    _4062 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _4062 + 68] = mem[idx + _4033 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4062 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4062 + -mem[64] + 100
                                if block.timestamp < stor10[address(arg1)][idx].field_256:
                                    revert with 0, 17
                                _4153 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4153] = 26
                                mem[_4153 + 32] = 'SafeMath: division by zero'
                                if not claimTime:
                                    _4170 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _4170 + 68] = mem[idx + _4153 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4170 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4170 + -mem[64] + 100
                    else:
                        if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                            revert with 0, 34
                        if not stor10[address(arg1)][idx].field_1:
                            mem[_1850] = _1858
                            mem[_1850 + 32] = stor10[address(arg1)][idx].field_256
                            mem[_1850 + 64] = stor10[address(arg1)][idx].field_512
                            mem[_1850 + 96] = stor10[address(arg1)][idx].field_768
                            if -stor10[address(arg1)][idx].field_512:
                                _1910 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1910] = 30
                                mem[_1910 + 32] = 'SafeMath: subtraction overflow'
                                if stor10[address(arg1)][idx].field_512 > block.timestamp:
                                    _1944 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _1944 + 68] = mem[idx + _1910 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_1944 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _1944 + -mem[64] + 100
                                if block.timestamp < stor10[address(arg1)][idx].field_512:
                                    revert with 0, 17
                                _2104 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2104] = 26
                                mem[_2104 + 32] = 'SafeMath: division by zero'
                                if not claimTime:
                                    _2192 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _2192 + 68] = mem[idx + _2104 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2192 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2192 + -mem[64] + 100
                                if 0 > !(block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime):
                                    revert with 0, 17
                                if block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not -rewardPerNode:
                                    if 0 > !stor10[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if stor10[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !stor10[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if idx >= stor10[address(arg1)].field_0:
                                        revert with 0, 50
                                    stor10[address(arg1)][idx].field_512 = block.timestamp
                                    mem[0] = sha3(address(arg1), 10)
                                    stor10[address(arg1)][idx].field_768 = 0
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + stor10[address(arg1)][idx].field_768
                                    continue 
                                if rewardPerNode and block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime > !stor10[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if (rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !((rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768):
                                    revert with 0, 17
                                if idx >= stor10[address(arg1)].field_0:
                                    revert with 0, 50
                                stor10[address(arg1)][idx].field_512 = block.timestamp
                                mem[0] = sha3(address(arg1), 10)
                                stor10[address(arg1)][idx].field_768 = 0
                                if not idx + 1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + (rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768
                                continue 
                            _2069 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2069] = 30
                            mem[_2069 + 32] = 'SafeMath: subtraction overflow'
                            if stor10[address(arg1)][idx].field_256 > block.timestamp:
                                _2142 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _2142 + 68] = mem[idx + _2069 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2142 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _2142 + -mem[64] + 100
                            if block.timestamp < stor10[address(arg1)][idx].field_256:
                                revert with 0, 17
                            _2411 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2411] = 26
                            mem[_2411 + 32] = 'SafeMath: division by zero'
                            if not claimTime:
                                _2487 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _2487 + 68] = mem[idx + _2411 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2487 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _2487 + -mem[64] + 100
                        else:
                            if 31 >= stor10[address(arg1)][idx].field_1:
                                mem[_1858 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                mem[_1850] = _1858
                                mem[_1850 + 32] = stor10[address(arg1)][idx].field_256
                                mem[_1850 + 64] = stor10[address(arg1)][idx].field_512
                                mem[_1850 + 96] = stor10[address(arg1)][idx].field_768
                                if -stor10[address(arg1)][idx].field_512:
                                    _1946 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_1946] = 30
                                    mem[_1946 + 32] = 'SafeMath: subtraction overflow'
                                    if stor10[address(arg1)][idx].field_512 > block.timestamp:
                                        _1987 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _1987 + 68] = mem[idx + _1946 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_1987 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _1987 + -mem[64] + 100
                                    if block.timestamp < stor10[address(arg1)][idx].field_512:
                                        revert with 0, 17
                                    _2193 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_2193] = 26
                                    mem[_2193 + 32] = 'SafeMath: division by zero'
                                    if not claimTime:
                                        _2286 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _2286 + 68] = mem[idx + _2193 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_2286 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _2286 + -mem[64] + 100
                                    if 0 > !(block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime):
                                        revert with 0, 17
                                    if block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not -rewardPerNode:
                                        if 0 > !stor10[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if stor10[address(arg1)][idx].field_768 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if s > !stor10[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if idx >= stor10[address(arg1)].field_0:
                                            revert with 0, 50
                                        stor10[address(arg1)][idx].field_512 = block.timestamp
                                        mem[0] = sha3(address(arg1), 10)
                                        stor10[address(arg1)][idx].field_768 = 0
                                        if not idx + 1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + stor10[address(arg1)][idx].field_768
                                        continue 
                                    if rewardPerNode and block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                        revert with 0, 17
                                    if not rewardPerNode:
                                        revert with 0, 18
                                    if rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime > !stor10[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if (rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !((rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768):
                                        revert with 0, 17
                                    if idx >= stor10[address(arg1)].field_0:
                                        revert with 0, 50
                                    stor10[address(arg1)][idx].field_512 = block.timestamp
                                    mem[0] = sha3(address(arg1), 10)
                                    stor10[address(arg1)][idx].field_768 = 0
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + (rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768
                                    continue 
                                _2145 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2145] = 30
                                mem[_2145 + 32] = 'SafeMath: subtraction overflow'
                                if stor10[address(arg1)][idx].field_256 > block.timestamp:
                                    _2242 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _2242 + 68] = mem[idx + _2145 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2242 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2242 + -mem[64] + 100
                                if block.timestamp < stor10[address(arg1)][idx].field_256:
                                    revert with 0, 17
                                _2489 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2489] = 26
                                mem[_2489 + 32] = 'SafeMath: division by zero'
                                if not claimTime:
                                    _2592 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _2592 + 68] = mem[idx + _2489 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2592 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2592 + -mem[64] + 100
                            else:
                                mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                mem[_1858 + 32] = stor10[address(arg1)][idx].field_0
                                t = _1858 + 32
                                u = sha3(mem[0])
                                while _1858 + stor10[address(arg1)][idx].field_1 > t:
                                    mem[t + 32] = uint256(stor1[u])
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                mem[_1850] = _1858
                                mem[_1850 + 32] = stor10[address(arg1)][idx].field_256
                                mem[_1850 + 64] = stor10[address(arg1)][idx].field_512
                                mem[_1850 + 96] = stor10[address(arg1)][idx].field_768
                                if -stor10[address(arg1)][idx].field_512:
                                    _3907 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3907] = 30
                                    mem[_3907 + 32] = 'SafeMath: subtraction overflow'
                                    if stor10[address(arg1)][idx].field_512 > block.timestamp:
                                        _3991 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _3991 + 68] = mem[idx + _3907 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_3991 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _3991 + -mem[64] + 100
                                    if block.timestamp < stor10[address(arg1)][idx].field_512:
                                        revert with 0, 17
                                    _4051 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4051] = 26
                                    mem[_4051 + 32] = 'SafeMath: division by zero'
                                    if not claimTime:
                                        _4075 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _4075 + 68] = mem[idx + _4051 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_4075 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _4075 + -mem[64] + 100
                                    if 0 > !(block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime):
                                        revert with 0, 17
                                    if block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not -rewardPerNode:
                                        if 0 > !stor10[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if stor10[address(arg1)][idx].field_768 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if s > !stor10[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if idx >= stor10[address(arg1)].field_0:
                                            revert with 0, 50
                                        stor10[address(arg1)][idx].field_512 = block.timestamp
                                        mem[0] = sha3(address(arg1), 10)
                                        stor10[address(arg1)][idx].field_768 = 0
                                        if not idx + 1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + stor10[address(arg1)][idx].field_768
                                        continue 
                                    if rewardPerNode and block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                        revert with 0, 17
                                    if not rewardPerNode:
                                        revert with 0, 18
                                    if rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime > !stor10[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if (rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !((rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768):
                                        revert with 0, 17
                                    if idx >= stor10[address(arg1)].field_0:
                                        revert with 0, 50
                                    stor10[address(arg1)][idx].field_512 = block.timestamp
                                    mem[0] = sha3(address(arg1), 10)
                                    stor10[address(arg1)][idx].field_768 = 0
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + (rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768
                                    continue 
                                _4035 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4035] = 30
                                mem[_4035 + 32] = 'SafeMath: subtraction overflow'
                                if stor10[address(arg1)][idx].field_256 > block.timestamp:
                                    _4063 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _4063 + 68] = mem[idx + _4035 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4063 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4063 + -mem[64] + 100
                                if block.timestamp < stor10[address(arg1)][idx].field_256:
                                    revert with 0, 17
                                _4155 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4155] = 26
                                mem[_4155 + 32] = 'SafeMath: division by zero'
                                if not claimTime:
                                    _4171 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _4171 + 68] = mem[idx + _4155 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4171 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4171 + -mem[64] + 100
                ('stor', ('name', 'claimTime', 17))
                if 1 > !(block.timestamp - stor10[address(arg1)][idx].field_256 / claimTime):
                    revert with 0, 17
                if (block.timestamp - stor10[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                    revert with 0, 'SafeMath: addition overflow'
                if not -rewardPerNode:
                    if 0 > !stor10[address(arg1)][idx].field_768:
                        revert with 0, 17
                    if stor10[address(arg1)][idx].field_768 < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    if s > !stor10[address(arg1)][idx].field_768:
                        revert with 0, 17
                    if idx >= stor10[address(arg1)].field_0:
                        revert with 0, 50
                    stor10[address(arg1)][idx].field_512 = block.timestamp
                    mem[0] = sha3(address(arg1), 10)
                    stor10[address(arg1)][idx].field_768 = 0
                    if not idx + 1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + stor10[address(arg1)][idx].field_768
                    continue 
                if rewardPerNode and (block.timestamp - stor10[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                    revert with 0, 17
                if not rewardPerNode:
                    revert with 0, 18
                if rewardPerNode + (block.timestamp - stor10[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - stor10[address(arg1)][idx].field_256 / claimTime) + 1:
                    revert with 0, 'SafeMath: multiplication overflow'
                if rewardPerNode + (block.timestamp - stor10[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !stor10[address(arg1)][idx].field_768:
                    revert with 0, 17
                if stor10[address(arg1)][idx].field_768 < 0:
                    revert with 0, 'SafeMath: addition overflow'
                if s > !(rewardPerNode + (block.timestamp - stor10[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + stor10[address(arg1)][idx].field_768):
                    revert with 0, 17
                if idx >= stor10[address(arg1)].field_0:
                    revert with 0, 50
                stor10[address(arg1)][idx].field_512 = block.timestamp
                mem[0] = sha3(address(arg1), 10)
                stor10[address(arg1)][idx].field_768 = 0
                if not idx + 1:
                    revert with 0, 17
                idx = idx + 1
                s = s + rewardPerNode + (block.timestamp - stor10[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + stor10[address(arg1)][idx].field_768
                continue 
        else:
            if address(stor0.field_0) != msg.sender:
                revert with 0, 'NodeManagerV2: NOT AUTHORIZED'
            mem[0] = arg1
            mem[32] = 10
            idx = 0
            s = 0
            while idx < stor10[address(arg1)].field_0:
                mem[0] = sha3(address(arg1), 10)
                _1853 = mem[64]
                mem[64] = mem[64] + 128
                if stor10[address(arg1)][idx].field_0:
                    if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                        revert with 0, 34
                    _1856 = mem[64]
                    mem[64] = mem[64] + ceil32(uint255(stor10[address(arg1)][idx].field_0) * 0.5) + 32
                    mem[_1856] = uint255(stor10[address(arg1)][idx].field_0) * 0.5
                    if stor10[address(arg1)][idx].field_0:
                        if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                            revert with 0, 34
                        if not Mask(256, -1, stor10[address(arg1)][idx].field_0):
                            mem[_1853] = _1856
                            mem[_1853 + 32] = stor10[address(arg1)][idx].field_256
                            mem[_1853 + 64] = stor10[address(arg1)][idx].field_512
                            mem[_1853 + 96] = stor10[address(arg1)][idx].field_768
                            if -stor10[address(arg1)][idx].field_512:
                                _1886 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1886] = 30
                                mem[_1886 + 32] = 'SafeMath: subtraction overflow'
                                if stor10[address(arg1)][idx].field_512 > block.timestamp:
                                    _1912 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _1912 + 68] = mem[idx + _1886 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_1912 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _1912 + -mem[64] + 100
                                if block.timestamp < stor10[address(arg1)][idx].field_512:
                                    revert with 0, 17
                                _2039 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2039] = 26
                                mem[_2039 + 32] = 'SafeMath: division by zero'
                                if not claimTime:
                                    _2106 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _2106 + 68] = mem[idx + _2039 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2106 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2106 + -mem[64] + 100
                                if 0 > !(block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime):
                                    revert with 0, 17
                                if block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not -rewardPerNode:
                                    if 0 > !stor10[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if stor10[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !stor10[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if idx >= stor10[address(arg1)].field_0:
                                        revert with 0, 50
                                    stor10[address(arg1)][idx].field_512 = block.timestamp
                                    mem[0] = sha3(address(arg1), 10)
                                    stor10[address(arg1)][idx].field_768 = 0
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + stor10[address(arg1)][idx].field_768
                                    continue 
                                if rewardPerNode and block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime > !stor10[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if (rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !((rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768):
                                    revert with 0, 17
                                if idx >= stor10[address(arg1)].field_0:
                                    revert with 0, 50
                                stor10[address(arg1)][idx].field_512 = block.timestamp
                                mem[0] = sha3(address(arg1), 10)
                                stor10[address(arg1)][idx].field_768 = 0
                                if not idx + 1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + (rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768
                                continue 
                            _2012 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2012] = 30
                            mem[_2012 + 32] = 'SafeMath: subtraction overflow'
                            if stor10[address(arg1)][idx].field_256 > block.timestamp:
                                _2071 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _2071 + 68] = mem[idx + _2012 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2071 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _2071 + -mem[64] + 100
                            if block.timestamp < stor10[address(arg1)][idx].field_256:
                                revert with 0, 17
                            _2332 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2332] = 26
                            mem[_2332 + 32] = 'SafeMath: division by zero'
                            if not claimTime:
                                _2415 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _2415 + 68] = mem[idx + _2332 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2415 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _2415 + -mem[64] + 100
                        else:
                            if 31 >= uint255(stor10[address(arg1)][idx].field_0) * 0.5:
                                mem[_1856 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                mem[_1853] = _1856
                                mem[_1853 + 32] = stor10[address(arg1)][idx].field_256
                                mem[_1853 + 64] = stor10[address(arg1)][idx].field_512
                                mem[_1853 + 96] = stor10[address(arg1)][idx].field_768
                                if -stor10[address(arg1)][idx].field_512:
                                    _1914 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_1914] = 30
                                    mem[_1914 + 32] = 'SafeMath: subtraction overflow'
                                    if stor10[address(arg1)][idx].field_512 > block.timestamp:
                                        _1949 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _1949 + 68] = mem[idx + _1914 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_1949 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _1949 + -mem[64] + 100
                                    if block.timestamp < stor10[address(arg1)][idx].field_512:
                                        revert with 0, 17
                                    _2107 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_2107] = 26
                                    mem[_2107 + 32] = 'SafeMath: division by zero'
                                    if not claimTime:
                                        _2196 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _2196 + 68] = mem[idx + _2107 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_2196 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _2196 + -mem[64] + 100
                                    if 0 > !(block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime):
                                        revert with 0, 17
                                    if block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not -rewardPerNode:
                                        if 0 > !stor10[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if stor10[address(arg1)][idx].field_768 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if s > !stor10[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if idx >= stor10[address(arg1)].field_0:
                                            revert with 0, 50
                                        stor10[address(arg1)][idx].field_512 = block.timestamp
                                        mem[0] = sha3(address(arg1), 10)
                                        stor10[address(arg1)][idx].field_768 = 0
                                        if not idx + 1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + stor10[address(arg1)][idx].field_768
                                        continue 
                                    if rewardPerNode and block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                        revert with 0, 17
                                    if not rewardPerNode:
                                        revert with 0, 18
                                    if rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime > !stor10[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if (rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !((rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768):
                                        revert with 0, 17
                                    if idx >= stor10[address(arg1)].field_0:
                                        revert with 0, 50
                                    stor10[address(arg1)][idx].field_512 = block.timestamp
                                    mem[0] = sha3(address(arg1), 10)
                                    stor10[address(arg1)][idx].field_768 = 0
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + (rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768
                                    continue 
                                _2074 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2074] = 30
                                mem[_2074 + 32] = 'SafeMath: subtraction overflow'
                                if stor10[address(arg1)][idx].field_256 > block.timestamp:
                                    _2151 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _2151 + 68] = mem[idx + _2074 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2151 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2151 + -mem[64] + 100
                                if block.timestamp < stor10[address(arg1)][idx].field_256:
                                    revert with 0, 17
                                _2417 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2417] = 26
                                mem[_2417 + 32] = 'SafeMath: division by zero'
                                if not claimTime:
                                    _2495 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _2495 + 68] = mem[idx + _2417 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2495 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2495 + -mem[64] + 100
                            else:
                                mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                mem[_1856 + 32] = stor10[address(arg1)][idx].field_0
                                t = _1856 + 32
                                u = sha3(mem[0])
                                while _1856 + (uint255(stor10[address(arg1)][idx].field_0) * 0.5) > t:
                                    mem[t + 32] = uint256(stor1[u])
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                mem[_1853] = _1856
                                mem[_1853 + 32] = stor10[address(arg1)][idx].field_256
                                mem[_1853 + 64] = stor10[address(arg1)][idx].field_512
                                mem[_1853 + 96] = stor10[address(arg1)][idx].field_768
                                if -stor10[address(arg1)][idx].field_512:
                                    _3924 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3924] = 30
                                    mem[_3924 + 32] = 'SafeMath: subtraction overflow'
                                    if stor10[address(arg1)][idx].field_512 > block.timestamp:
                                        _3992 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _3992 + 68] = mem[idx + _3924 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_3992 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _3992 + -mem[64] + 100
                                    if block.timestamp < stor10[address(arg1)][idx].field_512:
                                        revert with 0, 17
                                    _4052 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4052] = 26
                                    mem[_4052 + 32] = 'SafeMath: division by zero'
                                    if not claimTime:
                                        _4076 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _4076 + 68] = mem[idx + _4052 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_4076 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _4076 + -mem[64] + 100
                                    if 0 > !(block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime):
                                        revert with 0, 17
                                    if block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not -rewardPerNode:
                                        if 0 > !stor10[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if stor10[address(arg1)][idx].field_768 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if s > !stor10[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if idx >= stor10[address(arg1)].field_0:
                                            revert with 0, 50
                                        stor10[address(arg1)][idx].field_512 = block.timestamp
                                        mem[0] = sha3(address(arg1), 10)
                                        stor10[address(arg1)][idx].field_768 = 0
                                        if not idx + 1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + stor10[address(arg1)][idx].field_768
                                        continue 
                                    if rewardPerNode and block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                        revert with 0, 17
                                    if not rewardPerNode:
                                        revert with 0, 18
                                    if rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime > !stor10[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if (rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !((rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768):
                                        revert with 0, 17
                                    if idx >= stor10[address(arg1)].field_0:
                                        revert with 0, 50
                                    stor10[address(arg1)][idx].field_512 = block.timestamp
                                    mem[0] = sha3(address(arg1), 10)
                                    stor10[address(arg1)][idx].field_768 = 0
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + (rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768
                                    continue 
                                _4037 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4037] = 30
                                mem[_4037 + 32] = 'SafeMath: subtraction overflow'
                                if stor10[address(arg1)][idx].field_256 > block.timestamp:
                                    _4064 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _4064 + 68] = mem[idx + _4037 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4064 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4064 + -mem[64] + 100
                                if block.timestamp < stor10[address(arg1)][idx].field_256:
                                    revert with 0, 17
                                _4157 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4157] = 26
                                mem[_4157 + 32] = 'SafeMath: division by zero'
                                if not claimTime:
                                    _4172 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _4172 + 68] = mem[idx + _4157 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4172 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4172 + -mem[64] + 100
                    else:
                        if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                            revert with 0, 34
                        if not stor10[address(arg1)][idx].field_1:
                            mem[_1853] = _1856
                            mem[_1853 + 32] = stor10[address(arg1)][idx].field_256
                            mem[_1853 + 64] = stor10[address(arg1)][idx].field_512
                            mem[_1853 + 96] = stor10[address(arg1)][idx].field_768
                            if -stor10[address(arg1)][idx].field_512:
                                _1898 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1898] = 30
                                mem[_1898 + 32] = 'SafeMath: subtraction overflow'
                                if stor10[address(arg1)][idx].field_512 > block.timestamp:
                                    _1929 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _1929 + 68] = mem[idx + _1898 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_1929 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _1929 + -mem[64] + 100
                                if block.timestamp < stor10[address(arg1)][idx].field_512:
                                    revert with 0, 17
                                _2075 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2075] = 26
                                mem[_2075 + 32] = 'SafeMath: division by zero'
                                if not claimTime:
                                    _2152 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _2152 + 68] = mem[idx + _2075 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2152 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2152 + -mem[64] + 100
                                if 0 > !(block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime):
                                    revert with 0, 17
                                if block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not -rewardPerNode:
                                    if 0 > !stor10[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if stor10[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !stor10[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if idx >= stor10[address(arg1)].field_0:
                                        revert with 0, 50
                                    stor10[address(arg1)][idx].field_512 = block.timestamp
                                    mem[0] = sha3(address(arg1), 10)
                                    stor10[address(arg1)][idx].field_768 = 0
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + stor10[address(arg1)][idx].field_768
                                    continue 
                                if rewardPerNode and block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime > !stor10[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if (rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !((rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768):
                                    revert with 0, 17
                                if idx >= stor10[address(arg1)].field_0:
                                    revert with 0, 50
                                stor10[address(arg1)][idx].field_512 = block.timestamp
                                mem[0] = sha3(address(arg1), 10)
                                stor10[address(arg1)][idx].field_768 = 0
                                if not idx + 1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + (rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768
                                continue 
                            _2042 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2042] = 30
                            mem[_2042 + 32] = 'SafeMath: subtraction overflow'
                            if stor10[address(arg1)][idx].field_256 > block.timestamp:
                                _2108 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _2108 + 68] = mem[idx + _2042 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2108 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _2108 + -mem[64] + 100
                            if block.timestamp < stor10[address(arg1)][idx].field_256:
                                revert with 0, 17
                            _2379 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2379] = 26
                            mem[_2379 + 32] = 'SafeMath: division by zero'
                            if not claimTime:
                                _2452 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _2452 + 68] = mem[idx + _2379 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2452 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _2452 + -mem[64] + 100
                        else:
                            if 31 >= stor10[address(arg1)][idx].field_1:
                                mem[_1856 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                mem[_1853] = _1856
                                mem[_1853 + 32] = stor10[address(arg1)][idx].field_256
                                mem[_1853 + 64] = stor10[address(arg1)][idx].field_512
                                mem[_1853 + 96] = stor10[address(arg1)][idx].field_768
                                if -stor10[address(arg1)][idx].field_512:
                                    _1931 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_1931] = 30
                                    mem[_1931 + 32] = 'SafeMath: subtraction overflow'
                                    if stor10[address(arg1)][idx].field_512 > block.timestamp:
                                        _1970 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _1970 + 68] = mem[idx + _1931 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_1970 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _1970 + -mem[64] + 100
                                    if block.timestamp < stor10[address(arg1)][idx].field_512:
                                        revert with 0, 17
                                    _2153 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_2153] = 26
                                    mem[_2153 + 32] = 'SafeMath: division by zero'
                                    if not claimTime:
                                        _2249 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _2249 + 68] = mem[idx + _2153 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_2249 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _2249 + -mem[64] + 100
                                    if 0 > !(block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime):
                                        revert with 0, 17
                                    if block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not -rewardPerNode:
                                        if 0 > !stor10[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if stor10[address(arg1)][idx].field_768 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if s > !stor10[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if idx >= stor10[address(arg1)].field_0:
                                            revert with 0, 50
                                        stor10[address(arg1)][idx].field_512 = block.timestamp
                                        mem[0] = sha3(address(arg1), 10)
                                        stor10[address(arg1)][idx].field_768 = 0
                                        if not idx + 1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + stor10[address(arg1)][idx].field_768
                                        continue 
                                    if rewardPerNode and block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                        revert with 0, 17
                                    if not rewardPerNode:
                                        revert with 0, 18
                                    if rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime > !stor10[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if (rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !((rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768):
                                        revert with 0, 17
                                    if idx >= stor10[address(arg1)].field_0:
                                        revert with 0, 50
                                    stor10[address(arg1)][idx].field_512 = block.timestamp
                                    mem[0] = sha3(address(arg1), 10)
                                    stor10[address(arg1)][idx].field_768 = 0
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + (rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768
                                    continue 
                                _2111 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2111] = 30
                                mem[_2111 + 32] = 'SafeMath: subtraction overflow'
                                if stor10[address(arg1)][idx].field_256 > block.timestamp:
                                    _2202 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _2202 + 68] = mem[idx + _2111 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2202 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2202 + -mem[64] + 100
                                if block.timestamp < stor10[address(arg1)][idx].field_256:
                                    revert with 0, 17
                                _2454 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2454] = 26
                                mem[_2454 + 32] = 'SafeMath: division by zero'
                                if not claimTime:
                                    _2549 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _2549 + 68] = mem[idx + _2454 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2549 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2549 + -mem[64] + 100
                            else:
                                mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                mem[_1856 + 32] = stor10[address(arg1)][idx].field_0
                                t = _1856 + 32
                                u = sha3(mem[0])
                                while _1856 + stor10[address(arg1)][idx].field_1 > t:
                                    mem[t + 32] = uint256(stor1[u])
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                mem[_1853] = _1856
                                mem[_1853 + 32] = stor10[address(arg1)][idx].field_256
                                mem[_1853 + 64] = stor10[address(arg1)][idx].field_512
                                mem[_1853 + 96] = stor10[address(arg1)][idx].field_768
                                if -stor10[address(arg1)][idx].field_512:
                                    _3941 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3941] = 30
                                    mem[_3941 + 32] = 'SafeMath: subtraction overflow'
                                    if stor10[address(arg1)][idx].field_512 > block.timestamp:
                                        _3993 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _3993 + 68] = mem[idx + _3941 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_3993 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _3993 + -mem[64] + 100
                                    if block.timestamp < stor10[address(arg1)][idx].field_512:
                                        revert with 0, 17
                                    _4053 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4053] = 26
                                    mem[_4053 + 32] = 'SafeMath: division by zero'
                                    if not claimTime:
                                        _4077 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _4077 + 68] = mem[idx + _4053 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_4077 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _4077 + -mem[64] + 100
                                    if 0 > !(block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime):
                                        revert with 0, 17
                                    if block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not -rewardPerNode:
                                        if 0 > !stor10[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if stor10[address(arg1)][idx].field_768 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if s > !stor10[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if idx >= stor10[address(arg1)].field_0:
                                            revert with 0, 50
                                        stor10[address(arg1)][idx].field_512 = block.timestamp
                                        mem[0] = sha3(address(arg1), 10)
                                        stor10[address(arg1)][idx].field_768 = 0
                                        if not idx + 1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + stor10[address(arg1)][idx].field_768
                                        continue 
                                    if rewardPerNode and block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                        revert with 0, 17
                                    if not rewardPerNode:
                                        revert with 0, 18
                                    if rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime > !stor10[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if (rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !((rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768):
                                        revert with 0, 17
                                    if idx >= stor10[address(arg1)].field_0:
                                        revert with 0, 50
                                    stor10[address(arg1)][idx].field_512 = block.timestamp
                                    mem[0] = sha3(address(arg1), 10)
                                    stor10[address(arg1)][idx].field_768 = 0
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + (rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768
                                    continue 
                                _4039 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4039] = 30
                                mem[_4039 + 32] = 'SafeMath: subtraction overflow'
                                if stor10[address(arg1)][idx].field_256 > block.timestamp:
                                    _4065 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _4065 + 68] = mem[idx + _4039 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4065 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4065 + -mem[64] + 100
                                if block.timestamp < stor10[address(arg1)][idx].field_256:
                                    revert with 0, 17
                                _4159 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4159] = 26
                                mem[_4159 + 32] = 'SafeMath: division by zero'
                                if not claimTime:
                                    _4173 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _4173 + 68] = mem[idx + _4159 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4173 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4173 + -mem[64] + 100
                else:
                    if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                        revert with 0, 34
                    _1859 = mem[64]
                    mem[64] = mem[64] + ceil32(stor10[address(arg1)][idx].field_1) + 32
                    mem[_1859] = stor10[address(arg1)][idx].field_1
                    if stor10[address(arg1)][idx].field_0:
                        if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                            revert with 0, 34
                        if not Mask(256, -1, stor10[address(arg1)][idx].field_0):
                            mem[_1853] = _1859
                            mem[_1853 + 32] = stor10[address(arg1)][idx].field_256
                            mem[_1853 + 64] = stor10[address(arg1)][idx].field_512
                            mem[_1853 + 96] = stor10[address(arg1)][idx].field_768
                            if -stor10[address(arg1)][idx].field_512:
                                _1900 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1900] = 30
                                mem[_1900 + 32] = 'SafeMath: subtraction overflow'
                                if stor10[address(arg1)][idx].field_512 > block.timestamp:
                                    _1932 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _1932 + 68] = mem[idx + _1900 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_1932 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _1932 + -mem[64] + 100
                                if block.timestamp < stor10[address(arg1)][idx].field_512:
                                    revert with 0, 17
                                _2077 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2077] = 26
                                mem[_2077 + 32] = 'SafeMath: division by zero'
                                if not claimTime:
                                    _2154 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _2154 + 68] = mem[idx + _2077 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2154 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2154 + -mem[64] + 100
                                if 0 > !(block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime):
                                    revert with 0, 17
                                if block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not -rewardPerNode:
                                    if 0 > !stor10[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if stor10[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !stor10[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if idx >= stor10[address(arg1)].field_0:
                                        revert with 0, 50
                                    stor10[address(arg1)][idx].field_512 = block.timestamp
                                    mem[0] = sha3(address(arg1), 10)
                                    stor10[address(arg1)][idx].field_768 = 0
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + stor10[address(arg1)][idx].field_768
                                    continue 
                                if rewardPerNode and block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime > !stor10[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if (rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !((rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768):
                                    revert with 0, 17
                                if idx >= stor10[address(arg1)].field_0:
                                    revert with 0, 50
                                stor10[address(arg1)][idx].field_512 = block.timestamp
                                mem[0] = sha3(address(arg1), 10)
                                stor10[address(arg1)][idx].field_768 = 0
                                if not idx + 1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + (rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768
                                continue 
                            _2045 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2045] = 30
                            mem[_2045 + 32] = 'SafeMath: subtraction overflow'
                            if stor10[address(arg1)][idx].field_256 > block.timestamp:
                                _2112 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _2112 + 68] = mem[idx + _2045 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2112 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _2112 + -mem[64] + 100
                            if block.timestamp < stor10[address(arg1)][idx].field_256:
                                revert with 0, 17
                            _2384 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2384] = 26
                            mem[_2384 + 32] = 'SafeMath: division by zero'
                            if not claimTime:
                                _2455 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _2455 + 68] = mem[idx + _2384 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2455 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _2455 + -mem[64] + 100
                        else:
                            if 31 >= uint255(stor10[address(arg1)][idx].field_0) * 0.5:
                                mem[_1859 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                mem[_1853] = _1859
                                mem[_1853 + 32] = stor10[address(arg1)][idx].field_256
                                mem[_1853 + 64] = stor10[address(arg1)][idx].field_512
                                mem[_1853 + 96] = stor10[address(arg1)][idx].field_768
                                if -stor10[address(arg1)][idx].field_512:
                                    _1934 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_1934] = 30
                                    mem[_1934 + 32] = 'SafeMath: subtraction overflow'
                                    if stor10[address(arg1)][idx].field_512 > block.timestamp:
                                        _1973 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _1973 + 68] = mem[idx + _1934 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_1973 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _1973 + -mem[64] + 100
                                    if block.timestamp < stor10[address(arg1)][idx].field_512:
                                        revert with 0, 17
                                    _2155 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_2155] = 26
                                    mem[_2155 + 32] = 'SafeMath: division by zero'
                                    if not claimTime:
                                        _2252 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _2252 + 68] = mem[idx + _2155 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_2252 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _2252 + -mem[64] + 100
                                    if 0 > !(block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime):
                                        revert with 0, 17
                                    if block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not -rewardPerNode:
                                        if 0 > !stor10[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if stor10[address(arg1)][idx].field_768 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if s > !stor10[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if idx >= stor10[address(arg1)].field_0:
                                            revert with 0, 50
                                        stor10[address(arg1)][idx].field_512 = block.timestamp
                                        mem[0] = sha3(address(arg1), 10)
                                        stor10[address(arg1)][idx].field_768 = 0
                                        if not idx + 1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + stor10[address(arg1)][idx].field_768
                                        continue 
                                    if rewardPerNode and block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                        revert with 0, 17
                                    if not rewardPerNode:
                                        revert with 0, 18
                                    if rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime > !stor10[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if (rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !((rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768):
                                        revert with 0, 17
                                    if idx >= stor10[address(arg1)].field_0:
                                        revert with 0, 50
                                    stor10[address(arg1)][idx].field_512 = block.timestamp
                                    mem[0] = sha3(address(arg1), 10)
                                    stor10[address(arg1)][idx].field_768 = 0
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + (rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768
                                    continue 
                                _2115 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2115] = 30
                                mem[_2115 + 32] = 'SafeMath: subtraction overflow'
                                if stor10[address(arg1)][idx].field_256 > block.timestamp:
                                    _2208 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _2208 + 68] = mem[idx + _2115 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2208 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2208 + -mem[64] + 100
                                if block.timestamp < stor10[address(arg1)][idx].field_256:
                                    revert with 0, 17
                                _2457 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2457] = 26
                                mem[_2457 + 32] = 'SafeMath: division by zero'
                                if not claimTime:
                                    _2555 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _2555 + 68] = mem[idx + _2457 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2555 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2555 + -mem[64] + 100
                            else:
                                mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                mem[_1859 + 32] = stor10[address(arg1)][idx].field_0
                                t = _1859 + 32
                                u = sha3(mem[0])
                                while _1859 + (uint255(stor10[address(arg1)][idx].field_0) * 0.5) > t:
                                    mem[t + 32] = uint256(stor1[u])
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                mem[_1853] = _1859
                                mem[_1853 + 32] = stor10[address(arg1)][idx].field_256
                                mem[_1853 + 64] = stor10[address(arg1)][idx].field_512
                                mem[_1853 + 96] = stor10[address(arg1)][idx].field_768
                                if -stor10[address(arg1)][idx].field_512:
                                    _3958 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3958] = 30
                                    mem[_3958 + 32] = 'SafeMath: subtraction overflow'
                                    if stor10[address(arg1)][idx].field_512 > block.timestamp:
                                        _3994 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _3994 + 68] = mem[idx + _3958 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_3994 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _3994 + -mem[64] + 100
                                    if block.timestamp < stor10[address(arg1)][idx].field_512:
                                        revert with 0, 17
                                    _4054 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4054] = 26
                                    mem[_4054 + 32] = 'SafeMath: division by zero'
                                    if not claimTime:
                                        _4078 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _4078 + 68] = mem[idx + _4054 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_4078 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _4078 + -mem[64] + 100
                                    if 0 > !(block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime):
                                        revert with 0, 17
                                    if block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not -rewardPerNode:
                                        if 0 > !stor10[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if stor10[address(arg1)][idx].field_768 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if s > !stor10[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if idx >= stor10[address(arg1)].field_0:
                                            revert with 0, 50
                                        stor10[address(arg1)][idx].field_512 = block.timestamp
                                        mem[0] = sha3(address(arg1), 10)
                                        stor10[address(arg1)][idx].field_768 = 0
                                        if not idx + 1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + stor10[address(arg1)][idx].field_768
                                        continue 
                                    if rewardPerNode and block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                        revert with 0, 17
                                    if not rewardPerNode:
                                        revert with 0, 18
                                    if rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime > !stor10[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if (rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !((rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768):
                                        revert with 0, 17
                                    if idx >= stor10[address(arg1)].field_0:
                                        revert with 0, 50
                                    stor10[address(arg1)][idx].field_512 = block.timestamp
                                    mem[0] = sha3(address(arg1), 10)
                                    stor10[address(arg1)][idx].field_768 = 0
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + (rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768
                                    continue 
                                _4041 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4041] = 30
                                mem[_4041 + 32] = 'SafeMath: subtraction overflow'
                                if stor10[address(arg1)][idx].field_256 > block.timestamp:
                                    _4066 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _4066 + 68] = mem[idx + _4041 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4066 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4066 + -mem[64] + 100
                                if block.timestamp < stor10[address(arg1)][idx].field_256:
                                    revert with 0, 17
                                _4161 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4161] = 26
                                mem[_4161 + 32] = 'SafeMath: division by zero'
                                if not claimTime:
                                    _4174 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _4174 + 68] = mem[idx + _4161 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4174 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4174 + -mem[64] + 100
                    else:
                        if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                            revert with 0, 34
                        if not stor10[address(arg1)][idx].field_1:
                            mem[_1853] = _1859
                            mem[_1853 + 32] = stor10[address(arg1)][idx].field_256
                            mem[_1853 + 64] = stor10[address(arg1)][idx].field_512
                            mem[_1853 + 96] = stor10[address(arg1)][idx].field_768
                            if -stor10[address(arg1)][idx].field_512:
                                _1915 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1915] = 30
                                mem[_1915 + 32] = 'SafeMath: subtraction overflow'
                                if stor10[address(arg1)][idx].field_512 > block.timestamp:
                                    _1950 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _1950 + 68] = mem[idx + _1915 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_1950 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _1950 + -mem[64] + 100
                                if block.timestamp < stor10[address(arg1)][idx].field_512:
                                    revert with 0, 17
                                _2116 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2116] = 26
                                mem[_2116 + 32] = 'SafeMath: division by zero'
                                if not claimTime:
                                    _2209 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _2209 + 68] = mem[idx + _2116 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2209 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2209 + -mem[64] + 100
                                if 0 > !(block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime):
                                    revert with 0, 17
                                if block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not -rewardPerNode:
                                    if 0 > !stor10[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if stor10[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !stor10[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if idx >= stor10[address(arg1)].field_0:
                                        revert with 0, 50
                                    stor10[address(arg1)][idx].field_512 = block.timestamp
                                    mem[0] = sha3(address(arg1), 10)
                                    stor10[address(arg1)][idx].field_768 = 0
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + stor10[address(arg1)][idx].field_768
                                    continue 
                                if rewardPerNode and block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime > !stor10[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if (rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !((rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768):
                                    revert with 0, 17
                                if idx >= stor10[address(arg1)].field_0:
                                    revert with 0, 50
                                stor10[address(arg1)][idx].field_512 = block.timestamp
                                mem[0] = sha3(address(arg1), 10)
                                stor10[address(arg1)][idx].field_768 = 0
                                if not idx + 1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + (rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768
                                continue 
                            _2080 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2080] = 30
                            mem[_2080 + 32] = 'SafeMath: subtraction overflow'
                            if stor10[address(arg1)][idx].field_256 > block.timestamp:
                                _2156 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _2156 + 68] = mem[idx + _2080 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2156 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _2156 + -mem[64] + 100
                            if block.timestamp < stor10[address(arg1)][idx].field_256:
                                revert with 0, 17
                            _2423 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2423] = 26
                            mem[_2423 + 32] = 'SafeMath: division by zero'
                            if not claimTime:
                                _2502 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _2502 + 68] = mem[idx + _2423 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2502 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _2502 + -mem[64] + 100
                        else:
                            if 31 >= stor10[address(arg1)][idx].field_1:
                                mem[_1859 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                mem[_1853] = _1859
                                mem[_1853 + 32] = stor10[address(arg1)][idx].field_256
                                mem[_1853 + 64] = stor10[address(arg1)][idx].field_512
                                mem[_1853 + 96] = stor10[address(arg1)][idx].field_768
                                if -stor10[address(arg1)][idx].field_512:
                                    _1952 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_1952] = 30
                                    mem[_1952 + 32] = 'SafeMath: subtraction overflow'
                                    if stor10[address(arg1)][idx].field_512 > block.timestamp:
                                        _1994 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _1994 + 68] = mem[idx + _1952 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_1994 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _1994 + -mem[64] + 100
                                    if block.timestamp < stor10[address(arg1)][idx].field_512:
                                        revert with 0, 17
                                    _2210 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_2210] = 26
                                    mem[_2210 + 32] = 'SafeMath: division by zero'
                                    if not claimTime:
                                        _2300 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _2300 + 68] = mem[idx + _2210 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_2300 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _2300 + -mem[64] + 100
                                    if 0 > !(block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime):
                                        revert with 0, 17
                                    if block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not -rewardPerNode:
                                        if 0 > !stor10[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if stor10[address(arg1)][idx].field_768 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if s > !stor10[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if idx >= stor10[address(arg1)].field_0:
                                            revert with 0, 50
                                        stor10[address(arg1)][idx].field_512 = block.timestamp
                                        mem[0] = sha3(address(arg1), 10)
                                        stor10[address(arg1)][idx].field_768 = 0
                                        if not idx + 1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + stor10[address(arg1)][idx].field_768
                                        continue 
                                    if rewardPerNode and block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                        revert with 0, 17
                                    if not rewardPerNode:
                                        revert with 0, 18
                                    if rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime > !stor10[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if (rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !((rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768):
                                        revert with 0, 17
                                    if idx >= stor10[address(arg1)].field_0:
                                        revert with 0, 50
                                    stor10[address(arg1)][idx].field_512 = block.timestamp
                                    mem[0] = sha3(address(arg1), 10)
                                    stor10[address(arg1)][idx].field_768 = 0
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + (rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768
                                    continue 
                                _2159 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2159] = 30
                                mem[_2159 + 32] = 'SafeMath: subtraction overflow'
                                if stor10[address(arg1)][idx].field_256 > block.timestamp:
                                    _2258 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _2258 + 68] = mem[idx + _2159 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2258 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2258 + -mem[64] + 100
                                if block.timestamp < stor10[address(arg1)][idx].field_256:
                                    revert with 0, 17
                                _2504 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2504] = 26
                                mem[_2504 + 32] = 'SafeMath: division by zero'
                                if not claimTime:
                                    _2609 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _2609 + 68] = mem[idx + _2504 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_2609 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _2609 + -mem[64] + 100
                            else:
                                mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                mem[_1859 + 32] = stor10[address(arg1)][idx].field_0
                                t = _1859 + 32
                                u = sha3(mem[0])
                                while _1859 + stor10[address(arg1)][idx].field_1 > t:
                                    mem[t + 32] = uint256(stor1[u])
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                mem[_1853] = _1859
                                mem[_1853 + 32] = stor10[address(arg1)][idx].field_256
                                mem[_1853 + 64] = stor10[address(arg1)][idx].field_512
                                mem[_1853 + 96] = stor10[address(arg1)][idx].field_768
                                if -stor10[address(arg1)][idx].field_512:
                                    _3975 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3975] = 30
                                    mem[_3975 + 32] = 'SafeMath: subtraction overflow'
                                    if stor10[address(arg1)][idx].field_512 > block.timestamp:
                                        _3995 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _3995 + 68] = mem[idx + _3975 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_3995 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _3995 + -mem[64] + 100
                                    if block.timestamp < stor10[address(arg1)][idx].field_512:
                                        revert with 0, 17
                                    _4055 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4055] = 26
                                    mem[_4055 + 32] = 'SafeMath: division by zero'
                                    if not claimTime:
                                        _4079 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _4079 + 68] = mem[idx + _4055 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_4079 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _4079 + -mem[64] + 100
                                    if 0 > !(block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime):
                                        revert with 0, 17
                                    if block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not -rewardPerNode:
                                        if 0 > !stor10[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if stor10[address(arg1)][idx].field_768 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if s > !stor10[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if idx >= stor10[address(arg1)].field_0:
                                            revert with 0, 50
                                        stor10[address(arg1)][idx].field_512 = block.timestamp
                                        mem[0] = sha3(address(arg1), 10)
                                        stor10[address(arg1)][idx].field_768 = 0
                                        if not idx + 1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + stor10[address(arg1)][idx].field_768
                                        continue 
                                    if rewardPerNode and block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                        revert with 0, 17
                                    if not rewardPerNode:
                                        revert with 0, 18
                                    if rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime > !stor10[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if (rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !((rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768):
                                        revert with 0, 17
                                    if idx >= stor10[address(arg1)].field_0:
                                        revert with 0, 50
                                    stor10[address(arg1)][idx].field_512 = block.timestamp
                                    mem[0] = sha3(address(arg1), 10)
                                    stor10[address(arg1)][idx].field_768 = 0
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + (rewardPerNode * block.timestamp - stor10[address(arg1)][idx].field_512 / claimTime) + stor10[address(arg1)][idx].field_768
                                    continue 
                                _4043 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4043] = 30
                                mem[_4043 + 32] = 'SafeMath: subtraction overflow'
                                if stor10[address(arg1)][idx].field_256 > block.timestamp:
                                    _4067 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _4067 + 68] = mem[idx + _4043 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4067 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4067 + -mem[64] + 100
                                if block.timestamp < stor10[address(arg1)][idx].field_256:
                                    revert with 0, 17
                                _4163 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4163] = 26
                                mem[_4163 + 32] = 'SafeMath: division by zero'
                                if not claimTime:
                                    _4175 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _4175 + 68] = mem[idx + _4163 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4175 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4175 + -mem[64] + 100
                ('stor', ('name', 'claimTime', 17))
                if 1 > !(block.timestamp - stor10[address(arg1)][idx].field_256 / claimTime):
                    revert with 0, 17
                if (block.timestamp - stor10[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                    revert with 0, 'SafeMath: addition overflow'
                if not -rewardPerNode:
                    if 0 > !stor10[address(arg1)][idx].field_768:
                        revert with 0, 17
                    if stor10[address(arg1)][idx].field_768 < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    if s > !stor10[address(arg1)][idx].field_768:
                        revert with 0, 17
                    if idx >= stor10[address(arg1)].field_0:
                        revert with 0, 50
                    stor10[address(arg1)][idx].field_512 = block.timestamp
                    mem[0] = sha3(address(arg1), 10)
                    stor10[address(arg1)][idx].field_768 = 0
                    if not idx + 1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + stor10[address(arg1)][idx].field_768
                    continue 
                if rewardPerNode and (block.timestamp - stor10[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                    revert with 0, 17
                if not rewardPerNode:
                    revert with 0, 18
                if rewardPerNode + (block.timestamp - stor10[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - stor10[address(arg1)][idx].field_256 / claimTime) + 1:
                    revert with 0, 'SafeMath: multiplication overflow'
                if rewardPerNode + (block.timestamp - stor10[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !stor10[address(arg1)][idx].field_768:
                    revert with 0, 17
                if stor10[address(arg1)][idx].field_768 < 0:
                    revert with 0, 'SafeMath: addition overflow'
                if s > !(rewardPerNode + (block.timestamp - stor10[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + stor10[address(arg1)][idx].field_768):
                    revert with 0, 17
                if idx >= stor10[address(arg1)].field_0:
                    revert with 0, 50
                stor10[address(arg1)][idx].field_512 = block.timestamp
                mem[0] = sha3(address(arg1), 10)
                stor10[address(arg1)][idx].field_768 = 0
                if not idx + 1:
                    revert with 0, 17
                idx = idx + 1
                s = s + rewardPerNode + (block.timestamp - stor10[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + stor10[address(arg1)][idx].field_768
                continue 
    return s
}

function sub_d65f10d3(?) payable {
    require calldata.size - 4 >= 96
    require arg1 == address(arg1)
    require arg2 <= test266151307()
    require arg2 + 35 < calldata.size
    if arg2.length > test266151307():
        revert with 0, 65
    if ceil32(ceil32(arg2.length)) + 97 < 96 or ceil32(ceil32(arg2.length)) + 97 > test266151307():
        revert with 0, 65
    mem[96] = arg2.length
    require arg2 + arg2.length + 36 <= calldata.size
    mem[128 len arg2.length] = arg2[all]
    require arg3 == address(arg3)
    if msg.sender == tokenAddress:
        mem[ceil32(ceil32(arg2.length)) + 97] = 96
        mem[ceil32(ceil32(arg2.length)) + 129] = block.timestamp
        mem[ceil32(ceil32(arg2.length)) + 161] = block.timestamp
        mem[ceil32(ceil32(arg2.length)) + 193] = 0
        stor10[address(arg1)].field_0++
        if stor10[address(arg1)][stor10[address(arg1)].field_0].field_0:
            if not stor10[address(arg1)][stor10[address(arg1)].field_0].field_0 - (uint255(stor10[address(arg1)][stor10[address(arg1)].field_0].field_0) * 0.5 < 32):
                revert with 0, 34
            if arg2.length:
                stor10[address(arg1)][stor10[address(arg1)].field_0][].field_0 = Array(len=arg2.length, data=arg2[all])
                stor10[address(arg1)][stor10[address(arg1)].field_0].field_256 = block.timestamp
                stor10[address(arg1)][stor10[address(arg1)].field_0].field_512 = block.timestamp
                stor10[address(arg1)][stor10[address(arg1)].field_0].field_768 = 0
                mem[ceil32(ceil32(arg2.length)) + 229] = 6
                mem[ceil32(ceil32(arg2.length)) + 261] = address(arg1)
                mem[ceil32(ceil32(arg2.length)) + 293] = stor10[address(arg1)].field_0
                require ext_code.size(0x4b7a346b17572634bdbd85b98abae32c5fa837bb)
                delegate 0x4b7a346b17572634bdbd85b98abae32c5fa837bb.0xbc2b405c with:
                     gas gas_remaining wei
                    args 6, address(arg1), stor10[address(arg1)].field_0
                if not delegate.return_code:
                    revert with ext_call.return_data[0 len return_data.size]
                if not totalNodesCreated + 1:
                    revert with 0, 17
                totalNodesCreated++
                if msg.sender == tokenAddress:
                    mem[0] = address(arg1)
                    mem[64] = ceil32(ceil32(arg2.length)) + (32 * stor10[address(arg1)].field_0) + 257
                    mem[ceil32(ceil32(arg2.length)) + 225] = stor10[address(arg1)].field_0
                    s = ceil32(ceil32(arg2.length)) + 257
                    idx = 0
                    while idx < stor10[address(arg1)].field_0:
                        mem[0] = sha3(address(arg1), 10)
                        _22408 = mem[64]
                        mem[64] = mem[64] + 128
                        if stor10[address(arg1)][idx].field_0:
                            if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                                revert with 0, 34
                            _22744 = mem[64]
                            mem[64] = mem[64] + ceil32(uint255(stor10[address(arg1)][idx].field_0) * 0.5) + 32
                            mem[_22744] = uint255(stor10[address(arg1)][idx].field_0) * 0.5
                            if stor10[address(arg1)][idx].field_0:
                                if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                                    revert with 0, 34
                                if Mask(256, -1, stor10[address(arg1)][idx].field_0):
                                    if 31 >= uint255(stor10[address(arg1)][idx].field_0) * 0.5:
                                        mem[_22744 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                    else:
                                        mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                        mem[_22744 + 32] = stor10[address(arg1)][idx].field_0
                                        t = _22744 + 32
                                        u = sha3(mem[0])
                                        while _22744 + (uint255(stor10[address(arg1)][idx].field_0) * 0.5) > t:
                                            mem[t + 32] = uint256(stor1[u])
                                            t = t + 32
                                            u = u + 1
                                            continue 
                                mem[_22408] = _22744
                                mem[_22408 + 32] = stor10[address(arg1)][idx].field_256
                                mem[_22408 + 64] = stor10[address(arg1)][idx].field_512
                                mem[_22408 + 96] = stor10[address(arg1)][idx].field_768
                                mem[s] = _22408
                                s = s + 32
                                idx = idx + 1
                                continue 
                            if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                                revert with 0, 34
                            if not stor10[address(arg1)][idx].field_1:
                                mem[_22408] = _22744
                                mem[_22408 + 32] = stor10[address(arg1)][idx].field_256
                                mem[_22408 + 64] = stor10[address(arg1)][idx].field_512
                                mem[_22408 + 96] = stor10[address(arg1)][idx].field_768
                                mem[s] = _22408
                                s = s + 32
                                idx = idx + 1
                                continue 
                            if 31 >= stor10[address(arg1)][idx].field_1:
                                mem[_22744 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                mem[_22408] = _22744
                                mem[_22408 + 32] = stor10[address(arg1)][idx].field_256
                                mem[_22408 + 64] = stor10[address(arg1)][idx].field_512
                                mem[_22408 + 96] = stor10[address(arg1)][idx].field_768
                                mem[s] = _22408
                                s = s + 32
                                idx = idx + 1
                                continue 
                            mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                            mem[_22744 + 32] = stor10[address(arg1)][idx].field_0
                            t = _22744 + 32
                            u = sha3(mem[0])
                            while _22744 + stor10[address(arg1)][u].field_1 > t:
                                mem[t + 32] = uint256(stor1[u])
                                t = t + 32
                                u = u + 1
                                continue 
                            mem[_22408] = _22744
                            mem[_22408 + 32] = stor10[address(arg1)][u].field_256
                            mem[_22408 + 64] = stor10[address(arg1)][u].field_512
                            mem[_22408 + 96] = stor10[address(arg1)][u].field_768
                            mem[t] = _22408
                            t = t + 32
                            u = u + 1
                            continue 
                        if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                            revert with 0, 34
                        _22820 = mem[64]
                        mem[64] = mem[64] + ceil32(stor10[address(arg1)][idx].field_1) + 32
                        mem[_22820] = stor10[address(arg1)][idx].field_1
                        if stor10[address(arg1)][idx].field_0:
                            if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                                revert with 0, 34
                            if not Mask(256, -1, stor10[address(arg1)][idx].field_0):
                                mem[_22408] = _22820
                                mem[_22408 + 32] = stor10[address(arg1)][idx].field_256
                                mem[_22408 + 64] = stor10[address(arg1)][idx].field_512
                                mem[_22408 + 96] = stor10[address(arg1)][idx].field_768
                                mem[s] = _22408
                                s = s + 32
                                idx = idx + 1
                                continue 
                            if 31 >= uint255(stor10[address(arg1)][idx].field_0) * 0.5:
                                mem[_22820 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                mem[_22408] = _22820
                                mem[_22408 + 32] = stor10[address(arg1)][idx].field_256
                                mem[_22408 + 64] = stor10[address(arg1)][idx].field_512
                                mem[_22408 + 96] = stor10[address(arg1)][idx].field_768
                                mem[s] = _22408
                                s = s + 32
                                idx = idx + 1
                                continue 
                            mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                            mem[_22820 + 32] = stor10[address(arg1)][idx].field_0
                            t = _22820 + 32
                            u = sha3(mem[0])
                            while _22820 + (uint255(stor10[address(arg1)][u].field_0) * 0.5) > t:
                                mem[t + 32] = uint256(stor1[u])
                                t = t + 32
                                u = u + 1
                                continue 
                            mem[_22408] = _22820
                            mem[_22408 + 32] = stor10[address(arg1)][u].field_256
                            mem[_22408 + 64] = stor10[address(arg1)][u].field_512
                            mem[_22408 + 96] = stor10[address(arg1)][u].field_768
                            mem[t] = _22408
                            t = t + 32
                            u = u + 1
                            continue 
                        if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                            revert with 0, 34
                        if stor10[address(arg1)][idx].field_1:
                            if 31 >= stor10[address(arg1)][idx].field_1:
                                mem[_22820 + 32] = 256 * stor10[address(arg1)][idx].field_8
                            else:
                                mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                mem[_22820 + 32] = stor10[address(arg1)][idx].field_0
                                t = _22820 + 32
                                u = sha3(mem[0])
                                while _22820 + stor10[address(arg1)][idx].field_1 > t:
                                    mem[t + 32] = uint256(stor1[u])
                                    t = t + 32
                                    u = u + 1
                                    continue 
                        mem[_22408] = _22820
                        mem[_22408 + 32] = stor10[address(arg1)][idx].field_256
                        mem[_22408 + 64] = stor10[address(arg1)][idx].field_512
                        mem[_22408 + 96] = stor10[address(arg1)][idx].field_768
                        mem[s] = _22408
                        s = s + 32
                        idx = idx + 1
                        continue 
                    mem[0] = address(arg3)
                    mem[32] = 10
                    _22406 = mem[64]
                    mem[64] = mem[64] + (32 * stor10[address(arg3)].field_0) + 32
                    mem[_22406] = stor10[address(arg3)].field_0
                    s = _22406 + 32
                    idx = 0
                    while idx < stor10[address(arg3)].field_0:
                        mem[0] = sha3(address(arg3), 10)
                        _29060 = mem[64]
                        mem[64] = mem[64] + 128
                        if stor10[address(arg3)][idx].field_0:
                            if not stor10[address(arg3)][idx].field_0 - (uint255(stor10[address(arg3)][idx].field_0) * 0.5 < 32):
                                revert with 0, 34
                            _29131 = mem[64]
                            mem[64] = mem[64] + ceil32(uint255(stor10[address(arg3)][idx].field_0) * 0.5) + 32
                            mem[_29131] = uint255(stor10[address(arg3)][idx].field_0) * 0.5
                            if stor10[address(arg3)][idx].field_0:
                                if not stor10[address(arg3)][idx].field_0 - (uint255(stor10[address(arg3)][idx].field_0) * 0.5 < 32):
                                    revert with 0, 34
                                if Mask(256, -1, stor10[address(arg3)][idx].field_0):
                                    if 31 >= uint255(stor10[address(arg3)][idx].field_0) * 0.5:
                                        mem[_29131 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                    else:
                                        mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                        mem[_29131 + 32] = stor10[address(arg3)][idx].field_0
                                        t = _29131 + 32
                                        u = sha3(mem[0])
                                        while _29131 + (uint255(stor10[address(arg3)][idx].field_0) * 0.5) > t:
                                            mem[t + 32] = uint256(stor1[u])
                                            t = t + 32
                                            u = u + 1
                                            continue 
                                mem[_29060] = _29131
                                mem[_29060 + 32] = stor10[address(arg3)][idx].field_256
                                mem[_29060 + 64] = stor10[address(arg3)][idx].field_512
                                mem[_29060 + 96] = stor10[address(arg3)][idx].field_768
                                mem[s] = _29060
                                s = s + 32
                                idx = idx + 1
                                continue 
                            if not stor10[address(arg3)][idx].field_0 - (stor10[address(arg3)][idx].field_1 < 32):
                                revert with 0, 34
                            if not stor10[address(arg3)][idx].field_1:
                                mem[_29060] = _29131
                                mem[_29060 + 32] = stor10[address(arg3)][idx].field_256
                                mem[_29060 + 64] = stor10[address(arg3)][idx].field_512
                                mem[_29060 + 96] = stor10[address(arg3)][idx].field_768
                                mem[s] = _29060
                                s = s + 32
                                idx = idx + 1
                                continue 
                            if 31 >= stor10[address(arg3)][idx].field_1:
                                mem[_29131 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                mem[_29060] = _29131
                                mem[_29060 + 32] = stor10[address(arg3)][idx].field_256
                                mem[_29060 + 64] = stor10[address(arg3)][idx].field_512
                                mem[_29060 + 96] = stor10[address(arg3)][idx].field_768
                                mem[s] = _29060
                                s = s + 32
                                idx = idx + 1
                                continue 
                            mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                            mem[_29131 + 32] = stor10[address(arg3)][idx].field_0
                            t = _29131 + 32
                            u = sha3(mem[0])
                            while _29131 + stor10[address(arg3)][u].field_1 > t:
                                mem[t + 32] = uint256(stor1[u])
                                t = t + 32
                                u = u + 1
                                continue 
                            mem[_29060] = _29131
                            mem[_29060 + 32] = stor10[address(arg3)][u].field_256
                            mem[_29060 + 64] = stor10[address(arg3)][u].field_512
                            mem[_29060 + 96] = stor10[address(arg3)][u].field_768
                            mem[t] = _29060
                            t = t + 32
                            u = u + 1
                            continue 
                        if not stor10[address(arg3)][idx].field_0 - (stor10[address(arg3)][idx].field_1 < 32):
                            revert with 0, 34
                        _29150 = mem[64]
                        mem[64] = mem[64] + ceil32(stor10[address(arg3)][idx].field_1) + 32
                        mem[_29150] = stor10[address(arg3)][idx].field_1
                        if stor10[address(arg3)][idx].field_0:
                            if not stor10[address(arg3)][idx].field_0 - (uint255(stor10[address(arg3)][idx].field_0) * 0.5 < 32):
                                revert with 0, 34
                            if not Mask(256, -1, stor10[address(arg3)][idx].field_0):
                                mem[_29060] = _29150
                                mem[_29060 + 32] = stor10[address(arg3)][idx].field_256
                                mem[_29060 + 64] = stor10[address(arg3)][idx].field_512
                                mem[_29060 + 96] = stor10[address(arg3)][idx].field_768
                                mem[s] = _29060
                                s = s + 32
                                idx = idx + 1
                                continue 
                            if 31 >= uint255(stor10[address(arg3)][idx].field_0) * 0.5:
                                mem[_29150 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                mem[_29060] = _29150
                                mem[_29060 + 32] = stor10[address(arg3)][idx].field_256
                                mem[_29060 + 64] = stor10[address(arg3)][idx].field_512
                                mem[_29060 + 96] = stor10[address(arg3)][idx].field_768
                                mem[s] = _29060
                                s = s + 32
                                idx = idx + 1
                                continue 
                            mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                            mem[_29150 + 32] = stor10[address(arg3)][idx].field_0
                            t = _29150 + 32
                            u = sha3(mem[0])
                            while _29150 + (uint255(stor10[address(arg3)][u].field_0) * 0.5) > t:
                                mem[t + 32] = uint256(stor1[u])
                                t = t + 32
                                u = u + 1
                                continue 
                            mem[_29060] = _29150
                            mem[_29060 + 32] = stor10[address(arg3)][u].field_256
                            mem[_29060 + 64] = stor10[address(arg3)][u].field_512
                            mem[_29060 + 96] = stor10[address(arg3)][u].field_768
                            mem[t] = _29060
                            t = t + 32
                            u = u + 1
                            continue 
                        if not stor10[address(arg3)][idx].field_0 - (stor10[address(arg3)][idx].field_1 < 32):
                            revert with 0, 34
                        if stor10[address(arg3)][idx].field_1:
                            if 31 >= stor10[address(arg3)][idx].field_1:
                                mem[_29150 + 32] = 256 * stor10[address(arg3)][idx].field_8
                            else:
                                mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                mem[_29150 + 32] = stor10[address(arg3)][idx].field_0
                                t = _29150 + 32
                                u = sha3(mem[0])
                                while _29150 + stor10[address(arg3)][idx].field_1 > t:
                                    mem[t + 32] = uint256(stor1[u])
                                    t = t + 32
                                    u = u + 1
                                    continue 
                        mem[_29060] = _29150
                        mem[_29060 + 32] = stor10[address(arg3)][idx].field_256
                        mem[_29060 + 64] = stor10[address(arg3)][idx].field_512
                        mem[_29060 + 96] = stor10[address(arg3)][idx].field_768
                        mem[s] = _29060
                        s = s + 32
                        idx = idx + 1
                        continue 
                    if address(arg1) != address(arg3):
                        if mem[ceil32(ceil32(arg2.length)) + 225] <= 1:
                            if mem[_22406] > 0:
                                if _referrals[address(arg1)] != address(arg3):
                                    _referrals[address(arg1)] = address(arg3)
                                    sub_989baf69[address(arg3)].field_0++
                                    sub_989baf69[address(arg3)][sub_989baf69[address(arg3)].field_0].field_0 = address(arg1)
                                if tokenAddress != msg.sender:
                                    if gateKeeperAddress != msg.sender:
                                        if address(stor0.field_0) != msg.sender:
                                            revert with 0, 'NodeManagerV2: NOT AUTHORIZED'
                                if stor10[stor11[address(arg1)]].field_0:
                                    if not -referralBonusPercent:
                                        sub_e27e434a[stor11[address(arg1)]][address(arg1)] = 0
                                        if sub_666755bb[stor11[address(arg1)]] > -1:
                                            revert with 0, 17
                                    else:
                                        if referralBonusPercent and nodePrice > -1 / referralBonusPercent:
                                            revert with 0, 17
                                        if not referralBonusPercent:
                                            revert with 0, 18
                                        if referralBonusPercent * nodePrice / referralBonusPercent != nodePrice:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        sub_e27e434a[stor11[address(arg1)]][address(arg1)] = referralBonusPercent * nodePrice / 100
                                        if sub_666755bb[stor11[address(arg1)]] > !(referralBonusPercent * nodePrice / 100):
                                            revert with 0, 17
                                        sub_666755bb[stor11[address(arg1)]] += referralBonusPercent * nodePrice / 100
                else:
                    if msg.sender == gateKeeperAddress:
                        mem[0] = address(arg1)
                        mem[64] = ceil32(ceil32(arg2.length)) + (32 * stor10[address(arg1)].field_0) + 257
                        mem[ceil32(ceil32(arg2.length)) + 225] = stor10[address(arg1)].field_0
                        s = ceil32(ceil32(arg2.length)) + 257
                        idx = 0
                        while idx < stor10[address(arg1)].field_0:
                            mem[0] = sha3(address(arg1), 10)
                            _22412 = mem[64]
                            mem[64] = mem[64] + 128
                            if stor10[address(arg1)][idx].field_0:
                                if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                                    revert with 0, 34
                                _22745 = mem[64]
                                mem[64] = mem[64] + ceil32(uint255(stor10[address(arg1)][idx].field_0) * 0.5) + 32
                                mem[_22745] = uint255(stor10[address(arg1)][idx].field_0) * 0.5
                                if stor10[address(arg1)][idx].field_0:
                                    if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                                        revert with 0, 34
                                    if Mask(256, -1, stor10[address(arg1)][idx].field_0):
                                        if 31 >= uint255(stor10[address(arg1)][idx].field_0) * 0.5:
                                            mem[_22745 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                        else:
                                            mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                            mem[_22745 + 32] = stor10[address(arg1)][idx].field_0
                                            t = _22745 + 32
                                            u = sha3(mem[0])
                                            while _22745 + (uint255(stor10[address(arg1)][idx].field_0) * 0.5) > t:
                                                mem[t + 32] = uint256(stor1[u])
                                                t = t + 32
                                                u = u + 1
                                                continue 
                                    mem[_22412] = _22745
                                    mem[_22412 + 32] = stor10[address(arg1)][idx].field_256
                                    mem[_22412 + 64] = stor10[address(arg1)][idx].field_512
                                    mem[_22412 + 96] = stor10[address(arg1)][idx].field_768
                                    mem[s] = _22412
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                                    revert with 0, 34
                                if not stor10[address(arg1)][idx].field_1:
                                    mem[_22412] = _22745
                                    mem[_22412 + 32] = stor10[address(arg1)][idx].field_256
                                    mem[_22412 + 64] = stor10[address(arg1)][idx].field_512
                                    mem[_22412 + 96] = stor10[address(arg1)][idx].field_768
                                    mem[s] = _22412
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                if 31 >= stor10[address(arg1)][idx].field_1:
                                    mem[_22745 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                    mem[_22412] = _22745
                                    mem[_22412 + 32] = stor10[address(arg1)][idx].field_256
                                    mem[_22412 + 64] = stor10[address(arg1)][idx].field_512
                                    mem[_22412 + 96] = stor10[address(arg1)][idx].field_768
                                    mem[s] = _22412
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                mem[_22745 + 32] = stor10[address(arg1)][idx].field_0
                                t = _22745 + 32
                                u = sha3(mem[0])
                                while _22745 + stor10[address(arg1)][u].field_1 > t:
                                    mem[t + 32] = uint256(stor1[u])
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                mem[_22412] = _22745
                                mem[_22412 + 32] = stor10[address(arg1)][u].field_256
                                mem[_22412 + 64] = stor10[address(arg1)][u].field_512
                                mem[_22412 + 96] = stor10[address(arg1)][u].field_768
                                mem[t] = _22412
                                t = t + 32
                                u = u + 1
                                continue 
                            if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                                revert with 0, 34
                            _22822 = mem[64]
                            mem[64] = mem[64] + ceil32(stor10[address(arg1)][idx].field_1) + 32
                            mem[_22822] = stor10[address(arg1)][idx].field_1
                            if stor10[address(arg1)][idx].field_0:
                                if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                                    revert with 0, 34
                                if not Mask(256, -1, stor10[address(arg1)][idx].field_0):
                                    mem[_22412] = _22822
                                    mem[_22412 + 32] = stor10[address(arg1)][idx].field_256
                                    mem[_22412 + 64] = stor10[address(arg1)][idx].field_512
                                    mem[_22412 + 96] = stor10[address(arg1)][idx].field_768
                                    mem[s] = _22412
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                if 31 >= uint255(stor10[address(arg1)][idx].field_0) * 0.5:
                                    mem[_22822 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                    mem[_22412] = _22822
                                    mem[_22412 + 32] = stor10[address(arg1)][idx].field_256
                                    mem[_22412 + 64] = stor10[address(arg1)][idx].field_512
                                    mem[_22412 + 96] = stor10[address(arg1)][idx].field_768
                                    mem[s] = _22412
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                mem[_22822 + 32] = stor10[address(arg1)][idx].field_0
                                t = _22822 + 32
                                u = sha3(mem[0])
                                while _22822 + (uint255(stor10[address(arg1)][u].field_0) * 0.5) > t:
                                    mem[t + 32] = uint256(stor1[u])
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                mem[_22412] = _22822
                                mem[_22412 + 32] = stor10[address(arg1)][u].field_256
                                mem[_22412 + 64] = stor10[address(arg1)][u].field_512
                                mem[_22412 + 96] = stor10[address(arg1)][u].field_768
                                mem[t] = _22412
                                t = t + 32
                                u = u + 1
                                continue 
                            if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                                revert with 0, 34
                            if stor10[address(arg1)][idx].field_1:
                                if 31 >= stor10[address(arg1)][idx].field_1:
                                    mem[_22822 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                else:
                                    mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                    mem[_22822 + 32] = stor10[address(arg1)][idx].field_0
                                    t = _22822 + 32
                                    u = sha3(mem[0])
                                    while _22822 + stor10[address(arg1)][idx].field_1 > t:
                                        mem[t + 32] = uint256(stor1[u])
                                        t = t + 32
                                        u = u + 1
                                        continue 
                            mem[_22412] = _22822
                            mem[_22412 + 32] = stor10[address(arg1)][idx].field_256
                            mem[_22412 + 64] = stor10[address(arg1)][idx].field_512
                            mem[_22412 + 96] = stor10[address(arg1)][idx].field_768
                            mem[s] = _22412
                            s = s + 32
                            idx = idx + 1
                            continue 
                        mem[0] = address(arg3)
                        mem[32] = 10
                        _22410 = mem[64]
                        mem[64] = mem[64] + (32 * stor10[address(arg3)].field_0) + 32
                        mem[_22410] = stor10[address(arg3)].field_0
                        s = _22410 + 32
                        idx = 0
                        while idx < stor10[address(arg3)].field_0:
                            mem[0] = sha3(address(arg3), 10)
                            _29062 = mem[64]
                            mem[64] = mem[64] + 128
                            if stor10[address(arg3)][idx].field_0:
                                if not stor10[address(arg3)][idx].field_0 - (uint255(stor10[address(arg3)][idx].field_0) * 0.5 < 32):
                                    revert with 0, 34
                                _29132 = mem[64]
                                mem[64] = mem[64] + ceil32(uint255(stor10[address(arg3)][idx].field_0) * 0.5) + 32
                                mem[_29132] = uint255(stor10[address(arg3)][idx].field_0) * 0.5
                                if stor10[address(arg3)][idx].field_0:
                                    if not stor10[address(arg3)][idx].field_0 - (uint255(stor10[address(arg3)][idx].field_0) * 0.5 < 32):
                                        revert with 0, 34
                                    if Mask(256, -1, stor10[address(arg3)][idx].field_0):
                                        if 31 >= uint255(stor10[address(arg3)][idx].field_0) * 0.5:
                                            mem[_29132 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                        else:
                                            mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                            mem[_29132 + 32] = stor10[address(arg3)][idx].field_0
                                            t = _29132 + 32
                                            u = sha3(mem[0])
                                            while _29132 + (uint255(stor10[address(arg3)][idx].field_0) * 0.5) > t:
                                                mem[t + 32] = uint256(stor1[u])
                                                t = t + 32
                                                u = u + 1
                                                continue 
                                    mem[_29062] = _29132
                                    mem[_29062 + 32] = stor10[address(arg3)][idx].field_256
                                    mem[_29062 + 64] = stor10[address(arg3)][idx].field_512
                                    mem[_29062 + 96] = stor10[address(arg3)][idx].field_768
                                    mem[s] = _29062
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                if not stor10[address(arg3)][idx].field_0 - (stor10[address(arg3)][idx].field_1 < 32):
                                    revert with 0, 34
                                if not stor10[address(arg3)][idx].field_1:
                                    mem[_29062] = _29132
                                    mem[_29062 + 32] = stor10[address(arg3)][idx].field_256
                                    mem[_29062 + 64] = stor10[address(arg3)][idx].field_512
                                    mem[_29062 + 96] = stor10[address(arg3)][idx].field_768
                                    mem[s] = _29062
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                if 31 >= stor10[address(arg3)][idx].field_1:
                                    mem[_29132 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                    mem[_29062] = _29132
                                    mem[_29062 + 32] = stor10[address(arg3)][idx].field_256
                                    mem[_29062 + 64] = stor10[address(arg3)][idx].field_512
                                    mem[_29062 + 96] = stor10[address(arg3)][idx].field_768
                                    mem[s] = _29062
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                mem[_29132 + 32] = stor10[address(arg3)][idx].field_0
                                t = _29132 + 32
                                u = sha3(mem[0])
                                while _29132 + stor10[address(arg3)][u].field_1 > t:
                                    mem[t + 32] = uint256(stor1[u])
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                mem[_29062] = _29132
                                mem[_29062 + 32] = stor10[address(arg3)][u].field_256
                                mem[_29062 + 64] = stor10[address(arg3)][u].field_512
                                mem[_29062 + 96] = stor10[address(arg3)][u].field_768
                                mem[t] = _29062
                                t = t + 32
                                u = u + 1
                                continue 
                            if not stor10[address(arg3)][idx].field_0 - (stor10[address(arg3)][idx].field_1 < 32):
                                revert with 0, 34
                            _29152 = mem[64]
                            mem[64] = mem[64] + ceil32(stor10[address(arg3)][idx].field_1) + 32
                            mem[_29152] = stor10[address(arg3)][idx].field_1
                            if stor10[address(arg3)][idx].field_0:
                                if not stor10[address(arg3)][idx].field_0 - (uint255(stor10[address(arg3)][idx].field_0) * 0.5 < 32):
                                    revert with 0, 34
                                if not Mask(256, -1, stor10[address(arg3)][idx].field_0):
                                    mem[_29062] = _29152
                                    mem[_29062 + 32] = stor10[address(arg3)][idx].field_256
                                    mem[_29062 + 64] = stor10[address(arg3)][idx].field_512
                                    mem[_29062 + 96] = stor10[address(arg3)][idx].field_768
                                    mem[s] = _29062
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                if 31 >= uint255(stor10[address(arg3)][idx].field_0) * 0.5:
                                    mem[_29152 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                    mem[_29062] = _29152
                                    mem[_29062 + 32] = stor10[address(arg3)][idx].field_256
                                    mem[_29062 + 64] = stor10[address(arg3)][idx].field_512
                                    mem[_29062 + 96] = stor10[address(arg3)][idx].field_768
                                    mem[s] = _29062
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                mem[_29152 + 32] = stor10[address(arg3)][idx].field_0
                                t = _29152 + 32
                                u = sha3(mem[0])
                                while _29152 + (uint255(stor10[address(arg3)][u].field_0) * 0.5) > t:
                                    mem[t + 32] = uint256(stor1[u])
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                mem[_29062] = _29152
                                mem[_29062 + 32] = stor10[address(arg3)][u].field_256
                                mem[_29062 + 64] = stor10[address(arg3)][u].field_512
                                mem[_29062 + 96] = stor10[address(arg3)][u].field_768
                                mem[t] = _29062
                                t = t + 32
                                u = u + 1
                                continue 
                            if not stor10[address(arg3)][idx].field_0 - (stor10[address(arg3)][idx].field_1 < 32):
                                revert with 0, 34
                            if stor10[address(arg3)][idx].field_1:
                                if 31 >= stor10[address(arg3)][idx].field_1:
                                    mem[_29152 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                else:
                                    mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                    mem[_29152 + 32] = stor10[address(arg3)][idx].field_0
                                    t = _29152 + 32
                                    u = sha3(mem[0])
                                    while _29152 + stor10[address(arg3)][idx].field_1 > t:
                                        mem[t + 32] = uint256(stor1[u])
                                        t = t + 32
                                        u = u + 1
                                        continue 
                            mem[_29062] = _29152
                            mem[_29062 + 32] = stor10[address(arg3)][idx].field_256
                            mem[_29062 + 64] = stor10[address(arg3)][idx].field_512
                            mem[_29062 + 96] = stor10[address(arg3)][idx].field_768
                            mem[s] = _29062
                            s = s + 32
                            idx = idx + 1
                            continue 
                        if address(arg1) != address(arg3):
                            if mem[ceil32(ceil32(arg2.length)) + 225] <= 1:
                                if mem[_22410] > 0:
                                    if _referrals[address(arg1)] != address(arg3):
                                        _referrals[address(arg1)] = address(arg3)
                                        sub_989baf69[address(arg3)].field_0++
                                        sub_989baf69[address(arg3)][sub_989baf69[address(arg3)].field_0].field_0 = address(arg1)
                                    if tokenAddress != msg.sender:
                                        if gateKeeperAddress != msg.sender:
                                            if address(stor0.field_0) != msg.sender:
                                                revert with 0, 'NodeManagerV2: NOT AUTHORIZED'
                                    if stor10[stor11[address(arg1)]].field_0:
                                        if not -referralBonusPercent:
                                            sub_e27e434a[stor11[address(arg1)]][address(arg1)] = 0
                                            if sub_666755bb[stor11[address(arg1)]] > -1:
                                                revert with 0, 17
                                        else:
                                            if referralBonusPercent and nodePrice > -1 / referralBonusPercent:
                                                revert with 0, 17
                                            if not referralBonusPercent:
                                                revert with 0, 18
                                            if referralBonusPercent * nodePrice / referralBonusPercent != nodePrice:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            sub_e27e434a[stor11[address(arg1)]][address(arg1)] = referralBonusPercent * nodePrice / 100
                                            if sub_666755bb[stor11[address(arg1)]] > !(referralBonusPercent * nodePrice / 100):
                                                revert with 0, 17
                                            sub_666755bb[stor11[address(arg1)]] += referralBonusPercent * nodePrice / 100
                    else:
                        if address(stor0.field_0) != msg.sender:
                            revert with 0, 'NodeManagerV2: NOT AUTHORIZED'
                        mem[0] = address(arg1)
                        mem[64] = ceil32(ceil32(arg2.length)) + (32 * stor10[address(arg1)].field_0) + 257
                        mem[ceil32(ceil32(arg2.length)) + 225] = stor10[address(arg1)].field_0
                        s = ceil32(ceil32(arg2.length)) + 257
                        idx = 0
                        while idx < stor10[address(arg1)].field_0:
                            mem[0] = sha3(address(arg1), 10)
                            _22416 = mem[64]
                            mem[64] = mem[64] + 128
                            if stor10[address(arg1)][idx].field_0:
                                if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                                    revert with 0, 34
                                _22746 = mem[64]
                                mem[64] = mem[64] + ceil32(uint255(stor10[address(arg1)][idx].field_0) * 0.5) + 32
                                mem[_22746] = uint255(stor10[address(arg1)][idx].field_0) * 0.5
                                if stor10[address(arg1)][idx].field_0:
                                    if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                                        revert with 0, 34
                                    if Mask(256, -1, stor10[address(arg1)][idx].field_0):
                                        if 31 >= uint255(stor10[address(arg1)][idx].field_0) * 0.5:
                                            mem[_22746 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                        else:
                                            mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                            mem[_22746 + 32] = stor10[address(arg1)][idx].field_0
                                            t = _22746 + 32
                                            u = sha3(mem[0])
                                            while _22746 + (uint255(stor10[address(arg1)][idx].field_0) * 0.5) > t:
                                                mem[t + 32] = uint256(stor1[u])
                                                t = t + 32
                                                u = u + 1
                                                continue 
                                    mem[_22416] = _22746
                                    mem[_22416 + 32] = stor10[address(arg1)][idx].field_256
                                    mem[_22416 + 64] = stor10[address(arg1)][idx].field_512
                                    mem[_22416 + 96] = stor10[address(arg1)][idx].field_768
                                    mem[s] = _22416
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                                    revert with 0, 34
                                if not stor10[address(arg1)][idx].field_1:
                                    mem[_22416] = _22746
                                    mem[_22416 + 32] = stor10[address(arg1)][idx].field_256
                                    mem[_22416 + 64] = stor10[address(arg1)][idx].field_512
                                    mem[_22416 + 96] = stor10[address(arg1)][idx].field_768
                                    mem[s] = _22416
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                if 31 >= stor10[address(arg1)][idx].field_1:
                                    mem[_22746 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                    mem[_22416] = _22746
                                    mem[_22416 + 32] = stor10[address(arg1)][idx].field_256
                                    mem[_22416 + 64] = stor10[address(arg1)][idx].field_512
                                    mem[_22416 + 96] = stor10[address(arg1)][idx].field_768
                                    mem[s] = _22416
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                mem[_22746 + 32] = stor10[address(arg1)][idx].field_0
                                t = _22746 + 32
                                u = sha3(mem[0])
                                while _22746 + stor10[address(arg1)][u].field_1 > t:
                                    mem[t + 32] = uint256(stor1[u])
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                mem[_22416] = _22746
                                mem[_22416 + 32] = stor10[address(arg1)][u].field_256
                                mem[_22416 + 64] = stor10[address(arg1)][u].field_512
                                mem[_22416 + 96] = stor10[address(arg1)][u].field_768
                                mem[t] = _22416
                                t = t + 32
                                u = u + 1
                                continue 
                            if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                                revert with 0, 34
                            _22824 = mem[64]
                            mem[64] = mem[64] + ceil32(stor10[address(arg1)][idx].field_1) + 32
                            mem[_22824] = stor10[address(arg1)][idx].field_1
                            if stor10[address(arg1)][idx].field_0:
                                if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                                    revert with 0, 34
                                if not Mask(256, -1, stor10[address(arg1)][idx].field_0):
                                    mem[_22416] = _22824
                                    mem[_22416 + 32] = stor10[address(arg1)][idx].field_256
                                    mem[_22416 + 64] = stor10[address(arg1)][idx].field_512
                                    mem[_22416 + 96] = stor10[address(arg1)][idx].field_768
                                    mem[s] = _22416
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                if 31 >= uint255(stor10[address(arg1)][idx].field_0) * 0.5:
                                    mem[_22824 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                    mem[_22416] = _22824
                                    mem[_22416 + 32] = stor10[address(arg1)][idx].field_256
                                    mem[_22416 + 64] = stor10[address(arg1)][idx].field_512
                                    mem[_22416 + 96] = stor10[address(arg1)][idx].field_768
                                    mem[s] = _22416
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                mem[_22824 + 32] = stor10[address(arg1)][idx].field_0
                                t = _22824 + 32
                                u = sha3(mem[0])
                                while _22824 + (uint255(stor10[address(arg1)][u].field_0) * 0.5) > t:
                                    mem[t + 32] = uint256(stor1[u])
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                mem[_22416] = _22824
                                mem[_22416 + 32] = stor10[address(arg1)][u].field_256
                                mem[_22416 + 64] = stor10[address(arg1)][u].field_512
                                mem[_22416 + 96] = stor10[address(arg1)][u].field_768
                                mem[t] = _22416
                                t = t + 32
                                u = u + 1
                                continue 
                            if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                                revert with 0, 34
                            if stor10[address(arg1)][idx].field_1:
                                if 31 >= stor10[address(arg1)][idx].field_1:
                                    mem[_22824 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                else:
                                    mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                    mem[_22824 + 32] = stor10[address(arg1)][idx].field_0
                                    t = _22824 + 32
                                    u = sha3(mem[0])
                                    while _22824 + stor10[address(arg1)][idx].field_1 > t:
                                        mem[t + 32] = uint256(stor1[u])
                                        t = t + 32
                                        u = u + 1
                                        continue 
                            mem[_22416] = _22824
                            mem[_22416 + 32] = stor10[address(arg1)][idx].field_256
                            mem[_22416 + 64] = stor10[address(arg1)][idx].field_512
                            mem[_22416 + 96] = stor10[address(arg1)][idx].field_768
                            mem[s] = _22416
                            s = s + 32
                            idx = idx + 1
                            continue 
                        mem[0] = address(arg3)
                        mem[32] = 10
                        _22414 = mem[64]
                        mem[64] = mem[64] + (32 * stor10[address(arg3)].field_0) + 32
                        mem[_22414] = stor10[address(arg3)].field_0
                        s = _22414 + 32
                        idx = 0
                        while idx < stor10[address(arg3)].field_0:
                            mem[0] = sha3(address(arg3), 10)
                            _29064 = mem[64]
                            mem[64] = mem[64] + 128
                            if stor10[address(arg3)][idx].field_0:
                                if not stor10[address(arg3)][idx].field_0 - (uint255(stor10[address(arg3)][idx].field_0) * 0.5 < 32):
                                    revert with 0, 34
                                _29133 = mem[64]
                                mem[64] = mem[64] + ceil32(uint255(stor10[address(arg3)][idx].field_0) * 0.5) + 32
                                mem[_29133] = uint255(stor10[address(arg3)][idx].field_0) * 0.5
                                if stor10[address(arg3)][idx].field_0:
                                    if not stor10[address(arg3)][idx].field_0 - (uint255(stor10[address(arg3)][idx].field_0) * 0.5 < 32):
                                        revert with 0, 34
                                    if Mask(256, -1, stor10[address(arg3)][idx].field_0):
                                        if 31 >= uint255(stor10[address(arg3)][idx].field_0) * 0.5:
                                            mem[_29133 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                        else:
                                            mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                            mem[_29133 + 32] = stor10[address(arg3)][idx].field_0
                                            t = _29133 + 32
                                            u = sha3(mem[0])
                                            while _29133 + (uint255(stor10[address(arg3)][idx].field_0) * 0.5) > t:
                                                mem[t + 32] = uint256(stor1[u])
                                                t = t + 32
                                                u = u + 1
                                                continue 
                                    mem[_29064] = _29133
                                    mem[_29064 + 32] = stor10[address(arg3)][idx].field_256
                                    mem[_29064 + 64] = stor10[address(arg3)][idx].field_512
                                    mem[_29064 + 96] = stor10[address(arg3)][idx].field_768
                                    mem[s] = _29064
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                if not stor10[address(arg3)][idx].field_0 - (stor10[address(arg3)][idx].field_1 < 32):
                                    revert with 0, 34
                                if not stor10[address(arg3)][idx].field_1:
                                    mem[_29064] = _29133
                                    mem[_29064 + 32] = stor10[address(arg3)][idx].field_256
                                    mem[_29064 + 64] = stor10[address(arg3)][idx].field_512
                                    mem[_29064 + 96] = stor10[address(arg3)][idx].field_768
                                    mem[s] = _29064
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                if 31 >= stor10[address(arg3)][idx].field_1:
                                    mem[_29133 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                    mem[_29064] = _29133
                                    mem[_29064 + 32] = stor10[address(arg3)][idx].field_256
                                    mem[_29064 + 64] = stor10[address(arg3)][idx].field_512
                                    mem[_29064 + 96] = stor10[address(arg3)][idx].field_768
                                    mem[s] = _29064
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                mem[_29133 + 32] = stor10[address(arg3)][idx].field_0
                                t = _29133 + 32
                                u = sha3(mem[0])
                                while _29133 + stor10[address(arg3)][u].field_1 > t:
                                    mem[t + 32] = uint256(stor1[u])
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                mem[_29064] = _29133
                                mem[_29064 + 32] = stor10[address(arg3)][u].field_256
                                mem[_29064 + 64] = stor10[address(arg3)][u].field_512
                                mem[_29064 + 96] = stor10[address(arg3)][u].field_768
                                mem[t] = _29064
                                t = t + 32
                                u = u + 1
                                continue 
                            if not stor10[address(arg3)][idx].field_0 - (stor10[address(arg3)][idx].field_1 < 32):
                                revert with 0, 34
                            _29154 = mem[64]
                            mem[64] = mem[64] + ceil32(stor10[address(arg3)][idx].field_1) + 32
                            mem[_29154] = stor10[address(arg3)][idx].field_1
                            if stor10[address(arg3)][idx].field_0:
                                if not stor10[address(arg3)][idx].field_0 - (uint255(stor10[address(arg3)][idx].field_0) * 0.5 < 32):
                                    revert with 0, 34
                                if not Mask(256, -1, stor10[address(arg3)][idx].field_0):
                                    mem[_29064] = _29154
                                    mem[_29064 + 32] = stor10[address(arg3)][idx].field_256
                                    mem[_29064 + 64] = stor10[address(arg3)][idx].field_512
                                    mem[_29064 + 96] = stor10[address(arg3)][idx].field_768
                                    mem[s] = _29064
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                if 31 >= uint255(stor10[address(arg3)][idx].field_0) * 0.5:
                                    mem[_29154 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                    mem[_29064] = _29154
                                    mem[_29064 + 32] = stor10[address(arg3)][idx].field_256
                                    mem[_29064 + 64] = stor10[address(arg3)][idx].field_512
                                    mem[_29064 + 96] = stor10[address(arg3)][idx].field_768
                                    mem[s] = _29064
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                mem[_29154 + 32] = stor10[address(arg3)][idx].field_0
                                t = _29154 + 32
                                u = sha3(mem[0])
                                while _29154 + (uint255(stor10[address(arg3)][u].field_0) * 0.5) > t:
                                    mem[t + 32] = uint256(stor1[u])
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                mem[_29064] = _29154
                                mem[_29064 + 32] = stor10[address(arg3)][u].field_256
                                mem[_29064 + 64] = stor10[address(arg3)][u].field_512
                                mem[_29064 + 96] = stor10[address(arg3)][u].field_768
                                mem[t] = _29064
                                t = t + 32
                                u = u + 1
                                continue 
                            if not stor10[address(arg3)][idx].field_0 - (stor10[address(arg3)][idx].field_1 < 32):
                                revert with 0, 34
                            if stor10[address(arg3)][idx].field_1:
                                if 31 >= stor10[address(arg3)][idx].field_1:
                                    mem[_29154 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                else:
                                    mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                    mem[_29154 + 32] = stor10[address(arg3)][idx].field_0
                                    t = _29154 + 32
                                    u = sha3(mem[0])
                                    while _29154 + stor10[address(arg3)][idx].field_1 > t:
                                        mem[t + 32] = uint256(stor1[u])
                                        t = t + 32
                                        u = u + 1
                                        continue 
                            mem[_29064] = _29154
                            mem[_29064 + 32] = stor10[address(arg3)][idx].field_256
                            mem[_29064 + 64] = stor10[address(arg3)][idx].field_512
                            mem[_29064 + 96] = stor10[address(arg3)][idx].field_768
                            mem[s] = _29064
                            s = s + 32
                            idx = idx + 1
                            continue 
                        if address(arg1) != address(arg3):
                            if mem[ceil32(ceil32(arg2.length)) + 225] <= 1:
                                if mem[_22414] > 0:
                                    if _referrals[address(arg1)] != address(arg3):
                                        _referrals[address(arg1)] = address(arg3)
                                        sub_989baf69[address(arg3)].field_0++
                                        sub_989baf69[address(arg3)][sub_989baf69[address(arg3)].field_0].field_0 = address(arg1)
                                    if tokenAddress != msg.sender:
                                        if gateKeeperAddress != msg.sender:
                                            if address(stor0.field_0) != msg.sender:
                                                revert with 0, 'NodeManagerV2: NOT AUTHORIZED'
                                    if stor10[stor11[address(arg1)]].field_0:
                                        if not -referralBonusPercent:
                                            sub_e27e434a[stor11[address(arg1)]][address(arg1)] = 0
                                            if sub_666755bb[stor11[address(arg1)]] > -1:
                                                revert with 0, 17
                                        else:
                                            if referralBonusPercent and nodePrice > -1 / referralBonusPercent:
                                                revert with 0, 17
                                            if not referralBonusPercent:
                                                revert with 0, 18
                                            if referralBonusPercent * nodePrice / referralBonusPercent != nodePrice:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            sub_e27e434a[stor11[address(arg1)]][address(arg1)] = referralBonusPercent * nodePrice / 100
                                            if sub_666755bb[stor11[address(arg1)]] > !(referralBonusPercent * nodePrice / 100):
                                                revert with 0, 17
                                            sub_666755bb[stor11[address(arg1)]] += referralBonusPercent * nodePrice / 100
            else:
                stor10[address(arg1)][stor10[address(arg1)].field_0].field_0 = 0
                idx = 0
                while (uint255(stor10[address(arg1)][stor10[address(arg1)].field_0].field_0) * 0.5) + 31 / 32 > idx:
                    stor10[address(arg1)][(4 * stor10[address(arg1)].field_0) + idx].field_0 = 0
                    idx = idx + 1
                    continue 
                stor10[address(arg1)][stor10[address(arg1)].field_0].field_256 = block.timestamp
                stor10[address(arg1)][stor10[address(arg1)].field_0].field_512 = block.timestamp
                stor10[address(arg1)][stor10[address(arg1)].field_0].field_768 = 0
                mem[ceil32(ceil32(arg2.length)) + 229] = 6
                mem[ceil32(ceil32(arg2.length)) + 261] = address(arg1)
                mem[ceil32(ceil32(arg2.length)) + 293] = stor10[address(arg1)].field_0
                require ext_code.size(0x4b7a346b17572634bdbd85b98abae32c5fa837bb)
                delegate 0x4b7a346b17572634bdbd85b98abae32c5fa837bb.0xbc2b405c with:
                     gas gas_remaining wei
                    args 6, address(arg1), stor10[address(arg1)].field_0
                if not delegate.return_code:
                    revert with ext_call.return_data[0 len return_data.size]
                if not totalNodesCreated + 1:
                    revert with 0, 17
                totalNodesCreated++
                if msg.sender == tokenAddress:
                    mem[0] = address(arg1)
                    mem[64] = ceil32(ceil32(arg2.length)) + (32 * stor10[address(arg1)].field_0) + 257
                    mem[ceil32(ceil32(arg2.length)) + 225] = stor10[address(arg1)].field_0
                    s = ceil32(ceil32(arg2.length)) + 257
                    idx = 0
                    while idx < stor10[address(arg1)].field_0:
                        mem[0] = sha3(address(arg1), 10)
                        _15142 = mem[64]
                        mem[64] = mem[64] + 128
                        if stor10[address(arg1)][idx].field_0:
                            if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                                revert with 0, 34
                            _15535 = mem[64]
                            mem[64] = mem[64] + ceil32(uint255(stor10[address(arg1)][idx].field_0) * 0.5) + 32
                            mem[_15535] = uint255(stor10[address(arg1)][idx].field_0) * 0.5
                            if stor10[address(arg1)][idx].field_0:
                                if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                                    revert with 0, 34
                                if Mask(256, -1, stor10[address(arg1)][idx].field_0):
                                    if 31 >= uint255(stor10[address(arg1)][idx].field_0) * 0.5:
                                        mem[_15535 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                    else:
                                        mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                        mem[_15535 + 32] = stor10[address(arg1)][idx].field_0
                                        t = _15535 + 32
                                        u = sha3(mem[0])
                                        while _15535 + (uint255(stor10[address(arg1)][idx].field_0) * 0.5) > t:
                                            mem[t + 32] = uint256(stor1[u])
                                            t = t + 32
                                            u = u + 1
                                            continue 
                                mem[_15142] = _15535
                                mem[_15142 + 32] = stor10[address(arg1)][idx].field_256
                                mem[_15142 + 64] = stor10[address(arg1)][idx].field_512
                                mem[_15142 + 96] = stor10[address(arg1)][idx].field_768
                                mem[s] = _15142
                                s = s + 32
                                idx = idx + 1
                                continue 
                            if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                                revert with 0, 34
                            if not stor10[address(arg1)][idx].field_1:
                                mem[_15142] = _15535
                                mem[_15142 + 32] = stor10[address(arg1)][idx].field_256
                                mem[_15142 + 64] = stor10[address(arg1)][idx].field_512
                                mem[_15142 + 96] = stor10[address(arg1)][idx].field_768
                                mem[s] = _15142
                                s = s + 32
                                idx = idx + 1
                                continue 
                            if 31 >= stor10[address(arg1)][idx].field_1:
                                mem[_15535 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                mem[_15142] = _15535
                                mem[_15142 + 32] = stor10[address(arg1)][idx].field_256
                                mem[_15142 + 64] = stor10[address(arg1)][idx].field_512
                                mem[_15142 + 96] = stor10[address(arg1)][idx].field_768
                                mem[s] = _15142
                                s = s + 32
                                idx = idx + 1
                                continue 
                            mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                            mem[_15535 + 32] = stor10[address(arg1)][idx].field_0
                            t = _15535 + 32
                            u = sha3(mem[0])
                            while _15535 + stor10[address(arg1)][u].field_1 > t:
                                mem[t + 32] = uint256(stor1[u])
                                t = t + 32
                                u = u + 1
                                continue 
                            mem[_15142] = _15535
                            mem[_15142 + 32] = stor10[address(arg1)][u].field_256
                            mem[_15142 + 64] = stor10[address(arg1)][u].field_512
                            mem[_15142 + 96] = stor10[address(arg1)][u].field_768
                            mem[t] = _15142
                            t = t + 32
                            u = u + 1
                            continue 
                        if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                            revert with 0, 34
                        _15596 = mem[64]
                        mem[64] = mem[64] + ceil32(stor10[address(arg1)][idx].field_1) + 32
                        mem[_15596] = stor10[address(arg1)][idx].field_1
                        if stor10[address(arg1)][idx].field_0:
                            if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                                revert with 0, 34
                            if not Mask(256, -1, stor10[address(arg1)][idx].field_0):
                                mem[_15142] = _15596
                                mem[_15142 + 32] = stor10[address(arg1)][idx].field_256
                                mem[_15142 + 64] = stor10[address(arg1)][idx].field_512
                                mem[_15142 + 96] = stor10[address(arg1)][idx].field_768
                                mem[s] = _15142
                                s = s + 32
                                idx = idx + 1
                                continue 
                            if 31 >= uint255(stor10[address(arg1)][idx].field_0) * 0.5:
                                mem[_15596 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                mem[_15142] = _15596
                                mem[_15142 + 32] = stor10[address(arg1)][idx].field_256
                                mem[_15142 + 64] = stor10[address(arg1)][idx].field_512
                                mem[_15142 + 96] = stor10[address(arg1)][idx].field_768
                                mem[s] = _15142
                                s = s + 32
                                idx = idx + 1
                                continue 
                            mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                            mem[_15596 + 32] = stor10[address(arg1)][idx].field_0
                            t = _15596 + 32
                            u = sha3(mem[0])
                            while _15596 + (uint255(stor10[address(arg1)][u].field_0) * 0.5) > t:
                                mem[t + 32] = uint256(stor1[u])
                                t = t + 32
                                u = u + 1
                                continue 
                            mem[_15142] = _15596
                            mem[_15142 + 32] = stor10[address(arg1)][u].field_256
                            mem[_15142 + 64] = stor10[address(arg1)][u].field_512
                            mem[_15142 + 96] = stor10[address(arg1)][u].field_768
                            mem[t] = _15142
                            t = t + 32
                            u = u + 1
                            continue 
                        if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                            revert with 0, 34
                        if stor10[address(arg1)][idx].field_1:
                            if 31 >= stor10[address(arg1)][idx].field_1:
                                mem[_15596 + 32] = 256 * stor10[address(arg1)][idx].field_8
                            else:
                                mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                mem[_15596 + 32] = stor10[address(arg1)][idx].field_0
                                t = _15596 + 32
                                u = sha3(mem[0])
                                while _15596 + stor10[address(arg1)][idx].field_1 > t:
                                    mem[t + 32] = uint256(stor1[u])
                                    t = t + 32
                                    u = u + 1
                                    continue 
                        mem[_15142] = _15596
                        mem[_15142 + 32] = stor10[address(arg1)][idx].field_256
                        mem[_15142 + 64] = stor10[address(arg1)][idx].field_512
                        mem[_15142 + 96] = stor10[address(arg1)][idx].field_768
                        mem[s] = _15142
                        s = s + 32
                        idx = idx + 1
                        continue 
                    mem[0] = address(arg3)
                    mem[32] = 10
                    _15140 = mem[64]
                    mem[64] = mem[64] + (32 * stor10[address(arg3)].field_0) + 32
                    mem[_15140] = stor10[address(arg3)].field_0
                    s = _15140 + 32
                    idx = 0
                    while idx < stor10[address(arg3)].field_0:
                        mem[0] = sha3(address(arg3), 10)
                        _22424 = mem[64]
                        mem[64] = mem[64] + 128
                        if stor10[address(arg3)][idx].field_0:
                            if not stor10[address(arg3)][idx].field_0 - (uint255(stor10[address(arg3)][idx].field_0) * 0.5 < 32):
                                revert with 0, 34
                            _22750 = mem[64]
                            mem[64] = mem[64] + ceil32(uint255(stor10[address(arg3)][idx].field_0) * 0.5) + 32
                            mem[_22750] = uint255(stor10[address(arg3)][idx].field_0) * 0.5
                            if stor10[address(arg3)][idx].field_0:
                                if not stor10[address(arg3)][idx].field_0 - (uint255(stor10[address(arg3)][idx].field_0) * 0.5 < 32):
                                    revert with 0, 34
                                if Mask(256, -1, stor10[address(arg3)][idx].field_0):
                                    if 31 >= uint255(stor10[address(arg3)][idx].field_0) * 0.5:
                                        mem[_22750 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                    else:
                                        mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                        mem[_22750 + 32] = stor10[address(arg3)][idx].field_0
                                        t = _22750 + 32
                                        u = sha3(mem[0])
                                        while _22750 + (uint255(stor10[address(arg3)][idx].field_0) * 0.5) > t:
                                            mem[t + 32] = uint256(stor1[u])
                                            t = t + 32
                                            u = u + 1
                                            continue 
                                mem[_22424] = _22750
                                mem[_22424 + 32] = stor10[address(arg3)][idx].field_256
                                mem[_22424 + 64] = stor10[address(arg3)][idx].field_512
                                mem[_22424 + 96] = stor10[address(arg3)][idx].field_768
                                mem[s] = _22424
                                s = s + 32
                                idx = idx + 1
                                continue 
                            if not stor10[address(arg3)][idx].field_0 - (stor10[address(arg3)][idx].field_1 < 32):
                                revert with 0, 34
                            if not stor10[address(arg3)][idx].field_1:
                                mem[_22424] = _22750
                                mem[_22424 + 32] = stor10[address(arg3)][idx].field_256
                                mem[_22424 + 64] = stor10[address(arg3)][idx].field_512
                                mem[_22424 + 96] = stor10[address(arg3)][idx].field_768
                                mem[s] = _22424
                                s = s + 32
                                idx = idx + 1
                                continue 
                            if 31 >= stor10[address(arg3)][idx].field_1:
                                mem[_22750 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                mem[_22424] = _22750
                                mem[_22424 + 32] = stor10[address(arg3)][idx].field_256
                                mem[_22424 + 64] = stor10[address(arg3)][idx].field_512
                                mem[_22424 + 96] = stor10[address(arg3)][idx].field_768
                                mem[s] = _22424
                                s = s + 32
                                idx = idx + 1
                                continue 
                            mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                            mem[_22750 + 32] = stor10[address(arg3)][idx].field_0
                            t = _22750 + 32
                            u = sha3(mem[0])
                            while _22750 + stor10[address(arg3)][u].field_1 > t:
                                mem[t + 32] = uint256(stor1[u])
                                t = t + 32
                                u = u + 1
                                continue 
                            mem[_22424] = _22750
                            mem[_22424 + 32] = stor10[address(arg3)][u].field_256
                            mem[_22424 + 64] = stor10[address(arg3)][u].field_512
                            mem[_22424 + 96] = stor10[address(arg3)][u].field_768
                            mem[t] = _22424
                            t = t + 32
                            u = u + 1
                            continue 
                        if not stor10[address(arg3)][idx].field_0 - (stor10[address(arg3)][idx].field_1 < 32):
                            revert with 0, 34
                        _22832 = mem[64]
                        mem[64] = mem[64] + ceil32(stor10[address(arg3)][idx].field_1) + 32
                        mem[_22832] = stor10[address(arg3)][idx].field_1
                        if stor10[address(arg3)][idx].field_0:
                            if not stor10[address(arg3)][idx].field_0 - (uint255(stor10[address(arg3)][idx].field_0) * 0.5 < 32):
                                revert with 0, 34
                            if not Mask(256, -1, stor10[address(arg3)][idx].field_0):
                                mem[_22424] = _22832
                                mem[_22424 + 32] = stor10[address(arg3)][idx].field_256
                                mem[_22424 + 64] = stor10[address(arg3)][idx].field_512
                                mem[_22424 + 96] = stor10[address(arg3)][idx].field_768
                                mem[s] = _22424
                                s = s + 32
                                idx = idx + 1
                                continue 
                            if 31 >= uint255(stor10[address(arg3)][idx].field_0) * 0.5:
                                mem[_22832 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                mem[_22424] = _22832
                                mem[_22424 + 32] = stor10[address(arg3)][idx].field_256
                                mem[_22424 + 64] = stor10[address(arg3)][idx].field_512
                                mem[_22424 + 96] = stor10[address(arg3)][idx].field_768
                                mem[s] = _22424
                                s = s + 32
                                idx = idx + 1
                                continue 
                            mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                            mem[_22832 + 32] = stor10[address(arg3)][idx].field_0
                            t = _22832 + 32
                            u = sha3(mem[0])
                            while _22832 + (uint255(stor10[address(arg3)][u].field_0) * 0.5) > t:
                                mem[t + 32] = uint256(stor1[u])
                                t = t + 32
                                u = u + 1
                                continue 
                            mem[_22424] = _22832
                            mem[_22424 + 32] = stor10[address(arg3)][u].field_256
                            mem[_22424 + 64] = stor10[address(arg3)][u].field_512
                            mem[_22424 + 96] = stor10[address(arg3)][u].field_768
                            mem[t] = _22424
                            t = t + 32
                            u = u + 1
                            continue 
                        if not stor10[address(arg3)][idx].field_0 - (stor10[address(arg3)][idx].field_1 < 32):
                            revert with 0, 34
                        if stor10[address(arg3)][idx].field_1:
                            if 31 >= stor10[address(arg3)][idx].field_1:
                                mem[_22832 + 32] = 256 * stor10[address(arg3)][idx].field_8
                            else:
                                mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                mem[_22832 + 32] = stor10[address(arg3)][idx].field_0
                                t = _22832 + 32
                                u = sha3(mem[0])
                                while _22832 + stor10[address(arg3)][idx].field_1 > t:
                                    mem[t + 32] = uint256(stor1[u])
                                    t = t + 32
                                    u = u + 1
                                    continue 
                        mem[_22424] = _22832
                        mem[_22424 + 32] = stor10[address(arg3)][idx].field_256
                        mem[_22424 + 64] = stor10[address(arg3)][idx].field_512
                        mem[_22424 + 96] = stor10[address(arg3)][idx].field_768
                        mem[s] = _22424
                        s = s + 32
                        idx = idx + 1
                        continue 
                    if address(arg1) != address(arg3):
                        if mem[ceil32(ceil32(arg2.length)) + 225] <= 1:
                            if mem[_15140] > 0:
                                if _referrals[address(arg1)] != address(arg3):
                                    _referrals[address(arg1)] = address(arg3)
                                    sub_989baf69[address(arg3)].field_0++
                                    sub_989baf69[address(arg3)][sub_989baf69[address(arg3)].field_0].field_0 = address(arg1)
                                if tokenAddress != msg.sender:
                                    if gateKeeperAddress != msg.sender:
                                        if address(stor0.field_0) != msg.sender:
                                            revert with 0, 'NodeManagerV2: NOT AUTHORIZED'
                                if stor10[stor11[address(arg1)]].field_0:
                                    if not -referralBonusPercent:
                                        sub_e27e434a[stor11[address(arg1)]][address(arg1)] = 0
                                        if sub_666755bb[stor11[address(arg1)]] > -1:
                                            revert with 0, 17
                                    else:
                                        if referralBonusPercent and nodePrice > -1 / referralBonusPercent:
                                            revert with 0, 17
                                        if not referralBonusPercent:
                                            revert with 0, 18
                                        if referralBonusPercent * nodePrice / referralBonusPercent != nodePrice:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        sub_e27e434a[stor11[address(arg1)]][address(arg1)] = referralBonusPercent * nodePrice / 100
                                        if sub_666755bb[stor11[address(arg1)]] > !(referralBonusPercent * nodePrice / 100):
                                            revert with 0, 17
                                        sub_666755bb[stor11[address(arg1)]] += referralBonusPercent * nodePrice / 100
                else:
                    if msg.sender == gateKeeperAddress:
                        mem[0] = address(arg1)
                        mem[64] = ceil32(ceil32(arg2.length)) + (32 * stor10[address(arg1)].field_0) + 257
                        mem[ceil32(ceil32(arg2.length)) + 225] = stor10[address(arg1)].field_0
                        s = ceil32(ceil32(arg2.length)) + 257
                        idx = 0
                        while idx < stor10[address(arg1)].field_0:
                            mem[0] = sha3(address(arg1), 10)
                            _15146 = mem[64]
                            mem[64] = mem[64] + 128
                            if stor10[address(arg1)][idx].field_0:
                                if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                                    revert with 0, 34
                                _15536 = mem[64]
                                mem[64] = mem[64] + ceil32(uint255(stor10[address(arg1)][idx].field_0) * 0.5) + 32
                                mem[_15536] = uint255(stor10[address(arg1)][idx].field_0) * 0.5
                                if stor10[address(arg1)][idx].field_0:
                                    if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                                        revert with 0, 34
                                    if Mask(256, -1, stor10[address(arg1)][idx].field_0):
                                        if 31 >= uint255(stor10[address(arg1)][idx].field_0) * 0.5:
                                            mem[_15536 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                        else:
                                            mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                            mem[_15536 + 32] = stor10[address(arg1)][idx].field_0
                                            t = _15536 + 32
                                            u = sha3(mem[0])
                                            while _15536 + (uint255(stor10[address(arg1)][idx].field_0) * 0.5) > t:
                                                mem[t + 32] = uint256(stor1[u])
                                                t = t + 32
                                                u = u + 1
                                                continue 
                                    mem[_15146] = _15536
                                    mem[_15146 + 32] = stor10[address(arg1)][idx].field_256
                                    mem[_15146 + 64] = stor10[address(arg1)][idx].field_512
                                    mem[_15146 + 96] = stor10[address(arg1)][idx].field_768
                                    mem[s] = _15146
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                                    revert with 0, 34
                                if not stor10[address(arg1)][idx].field_1:
                                    mem[_15146] = _15536
                                    mem[_15146 + 32] = stor10[address(arg1)][idx].field_256
                                    mem[_15146 + 64] = stor10[address(arg1)][idx].field_512
                                    mem[_15146 + 96] = stor10[address(arg1)][idx].field_768
                                    mem[s] = _15146
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                if 31 >= stor10[address(arg1)][idx].field_1:
                                    mem[_15536 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                    mem[_15146] = _15536
                                    mem[_15146 + 32] = stor10[address(arg1)][idx].field_256
                                    mem[_15146 + 64] = stor10[address(arg1)][idx].field_512
                                    mem[_15146 + 96] = stor10[address(arg1)][idx].field_768
                                    mem[s] = _15146
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                mem[_15536 + 32] = stor10[address(arg1)][idx].field_0
                                t = _15536 + 32
                                u = sha3(mem[0])
                                while _15536 + stor10[address(arg1)][u].field_1 > t:
                                    mem[t + 32] = uint256(stor1[u])
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                mem[_15146] = _15536
                                mem[_15146 + 32] = stor10[address(arg1)][u].field_256
                                mem[_15146 + 64] = stor10[address(arg1)][u].field_512
                                mem[_15146 + 96] = stor10[address(arg1)][u].field_768
                                mem[t] = _15146
                                t = t + 32
                                u = u + 1
                                continue 
                            if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                                revert with 0, 34
                            _15598 = mem[64]
                            mem[64] = mem[64] + ceil32(stor10[address(arg1)][idx].field_1) + 32
                            mem[_15598] = stor10[address(arg1)][idx].field_1
                            if stor10[address(arg1)][idx].field_0:
                                if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                                    revert with 0, 34
                                if not Mask(256, -1, stor10[address(arg1)][idx].field_0):
                                    mem[_15146] = _15598
                                    mem[_15146 + 32] = stor10[address(arg1)][idx].field_256
                                    mem[_15146 + 64] = stor10[address(arg1)][idx].field_512
                                    mem[_15146 + 96] = stor10[address(arg1)][idx].field_768
                                    mem[s] = _15146
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                if 31 >= uint255(stor10[address(arg1)][idx].field_0) * 0.5:
                                    mem[_15598 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                    mem[_15146] = _15598
                                    mem[_15146 + 32] = stor10[address(arg1)][idx].field_256
                                    mem[_15146 + 64] = stor10[address(arg1)][idx].field_512
                                    mem[_15146 + 96] = stor10[address(arg1)][idx].field_768
                                    mem[s] = _15146
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                mem[_15598 + 32] = stor10[address(arg1)][idx].field_0
                                t = _15598 + 32
                                u = sha3(mem[0])
                                while _15598 + (uint255(stor10[address(arg1)][u].field_0) * 0.5) > t:
                                    mem[t + 32] = uint256(stor1[u])
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                mem[_15146] = _15598
                                mem[_15146 + 32] = stor10[address(arg1)][u].field_256
                                mem[_15146 + 64] = stor10[address(arg1)][u].field_512
                                mem[_15146 + 96] = stor10[address(arg1)][u].field_768
                                mem[t] = _15146
                                t = t + 32
                                u = u + 1
                                continue 
                            if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                                revert with 0, 34
                            if stor10[address(arg1)][idx].field_1:
                                if 31 >= stor10[address(arg1)][idx].field_1:
                                    mem[_15598 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                else:
                                    mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                    mem[_15598 + 32] = stor10[address(arg1)][idx].field_0
                                    t = _15598 + 32
                                    u = sha3(mem[0])
                                    while _15598 + stor10[address(arg1)][idx].field_1 > t:
                                        mem[t + 32] = uint256(stor1[u])
                                        t = t + 32
                                        u = u + 1
                                        continue 
                            mem[_15146] = _15598
                            mem[_15146 + 32] = stor10[address(arg1)][idx].field_256
                            mem[_15146 + 64] = stor10[address(arg1)][idx].field_512
                            mem[_15146 + 96] = stor10[address(arg1)][idx].field_768
                            mem[s] = _15146
                            s = s + 32
                            idx = idx + 1
                            continue 
                        mem[0] = address(arg3)
                        mem[32] = 10
                        _15144 = mem[64]
                        mem[64] = mem[64] + (32 * stor10[address(arg3)].field_0) + 32
                        mem[_15144] = stor10[address(arg3)].field_0
                        s = _15144 + 32
                        idx = 0
                        while idx < stor10[address(arg3)].field_0:
                            mem[0] = sha3(address(arg3), 10)
                            _22426 = mem[64]
                            mem[64] = mem[64] + 128
                            if stor10[address(arg3)][idx].field_0:
                                if not stor10[address(arg3)][idx].field_0 - (uint255(stor10[address(arg3)][idx].field_0) * 0.5 < 32):
                                    revert with 0, 34
                                _22751 = mem[64]
                                mem[64] = mem[64] + ceil32(uint255(stor10[address(arg3)][idx].field_0) * 0.5) + 32
                                mem[_22751] = uint255(stor10[address(arg3)][idx].field_0) * 0.5
                                if stor10[address(arg3)][idx].field_0:
                                    if not stor10[address(arg3)][idx].field_0 - (uint255(stor10[address(arg3)][idx].field_0) * 0.5 < 32):
                                        revert with 0, 34
                                    if Mask(256, -1, stor10[address(arg3)][idx].field_0):
                                        if 31 >= uint255(stor10[address(arg3)][idx].field_0) * 0.5:
                                            mem[_22751 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                        else:
                                            mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                            mem[_22751 + 32] = stor10[address(arg3)][idx].field_0
                                            t = _22751 + 32
                                            u = sha3(mem[0])
                                            while _22751 + (uint255(stor10[address(arg3)][idx].field_0) * 0.5) > t:
                                                mem[t + 32] = uint256(stor1[u])
                                                t = t + 32
                                                u = u + 1
                                                continue 
                                    mem[_22426] = _22751
                                    mem[_22426 + 32] = stor10[address(arg3)][idx].field_256
                                    mem[_22426 + 64] = stor10[address(arg3)][idx].field_512
                                    mem[_22426 + 96] = stor10[address(arg3)][idx].field_768
                                    mem[s] = _22426
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                if not stor10[address(arg3)][idx].field_0 - (stor10[address(arg3)][idx].field_1 < 32):
                                    revert with 0, 34
                                if not stor10[address(arg3)][idx].field_1:
                                    mem[_22426] = _22751
                                    mem[_22426 + 32] = stor10[address(arg3)][idx].field_256
                                    mem[_22426 + 64] = stor10[address(arg3)][idx].field_512
                                    mem[_22426 + 96] = stor10[address(arg3)][idx].field_768
                                    mem[s] = _22426
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                if 31 >= stor10[address(arg3)][idx].field_1:
                                    mem[_22751 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                    mem[_22426] = _22751
                                    mem[_22426 + 32] = stor10[address(arg3)][idx].field_256
                                    mem[_22426 + 64] = stor10[address(arg3)][idx].field_512
                                    mem[_22426 + 96] = stor10[address(arg3)][idx].field_768
                                    mem[s] = _22426
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                mem[_22751 + 32] = stor10[address(arg3)][idx].field_0
                                t = _22751 + 32
                                u = sha3(mem[0])
                                while _22751 + stor10[address(arg3)][u].field_1 > t:
                                    mem[t + 32] = uint256(stor1[u])
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                mem[_22426] = _22751
                                mem[_22426 + 32] = stor10[address(arg3)][u].field_256
                                mem[_22426 + 64] = stor10[address(arg3)][u].field_512
                                mem[_22426 + 96] = stor10[address(arg3)][u].field_768
                                mem[t] = _22426
                                t = t + 32
                                u = u + 1
                                continue 
                            if not stor10[address(arg3)][idx].field_0 - (stor10[address(arg3)][idx].field_1 < 32):
                                revert with 0, 34
                            _22834 = mem[64]
                            mem[64] = mem[64] + ceil32(stor10[address(arg3)][idx].field_1) + 32
                            mem[_22834] = stor10[address(arg3)][idx].field_1
                            if stor10[address(arg3)][idx].field_0:
                                if not stor10[address(arg3)][idx].field_0 - (uint255(stor10[address(arg3)][idx].field_0) * 0.5 < 32):
                                    revert with 0, 34
                                if not Mask(256, -1, stor10[address(arg3)][idx].field_0):
                                    mem[_22426] = _22834
                                    mem[_22426 + 32] = stor10[address(arg3)][idx].field_256
                                    mem[_22426 + 64] = stor10[address(arg3)][idx].field_512
                                    mem[_22426 + 96] = stor10[address(arg3)][idx].field_768
                                    mem[s] = _22426
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                if 31 >= uint255(stor10[address(arg3)][idx].field_0) * 0.5:
                                    mem[_22834 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                    mem[_22426] = _22834
                                    mem[_22426 + 32] = stor10[address(arg3)][idx].field_256
                                    mem[_22426 + 64] = stor10[address(arg3)][idx].field_512
                                    mem[_22426 + 96] = stor10[address(arg3)][idx].field_768
                                    mem[s] = _22426
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                mem[_22834 + 32] = stor10[address(arg3)][idx].field_0
                                t = _22834 + 32
                                u = sha3(mem[0])
                                while _22834 + (uint255(stor10[address(arg3)][u].field_0) * 0.5) > t:
                                    mem[t + 32] = uint256(stor1[u])
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                mem[_22426] = _22834
                                mem[_22426 + 32] = stor10[address(arg3)][u].field_256
                                mem[_22426 + 64] = stor10[address(arg3)][u].field_512
                                mem[_22426 + 96] = stor10[address(arg3)][u].field_768
                                mem[t] = _22426
                                t = t + 32
                                u = u + 1
                                continue 
                            if not stor10[address(arg3)][idx].field_0 - (stor10[address(arg3)][idx].field_1 < 32):
                                revert with 0, 34
                            if stor10[address(arg3)][idx].field_1:
                                if 31 >= stor10[address(arg3)][idx].field_1:
                                    mem[_22834 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                else:
                                    mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                    mem[_22834 + 32] = stor10[address(arg3)][idx].field_0
                                    t = _22834 + 32
                                    u = sha3(mem[0])
                                    while _22834 + stor10[address(arg3)][idx].field_1 > t:
                                        mem[t + 32] = uint256(stor1[u])
                                        t = t + 32
                                        u = u + 1
                                        continue 
                            mem[_22426] = _22834
                            mem[_22426 + 32] = stor10[address(arg3)][idx].field_256
                            mem[_22426 + 64] = stor10[address(arg3)][idx].field_512
                            mem[_22426 + 96] = stor10[address(arg3)][idx].field_768
                            mem[s] = _22426
                            s = s + 32
                            idx = idx + 1
                            continue 
                        if address(arg1) != address(arg3):
                            if mem[ceil32(ceil32(arg2.length)) + 225] <= 1:
                                if mem[_15144] > 0:
                                    if _referrals[address(arg1)] != address(arg3):
                                        _referrals[address(arg1)] = address(arg3)
                                        sub_989baf69[address(arg3)].field_0++
                                        sub_989baf69[address(arg3)][sub_989baf69[address(arg3)].field_0].field_0 = address(arg1)
                                    if tokenAddress != msg.sender:
                                        if gateKeeperAddress != msg.sender:
                                            if address(stor0.field_0) != msg.sender:
                                                revert with 0, 'NodeManagerV2: NOT AUTHORIZED'
                                    if stor10[stor11[address(arg1)]].field_0:
                                        if not -referralBonusPercent:
                                            sub_e27e434a[stor11[address(arg1)]][address(arg1)] = 0
                                            if sub_666755bb[stor11[address(arg1)]] > -1:
                                                revert with 0, 17
                                        else:
                                            if referralBonusPercent and nodePrice > -1 / referralBonusPercent:
                                                revert with 0, 17
                                            if not referralBonusPercent:
                                                revert with 0, 18
                                            if referralBonusPercent * nodePrice / referralBonusPercent != nodePrice:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            sub_e27e434a[stor11[address(arg1)]][address(arg1)] = referralBonusPercent * nodePrice / 100
                                            if sub_666755bb[stor11[address(arg1)]] > !(referralBonusPercent * nodePrice / 100):
                                                revert with 0, 17
                                            sub_666755bb[stor11[address(arg1)]] += referralBonusPercent * nodePrice / 100
                    else:
                        if address(stor0.field_0) != msg.sender:
                            revert with 0, 'NodeManagerV2: NOT AUTHORIZED'
                        mem[0] = address(arg1)
                        mem[64] = ceil32(ceil32(arg2.length)) + (32 * stor10[address(arg1)].field_0) + 257
                        mem[ceil32(ceil32(arg2.length)) + 225] = stor10[address(arg1)].field_0
                        s = ceil32(ceil32(arg2.length)) + 257
                        idx = 0
                        while idx < stor10[address(arg1)].field_0:
                            mem[0] = sha3(address(arg1), 10)
                            _15150 = mem[64]
                            mem[64] = mem[64] + 128
                            if stor10[address(arg1)][idx].field_0:
                                if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                                    revert with 0, 34
                                _15537 = mem[64]
                                mem[64] = mem[64] + ceil32(uint255(stor10[address(arg1)][idx].field_0) * 0.5) + 32
                                mem[_15537] = uint255(stor10[address(arg1)][idx].field_0) * 0.5
                                if stor10[address(arg1)][idx].field_0:
                                    if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                                        revert with 0, 34
                                    if Mask(256, -1, stor10[address(arg1)][idx].field_0):
                                        if 31 >= uint255(stor10[address(arg1)][idx].field_0) * 0.5:
                                            mem[_15537 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                        else:
                                            mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                            mem[_15537 + 32] = stor10[address(arg1)][idx].field_0
                                            t = _15537 + 32
                                            u = sha3(mem[0])
                                            while _15537 + (uint255(stor10[address(arg1)][idx].field_0) * 0.5) > t:
                                                mem[t + 32] = uint256(stor1[u])
                                                t = t + 32
                                                u = u + 1
                                                continue 
                                    mem[_15150] = _15537
                                    mem[_15150 + 32] = stor10[address(arg1)][idx].field_256
                                    mem[_15150 + 64] = stor10[address(arg1)][idx].field_512
                                    mem[_15150 + 96] = stor10[address(arg1)][idx].field_768
                                    mem[s] = _15150
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                                    revert with 0, 34
                                if not stor10[address(arg1)][idx].field_1:
                                    mem[_15150] = _15537
                                    mem[_15150 + 32] = stor10[address(arg1)][idx].field_256
                                    mem[_15150 + 64] = stor10[address(arg1)][idx].field_512
                                    mem[_15150 + 96] = stor10[address(arg1)][idx].field_768
                                    mem[s] = _15150
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                if 31 >= stor10[address(arg1)][idx].field_1:
                                    mem[_15537 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                    mem[_15150] = _15537
                                    mem[_15150 + 32] = stor10[address(arg1)][idx].field_256
                                    mem[_15150 + 64] = stor10[address(arg1)][idx].field_512
                                    mem[_15150 + 96] = stor10[address(arg1)][idx].field_768
                                    mem[s] = _15150
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                mem[_15537 + 32] = stor10[address(arg1)][idx].field_0
                                t = _15537 + 32
                                u = sha3(mem[0])
                                while _15537 + stor10[address(arg1)][u].field_1 > t:
                                    mem[t + 32] = uint256(stor1[u])
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                mem[_15150] = _15537
                                mem[_15150 + 32] = stor10[address(arg1)][u].field_256
                                mem[_15150 + 64] = stor10[address(arg1)][u].field_512
                                mem[_15150 + 96] = stor10[address(arg1)][u].field_768
                                mem[t] = _15150
                                t = t + 32
                                u = u + 1
                                continue 
                            if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                                revert with 0, 34
                            _15600 = mem[64]
                            mem[64] = mem[64] + ceil32(stor10[address(arg1)][idx].field_1) + 32
                            mem[_15600] = stor10[address(arg1)][idx].field_1
                            if stor10[address(arg1)][idx].field_0:
                                if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                                    revert with 0, 34
                                if not Mask(256, -1, stor10[address(arg1)][idx].field_0):
                                    mem[_15150] = _15600
                                    mem[_15150 + 32] = stor10[address(arg1)][idx].field_256
                                    mem[_15150 + 64] = stor10[address(arg1)][idx].field_512
                                    mem[_15150 + 96] = stor10[address(arg1)][idx].field_768
                                    mem[s] = _15150
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                if 31 >= uint255(stor10[address(arg1)][idx].field_0) * 0.5:
                                    mem[_15600 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                    mem[_15150] = _15600
                                    mem[_15150 + 32] = stor10[address(arg1)][idx].field_256
                                    mem[_15150 + 64] = stor10[address(arg1)][idx].field_512
                                    mem[_15150 + 96] = stor10[address(arg1)][idx].field_768
                                    mem[s] = _15150
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                mem[_15600 + 32] = stor10[address(arg1)][idx].field_0
                                t = _15600 + 32
                                u = sha3(mem[0])
                                while _15600 + (uint255(stor10[address(arg1)][u].field_0) * 0.5) > t:
                                    mem[t + 32] = uint256(stor1[u])
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                mem[_15150] = _15600
                                mem[_15150 + 32] = stor10[address(arg1)][u].field_256
                                mem[_15150 + 64] = stor10[address(arg1)][u].field_512
                                mem[_15150 + 96] = stor10[address(arg1)][u].field_768
                                mem[t] = _15150
                                t = t + 32
                                u = u + 1
                                continue 
                            if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                                revert with 0, 34
                            if stor10[address(arg1)][idx].field_1:
                                if 31 >= stor10[address(arg1)][idx].field_1:
                                    mem[_15600 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                else:
                                    mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                    mem[_15600 + 32] = stor10[address(arg1)][idx].field_0
                                    t = _15600 + 32
                                    u = sha3(mem[0])
                                    while _15600 + stor10[address(arg1)][idx].field_1 > t:
                                        mem[t + 32] = uint256(stor1[u])
                                        t = t + 32
                                        u = u + 1
                                        continue 
                            mem[_15150] = _15600
                            mem[_15150 + 32] = stor10[address(arg1)][idx].field_256
                            mem[_15150 + 64] = stor10[address(arg1)][idx].field_512
                            mem[_15150 + 96] = stor10[address(arg1)][idx].field_768
                            mem[s] = _15150
                            s = s + 32
                            idx = idx + 1
                            continue 
                        mem[0] = address(arg3)
                        mem[32] = 10
                        _15148 = mem[64]
                        mem[64] = mem[64] + (32 * stor10[address(arg3)].field_0) + 32
                        mem[_15148] = stor10[address(arg3)].field_0
                        s = _15148 + 32
                        idx = 0
                        while idx < stor10[address(arg3)].field_0:
                            mem[0] = sha3(address(arg3), 10)
                            _22428 = mem[64]
                            mem[64] = mem[64] + 128
                            if stor10[address(arg3)][idx].field_0:
                                if not stor10[address(arg3)][idx].field_0 - (uint255(stor10[address(arg3)][idx].field_0) * 0.5 < 32):
                                    revert with 0, 34
                                _22752 = mem[64]
                                mem[64] = mem[64] + ceil32(uint255(stor10[address(arg3)][idx].field_0) * 0.5) + 32
                                mem[_22752] = uint255(stor10[address(arg3)][idx].field_0) * 0.5
                                if stor10[address(arg3)][idx].field_0:
                                    if not stor10[address(arg3)][idx].field_0 - (uint255(stor10[address(arg3)][idx].field_0) * 0.5 < 32):
                                        revert with 0, 34
                                    if Mask(256, -1, stor10[address(arg3)][idx].field_0):
                                        if 31 >= uint255(stor10[address(arg3)][idx].field_0) * 0.5:
                                            mem[_22752 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                        else:
                                            mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                            mem[_22752 + 32] = stor10[address(arg3)][idx].field_0
                                            t = _22752 + 32
                                            u = sha3(mem[0])
                                            while _22752 + (uint255(stor10[address(arg3)][idx].field_0) * 0.5) > t:
                                                mem[t + 32] = uint256(stor1[u])
                                                t = t + 32
                                                u = u + 1
                                                continue 
                                    mem[_22428] = _22752
                                    mem[_22428 + 32] = stor10[address(arg3)][idx].field_256
                                    mem[_22428 + 64] = stor10[address(arg3)][idx].field_512
                                    mem[_22428 + 96] = stor10[address(arg3)][idx].field_768
                                    mem[s] = _22428
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                if not stor10[address(arg3)][idx].field_0 - (stor10[address(arg3)][idx].field_1 < 32):
                                    revert with 0, 34
                                if not stor10[address(arg3)][idx].field_1:
                                    mem[_22428] = _22752
                                    mem[_22428 + 32] = stor10[address(arg3)][idx].field_256
                                    mem[_22428 + 64] = stor10[address(arg3)][idx].field_512
                                    mem[_22428 + 96] = stor10[address(arg3)][idx].field_768
                                    mem[s] = _22428
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                if 31 >= stor10[address(arg3)][idx].field_1:
                                    mem[_22752 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                    mem[_22428] = _22752
                                    mem[_22428 + 32] = stor10[address(arg3)][idx].field_256
                                    mem[_22428 + 64] = stor10[address(arg3)][idx].field_512
                                    mem[_22428 + 96] = stor10[address(arg3)][idx].field_768
                                    mem[s] = _22428
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                mem[_22752 + 32] = stor10[address(arg3)][idx].field_0
                                t = _22752 + 32
                                u = sha3(mem[0])
                                while _22752 + stor10[address(arg3)][u].field_1 > t:
                                    mem[t + 32] = uint256(stor1[u])
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                mem[_22428] = _22752
                                mem[_22428 + 32] = stor10[address(arg3)][u].field_256
                                mem[_22428 + 64] = stor10[address(arg3)][u].field_512
                                mem[_22428 + 96] = stor10[address(arg3)][u].field_768
                                mem[t] = _22428
                                t = t + 32
                                u = u + 1
                                continue 
                            if not stor10[address(arg3)][idx].field_0 - (stor10[address(arg3)][idx].field_1 < 32):
                                revert with 0, 34
                            _22836 = mem[64]
                            mem[64] = mem[64] + ceil32(stor10[address(arg3)][idx].field_1) + 32
                            mem[_22836] = stor10[address(arg3)][idx].field_1
                            if stor10[address(arg3)][idx].field_0:
                                if not stor10[address(arg3)][idx].field_0 - (uint255(stor10[address(arg3)][idx].field_0) * 0.5 < 32):
                                    revert with 0, 34
                                if not Mask(256, -1, stor10[address(arg3)][idx].field_0):
                                    mem[_22428] = _22836
                                    mem[_22428 + 32] = stor10[address(arg3)][idx].field_256
                                    mem[_22428 + 64] = stor10[address(arg3)][idx].field_512
                                    mem[_22428 + 96] = stor10[address(arg3)][idx].field_768
                                    mem[s] = _22428
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                if 31 >= uint255(stor10[address(arg3)][idx].field_0) * 0.5:
                                    mem[_22836 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                    mem[_22428] = _22836
                                    mem[_22428 + 32] = stor10[address(arg3)][idx].field_256
                                    mem[_22428 + 64] = stor10[address(arg3)][idx].field_512
                                    mem[_22428 + 96] = stor10[address(arg3)][idx].field_768
                                    mem[s] = _22428
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                mem[_22836 + 32] = stor10[address(arg3)][idx].field_0
                                t = _22836 + 32
                                u = sha3(mem[0])
                                while _22836 + (uint255(stor10[address(arg3)][u].field_0) * 0.5) > t:
                                    mem[t + 32] = uint256(stor1[u])
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                mem[_22428] = _22836
                                mem[_22428 + 32] = stor10[address(arg3)][u].field_256
                                mem[_22428 + 64] = stor10[address(arg3)][u].field_512
                                mem[_22428 + 96] = stor10[address(arg3)][u].field_768
                                mem[t] = _22428
                                t = t + 32
                                u = u + 1
                                continue 
                            if not stor10[address(arg3)][idx].field_0 - (stor10[address(arg3)][idx].field_1 < 32):
                                revert with 0, 34
                            if stor10[address(arg3)][idx].field_1:
                                if 31 >= stor10[address(arg3)][idx].field_1:
                                    mem[_22836 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                else:
                                    mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                    mem[_22836 + 32] = stor10[address(arg3)][idx].field_0
                                    t = _22836 + 32
                                    u = sha3(mem[0])
                                    while _22836 + stor10[address(arg3)][idx].field_1 > t:
                                        mem[t + 32] = uint256(stor1[u])
                                        t = t + 32
                                        u = u + 1
                                        continue 
                            mem[_22428] = _22836
                            mem[_22428 + 32] = stor10[address(arg3)][idx].field_256
                            mem[_22428 + 64] = stor10[address(arg3)][idx].field_512
                            mem[_22428 + 96] = stor10[address(arg3)][idx].field_768
                            mem[s] = _22428
                            s = s + 32
                            idx = idx + 1
                            continue 
                        if address(arg1) != address(arg3):
                            if mem[ceil32(ceil32(arg2.length)) + 225] <= 1:
                                if mem[_15148] > 0:
                                    if _referrals[address(arg1)] != address(arg3):
                                        _referrals[address(arg1)] = address(arg3)
                                        sub_989baf69[address(arg3)].field_0++
                                        sub_989baf69[address(arg3)][sub_989baf69[address(arg3)].field_0].field_0 = address(arg1)
                                    if tokenAddress != msg.sender:
                                        if gateKeeperAddress != msg.sender:
                                            if address(stor0.field_0) != msg.sender:
                                                revert with 0, 'NodeManagerV2: NOT AUTHORIZED'
                                    if stor10[stor11[address(arg1)]].field_0:
                                        if not -referralBonusPercent:
                                            sub_e27e434a[stor11[address(arg1)]][address(arg1)] = 0
                                            if sub_666755bb[stor11[address(arg1)]] > -1:
                                                revert with 0, 17
                                        else:
                                            if referralBonusPercent and nodePrice > -1 / referralBonusPercent:
                                                revert with 0, 17
                                            if not referralBonusPercent:
                                                revert with 0, 18
                                            if referralBonusPercent * nodePrice / referralBonusPercent != nodePrice:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            sub_e27e434a[stor11[address(arg1)]][address(arg1)] = referralBonusPercent * nodePrice / 100
                                            if sub_666755bb[stor11[address(arg1)]] > !(referralBonusPercent * nodePrice / 100):
                                                revert with 0, 17
                                            sub_666755bb[stor11[address(arg1)]] += referralBonusPercent * nodePrice / 100
        else:
            if not stor10[address(arg1)][stor10[address(arg1)].field_0].field_0 - (stor10[address(arg1)][stor10[address(arg1)].field_0].field_1 < 32):
                revert with 0, 34
            if arg2.length:
                stor10[address(arg1)][stor10[address(arg1)].field_0][].field_0 = Array(len=arg2.length, data=arg2[all])
                stor10[address(arg1)][stor10[address(arg1)].field_0].field_256 = block.timestamp
                stor10[address(arg1)][stor10[address(arg1)].field_0].field_512 = block.timestamp
                stor10[address(arg1)][stor10[address(arg1)].field_0].field_768 = 0
                mem[ceil32(ceil32(arg2.length)) + 229] = 6
                mem[ceil32(ceil32(arg2.length)) + 261] = address(arg1)
                mem[ceil32(ceil32(arg2.length)) + 293] = stor10[address(arg1)].field_0
                require ext_code.size(0x4b7a346b17572634bdbd85b98abae32c5fa837bb)
                delegate 0x4b7a346b17572634bdbd85b98abae32c5fa837bb.0xbc2b405c with:
                     gas gas_remaining wei
                    args 6, address(arg1), stor10[address(arg1)].field_0
                if not delegate.return_code:
                    revert with ext_call.return_data[0 len return_data.size]
                if not totalNodesCreated + 1:
                    revert with 0, 17
                totalNodesCreated++
                if msg.sender == tokenAddress:
                    mem[0] = address(arg1)
                    mem[64] = ceil32(ceil32(arg2.length)) + (32 * stor10[address(arg1)].field_0) + 257
                    mem[ceil32(ceil32(arg2.length)) + 225] = stor10[address(arg1)].field_0
                    s = ceil32(ceil32(arg2.length)) + 257
                    idx = 0
                    while idx < stor10[address(arg1)].field_0:
                        mem[0] = sha3(address(arg1), 10)
                        _22438 = mem[64]
                        mem[64] = mem[64] + 128
                        if stor10[address(arg1)][idx].field_0:
                            if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                                revert with 0, 34
                            _22756 = mem[64]
                            mem[64] = mem[64] + ceil32(uint255(stor10[address(arg1)][idx].field_0) * 0.5) + 32
                            mem[_22756] = uint255(stor10[address(arg1)][idx].field_0) * 0.5
                            if stor10[address(arg1)][idx].field_0:
                                if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                                    revert with 0, 34
                                if Mask(256, -1, stor10[address(arg1)][idx].field_0):
                                    if 31 >= uint255(stor10[address(arg1)][idx].field_0) * 0.5:
                                        mem[_22756 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                    else:
                                        mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                        mem[_22756 + 32] = stor10[address(arg1)][idx].field_0
                                        t = _22756 + 32
                                        u = sha3(mem[0])
                                        while _22756 + (uint255(stor10[address(arg1)][idx].field_0) * 0.5) > t:
                                            mem[t + 32] = uint256(stor1[u])
                                            t = t + 32
                                            u = u + 1
                                            continue 
                                mem[_22438] = _22756
                                mem[_22438 + 32] = stor10[address(arg1)][idx].field_256
                                mem[_22438 + 64] = stor10[address(arg1)][idx].field_512
                                mem[_22438 + 96] = stor10[address(arg1)][idx].field_768
                                mem[s] = _22438
                                s = s + 32
                                idx = idx + 1
                                continue 
                            if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                                revert with 0, 34
                            if not stor10[address(arg1)][idx].field_1:
                                mem[_22438] = _22756
                                mem[_22438 + 32] = stor10[address(arg1)][idx].field_256
                                mem[_22438 + 64] = stor10[address(arg1)][idx].field_512
                                mem[_22438 + 96] = stor10[address(arg1)][idx].field_768
                                mem[s] = _22438
                                s = s + 32
                                idx = idx + 1
                                continue 
                            if 31 >= stor10[address(arg1)][idx].field_1:
                                mem[_22756 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                mem[_22438] = _22756
                                mem[_22438 + 32] = stor10[address(arg1)][idx].field_256
                                mem[_22438 + 64] = stor10[address(arg1)][idx].field_512
                                mem[_22438 + 96] = stor10[address(arg1)][idx].field_768
                                mem[s] = _22438
                                s = s + 32
                                idx = idx + 1
                                continue 
                            mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                            mem[_22756 + 32] = stor10[address(arg1)][idx].field_0
                            t = _22756 + 32
                            u = sha3(mem[0])
                            while _22756 + stor10[address(arg1)][u].field_1 > t:
                                mem[t + 32] = uint256(stor1[u])
                                t = t + 32
                                u = u + 1
                                continue 
                            mem[_22438] = _22756
                            mem[_22438 + 32] = stor10[address(arg1)][u].field_256
                            mem[_22438 + 64] = stor10[address(arg1)][u].field_512
                            mem[_22438 + 96] = stor10[address(arg1)][u].field_768
                            mem[t] = _22438
                            t = t + 32
                            u = u + 1
                            continue 
                        if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                            revert with 0, 34
                        _22844 = mem[64]
                        mem[64] = mem[64] + ceil32(stor10[address(arg1)][idx].field_1) + 32
                        mem[_22844] = stor10[address(arg1)][idx].field_1
                        if stor10[address(arg1)][idx].field_0:
                            if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                                revert with 0, 34
                            if not Mask(256, -1, stor10[address(arg1)][idx].field_0):
                                mem[_22438] = _22844
                                mem[_22438 + 32] = stor10[address(arg1)][idx].field_256
                                mem[_22438 + 64] = stor10[address(arg1)][idx].field_512
                                mem[_22438 + 96] = stor10[address(arg1)][idx].field_768
                                mem[s] = _22438
                                s = s + 32
                                idx = idx + 1
                                continue 
                            if 31 >= uint255(stor10[address(arg1)][idx].field_0) * 0.5:
                                mem[_22844 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                mem[_22438] = _22844
                                mem[_22438 + 32] = stor10[address(arg1)][idx].field_256
                                mem[_22438 + 64] = stor10[address(arg1)][idx].field_512
                                mem[_22438 + 96] = stor10[address(arg1)][idx].field_768
                                mem[s] = _22438
                                s = s + 32
                                idx = idx + 1
                                continue 
                            mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                            mem[_22844 + 32] = stor10[address(arg1)][idx].field_0
                            t = _22844 + 32
                            u = sha3(mem[0])
                            while _22844 + (uint255(stor10[address(arg1)][u].field_0) * 0.5) > t:
                                mem[t + 32] = uint256(stor1[u])
                                t = t + 32
                                u = u + 1
                                continue 
                            mem[_22438] = _22844
                            mem[_22438 + 32] = stor10[address(arg1)][u].field_256
                            mem[_22438 + 64] = stor10[address(arg1)][u].field_512
                            mem[_22438 + 96] = stor10[address(arg1)][u].field_768
                            mem[t] = _22438
                            t = t + 32
                            u = u + 1
                            continue 
                        if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                            revert with 0, 34
                        if stor10[address(arg1)][idx].field_1:
                            if 31 >= stor10[address(arg1)][idx].field_1:
                                mem[_22844 + 32] = 256 * stor10[address(arg1)][idx].field_8
                            else:
                                mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                mem[_22844 + 32] = stor10[address(arg1)][idx].field_0
                                t = _22844 + 32
                                u = sha3(mem[0])
                                while _22844 + stor10[address(arg1)][idx].field_1 > t:
                                    mem[t + 32] = uint256(stor1[u])
                                    t = t + 32
                                    u = u + 1
                                    continue 
                        mem[_22438] = _22844
                        mem[_22438 + 32] = stor10[address(arg1)][idx].field_256
                        mem[_22438 + 64] = stor10[address(arg1)][idx].field_512
                        mem[_22438 + 96] = stor10[address(arg1)][idx].field_768
                        mem[s] = _22438
                        s = s + 32
                        idx = idx + 1
                        continue 
                    mem[0] = address(arg3)
                    mem[32] = 10
                    _22436 = mem[64]
                    mem[64] = mem[64] + (32 * stor10[address(arg3)].field_0) + 32
                    mem[_22436] = stor10[address(arg3)].field_0
                    s = _22436 + 32
                    idx = 0
                    while idx < stor10[address(arg3)].field_0:
                        mem[0] = sha3(address(arg3), 10)
                        _29066 = mem[64]
                        mem[64] = mem[64] + 128
                        if stor10[address(arg3)][idx].field_0:
                            if not stor10[address(arg3)][idx].field_0 - (uint255(stor10[address(arg3)][idx].field_0) * 0.5 < 32):
                                revert with 0, 34
                            _29134 = mem[64]
                            mem[64] = mem[64] + ceil32(uint255(stor10[address(arg3)][idx].field_0) * 0.5) + 32
                            mem[_29134] = uint255(stor10[address(arg3)][idx].field_0) * 0.5
                            if stor10[address(arg3)][idx].field_0:
                                if not stor10[address(arg3)][idx].field_0 - (uint255(stor10[address(arg3)][idx].field_0) * 0.5 < 32):
                                    revert with 0, 34
                                if Mask(256, -1, stor10[address(arg3)][idx].field_0):
                                    if 31 >= uint255(stor10[address(arg3)][idx].field_0) * 0.5:
                                        mem[_29134 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                    else:
                                        mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                        mem[_29134 + 32] = stor10[address(arg3)][idx].field_0
                                        t = _29134 + 32
                                        u = sha3(mem[0])
                                        while _29134 + (uint255(stor10[address(arg3)][idx].field_0) * 0.5) > t:
                                            mem[t + 32] = uint256(stor1[u])
                                            t = t + 32
                                            u = u + 1
                                            continue 
                                mem[_29066] = _29134
                                mem[_29066 + 32] = stor10[address(arg3)][idx].field_256
                                mem[_29066 + 64] = stor10[address(arg3)][idx].field_512
                                mem[_29066 + 96] = stor10[address(arg3)][idx].field_768
                                mem[s] = _29066
                                s = s + 32
                                idx = idx + 1
                                continue 
                            if not stor10[address(arg3)][idx].field_0 - (stor10[address(arg3)][idx].field_1 < 32):
                                revert with 0, 34
                            if not stor10[address(arg3)][idx].field_1:
                                mem[_29066] = _29134
                                mem[_29066 + 32] = stor10[address(arg3)][idx].field_256
                                mem[_29066 + 64] = stor10[address(arg3)][idx].field_512
                                mem[_29066 + 96] = stor10[address(arg3)][idx].field_768
                                mem[s] = _29066
                                s = s + 32
                                idx = idx + 1
                                continue 
                            if 31 >= stor10[address(arg3)][idx].field_1:
                                mem[_29134 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                mem[_29066] = _29134
                                mem[_29066 + 32] = stor10[address(arg3)][idx].field_256
                                mem[_29066 + 64] = stor10[address(arg3)][idx].field_512
                                mem[_29066 + 96] = stor10[address(arg3)][idx].field_768
                                mem[s] = _29066
                                s = s + 32
                                idx = idx + 1
                                continue 
                            mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                            mem[_29134 + 32] = stor10[address(arg3)][idx].field_0
                            t = _29134 + 32
                            u = sha3(mem[0])
                            while _29134 + stor10[address(arg3)][u].field_1 > t:
                                mem[t + 32] = uint256(stor1[u])
                                t = t + 32
                                u = u + 1
                                continue 
                            mem[_29066] = _29134
                            mem[_29066 + 32] = stor10[address(arg3)][u].field_256
                            mem[_29066 + 64] = stor10[address(arg3)][u].field_512
                            mem[_29066 + 96] = stor10[address(arg3)][u].field_768
                            mem[t] = _29066
                            t = t + 32
                            u = u + 1
                            continue 
                        if not stor10[address(arg3)][idx].field_0 - (stor10[address(arg3)][idx].field_1 < 32):
                            revert with 0, 34
                        _29156 = mem[64]
                        mem[64] = mem[64] + ceil32(stor10[address(arg3)][idx].field_1) + 32
                        mem[_29156] = stor10[address(arg3)][idx].field_1
                        if stor10[address(arg3)][idx].field_0:
                            if not stor10[address(arg3)][idx].field_0 - (uint255(stor10[address(arg3)][idx].field_0) * 0.5 < 32):
                                revert with 0, 34
                            if not Mask(256, -1, stor10[address(arg3)][idx].field_0):
                                mem[_29066] = _29156
                                mem[_29066 + 32] = stor10[address(arg3)][idx].field_256
                                mem[_29066 + 64] = stor10[address(arg3)][idx].field_512
                                mem[_29066 + 96] = stor10[address(arg3)][idx].field_768
                                mem[s] = _29066
                                s = s + 32
                                idx = idx + 1
                                continue 
                            if 31 >= uint255(stor10[address(arg3)][idx].field_0) * 0.5:
                                mem[_29156 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                mem[_29066] = _29156
                                mem[_29066 + 32] = stor10[address(arg3)][idx].field_256
                                mem[_29066 + 64] = stor10[address(arg3)][idx].field_512
                                mem[_29066 + 96] = stor10[address(arg3)][idx].field_768
                                mem[s] = _29066
                                s = s + 32
                                idx = idx + 1
                                continue 
                            mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                            mem[_29156 + 32] = stor10[address(arg3)][idx].field_0
                            t = _29156 + 32
                            u = sha3(mem[0])
                            while _29156 + (uint255(stor10[address(arg3)][u].field_0) * 0.5) > t:
                                mem[t + 32] = uint256(stor1[u])
                                t = t + 32
                                u = u + 1
                                continue 
                            mem[_29066] = _29156
                            mem[_29066 + 32] = stor10[address(arg3)][u].field_256
                            mem[_29066 + 64] = stor10[address(arg3)][u].field_512
                            mem[_29066 + 96] = stor10[address(arg3)][u].field_768
                            mem[t] = _29066
                            t = t + 32
                            u = u + 1
                            continue 
                        if not stor10[address(arg3)][idx].field_0 - (stor10[address(arg3)][idx].field_1 < 32):
                            revert with 0, 34
                        if stor10[address(arg3)][idx].field_1:
                            if 31 >= stor10[address(arg3)][idx].field_1:
                                mem[_29156 + 32] = 256 * stor10[address(arg3)][idx].field_8
                            else:
                                mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                mem[_29156 + 32] = stor10[address(arg3)][idx].field_0
                                t = _29156 + 32
                                u = sha3(mem[0])
                                while _29156 + stor10[address(arg3)][idx].field_1 > t:
                                    mem[t + 32] = uint256(stor1[u])
                                    t = t + 32
                                    u = u + 1
                                    continue 
                        mem[_29066] = _29156
                        mem[_29066 + 32] = stor10[address(arg3)][idx].field_256
                        mem[_29066 + 64] = stor10[address(arg3)][idx].field_512
                        mem[_29066 + 96] = stor10[address(arg3)][idx].field_768
                        mem[s] = _29066
                        s = s + 32
                        idx = idx + 1
                        continue 
                    if address(arg1) != address(arg3):
                        if mem[ceil32(ceil32(arg2.length)) + 225] <= 1:
                            if mem[_22436] > 0:
                                if _referrals[address(arg1)] != address(arg3):
                                    _referrals[address(arg1)] = address(arg3)
                                    sub_989baf69[address(arg3)].field_0++
                                    sub_989baf69[address(arg3)][sub_989baf69[address(arg3)].field_0].field_0 = address(arg1)
                                if tokenAddress != msg.sender:
                                    if gateKeeperAddress != msg.sender:
                                        if address(stor0.field_0) != msg.sender:
                                            revert with 0, 'NodeManagerV2: NOT AUTHORIZED'
                                if stor10[stor11[address(arg1)]].field_0:
                                    if not -referralBonusPercent:
                                        sub_e27e434a[stor11[address(arg1)]][address(arg1)] = 0
                                        if sub_666755bb[stor11[address(arg1)]] > -1:
                                            revert with 0, 17
                                    else:
                                        if referralBonusPercent and nodePrice > -1 / referralBonusPercent:
                                            revert with 0, 17
                                        if not referralBonusPercent:
                                            revert with 0, 18
                                        if referralBonusPercent * nodePrice / referralBonusPercent != nodePrice:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        sub_e27e434a[stor11[address(arg1)]][address(arg1)] = referralBonusPercent * nodePrice / 100
                                        if sub_666755bb[stor11[address(arg1)]] > !(referralBonusPercent * nodePrice / 100):
                                            revert with 0, 17
                                        sub_666755bb[stor11[address(arg1)]] += referralBonusPercent * nodePrice / 100
                else:
                    if msg.sender == gateKeeperAddress:
                        mem[0] = address(arg1)
                        mem[64] = ceil32(ceil32(arg2.length)) + (32 * stor10[address(arg1)].field_0) + 257
                        mem[ceil32(ceil32(arg2.length)) + 225] = stor10[address(arg1)].field_0
                        s = ceil32(ceil32(arg2.length)) + 257
                        idx = 0
                        while idx < stor10[address(arg1)].field_0:
                            mem[0] = sha3(address(arg1), 10)
                            _22442 = mem[64]
                            mem[64] = mem[64] + 128
                            if stor10[address(arg1)][idx].field_0:
                                if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                                    revert with 0, 34
                                _22757 = mem[64]
                                mem[64] = mem[64] + ceil32(uint255(stor10[address(arg1)][idx].field_0) * 0.5) + 32
                                mem[_22757] = uint255(stor10[address(arg1)][idx].field_0) * 0.5
                                if stor10[address(arg1)][idx].field_0:
                                    if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                                        revert with 0, 34
                                    if Mask(256, -1, stor10[address(arg1)][idx].field_0):
                                        if 31 >= uint255(stor10[address(arg1)][idx].field_0) * 0.5:
                                            mem[_22757 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                        else:
                                            mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                            mem[_22757 + 32] = stor10[address(arg1)][idx].field_0
                                            t = _22757 + 32
                                            u = sha3(mem[0])
                                            while _22757 + (uint255(stor10[address(arg1)][idx].field_0) * 0.5) > t:
                                                mem[t + 32] = uint256(stor1[u])
                                                t = t + 32
                                                u = u + 1
                                                continue 
                                    mem[_22442] = _22757
                                    mem[_22442 + 32] = stor10[address(arg1)][idx].field_256
                                    mem[_22442 + 64] = stor10[address(arg1)][idx].field_512
                                    mem[_22442 + 96] = stor10[address(arg1)][idx].field_768
                                    mem[s] = _22442
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                                    revert with 0, 34
                                if not stor10[address(arg1)][idx].field_1:
                                    mem[_22442] = _22757
                                    mem[_22442 + 32] = stor10[address(arg1)][idx].field_256
                                    mem[_22442 + 64] = stor10[address(arg1)][idx].field_512
                                    mem[_22442 + 96] = stor10[address(arg1)][idx].field_768
                                    mem[s] = _22442
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                if 31 >= stor10[address(arg1)][idx].field_1:
                                    mem[_22757 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                    mem[_22442] = _22757
                                    mem[_22442 + 32] = stor10[address(arg1)][idx].field_256
                                    mem[_22442 + 64] = stor10[address(arg1)][idx].field_512
                                    mem[_22442 + 96] = stor10[address(arg1)][idx].field_768
                                    mem[s] = _22442
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                mem[_22757 + 32] = stor10[address(arg1)][idx].field_0
                                t = _22757 + 32
                                u = sha3(mem[0])
                                while _22757 + stor10[address(arg1)][u].field_1 > t:
                                    mem[t + 32] = uint256(stor1[u])
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                mem[_22442] = _22757
                                mem[_22442 + 32] = stor10[address(arg1)][u].field_256
                                mem[_22442 + 64] = stor10[address(arg1)][u].field_512
                                mem[_22442 + 96] = stor10[address(arg1)][u].field_768
                                mem[t] = _22442
                                t = t + 32
                                u = u + 1
                                continue 
                            if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                                revert with 0, 34
                            _22846 = mem[64]
                            mem[64] = mem[64] + ceil32(stor10[address(arg1)][idx].field_1) + 32
                            mem[_22846] = stor10[address(arg1)][idx].field_1
                            if stor10[address(arg1)][idx].field_0:
                                if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                                    revert with 0, 34
                                if not Mask(256, -1, stor10[address(arg1)][idx].field_0):
                                    mem[_22442] = _22846
                                    mem[_22442 + 32] = stor10[address(arg1)][idx].field_256
                                    mem[_22442 + 64] = stor10[address(arg1)][idx].field_512
                                    mem[_22442 + 96] = stor10[address(arg1)][idx].field_768
                                    mem[s] = _22442
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                if 31 >= uint255(stor10[address(arg1)][idx].field_0) * 0.5:
                                    mem[_22846 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                    mem[_22442] = _22846
                                    mem[_22442 + 32] = stor10[address(arg1)][idx].field_256
                                    mem[_22442 + 64] = stor10[address(arg1)][idx].field_512
                                    mem[_22442 + 96] = stor10[address(arg1)][idx].field_768
                                    mem[s] = _22442
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                mem[_22846 + 32] = stor10[address(arg1)][idx].field_0
                                t = _22846 + 32
                                u = sha3(mem[0])
                                while _22846 + (uint255(stor10[address(arg1)][u].field_0) * 0.5) > t:
                                    mem[t + 32] = uint256(stor1[u])
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                mem[_22442] = _22846
                                mem[_22442 + 32] = stor10[address(arg1)][u].field_256
                                mem[_22442 + 64] = stor10[address(arg1)][u].field_512
                                mem[_22442 + 96] = stor10[address(arg1)][u].field_768
                                mem[t] = _22442
                                t = t + 32
                                u = u + 1
                                continue 
                            if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                                revert with 0, 34
                            if stor10[address(arg1)][idx].field_1:
                                if 31 >= stor10[address(arg1)][idx].field_1:
                                    mem[_22846 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                else:
                                    mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                    mem[_22846 + 32] = stor10[address(arg1)][idx].field_0
                                    t = _22846 + 32
                                    u = sha3(mem[0])
                                    while _22846 + stor10[address(arg1)][idx].field_1 > t:
                                        mem[t + 32] = uint256(stor1[u])
                                        t = t + 32
                                        u = u + 1
                                        continue 
                            mem[_22442] = _22846
                            mem[_22442 + 32] = stor10[address(arg1)][idx].field_256
                            mem[_22442 + 64] = stor10[address(arg1)][idx].field_512
                            mem[_22442 + 96] = stor10[address(arg1)][idx].field_768
                            mem[s] = _22442
                            s = s + 32
                            idx = idx + 1
                            continue 
                        mem[0] = address(arg3)
                        mem[32] = 10
                        _22440 = mem[64]
                        mem[64] = mem[64] + (32 * stor10[address(arg3)].field_0) + 32
                        mem[_22440] = stor10[address(arg3)].field_0
                        s = _22440 + 32
                        idx = 0
                        while idx < stor10[address(arg3)].field_0:
                            mem[0] = sha3(address(arg3), 10)
                            _29068 = mem[64]
                            mem[64] = mem[64] + 128
                            if stor10[address(arg3)][idx].field_0:
                                if not stor10[address(arg3)][idx].field_0 - (uint255(stor10[address(arg3)][idx].field_0) * 0.5 < 32):
                                    revert with 0, 34
                                _29135 = mem[64]
                                mem[64] = mem[64] + ceil32(uint255(stor10[address(arg3)][idx].field_0) * 0.5) + 32
                                mem[_29135] = uint255(stor10[address(arg3)][idx].field_0) * 0.5
                                if stor10[address(arg3)][idx].field_0:
                                    if not stor10[address(arg3)][idx].field_0 - (uint255(stor10[address(arg3)][idx].field_0) * 0.5 < 32):
                                        revert with 0, 34
                                    if Mask(256, -1, stor10[address(arg3)][idx].field_0):
                                        if 31 >= uint255(stor10[address(arg3)][idx].field_0) * 0.5:
                                            mem[_29135 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                        else:
                                            mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                            mem[_29135 + 32] = stor10[address(arg3)][idx].field_0
                                            t = _29135 + 32
                                            u = sha3(mem[0])
                                            while _29135 + (uint255(stor10[address(arg3)][idx].field_0) * 0.5) > t:
                                                mem[t + 32] = uint256(stor1[u])
                                                t = t + 32
                                                u = u + 1
                                                continue 
                                    mem[_29068] = _29135
                                    mem[_29068 + 32] = stor10[address(arg3)][idx].field_256
                                    mem[_29068 + 64] = stor10[address(arg3)][idx].field_512
                                    mem[_29068 + 96] = stor10[address(arg3)][idx].field_768
                                    mem[s] = _29068
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                if not stor10[address(arg3)][idx].field_0 - (stor10[address(arg3)][idx].field_1 < 32):
                                    revert with 0, 34
                                if not stor10[address(arg3)][idx].field_1:
                                    mem[_29068] = _29135
                                    mem[_29068 + 32] = stor10[address(arg3)][idx].field_256
                                    mem[_29068 + 64] = stor10[address(arg3)][idx].field_512
                                    mem[_29068 + 96] = stor10[address(arg3)][idx].field_768
                                    mem[s] = _29068
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                if 31 >= stor10[address(arg3)][idx].field_1:
                                    mem[_29135 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                    mem[_29068] = _29135
                                    mem[_29068 + 32] = stor10[address(arg3)][idx].field_256
                                    mem[_29068 + 64] = stor10[address(arg3)][idx].field_512
                                    mem[_29068 + 96] = stor10[address(arg3)][idx].field_768
                                    mem[s] = _29068
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                mem[_29135 + 32] = stor10[address(arg3)][idx].field_0
                                t = _29135 + 32
                                u = sha3(mem[0])
                                while _29135 + stor10[address(arg3)][u].field_1 > t:
                                    mem[t + 32] = uint256(stor1[u])
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                mem[_29068] = _29135
                                mem[_29068 + 32] = stor10[address(arg3)][u].field_256
                                mem[_29068 + 64] = stor10[address(arg3)][u].field_512
                                mem[_29068 + 96] = stor10[address(arg3)][u].field_768
                                mem[t] = _29068
                                t = t + 32
                                u = u + 1
                                continue 
                            if not stor10[address(arg3)][idx].field_0 - (stor10[address(arg3)][idx].field_1 < 32):
                                revert with 0, 34
                            _29158 = mem[64]
                            mem[64] = mem[64] + ceil32(stor10[address(arg3)][idx].field_1) + 32
                            mem[_29158] = stor10[address(arg3)][idx].field_1
                            if stor10[address(arg3)][idx].field_0:
                                if not stor10[address(arg3)][idx].field_0 - (uint255(stor10[address(arg3)][idx].field_0) * 0.5 < 32):
                                    revert with 0, 34
                                if not Mask(256, -1, stor10[address(arg3)][idx].field_0):
                                    mem[_29068] = _29158
                                    mem[_29068 + 32] = stor10[address(arg3)][idx].field_256
                                    mem[_29068 + 64] = stor10[address(arg3)][idx].field_512
                                    mem[_29068 + 96] = stor10[address(arg3)][idx].field_768
                                    mem[s] = _29068
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                if 31 >= uint255(stor10[address(arg3)][idx].field_0) * 0.5:
                                    mem[_29158 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                    mem[_29068] = _29158
                                    mem[_29068 + 32] = stor10[address(arg3)][idx].field_256
                                    mem[_29068 + 64] = stor10[address(arg3)][idx].field_512
                                    mem[_29068 + 96] = stor10[address(arg3)][idx].field_768
                                    mem[s] = _29068
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                mem[_29158 + 32] = stor10[address(arg3)][idx].field_0
                                t = _29158 + 32
                                u = sha3(mem[0])
                                while _29158 + (uint255(stor10[address(arg3)][u].field_0) * 0.5) > t:
                                    mem[t + 32] = uint256(stor1[u])
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                mem[_29068] = _29158
                                mem[_29068 + 32] = stor10[address(arg3)][u].field_256
                                mem[_29068 + 64] = stor10[address(arg3)][u].field_512
                                mem[_29068 + 96] = stor10[address(arg3)][u].field_768
                                mem[t] = _29068
                                t = t + 32
                                u = u + 1
                                continue 
                            if not stor10[address(arg3)][idx].field_0 - (stor10[address(arg3)][idx].field_1 < 32):
                                revert with 0, 34
                            if stor10[address(arg3)][idx].field_1:
                                if 31 >= stor10[address(arg3)][idx].field_1:
                                    mem[_29158 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                else:
                                    mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                    mem[_29158 + 32] = stor10[address(arg3)][idx].field_0
                                    t = _29158 + 32
                                    u = sha3(mem[0])
                                    while _29158 + stor10[address(arg3)][idx].field_1 > t:
                                        mem[t + 32] = uint256(stor1[u])
                                        t = t + 32
                                        u = u + 1
                                        continue 
                            mem[_29068] = _29158
                            mem[_29068 + 32] = stor10[address(arg3)][idx].field_256
                            mem[_29068 + 64] = stor10[address(arg3)][idx].field_512
                            mem[_29068 + 96] = stor10[address(arg3)][idx].field_768
                            mem[s] = _29068
                            s = s + 32
                            idx = idx + 1
                            continue 
                        if address(arg1) != address(arg3):
                            if mem[ceil32(ceil32(arg2.length)) + 225] <= 1:
                                if mem[_22440] > 0:
                                    if _referrals[address(arg1)] != address(arg3):
                                        _referrals[address(arg1)] = address(arg3)
                                        sub_989baf69[address(arg3)].field_0++
                                        sub_989baf69[address(arg3)][sub_989baf69[address(arg3)].field_0].field_0 = address(arg1)
                                    if tokenAddress != msg.sender:
                                        if gateKeeperAddress != msg.sender:
                                            if address(stor0.field_0) != msg.sender:
                                                revert with 0, 'NodeManagerV2: NOT AUTHORIZED'
                                    if stor10[stor11[address(arg1)]].field_0:
                                        if not -referralBonusPercent:
                                            sub_e27e434a[stor11[address(arg1)]][address(arg1)] = 0
                                            if sub_666755bb[stor11[address(arg1)]] > -1:
                                                revert with 0, 17
                                        else:
                                            if referralBonusPercent and nodePrice > -1 / referralBonusPercent:
                                                revert with 0, 17
                                            if not referralBonusPercent:
                                                revert with 0, 18
                                            if referralBonusPercent * nodePrice / referralBonusPercent != nodePrice:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            sub_e27e434a[stor11[address(arg1)]][address(arg1)] = referralBonusPercent * nodePrice / 100
                                            if sub_666755bb[stor11[address(arg1)]] > !(referralBonusPercent * nodePrice / 100):
                                                revert with 0, 17
                                            sub_666755bb[stor11[address(arg1)]] += referralBonusPercent * nodePrice / 100
                    else:
                        if address(stor0.field_0) != msg.sender:
                            revert with 0, 'NodeManagerV2: NOT AUTHORIZED'
                        mem[0] = address(arg1)
                        mem[64] = ceil32(ceil32(arg2.length)) + (32 * stor10[address(arg1)].field_0) + 257
                        mem[ceil32(ceil32(arg2.length)) + 225] = stor10[address(arg1)].field_0
                        s = ceil32(ceil32(arg2.length)) + 257
                        idx = 0
                        while idx < stor10[address(arg1)].field_0:
                            mem[0] = sha3(address(arg1), 10)
                            _22446 = mem[64]
                            mem[64] = mem[64] + 128
                            if stor10[address(arg1)][idx].field_0:
                                if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                                    revert with 0, 34
                                _22758 = mem[64]
                                mem[64] = mem[64] + ceil32(uint255(stor10[address(arg1)][idx].field_0) * 0.5) + 32
                                mem[_22758] = uint255(stor10[address(arg1)][idx].field_0) * 0.5
                                if stor10[address(arg1)][idx].field_0:
                                    if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                                        revert with 0, 34
                                    if Mask(256, -1, stor10[address(arg1)][idx].field_0):
                                        if 31 >= uint255(stor10[address(arg1)][idx].field_0) * 0.5:
                                            mem[_22758 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                        else:
                                            mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                            mem[_22758 + 32] = stor10[address(arg1)][idx].field_0
                                            t = _22758 + 32
                                            u = sha3(mem[0])
                                            while _22758 + (uint255(stor10[address(arg1)][idx].field_0) * 0.5) > t:
                                                mem[t + 32] = uint256(stor1[u])
                                                t = t + 32
                                                u = u + 1
                                                continue 
                                    mem[_22446] = _22758
                                    mem[_22446 + 32] = stor10[address(arg1)][idx].field_256
                                    mem[_22446 + 64] = stor10[address(arg1)][idx].field_512
                                    mem[_22446 + 96] = stor10[address(arg1)][idx].field_768
                                    mem[s] = _22446
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                                    revert with 0, 34
                                if not stor10[address(arg1)][idx].field_1:
                                    mem[_22446] = _22758
                                    mem[_22446 + 32] = stor10[address(arg1)][idx].field_256
                                    mem[_22446 + 64] = stor10[address(arg1)][idx].field_512
                                    mem[_22446 + 96] = stor10[address(arg1)][idx].field_768
                                    mem[s] = _22446
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                if 31 >= stor10[address(arg1)][idx].field_1:
                                    mem[_22758 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                    mem[_22446] = _22758
                                    mem[_22446 + 32] = stor10[address(arg1)][idx].field_256
                                    mem[_22446 + 64] = stor10[address(arg1)][idx].field_512
                                    mem[_22446 + 96] = stor10[address(arg1)][idx].field_768
                                    mem[s] = _22446
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                mem[_22758 + 32] = stor10[address(arg1)][idx].field_0
                                t = _22758 + 32
                                u = sha3(mem[0])
                                while _22758 + stor10[address(arg1)][u].field_1 > t:
                                    mem[t + 32] = uint256(stor1[u])
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                mem[_22446] = _22758
                                mem[_22446 + 32] = stor10[address(arg1)][u].field_256
                                mem[_22446 + 64] = stor10[address(arg1)][u].field_512
                                mem[_22446 + 96] = stor10[address(arg1)][u].field_768
                                mem[t] = _22446
                                t = t + 32
                                u = u + 1
                                continue 
                            if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                                revert with 0, 34
                            _22848 = mem[64]
                            mem[64] = mem[64] + ceil32(stor10[address(arg1)][idx].field_1) + 32
                            mem[_22848] = stor10[address(arg1)][idx].field_1
                            if stor10[address(arg1)][idx].field_0:
                                if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                                    revert with 0, 34
                                if not Mask(256, -1, stor10[address(arg1)][idx].field_0):
                                    mem[_22446] = _22848
                                    mem[_22446 + 32] = stor10[address(arg1)][idx].field_256
                                    mem[_22446 + 64] = stor10[address(arg1)][idx].field_512
                                    mem[_22446 + 96] = stor10[address(arg1)][idx].field_768
                                    mem[s] = _22446
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                if 31 >= uint255(stor10[address(arg1)][idx].field_0) * 0.5:
                                    mem[_22848 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                    mem[_22446] = _22848
                                    mem[_22446 + 32] = stor10[address(arg1)][idx].field_256
                                    mem[_22446 + 64] = stor10[address(arg1)][idx].field_512
                                    mem[_22446 + 96] = stor10[address(arg1)][idx].field_768
                                    mem[s] = _22446
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                mem[_22848 + 32] = stor10[address(arg1)][idx].field_0
                                t = _22848 + 32
                                u = sha3(mem[0])
                                while _22848 + (uint255(stor10[address(arg1)][u].field_0) * 0.5) > t:
                                    mem[t + 32] = uint256(stor1[u])
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                mem[_22446] = _22848
                                mem[_22446 + 32] = stor10[address(arg1)][u].field_256
                                mem[_22446 + 64] = stor10[address(arg1)][u].field_512
                                mem[_22446 + 96] = stor10[address(arg1)][u].field_768
                                mem[t] = _22446
                                t = t + 32
                                u = u + 1
                                continue 
                            if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                                revert with 0, 34
                            if stor10[address(arg1)][idx].field_1:
                                if 31 >= stor10[address(arg1)][idx].field_1:
                                    mem[_22848 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                else:
                                    mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                    mem[_22848 + 32] = stor10[address(arg1)][idx].field_0
                                    t = _22848 + 32
                                    u = sha3(mem[0])
                                    while _22848 + stor10[address(arg1)][idx].field_1 > t:
                                        mem[t + 32] = uint256(stor1[u])
                                        t = t + 32
                                        u = u + 1
                                        continue 
                            mem[_22446] = _22848
                            mem[_22446 + 32] = stor10[address(arg1)][idx].field_256
                            mem[_22446 + 64] = stor10[address(arg1)][idx].field_512
                            mem[_22446 + 96] = stor10[address(arg1)][idx].field_768
                            mem[s] = _22446
                            s = s + 32
                            idx = idx + 1
                            continue 
                        mem[0] = address(arg3)
                        mem[32] = 10
                        _22444 = mem[64]
                        mem[64] = mem[64] + (32 * stor10[address(arg3)].field_0) + 32
                        mem[_22444] = stor10[address(arg3)].field_0
                        s = _22444 + 32
                        idx = 0
                        while idx < stor10[address(arg3)].field_0:
                            mem[0] = sha3(address(arg3), 10)
                            _29070 = mem[64]
                            mem[64] = mem[64] + 128
                            if stor10[address(arg3)][idx].field_0:
                                if not stor10[address(arg3)][idx].field_0 - (uint255(stor10[address(arg3)][idx].field_0) * 0.5 < 32):
                                    revert with 0, 34
                                _29136 = mem[64]
                                mem[64] = mem[64] + ceil32(uint255(stor10[address(arg3)][idx].field_0) * 0.5) + 32
                                mem[_29136] = uint255(stor10[address(arg3)][idx].field_0) * 0.5
                                if stor10[address(arg3)][idx].field_0:
                                    if not stor10[address(arg3)][idx].field_0 - (uint255(stor10[address(arg3)][idx].field_0) * 0.5 < 32):
                                        revert with 0, 34
                                    if Mask(256, -1, stor10[address(arg3)][idx].field_0):
                                        if 31 >= uint255(stor10[address(arg3)][idx].field_0) * 0.5:
                                            mem[_29136 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                        else:
                                            mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                            mem[_29136 + 32] = stor10[address(arg3)][idx].field_0
                                            t = _29136 + 32
                                            u = sha3(mem[0])
                                            while _29136 + (uint255(stor10[address(arg3)][idx].field_0) * 0.5) > t:
                                                mem[t + 32] = uint256(stor1[u])
                                                t = t + 32
                                                u = u + 1
                                                continue 
                                    mem[_29070] = _29136
                                    mem[_29070 + 32] = stor10[address(arg3)][idx].field_256
                                    mem[_29070 + 64] = stor10[address(arg3)][idx].field_512
                                    mem[_29070 + 96] = stor10[address(arg3)][idx].field_768
                                    mem[s] = _29070
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                if not stor10[address(arg3)][idx].field_0 - (stor10[address(arg3)][idx].field_1 < 32):
                                    revert with 0, 34
                                if not stor10[address(arg3)][idx].field_1:
                                    mem[_29070] = _29136
                                    mem[_29070 + 32] = stor10[address(arg3)][idx].field_256
                                    mem[_29070 + 64] = stor10[address(arg3)][idx].field_512
                                    mem[_29070 + 96] = stor10[address(arg3)][idx].field_768
                                    mem[s] = _29070
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                if 31 >= stor10[address(arg3)][idx].field_1:
                                    mem[_29136 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                    mem[_29070] = _29136
                                    mem[_29070 + 32] = stor10[address(arg3)][idx].field_256
                                    mem[_29070 + 64] = stor10[address(arg3)][idx].field_512
                                    mem[_29070 + 96] = stor10[address(arg3)][idx].field_768
                                    mem[s] = _29070
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                mem[_29136 + 32] = stor10[address(arg3)][idx].field_0
                                t = _29136 + 32
                                u = sha3(mem[0])
                                while _29136 + stor10[address(arg3)][u].field_1 > t:
                                    mem[t + 32] = uint256(stor1[u])
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                mem[_29070] = _29136
                                mem[_29070 + 32] = stor10[address(arg3)][u].field_256
                                mem[_29070 + 64] = stor10[address(arg3)][u].field_512
                                mem[_29070 + 96] = stor10[address(arg3)][u].field_768
                                mem[t] = _29070
                                t = t + 32
                                u = u + 1
                                continue 
                            if not stor10[address(arg3)][idx].field_0 - (stor10[address(arg3)][idx].field_1 < 32):
                                revert with 0, 34
                            _29160 = mem[64]
                            mem[64] = mem[64] + ceil32(stor10[address(arg3)][idx].field_1) + 32
                            mem[_29160] = stor10[address(arg3)][idx].field_1
                            if stor10[address(arg3)][idx].field_0:
                                if not stor10[address(arg3)][idx].field_0 - (uint255(stor10[address(arg3)][idx].field_0) * 0.5 < 32):
                                    revert with 0, 34
                                if not Mask(256, -1, stor10[address(arg3)][idx].field_0):
                                    mem[_29070] = _29160
                                    mem[_29070 + 32] = stor10[address(arg3)][idx].field_256
                                    mem[_29070 + 64] = stor10[address(arg3)][idx].field_512
                                    mem[_29070 + 96] = stor10[address(arg3)][idx].field_768
                                    mem[s] = _29070
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                if 31 >= uint255(stor10[address(arg3)][idx].field_0) * 0.5:
                                    mem[_29160 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                    mem[_29070] = _29160
                                    mem[_29070 + 32] = stor10[address(arg3)][idx].field_256
                                    mem[_29070 + 64] = stor10[address(arg3)][idx].field_512
                                    mem[_29070 + 96] = stor10[address(arg3)][idx].field_768
                                    mem[s] = _29070
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                mem[_29160 + 32] = stor10[address(arg3)][idx].field_0
                                t = _29160 + 32
                                u = sha3(mem[0])
                                while _29160 + (uint255(stor10[address(arg3)][u].field_0) * 0.5) > t:
                                    mem[t + 32] = uint256(stor1[u])
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                mem[_29070] = _29160
                                mem[_29070 + 32] = stor10[address(arg3)][u].field_256
                                mem[_29070 + 64] = stor10[address(arg3)][u].field_512
                                mem[_29070 + 96] = stor10[address(arg3)][u].field_768
                                mem[t] = _29070
                                t = t + 32
                                u = u + 1
                                continue 
                            if not stor10[address(arg3)][idx].field_0 - (stor10[address(arg3)][idx].field_1 < 32):
                                revert with 0, 34
                            if stor10[address(arg3)][idx].field_1:
                                if 31 >= stor10[address(arg3)][idx].field_1:
                                    mem[_29160 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                else:
                                    mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                    mem[_29160 + 32] = stor10[address(arg3)][idx].field_0
                                    t = _29160 + 32
                                    u = sha3(mem[0])
                                    while _29160 + stor10[address(arg3)][idx].field_1 > t:
                                        mem[t + 32] = uint256(stor1[u])
                                        t = t + 32
                                        u = u + 1
                                        continue 
                            mem[_29070] = _29160
                            mem[_29070 + 32] = stor10[address(arg3)][idx].field_256
                            mem[_29070 + 64] = stor10[address(arg3)][idx].field_512
                            mem[_29070 + 96] = stor10[address(arg3)][idx].field_768
                            mem[s] = _29070
                            s = s + 32
                            idx = idx + 1
                            continue 
                        if address(arg1) != address(arg3):
                            if mem[ceil32(ceil32(arg2.length)) + 225] <= 1:
                                if mem[_22444] > 0:
                                    if _referrals[address(arg1)] != address(arg3):
                                        _referrals[address(arg1)] = address(arg3)
                                        sub_989baf69[address(arg3)].field_0++
                                        sub_989baf69[address(arg3)][sub_989baf69[address(arg3)].field_0].field_0 = address(arg1)
                                    if tokenAddress != msg.sender:
                                        if gateKeeperAddress != msg.sender:
                                            if address(stor0.field_0) != msg.sender:
                                                revert with 0, 'NodeManagerV2: NOT AUTHORIZED'
                                    if stor10[stor11[address(arg1)]].field_0:
                                        if not -referralBonusPercent:
                                            sub_e27e434a[stor11[address(arg1)]][address(arg1)] = 0
                                            if sub_666755bb[stor11[address(arg1)]] > -1:
                                                revert with 0, 17
                                        else:
                                            if referralBonusPercent and nodePrice > -1 / referralBonusPercent:
                                                revert with 0, 17
                                            if not referralBonusPercent:
                                                revert with 0, 18
                                            if referralBonusPercent * nodePrice / referralBonusPercent != nodePrice:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            sub_e27e434a[stor11[address(arg1)]][address(arg1)] = referralBonusPercent * nodePrice / 100
                                            if sub_666755bb[stor11[address(arg1)]] > !(referralBonusPercent * nodePrice / 100):
                                                revert with 0, 17
                                            sub_666755bb[stor11[address(arg1)]] += referralBonusPercent * nodePrice / 100
            else:
                stor10[address(arg1)][stor10[address(arg1)].field_0].field_0 = 0
                idx = 0
                while stor10[address(arg1)][stor10[address(arg1)].field_0].field_1 + 31 / 32 > idx:
                    stor10[address(arg1)][(4 * stor10[address(arg1)].field_0) + idx].field_0 = 0
                    idx = idx + 1
                    continue 
                stor10[address(arg1)][stor10[address(arg1)].field_0].field_256 = block.timestamp
                stor10[address(arg1)][stor10[address(arg1)].field_0].field_512 = block.timestamp
                stor10[address(arg1)][stor10[address(arg1)].field_0].field_768 = 0
                mem[ceil32(ceil32(arg2.length)) + 229] = 6
                mem[ceil32(ceil32(arg2.length)) + 261] = address(arg1)
                mem[ceil32(ceil32(arg2.length)) + 293] = stor10[address(arg1)].field_0
                require ext_code.size(0x4b7a346b17572634bdbd85b98abae32c5fa837bb)
                delegate 0x4b7a346b17572634bdbd85b98abae32c5fa837bb.0xbc2b405c with:
                     gas gas_remaining wei
                    args 6, address(arg1), stor10[address(arg1)].field_0
                if not delegate.return_code:
                    revert with ext_call.return_data[0 len return_data.size]
                if not totalNodesCreated + 1:
                    revert with 0, 17
                totalNodesCreated++
                if msg.sender == tokenAddress:
                    mem[0] = address(arg1)
                    mem[64] = ceil32(ceil32(arg2.length)) + (32 * stor10[address(arg1)].field_0) + 257
                    mem[ceil32(ceil32(arg2.length)) + 225] = stor10[address(arg1)].field_0
                    s = ceil32(ceil32(arg2.length)) + 257
                    idx = 0
                    while idx < stor10[address(arg1)].field_0:
                        mem[0] = sha3(address(arg1), 10)
                        _15178 = mem[64]
                        mem[64] = mem[64] + 128
                        if stor10[address(arg1)][idx].field_0:
                            if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                                revert with 0, 34
                            _15544 = mem[64]
                            mem[64] = mem[64] + ceil32(uint255(stor10[address(arg1)][idx].field_0) * 0.5) + 32
                            mem[_15544] = uint255(stor10[address(arg1)][idx].field_0) * 0.5
                            if stor10[address(arg1)][idx].field_0:
                                if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                                    revert with 0, 34
                                if Mask(256, -1, stor10[address(arg1)][idx].field_0):
                                    if 31 >= uint255(stor10[address(arg1)][idx].field_0) * 0.5:
                                        mem[_15544 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                    else:
                                        mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                        mem[_15544 + 32] = stor10[address(arg1)][idx].field_0
                                        t = _15544 + 32
                                        u = sha3(mem[0])
                                        while _15544 + (uint255(stor10[address(arg1)][idx].field_0) * 0.5) > t:
                                            mem[t + 32] = uint256(stor1[u])
                                            t = t + 32
                                            u = u + 1
                                            continue 
                                mem[_15178] = _15544
                                mem[_15178 + 32] = stor10[address(arg1)][idx].field_256
                                mem[_15178 + 64] = stor10[address(arg1)][idx].field_512
                                mem[_15178 + 96] = stor10[address(arg1)][idx].field_768
                                mem[s] = _15178
                                s = s + 32
                                idx = idx + 1
                                continue 
                            if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                                revert with 0, 34
                            if not stor10[address(arg1)][idx].field_1:
                                mem[_15178] = _15544
                                mem[_15178 + 32] = stor10[address(arg1)][idx].field_256
                                mem[_15178 + 64] = stor10[address(arg1)][idx].field_512
                                mem[_15178 + 96] = stor10[address(arg1)][idx].field_768
                                mem[s] = _15178
                                s = s + 32
                                idx = idx + 1
                                continue 
                            if 31 >= stor10[address(arg1)][idx].field_1:
                                mem[_15544 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                mem[_15178] = _15544
                                mem[_15178 + 32] = stor10[address(arg1)][idx].field_256
                                mem[_15178 + 64] = stor10[address(arg1)][idx].field_512
                                mem[_15178 + 96] = stor10[address(arg1)][idx].field_768
                                mem[s] = _15178
                                s = s + 32
                                idx = idx + 1
                                continue 
                            mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                            mem[_15544 + 32] = stor10[address(arg1)][idx].field_0
                            t = _15544 + 32
                            u = sha3(mem[0])
                            while _15544 + stor10[address(arg1)][u].field_1 > t:
                                mem[t + 32] = uint256(stor1[u])
                                t = t + 32
                                u = u + 1
                                continue 
                            mem[_15178] = _15544
                            mem[_15178 + 32] = stor10[address(arg1)][u].field_256
                            mem[_15178 + 64] = stor10[address(arg1)][u].field_512
                            mem[_15178 + 96] = stor10[address(arg1)][u].field_768
                            mem[t] = _15178
                            t = t + 32
                            u = u + 1
                            continue 
                        if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                            revert with 0, 34
                        _15614 = mem[64]
                        mem[64] = mem[64] + ceil32(stor10[address(arg1)][idx].field_1) + 32
                        mem[_15614] = stor10[address(arg1)][idx].field_1
                        if stor10[address(arg1)][idx].field_0:
                            if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                                revert with 0, 34
                            if not Mask(256, -1, stor10[address(arg1)][idx].field_0):
                                mem[_15178] = _15614
                                mem[_15178 + 32] = stor10[address(arg1)][idx].field_256
                                mem[_15178 + 64] = stor10[address(arg1)][idx].field_512
                                mem[_15178 + 96] = stor10[address(arg1)][idx].field_768
                                mem[s] = _15178
                                s = s + 32
                                idx = idx + 1
                                continue 
                            if 31 >= uint255(stor10[address(arg1)][idx].field_0) * 0.5:
                                mem[_15614 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                mem[_15178] = _15614
                                mem[_15178 + 32] = stor10[address(arg1)][idx].field_256
                                mem[_15178 + 64] = stor10[address(arg1)][idx].field_512
                                mem[_15178 + 96] = stor10[address(arg1)][idx].field_768
                                mem[s] = _15178
                                s = s + 32
                                idx = idx + 1
                                continue 
                            mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                            mem[_15614 + 32] = stor10[address(arg1)][idx].field_0
                            t = _15614 + 32
                            u = sha3(mem[0])
                            while _15614 + (uint255(stor10[address(arg1)][u].field_0) * 0.5) > t:
                                mem[t + 32] = uint256(stor1[u])
                                t = t + 32
                                u = u + 1
                                continue 
                            mem[_15178] = _15614
                            mem[_15178 + 32] = stor10[address(arg1)][u].field_256
                            mem[_15178 + 64] = stor10[address(arg1)][u].field_512
                            mem[_15178 + 96] = stor10[address(arg1)][u].field_768
                            mem[t] = _15178
                            t = t + 32
                            u = u + 1
                            continue 
                        if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                            revert with 0, 34
                        if stor10[address(arg1)][idx].field_1:
                            if 31 >= stor10[address(arg1)][idx].field_1:
                                mem[_15614 + 32] = 256 * stor10[address(arg1)][idx].field_8
                            else:
                                mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                mem[_15614 + 32] = stor10[address(arg1)][idx].field_0
                                t = _15614 + 32
                                u = sha3(mem[0])
                                while _15614 + stor10[address(arg1)][idx].field_1 > t:
                                    mem[t + 32] = uint256(stor1[u])
                                    t = t + 32
                                    u = u + 1
                                    continue 
                        mem[_15178] = _15614
                        mem[_15178 + 32] = stor10[address(arg1)][idx].field_256
                        mem[_15178 + 64] = stor10[address(arg1)][idx].field_512
                        mem[_15178 + 96] = stor10[address(arg1)][idx].field_768
                        mem[s] = _15178
                        s = s + 32
                        idx = idx + 1
                        continue 
                    mem[0] = address(arg3)
                    mem[32] = 10
                    _15176 = mem[64]
                    mem[64] = mem[64] + (32 * stor10[address(arg3)].field_0) + 32
                    mem[_15176] = stor10[address(arg3)].field_0
                    s = _15176 + 32
                    idx = 0
                    while idx < stor10[address(arg3)].field_0:
                        mem[0] = sha3(address(arg3), 10)
                        _22454 = mem[64]
                        mem[64] = mem[64] + 128
                        if stor10[address(arg3)][idx].field_0:
                            if not stor10[address(arg3)][idx].field_0 - (uint255(stor10[address(arg3)][idx].field_0) * 0.5 < 32):
                                revert with 0, 34
                            _22762 = mem[64]
                            mem[64] = mem[64] + ceil32(uint255(stor10[address(arg3)][idx].field_0) * 0.5) + 32
                            mem[_22762] = uint255(stor10[address(arg3)][idx].field_0) * 0.5
                            if stor10[address(arg3)][idx].field_0:
                                if not stor10[address(arg3)][idx].field_0 - (uint255(stor10[address(arg3)][idx].field_0) * 0.5 < 32):
                                    revert with 0, 34
                                if Mask(256, -1, stor10[address(arg3)][idx].field_0):
                                    if 31 >= uint255(stor10[address(arg3)][idx].field_0) * 0.5:
                                        mem[_22762 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                    else:
                                        mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                        mem[_22762 + 32] = stor10[address(arg3)][idx].field_0
                                        t = _22762 + 32
                                        u = sha3(mem[0])
                                        while _22762 + (uint255(stor10[address(arg3)][idx].field_0) * 0.5) > t:
                                            mem[t + 32] = uint256(stor1[u])
                                            t = t + 32
                                            u = u + 1
                                            continue 
                                mem[_22454] = _22762
                                mem[_22454 + 32] = stor10[address(arg3)][idx].field_256
                                mem[_22454 + 64] = stor10[address(arg3)][idx].field_512
                                mem[_22454 + 96] = stor10[address(arg3)][idx].field_768
                                mem[s] = _22454
                                s = s + 32
                                idx = idx + 1
                                continue 
                            if not stor10[address(arg3)][idx].field_0 - (stor10[address(arg3)][idx].field_1 < 32):
                                revert with 0, 34
                            if not stor10[address(arg3)][idx].field_1:
                                mem[_22454] = _22762
                                mem[_22454 + 32] = stor10[address(arg3)][idx].field_256
                                mem[_22454 + 64] = stor10[address(arg3)][idx].field_512
                                mem[_22454 + 96] = stor10[address(arg3)][idx].field_768
                                mem[s] = _22454
                                s = s + 32
                                idx = idx + 1
                                continue 
                            if 31 >= stor10[address(arg3)][idx].field_1:
                                mem[_22762 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                mem[_22454] = _22762
                                mem[_22454 + 32] = stor10[address(arg3)][idx].field_256
                                mem[_22454 + 64] = stor10[address(arg3)][idx].field_512
                                mem[_22454 + 96] = stor10[address(arg3)][idx].field_768
                                mem[s] = _22454
                                s = s + 32
                                idx = idx + 1
                                continue 
                            mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                            mem[_22762 + 32] = stor10[address(arg3)][idx].field_0
                            t = _22762 + 32
                            u = sha3(mem[0])
                            while _22762 + stor10[address(arg3)][u].field_1 > t:
                                mem[t + 32] = uint256(stor1[u])
                                t = t + 32
                                u = u + 1
                                continue 
                            mem[_22454] = _22762
                            mem[_22454 + 32] = stor10[address(arg3)][u].field_256
                            mem[_22454 + 64] = stor10[address(arg3)][u].field_512
                            mem[_22454 + 96] = stor10[address(arg3)][u].field_768
                            mem[t] = _22454
                            t = t + 32
                            u = u + 1
                            continue 
                        if not stor10[address(arg3)][idx].field_0 - (stor10[address(arg3)][idx].field_1 < 32):
                            revert with 0, 34
                        _22856 = mem[64]
                        mem[64] = mem[64] + ceil32(stor10[address(arg3)][idx].field_1) + 32
                        mem[_22856] = stor10[address(arg3)][idx].field_1
                        if stor10[address(arg3)][idx].field_0:
                            if not stor10[address(arg3)][idx].field_0 - (uint255(stor10[address(arg3)][idx].field_0) * 0.5 < 32):
                                revert with 0, 34
                            if not Mask(256, -1, stor10[address(arg3)][idx].field_0):
                                mem[_22454] = _22856
                                mem[_22454 + 32] = stor10[address(arg3)][idx].field_256
                                mem[_22454 + 64] = stor10[address(arg3)][idx].field_512
                                mem[_22454 + 96] = stor10[address(arg3)][idx].field_768
                                mem[s] = _22454
                                s = s + 32
                                idx = idx + 1
                                continue 
                            if 31 >= uint255(stor10[address(arg3)][idx].field_0) * 0.5:
                                mem[_22856 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                mem[_22454] = _22856
                                mem[_22454 + 32] = stor10[address(arg3)][idx].field_256
                                mem[_22454 + 64] = stor10[address(arg3)][idx].field_512
                                mem[_22454 + 96] = stor10[address(arg3)][idx].field_768
                                mem[s] = _22454
                                s = s + 32
                                idx = idx + 1
                                continue 
                            mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                            mem[_22856 + 32] = stor10[address(arg3)][idx].field_0
                            t = _22856 + 32
                            u = sha3(mem[0])
                            while _22856 + (uint255(stor10[address(arg3)][u].field_0) * 0.5) > t:
                                mem[t + 32] = uint256(stor1[u])
                                t = t + 32
                                u = u + 1
                                continue 
                            mem[_22454] = _22856
                            mem[_22454 + 32] = stor10[address(arg3)][u].field_256
                            mem[_22454 + 64] = stor10[address(arg3)][u].field_512
                            mem[_22454 + 96] = stor10[address(arg3)][u].field_768
                            mem[t] = _22454
                            t = t + 32
                            u = u + 1
                            continue 
                        if not stor10[address(arg3)][idx].field_0 - (stor10[address(arg3)][idx].field_1 < 32):
                            revert with 0, 34
                        if stor10[address(arg3)][idx].field_1:
                            if 31 >= stor10[address(arg3)][idx].field_1:
                                mem[_22856 + 32] = 256 * stor10[address(arg3)][idx].field_8
                            else:
                                mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                mem[_22856 + 32] = stor10[address(arg3)][idx].field_0
                                t = _22856 + 32
                                u = sha3(mem[0])
                                while _22856 + stor10[address(arg3)][idx].field_1 > t:
                                    mem[t + 32] = uint256(stor1[u])
                                    t = t + 32
                                    u = u + 1
                                    continue 
                        mem[_22454] = _22856
                        mem[_22454 + 32] = stor10[address(arg3)][idx].field_256
                        mem[_22454 + 64] = stor10[address(arg3)][idx].field_512
                        mem[_22454 + 96] = stor10[address(arg3)][idx].field_768
                        mem[s] = _22454
                        s = s + 32
                        idx = idx + 1
                        continue 
                    if address(arg1) != address(arg3):
                        if mem[ceil32(ceil32(arg2.length)) + 225] <= 1:
                            if mem[_15176] > 0:
                                if _referrals[address(arg1)] != address(arg3):
                                    _referrals[address(arg1)] = address(arg3)
                                    sub_989baf69[address(arg3)].field_0++
                                    sub_989baf69[address(arg3)][sub_989baf69[address(arg3)].field_0].field_0 = address(arg1)
                                if tokenAddress != msg.sender:
                                    if gateKeeperAddress != msg.sender:
                                        if address(stor0.field_0) != msg.sender:
                                            revert with 0, 'NodeManagerV2: NOT AUTHORIZED'
                                if stor10[stor11[address(arg1)]].field_0:
                                    if not -referralBonusPercent:
                                        sub_e27e434a[stor11[address(arg1)]][address(arg1)] = 0
                                        if sub_666755bb[stor11[address(arg1)]] > -1:
                                            revert with 0, 17
                                    else:
                                        if referralBonusPercent and nodePrice > -1 / referralBonusPercent:
                                            revert with 0, 17
                                        if not referralBonusPercent:
                                            revert with 0, 18
                                        if referralBonusPercent * nodePrice / referralBonusPercent != nodePrice:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        sub_e27e434a[stor11[address(arg1)]][address(arg1)] = referralBonusPercent * nodePrice / 100
                                        if sub_666755bb[stor11[address(arg1)]] > !(referralBonusPercent * nodePrice / 100):
                                            revert with 0, 17
                                        sub_666755bb[stor11[address(arg1)]] += referralBonusPercent * nodePrice / 100
                else:
                    if msg.sender == gateKeeperAddress:
                        mem[0] = address(arg1)
                        mem[64] = ceil32(ceil32(arg2.length)) + (32 * stor10[address(arg1)].field_0) + 257
                        mem[ceil32(ceil32(arg2.length)) + 225] = stor10[address(arg1)].field_0
                        s = ceil32(ceil32(arg2.length)) + 257
                        idx = 0
                        while idx < stor10[address(arg1)].field_0:
                            mem[0] = sha3(address(arg1), 10)
                            _15182 = mem[64]
                            mem[64] = mem[64] + 128
                            if stor10[address(arg1)][idx].field_0:
                                if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                                    revert with 0, 34
                                _15545 = mem[64]
                                mem[64] = mem[64] + ceil32(uint255(stor10[address(arg1)][idx].field_0) * 0.5) + 32
                                mem[_15545] = uint255(stor10[address(arg1)][idx].field_0) * 0.5
                                if stor10[address(arg1)][idx].field_0:
                                    if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                                        revert with 0, 34
                                    if Mask(256, -1, stor10[address(arg1)][idx].field_0):
                                        if 31 >= uint255(stor10[address(arg1)][idx].field_0) * 0.5:
                                            mem[_15545 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                        else:
                                            mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                            mem[_15545 + 32] = stor10[address(arg1)][idx].field_0
                                            t = _15545 + 32
                                            u = sha3(mem[0])
                                            while _15545 + (uint255(stor10[address(arg1)][idx].field_0) * 0.5) > t:
                                                mem[t + 32] = uint256(stor1[u])
                                                t = t + 32
                                                u = u + 1
                                                continue 
                                    mem[_15182] = _15545
                                    mem[_15182 + 32] = stor10[address(arg1)][idx].field_256
                                    mem[_15182 + 64] = stor10[address(arg1)][idx].field_512
                                    mem[_15182 + 96] = stor10[address(arg1)][idx].field_768
                                    mem[s] = _15182
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                                    revert with 0, 34
                                if not stor10[address(arg1)][idx].field_1:
                                    mem[_15182] = _15545
                                    mem[_15182 + 32] = stor10[address(arg1)][idx].field_256
                                    mem[_15182 + 64] = stor10[address(arg1)][idx].field_512
                                    mem[_15182 + 96] = stor10[address(arg1)][idx].field_768
                                    mem[s] = _15182
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                if 31 >= stor10[address(arg1)][idx].field_1:
                                    mem[_15545 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                    mem[_15182] = _15545
                                    mem[_15182 + 32] = stor10[address(arg1)][idx].field_256
                                    mem[_15182 + 64] = stor10[address(arg1)][idx].field_512
                                    mem[_15182 + 96] = stor10[address(arg1)][idx].field_768
                                    mem[s] = _15182
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                mem[_15545 + 32] = stor10[address(arg1)][idx].field_0
                                t = _15545 + 32
                                u = sha3(mem[0])
                                while _15545 + stor10[address(arg1)][u].field_1 > t:
                                    mem[t + 32] = uint256(stor1[u])
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                mem[_15182] = _15545
                                mem[_15182 + 32] = stor10[address(arg1)][u].field_256
                                mem[_15182 + 64] = stor10[address(arg1)][u].field_512
                                mem[_15182 + 96] = stor10[address(arg1)][u].field_768
                                mem[t] = _15182
                                t = t + 32
                                u = u + 1
                                continue 
                            if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                                revert with 0, 34
                            _15616 = mem[64]
                            mem[64] = mem[64] + ceil32(stor10[address(arg1)][idx].field_1) + 32
                            mem[_15616] = stor10[address(arg1)][idx].field_1
                            if stor10[address(arg1)][idx].field_0:
                                if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                                    revert with 0, 34
                                if not Mask(256, -1, stor10[address(arg1)][idx].field_0):
                                    mem[_15182] = _15616
                                    mem[_15182 + 32] = stor10[address(arg1)][idx].field_256
                                    mem[_15182 + 64] = stor10[address(arg1)][idx].field_512
                                    mem[_15182 + 96] = stor10[address(arg1)][idx].field_768
                                    mem[s] = _15182
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                if 31 >= uint255(stor10[address(arg1)][idx].field_0) * 0.5:
                                    mem[_15616 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                    mem[_15182] = _15616
                                    mem[_15182 + 32] = stor10[address(arg1)][idx].field_256
                                    mem[_15182 + 64] = stor10[address(arg1)][idx].field_512
                                    mem[_15182 + 96] = stor10[address(arg1)][idx].field_768
                                    mem[s] = _15182
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                mem[_15616 + 32] = stor10[address(arg1)][idx].field_0
                                t = _15616 + 32
                                u = sha3(mem[0])
                                while _15616 + (uint255(stor10[address(arg1)][u].field_0) * 0.5) > t:
                                    mem[t + 32] = uint256(stor1[u])
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                mem[_15182] = _15616
                                mem[_15182 + 32] = stor10[address(arg1)][u].field_256
                                mem[_15182 + 64] = stor10[address(arg1)][u].field_512
                                mem[_15182 + 96] = stor10[address(arg1)][u].field_768
                                mem[t] = _15182
                                t = t + 32
                                u = u + 1
                                continue 
                            if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                                revert with 0, 34
                            if stor10[address(arg1)][idx].field_1:
                                if 31 >= stor10[address(arg1)][idx].field_1:
                                    mem[_15616 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                else:
                                    mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                    mem[_15616 + 32] = stor10[address(arg1)][idx].field_0
                                    t = _15616 + 32
                                    u = sha3(mem[0])
                                    while _15616 + stor10[address(arg1)][idx].field_1 > t:
                                        mem[t + 32] = uint256(stor1[u])
                                        t = t + 32
                                        u = u + 1
                                        continue 
                            mem[_15182] = _15616
                            mem[_15182 + 32] = stor10[address(arg1)][idx].field_256
                            mem[_15182 + 64] = stor10[address(arg1)][idx].field_512
                            mem[_15182 + 96] = stor10[address(arg1)][idx].field_768
                            mem[s] = _15182
                            s = s + 32
                            idx = idx + 1
                            continue 
                        mem[0] = address(arg3)
                        mem[32] = 10
                        _15180 = mem[64]
                        mem[64] = mem[64] + (32 * stor10[address(arg3)].field_0) + 32
                        mem[_15180] = stor10[address(arg3)].field_0
                        s = _15180 + 32
                        idx = 0
                        while idx < stor10[address(arg3)].field_0:
                            mem[0] = sha3(address(arg3), 10)
                            _22456 = mem[64]
                            mem[64] = mem[64] + 128
                            if stor10[address(arg3)][idx].field_0:
                                if not stor10[address(arg3)][idx].field_0 - (uint255(stor10[address(arg3)][idx].field_0) * 0.5 < 32):
                                    revert with 0, 34
                                _22763 = mem[64]
                                mem[64] = mem[64] + ceil32(uint255(stor10[address(arg3)][idx].field_0) * 0.5) + 32
                                mem[_22763] = uint255(stor10[address(arg3)][idx].field_0) * 0.5
                                if stor10[address(arg3)][idx].field_0:
                                    if not stor10[address(arg3)][idx].field_0 - (uint255(stor10[address(arg3)][idx].field_0) * 0.5 < 32):
                                        revert with 0, 34
                                    if Mask(256, -1, stor10[address(arg3)][idx].field_0):
                                        if 31 >= uint255(stor10[address(arg3)][idx].field_0) * 0.5:
                                            mem[_22763 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                        else:
                                            mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                            mem[_22763 + 32] = stor10[address(arg3)][idx].field_0
                                            t = _22763 + 32
                                            u = sha3(mem[0])
                                            while _22763 + (uint255(stor10[address(arg3)][idx].field_0) * 0.5) > t:
                                                mem[t + 32] = uint256(stor1[u])
                                                t = t + 32
                                                u = u + 1
                                                continue 
                                    mem[_22456] = _22763
                                    mem[_22456 + 32] = stor10[address(arg3)][idx].field_256
                                    mem[_22456 + 64] = stor10[address(arg3)][idx].field_512
                                    mem[_22456 + 96] = stor10[address(arg3)][idx].field_768
                                    mem[s] = _22456
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                if not stor10[address(arg3)][idx].field_0 - (stor10[address(arg3)][idx].field_1 < 32):
                                    revert with 0, 34
                                if not stor10[address(arg3)][idx].field_1:
                                    mem[_22456] = _22763
                                    mem[_22456 + 32] = stor10[address(arg3)][idx].field_256
                                    mem[_22456 + 64] = stor10[address(arg3)][idx].field_512
                                    mem[_22456 + 96] = stor10[address(arg3)][idx].field_768
                                    mem[s] = _22456
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                if 31 >= stor10[address(arg3)][idx].field_1:
                                    mem[_22763 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                    mem[_22456] = _22763
                                    mem[_22456 + 32] = stor10[address(arg3)][idx].field_256
                                    mem[_22456 + 64] = stor10[address(arg3)][idx].field_512
                                    mem[_22456 + 96] = stor10[address(arg3)][idx].field_768
                                    mem[s] = _22456
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                mem[_22763 + 32] = stor10[address(arg3)][idx].field_0
                                t = _22763 + 32
                                u = sha3(mem[0])
                                while _22763 + stor10[address(arg3)][u].field_1 > t:
                                    mem[t + 32] = uint256(stor1[u])
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                mem[_22456] = _22763
                                mem[_22456 + 32] = stor10[address(arg3)][u].field_256
                                mem[_22456 + 64] = stor10[address(arg3)][u].field_512
                                mem[_22456 + 96] = stor10[address(arg3)][u].field_768
                                mem[t] = _22456
                                t = t + 32
                                u = u + 1
                                continue 
                            if not stor10[address(arg3)][idx].field_0 - (stor10[address(arg3)][idx].field_1 < 32):
                                revert with 0, 34
                            _22858 = mem[64]
                            mem[64] = mem[64] + ceil32(stor10[address(arg3)][idx].field_1) + 32
                            mem[_22858] = stor10[address(arg3)][idx].field_1
                            if stor10[address(arg3)][idx].field_0:
                                if not stor10[address(arg3)][idx].field_0 - (uint255(stor10[address(arg3)][idx].field_0) * 0.5 < 32):
                                    revert with 0, 34
                                if not Mask(256, -1, stor10[address(arg3)][idx].field_0):
                                    mem[_22456] = _22858
                                    mem[_22456 + 32] = stor10[address(arg3)][idx].field_256
                                    mem[_22456 + 64] = stor10[address(arg3)][idx].field_512
                                    mem[_22456 + 96] = stor10[address(arg3)][idx].field_768
                                    mem[s] = _22456
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                if 31 >= uint255(stor10[address(arg3)][idx].field_0) * 0.5:
                                    mem[_22858 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                    mem[_22456] = _22858
                                    mem[_22456 + 32] = stor10[address(arg3)][idx].field_256
                                    mem[_22456 + 64] = stor10[address(arg3)][idx].field_512
                                    mem[_22456 + 96] = stor10[address(arg3)][idx].field_768
                                    mem[s] = _22456
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                mem[_22858 + 32] = stor10[address(arg3)][idx].field_0
                                t = _22858 + 32
                                u = sha3(mem[0])
                                while _22858 + (uint255(stor10[address(arg3)][u].field_0) * 0.5) > t:
                                    mem[t + 32] = uint256(stor1[u])
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                mem[_22456] = _22858
                                mem[_22456 + 32] = stor10[address(arg3)][u].field_256
                                mem[_22456 + 64] = stor10[address(arg3)][u].field_512
                                mem[_22456 + 96] = stor10[address(arg3)][u].field_768
                                mem[t] = _22456
                                t = t + 32
                                u = u + 1
                                continue 
                            if not stor10[address(arg3)][idx].field_0 - (stor10[address(arg3)][idx].field_1 < 32):
                                revert with 0, 34
                            if stor10[address(arg3)][idx].field_1:
                                if 31 >= stor10[address(arg3)][idx].field_1:
                                    mem[_22858 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                else:
                                    mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                    mem[_22858 + 32] = stor10[address(arg3)][idx].field_0
                                    t = _22858 + 32
                                    u = sha3(mem[0])
                                    while _22858 + stor10[address(arg3)][idx].field_1 > t:
                                        mem[t + 32] = uint256(stor1[u])
                                        t = t + 32
                                        u = u + 1
                                        continue 
                            mem[_22456] = _22858
                            mem[_22456 + 32] = stor10[address(arg3)][idx].field_256
                            mem[_22456 + 64] = stor10[address(arg3)][idx].field_512
                            mem[_22456 + 96] = stor10[address(arg3)][idx].field_768
                            mem[s] = _22456
                            s = s + 32
                            idx = idx + 1
                            continue 
                        if address(arg1) != address(arg3):
                            if mem[ceil32(ceil32(arg2.length)) + 225] <= 1:
                                if mem[_15180] > 0:
                                    if _referrals[address(arg1)] != address(arg3):
                                        _referrals[address(arg1)] = address(arg3)
                                        sub_989baf69[address(arg3)].field_0++
                                        sub_989baf69[address(arg3)][sub_989baf69[address(arg3)].field_0].field_0 = address(arg1)
                                    if tokenAddress != msg.sender:
                                        if gateKeeperAddress != msg.sender:
                                            if address(stor0.field_0) != msg.sender:
                                                revert with 0, 'NodeManagerV2: NOT AUTHORIZED'
                                    if stor10[stor11[address(arg1)]].field_0:
                                        if not -referralBonusPercent:
                                            sub_e27e434a[stor11[address(arg1)]][address(arg1)] = 0
                                            if sub_666755bb[stor11[address(arg1)]] > -1:
                                                revert with 0, 17
                                        else:
                                            if referralBonusPercent and nodePrice > -1 / referralBonusPercent:
                                                revert with 0, 17
                                            if not referralBonusPercent:
                                                revert with 0, 18
                                            if referralBonusPercent * nodePrice / referralBonusPercent != nodePrice:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            sub_e27e434a[stor11[address(arg1)]][address(arg1)] = referralBonusPercent * nodePrice / 100
                                            if sub_666755bb[stor11[address(arg1)]] > !(referralBonusPercent * nodePrice / 100):
                                                revert with 0, 17
                                            sub_666755bb[stor11[address(arg1)]] += referralBonusPercent * nodePrice / 100
                    else:
                        if address(stor0.field_0) != msg.sender:
                            revert with 0, 'NodeManagerV2: NOT AUTHORIZED'
                        mem[0] = address(arg1)
                        mem[64] = ceil32(ceil32(arg2.length)) + (32 * stor10[address(arg1)].field_0) + 257
                        mem[ceil32(ceil32(arg2.length)) + 225] = stor10[address(arg1)].field_0
                        s = ceil32(ceil32(arg2.length)) + 257
                        idx = 0
                        while idx < stor10[address(arg1)].field_0:
                            mem[0] = sha3(address(arg1), 10)
                            _15186 = mem[64]
                            mem[64] = mem[64] + 128
                            if stor10[address(arg1)][idx].field_0:
                                if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                                    revert with 0, 34
                                _15546 = mem[64]
                                mem[64] = mem[64] + ceil32(uint255(stor10[address(arg1)][idx].field_0) * 0.5) + 32
                                mem[_15546] = uint255(stor10[address(arg1)][idx].field_0) * 0.5
                                if stor10[address(arg1)][idx].field_0:
                                    if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                                        revert with 0, 34
                                    if Mask(256, -1, stor10[address(arg1)][idx].field_0):
                                        if 31 >= uint255(stor10[address(arg1)][idx].field_0) * 0.5:
                                            mem[_15546 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                        else:
                                            mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                            mem[_15546 + 32] = stor10[address(arg1)][idx].field_0
                                            t = _15546 + 32
                                            u = sha3(mem[0])
                                            while _15546 + (uint255(stor10[address(arg1)][idx].field_0) * 0.5) > t:
                                                mem[t + 32] = uint256(stor1[u])
                                                t = t + 32
                                                u = u + 1
                                                continue 
                                    mem[_15186] = _15546
                                    mem[_15186 + 32] = stor10[address(arg1)][idx].field_256
                                    mem[_15186 + 64] = stor10[address(arg1)][idx].field_512
                                    mem[_15186 + 96] = stor10[address(arg1)][idx].field_768
                                    mem[s] = _15186
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                                    revert with 0, 34
                                if not stor10[address(arg1)][idx].field_1:
                                    mem[_15186] = _15546
                                    mem[_15186 + 32] = stor10[address(arg1)][idx].field_256
                                    mem[_15186 + 64] = stor10[address(arg1)][idx].field_512
                                    mem[_15186 + 96] = stor10[address(arg1)][idx].field_768
                                    mem[s] = _15186
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                if 31 >= stor10[address(arg1)][idx].field_1:
                                    mem[_15546 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                    mem[_15186] = _15546
                                    mem[_15186 + 32] = stor10[address(arg1)][idx].field_256
                                    mem[_15186 + 64] = stor10[address(arg1)][idx].field_512
                                    mem[_15186 + 96] = stor10[address(arg1)][idx].field_768
                                    mem[s] = _15186
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                mem[_15546 + 32] = stor10[address(arg1)][idx].field_0
                                t = _15546 + 32
                                u = sha3(mem[0])
                                while _15546 + stor10[address(arg1)][u].field_1 > t:
                                    mem[t + 32] = uint256(stor1[u])
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                mem[_15186] = _15546
                                mem[_15186 + 32] = stor10[address(arg1)][u].field_256
                                mem[_15186 + 64] = stor10[address(arg1)][u].field_512
                                mem[_15186 + 96] = stor10[address(arg1)][u].field_768
                                mem[t] = _15186
                                t = t + 32
                                u = u + 1
                                continue 
                            if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                                revert with 0, 34
                            _15618 = mem[64]
                            mem[64] = mem[64] + ceil32(stor10[address(arg1)][idx].field_1) + 32
                            mem[_15618] = stor10[address(arg1)][idx].field_1
                            if stor10[address(arg1)][idx].field_0:
                                if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                                    revert with 0, 34
                                if not Mask(256, -1, stor10[address(arg1)][idx].field_0):
                                    mem[_15186] = _15618
                                    mem[_15186 + 32] = stor10[address(arg1)][idx].field_256
                                    mem[_15186 + 64] = stor10[address(arg1)][idx].field_512
                                    mem[_15186 + 96] = stor10[address(arg1)][idx].field_768
                                    mem[s] = _15186
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                if 31 >= uint255(stor10[address(arg1)][idx].field_0) * 0.5:
                                    mem[_15618 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                    mem[_15186] = _15618
                                    mem[_15186 + 32] = stor10[address(arg1)][idx].field_256
                                    mem[_15186 + 64] = stor10[address(arg1)][idx].field_512
                                    mem[_15186 + 96] = stor10[address(arg1)][idx].field_768
                                    mem[s] = _15186
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                mem[_15618 + 32] = stor10[address(arg1)][idx].field_0
                                t = _15618 + 32
                                u = sha3(mem[0])
                                while _15618 + (uint255(stor10[address(arg1)][u].field_0) * 0.5) > t:
                                    mem[t + 32] = uint256(stor1[u])
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                mem[_15186] = _15618
                                mem[_15186 + 32] = stor10[address(arg1)][u].field_256
                                mem[_15186 + 64] = stor10[address(arg1)][u].field_512
                                mem[_15186 + 96] = stor10[address(arg1)][u].field_768
                                mem[t] = _15186
                                t = t + 32
                                u = u + 1
                                continue 
                            if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                                revert with 0, 34
                            if stor10[address(arg1)][idx].field_1:
                                if 31 >= stor10[address(arg1)][idx].field_1:
                                    mem[_15618 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                else:
                                    mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                    mem[_15618 + 32] = stor10[address(arg1)][idx].field_0
                                    t = _15618 + 32
                                    u = sha3(mem[0])
                                    while _15618 + stor10[address(arg1)][idx].field_1 > t:
                                        mem[t + 32] = uint256(stor1[u])
                                        t = t + 32
                                        u = u + 1
                                        continue 
                            mem[_15186] = _15618
                            mem[_15186 + 32] = stor10[address(arg1)][idx].field_256
                            mem[_15186 + 64] = stor10[address(arg1)][idx].field_512
                            mem[_15186 + 96] = stor10[address(arg1)][idx].field_768
                            mem[s] = _15186
                            s = s + 32
                            idx = idx + 1
                            continue 
                        mem[0] = address(arg3)
                        mem[32] = 10
                        _15184 = mem[64]
                        mem[64] = mem[64] + (32 * stor10[address(arg3)].field_0) + 32
                        mem[_15184] = stor10[address(arg3)].field_0
                        s = _15184 + 32
                        idx = 0
                        while idx < stor10[address(arg3)].field_0:
                            mem[0] = sha3(address(arg3), 10)
                            _22458 = mem[64]
                            mem[64] = mem[64] + 128
                            if stor10[address(arg3)][idx].field_0:
                                if not stor10[address(arg3)][idx].field_0 - (uint255(stor10[address(arg3)][idx].field_0) * 0.5 < 32):
                                    revert with 0, 34
                                _22764 = mem[64]
                                mem[64] = mem[64] + ceil32(uint255(stor10[address(arg3)][idx].field_0) * 0.5) + 32
                                mem[_22764] = uint255(stor10[address(arg3)][idx].field_0) * 0.5
                                if stor10[address(arg3)][idx].field_0:
                                    if not stor10[address(arg3)][idx].field_0 - (uint255(stor10[address(arg3)][idx].field_0) * 0.5 < 32):
                                        revert with 0, 34
                                    if Mask(256, -1, stor10[address(arg3)][idx].field_0):
                                        if 31 >= uint255(stor10[address(arg3)][idx].field_0) * 0.5:
                                            mem[_22764 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                        else:
                                            mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                            mem[_22764 + 32] = stor10[address(arg3)][idx].field_0
                                            t = _22764 + 32
                                            u = sha3(mem[0])
                                            while _22764 + (uint255(stor10[address(arg3)][idx].field_0) * 0.5) > t:
                                                mem[t + 32] = uint256(stor1[u])
                                                t = t + 32
                                                u = u + 1
                                                continue 
                                    mem[_22458] = _22764
                                    mem[_22458 + 32] = stor10[address(arg3)][idx].field_256
                                    mem[_22458 + 64] = stor10[address(arg3)][idx].field_512
                                    mem[_22458 + 96] = stor10[address(arg3)][idx].field_768
                                    mem[s] = _22458
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                if not stor10[address(arg3)][idx].field_0 - (stor10[address(arg3)][idx].field_1 < 32):
                                    revert with 0, 34
                                if not stor10[address(arg3)][idx].field_1:
                                    mem[_22458] = _22764
                                    mem[_22458 + 32] = stor10[address(arg3)][idx].field_256
                                    mem[_22458 + 64] = stor10[address(arg3)][idx].field_512
                                    mem[_22458 + 96] = stor10[address(arg3)][idx].field_768
                                    mem[s] = _22458
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                if 31 >= stor10[address(arg3)][idx].field_1:
                                    mem[_22764 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                    mem[_22458] = _22764
                                    mem[_22458 + 32] = stor10[address(arg3)][idx].field_256
                                    mem[_22458 + 64] = stor10[address(arg3)][idx].field_512
                                    mem[_22458 + 96] = stor10[address(arg3)][idx].field_768
                                    mem[s] = _22458
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                mem[_22764 + 32] = stor10[address(arg3)][idx].field_0
                                t = _22764 + 32
                                u = sha3(mem[0])
                                while _22764 + stor10[address(arg3)][u].field_1 > t:
                                    mem[t + 32] = uint256(stor1[u])
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                mem[_22458] = _22764
                                mem[_22458 + 32] = stor10[address(arg3)][u].field_256
                                mem[_22458 + 64] = stor10[address(arg3)][u].field_512
                                mem[_22458 + 96] = stor10[address(arg3)][u].field_768
                                mem[t] = _22458
                                t = t + 32
                                u = u + 1
                                continue 
                            if not stor10[address(arg3)][idx].field_0 - (stor10[address(arg3)][idx].field_1 < 32):
                                revert with 0, 34
                            _22860 = mem[64]
                            mem[64] = mem[64] + ceil32(stor10[address(arg3)][idx].field_1) + 32
                            mem[_22860] = stor10[address(arg3)][idx].field_1
                            if stor10[address(arg3)][idx].field_0:
                                if not stor10[address(arg3)][idx].field_0 - (uint255(stor10[address(arg3)][idx].field_0) * 0.5 < 32):
                                    revert with 0, 34
                                if not Mask(256, -1, stor10[address(arg3)][idx].field_0):
                                    mem[_22458] = _22860
                                    mem[_22458 + 32] = stor10[address(arg3)][idx].field_256
                                    mem[_22458 + 64] = stor10[address(arg3)][idx].field_512
                                    mem[_22458 + 96] = stor10[address(arg3)][idx].field_768
                                    mem[s] = _22458
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                if 31 >= uint255(stor10[address(arg3)][idx].field_0) * 0.5:
                                    mem[_22860 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                    mem[_22458] = _22860
                                    mem[_22458 + 32] = stor10[address(arg3)][idx].field_256
                                    mem[_22458 + 64] = stor10[address(arg3)][idx].field_512
                                    mem[_22458 + 96] = stor10[address(arg3)][idx].field_768
                                    mem[s] = _22458
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                mem[_22860 + 32] = stor10[address(arg3)][idx].field_0
                                t = _22860 + 32
                                u = sha3(mem[0])
                                while _22860 + (uint255(stor10[address(arg3)][u].field_0) * 0.5) > t:
                                    mem[t + 32] = uint256(stor1[u])
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                mem[_22458] = _22860
                                mem[_22458 + 32] = stor10[address(arg3)][u].field_256
                                mem[_22458 + 64] = stor10[address(arg3)][u].field_512
                                mem[_22458 + 96] = stor10[address(arg3)][u].field_768
                                mem[t] = _22458
                                t = t + 32
                                u = u + 1
                                continue 
                            if not stor10[address(arg3)][idx].field_0 - (stor10[address(arg3)][idx].field_1 < 32):
                                revert with 0, 34
                            if stor10[address(arg3)][idx].field_1:
                                if 31 >= stor10[address(arg3)][idx].field_1:
                                    mem[_22860 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                else:
                                    mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                    mem[_22860 + 32] = stor10[address(arg3)][idx].field_0
                                    t = _22860 + 32
                                    u = sha3(mem[0])
                                    while _22860 + stor10[address(arg3)][idx].field_1 > t:
                                        mem[t + 32] = uint256(stor1[u])
                                        t = t + 32
                                        u = u + 1
                                        continue 
                            mem[_22458] = _22860
                            mem[_22458 + 32] = stor10[address(arg3)][idx].field_256
                            mem[_22458 + 64] = stor10[address(arg3)][idx].field_512
                            mem[_22458 + 96] = stor10[address(arg3)][idx].field_768
                            mem[s] = _22458
                            s = s + 32
                            idx = idx + 1
                            continue 
                        if address(arg1) != address(arg3):
                            if mem[ceil32(ceil32(arg2.length)) + 225] <= 1:
                                if mem[_15184] > 0:
                                    if _referrals[address(arg1)] != address(arg3):
                                        _referrals[address(arg1)] = address(arg3)
                                        sub_989baf69[address(arg3)].field_0++
                                        sub_989baf69[address(arg3)][sub_989baf69[address(arg3)].field_0].field_0 = address(arg1)
                                    if tokenAddress != msg.sender:
                                        if gateKeeperAddress != msg.sender:
                                            if address(stor0.field_0) != msg.sender:
                                                revert with 0, 'NodeManagerV2: NOT AUTHORIZED'
                                    if stor10[stor11[address(arg1)]].field_0:
                                        if not -referralBonusPercent:
                                            sub_e27e434a[stor11[address(arg1)]][address(arg1)] = 0
                                            if sub_666755bb[stor11[address(arg1)]] > -1:
                                                revert with 0, 17
                                        else:
                                            if referralBonusPercent and nodePrice > -1 / referralBonusPercent:
                                                revert with 0, 17
                                            if not referralBonusPercent:
                                                revert with 0, 18
                                            if referralBonusPercent * nodePrice / referralBonusPercent != nodePrice:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            sub_e27e434a[stor11[address(arg1)]][address(arg1)] = referralBonusPercent * nodePrice / 100
                                            if sub_666755bb[stor11[address(arg1)]] > !(referralBonusPercent * nodePrice / 100):
                                                revert with 0, 17
                                            sub_666755bb[stor11[address(arg1)]] += referralBonusPercent * nodePrice / 100
    else:
        if msg.sender == gateKeeperAddress:
            mem[ceil32(ceil32(arg2.length)) + 97] = 96
            mem[ceil32(ceil32(arg2.length)) + 129] = block.timestamp
            mem[ceil32(ceil32(arg2.length)) + 161] = block.timestamp
            mem[ceil32(ceil32(arg2.length)) + 193] = 0
            stor10[address(arg1)].field_0++
            if stor10[address(arg1)][stor10[address(arg1)].field_0].field_0:
                if not stor10[address(arg1)][stor10[address(arg1)].field_0].field_0 - (uint255(stor10[address(arg1)][stor10[address(arg1)].field_0].field_0) * 0.5 < 32):
                    revert with 0, 34
                if arg2.length:
                    stor10[address(arg1)][stor10[address(arg1)].field_0][].field_0 = Array(len=arg2.length, data=arg2[all])
                    stor10[address(arg1)][stor10[address(arg1)].field_0].field_256 = block.timestamp
                    stor10[address(arg1)][stor10[address(arg1)].field_0].field_512 = block.timestamp
                    stor10[address(arg1)][stor10[address(arg1)].field_0].field_768 = 0
                    mem[ceil32(ceil32(arg2.length)) + 229] = 6
                    mem[ceil32(ceil32(arg2.length)) + 261] = address(arg1)
                    mem[ceil32(ceil32(arg2.length)) + 293] = stor10[address(arg1)].field_0
                    require ext_code.size(0x4b7a346b17572634bdbd85b98abae32c5fa837bb)
                    delegate 0x4b7a346b17572634bdbd85b98abae32c5fa837bb.0xbc2b405c with:
                         gas gas_remaining wei
                        args 6, address(arg1), stor10[address(arg1)].field_0
                    if not delegate.return_code:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not totalNodesCreated + 1:
                        revert with 0, 17
                    totalNodesCreated++
                    if msg.sender == tokenAddress:
                        mem[0] = address(arg1)
                        mem[64] = ceil32(ceil32(arg2.length)) + (32 * stor10[address(arg1)].field_0) + 257
                        mem[ceil32(ceil32(arg2.length)) + 225] = stor10[address(arg1)].field_0
                        s = ceil32(ceil32(arg2.length)) + 257
                        idx = 0
                        while idx < stor10[address(arg1)].field_0:
                            mem[0] = sha3(address(arg1), 10)
                            _22468 = mem[64]
                            mem[64] = mem[64] + 128
                            if stor10[address(arg1)][idx].field_0:
                                if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                                    revert with 0, 34
                                _22768 = mem[64]
                                mem[64] = mem[64] + ceil32(uint255(stor10[address(arg1)][idx].field_0) * 0.5) + 32
                                mem[_22768] = uint255(stor10[address(arg1)][idx].field_0) * 0.5
                                if stor10[address(arg1)][idx].field_0:
                                    if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                                        revert with 0, 34
                                    if Mask(256, -1, stor10[address(arg1)][idx].field_0):
                                        if 31 >= uint255(stor10[address(arg1)][idx].field_0) * 0.5:
                                            mem[_22768 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                        else:
                                            mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                            mem[_22768 + 32] = stor10[address(arg1)][idx].field_0
                                            t = _22768 + 32
                                            u = sha3(mem[0])
                                            while _22768 + (uint255(stor10[address(arg1)][idx].field_0) * 0.5) > t:
                                                mem[t + 32] = uint256(stor1[u])
                                                t = t + 32
                                                u = u + 1
                                                continue 
                                    mem[_22468] = _22768
                                    mem[_22468 + 32] = stor10[address(arg1)][idx].field_256
                                    mem[_22468 + 64] = stor10[address(arg1)][idx].field_512
                                    mem[_22468 + 96] = stor10[address(arg1)][idx].field_768
                                    mem[s] = _22468
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                                    revert with 0, 34
                                if not stor10[address(arg1)][idx].field_1:
                                    mem[_22468] = _22768
                                    mem[_22468 + 32] = stor10[address(arg1)][idx].field_256
                                    mem[_22468 + 64] = stor10[address(arg1)][idx].field_512
                                    mem[_22468 + 96] = stor10[address(arg1)][idx].field_768
                                    mem[s] = _22468
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                if 31 >= stor10[address(arg1)][idx].field_1:
                                    mem[_22768 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                    mem[_22468] = _22768
                                    mem[_22468 + 32] = stor10[address(arg1)][idx].field_256
                                    mem[_22468 + 64] = stor10[address(arg1)][idx].field_512
                                    mem[_22468 + 96] = stor10[address(arg1)][idx].field_768
                                    mem[s] = _22468
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                mem[_22768 + 32] = stor10[address(arg1)][idx].field_0
                                t = _22768 + 32
                                u = sha3(mem[0])
                                while _22768 + stor10[address(arg1)][u].field_1 > t:
                                    mem[t + 32] = uint256(stor1[u])
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                mem[_22468] = _22768
                                mem[_22468 + 32] = stor10[address(arg1)][u].field_256
                                mem[_22468 + 64] = stor10[address(arg1)][u].field_512
                                mem[_22468 + 96] = stor10[address(arg1)][u].field_768
                                mem[t] = _22468
                                t = t + 32
                                u = u + 1
                                continue 
                            if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                                revert with 0, 34
                            _22868 = mem[64]
                            mem[64] = mem[64] + ceil32(stor10[address(arg1)][idx].field_1) + 32
                            mem[_22868] = stor10[address(arg1)][idx].field_1
                            if stor10[address(arg1)][idx].field_0:
                                if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                                    revert with 0, 34
                                if not Mask(256, -1, stor10[address(arg1)][idx].field_0):
                                    mem[_22468] = _22868
                                    mem[_22468 + 32] = stor10[address(arg1)][idx].field_256
                                    mem[_22468 + 64] = stor10[address(arg1)][idx].field_512
                                    mem[_22468 + 96] = stor10[address(arg1)][idx].field_768
                                    mem[s] = _22468
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                if 31 >= uint255(stor10[address(arg1)][idx].field_0) * 0.5:
                                    mem[_22868 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                    mem[_22468] = _22868
                                    mem[_22468 + 32] = stor10[address(arg1)][idx].field_256
                                    mem[_22468 + 64] = stor10[address(arg1)][idx].field_512
                                    mem[_22468 + 96] = stor10[address(arg1)][idx].field_768
                                    mem[s] = _22468
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                mem[_22868 + 32] = stor10[address(arg1)][idx].field_0
                                t = _22868 + 32
                                u = sha3(mem[0])
                                while _22868 + (uint255(stor10[address(arg1)][u].field_0) * 0.5) > t:
                                    mem[t + 32] = uint256(stor1[u])
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                mem[_22468] = _22868
                                mem[_22468 + 32] = stor10[address(arg1)][u].field_256
                                mem[_22468 + 64] = stor10[address(arg1)][u].field_512
                                mem[_22468 + 96] = stor10[address(arg1)][u].field_768
                                mem[t] = _22468
                                t = t + 32
                                u = u + 1
                                continue 
                            if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                                revert with 0, 34
                            if stor10[address(arg1)][idx].field_1:
                                if 31 >= stor10[address(arg1)][idx].field_1:
                                    mem[_22868 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                else:
                                    mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                    mem[_22868 + 32] = stor10[address(arg1)][idx].field_0
                                    t = _22868 + 32
                                    u = sha3(mem[0])
                                    while _22868 + stor10[address(arg1)][idx].field_1 > t:
                                        mem[t + 32] = uint256(stor1[u])
                                        t = t + 32
                                        u = u + 1
                                        continue 
                            mem[_22468] = _22868
                            mem[_22468 + 32] = stor10[address(arg1)][idx].field_256
                            mem[_22468 + 64] = stor10[address(arg1)][idx].field_512
                            mem[_22468 + 96] = stor10[address(arg1)][idx].field_768
                            mem[s] = _22468
                            s = s + 32
                            idx = idx + 1
                            continue 
                        mem[0] = address(arg3)
                        mem[32] = 10
                        _22466 = mem[64]
                        mem[64] = mem[64] + (32 * stor10[address(arg3)].field_0) + 32
                        mem[_22466] = stor10[address(arg3)].field_0
                        s = _22466 + 32
                        idx = 0
                        while idx < stor10[address(arg3)].field_0:
                            mem[0] = sha3(address(arg3), 10)
                            _29072 = mem[64]
                            mem[64] = mem[64] + 128
                            if stor10[address(arg3)][idx].field_0:
                                if not stor10[address(arg3)][idx].field_0 - (uint255(stor10[address(arg3)][idx].field_0) * 0.5 < 32):
                                    revert with 0, 34
                                _29137 = mem[64]
                                mem[64] = mem[64] + ceil32(uint255(stor10[address(arg3)][idx].field_0) * 0.5) + 32
                                mem[_29137] = uint255(stor10[address(arg3)][idx].field_0) * 0.5
                                if stor10[address(arg3)][idx].field_0:
                                    if not stor10[address(arg3)][idx].field_0 - (uint255(stor10[address(arg3)][idx].field_0) * 0.5 < 32):
                                        revert with 0, 34
                                    if Mask(256, -1, stor10[address(arg3)][idx].field_0):
                                        if 31 >= uint255(stor10[address(arg3)][idx].field_0) * 0.5:
                                            mem[_29137 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                        else:
                                            mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                            mem[_29137 + 32] = stor10[address(arg3)][idx].field_0
                                            t = _29137 + 32
                                            u = sha3(mem[0])
                                            while _29137 + (uint255(stor10[address(arg3)][idx].field_0) * 0.5) > t:
                                                mem[t + 32] = uint256(stor1[u])
                                                t = t + 32
                                                u = u + 1
                                                continue 
                                    mem[_29072] = _29137
                                    mem[_29072 + 32] = stor10[address(arg3)][idx].field_256
                                    mem[_29072 + 64] = stor10[address(arg3)][idx].field_512
                                    mem[_29072 + 96] = stor10[address(arg3)][idx].field_768
                                    mem[s] = _29072
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                if not stor10[address(arg3)][idx].field_0 - (stor10[address(arg3)][idx].field_1 < 32):
                                    revert with 0, 34
                                if not stor10[address(arg3)][idx].field_1:
                                    mem[_29072] = _29137
                                    mem[_29072 + 32] = stor10[address(arg3)][idx].field_256
                                    mem[_29072 + 64] = stor10[address(arg3)][idx].field_512
                                    mem[_29072 + 96] = stor10[address(arg3)][idx].field_768
                                    mem[s] = _29072
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                if 31 >= stor10[address(arg3)][idx].field_1:
                                    mem[_29137 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                    mem[_29072] = _29137
                                    mem[_29072 + 32] = stor10[address(arg3)][idx].field_256
                                    mem[_29072 + 64] = stor10[address(arg3)][idx].field_512
                                    mem[_29072 + 96] = stor10[address(arg3)][idx].field_768
                                    mem[s] = _29072
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                mem[_29137 + 32] = stor10[address(arg3)][idx].field_0
                                t = _29137 + 32
                                u = sha3(mem[0])
                                while _29137 + stor10[address(arg3)][u].field_1 > t:
                                    mem[t + 32] = uint256(stor1[u])
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                mem[_29072] = _29137
                                mem[_29072 + 32] = stor10[address(arg3)][u].field_256
                                mem[_29072 + 64] = stor10[address(arg3)][u].field_512
                                mem[_29072 + 96] = stor10[address(arg3)][u].field_768
                                mem[t] = _29072
                                t = t + 32
                                u = u + 1
                                continue 
                            if not stor10[address(arg3)][idx].field_0 - (stor10[address(arg3)][idx].field_1 < 32):
                                revert with 0, 34
                            _29162 = mem[64]
                            mem[64] = mem[64] + ceil32(stor10[address(arg3)][idx].field_1) + 32
                            mem[_29162] = stor10[address(arg3)][idx].field_1
                            if stor10[address(arg3)][idx].field_0:
                                if not stor10[address(arg3)][idx].field_0 - (uint255(stor10[address(arg3)][idx].field_0) * 0.5 < 32):
                                    revert with 0, 34
                                if not Mask(256, -1, stor10[address(arg3)][idx].field_0):
                                    mem[_29072] = _29162
                                    mem[_29072 + 32] = stor10[address(arg3)][idx].field_256
                                    mem[_29072 + 64] = stor10[address(arg3)][idx].field_512
                                    mem[_29072 + 96] = stor10[address(arg3)][idx].field_768
                                    mem[s] = _29072
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                if 31 >= uint255(stor10[address(arg3)][idx].field_0) * 0.5:
                                    mem[_29162 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                    mem[_29072] = _29162
                                    mem[_29072 + 32] = stor10[address(arg3)][idx].field_256
                                    mem[_29072 + 64] = stor10[address(arg3)][idx].field_512
                                    mem[_29072 + 96] = stor10[address(arg3)][idx].field_768
                                    mem[s] = _29072
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                mem[_29162 + 32] = stor10[address(arg3)][idx].field_0
                                t = _29162 + 32
                                u = sha3(mem[0])
                                while _29162 + (uint255(stor10[address(arg3)][u].field_0) * 0.5) > t:
                                    mem[t + 32] = uint256(stor1[u])
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                mem[_29072] = _29162
                                mem[_29072 + 32] = stor10[address(arg3)][u].field_256
                                mem[_29072 + 64] = stor10[address(arg3)][u].field_512
                                mem[_29072 + 96] = stor10[address(arg3)][u].field_768
                                mem[t] = _29072
                                t = t + 32
                                u = u + 1
                                continue 
                            if not stor10[address(arg3)][idx].field_0 - (stor10[address(arg3)][idx].field_1 < 32):
                                revert with 0, 34
                            if stor10[address(arg3)][idx].field_1:
                                if 31 >= stor10[address(arg3)][idx].field_1:
                                    mem[_29162 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                else:
                                    mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                    mem[_29162 + 32] = stor10[address(arg3)][idx].field_0
                                    t = _29162 + 32
                                    u = sha3(mem[0])
                                    while _29162 + stor10[address(arg3)][idx].field_1 > t:
                                        mem[t + 32] = uint256(stor1[u])
                                        t = t + 32
                                        u = u + 1
                                        continue 
                            mem[_29072] = _29162
                            mem[_29072 + 32] = stor10[address(arg3)][idx].field_256
                            mem[_29072 + 64] = stor10[address(arg3)][idx].field_512
                            mem[_29072 + 96] = stor10[address(arg3)][idx].field_768
                            mem[s] = _29072
                            s = s + 32
                            idx = idx + 1
                            continue 
                        if address(arg1) != address(arg3):
                            if mem[ceil32(ceil32(arg2.length)) + 225] <= 1:
                                if mem[_22466] > 0:
                                    if _referrals[address(arg1)] != address(arg3):
                                        _referrals[address(arg1)] = address(arg3)
                                        sub_989baf69[address(arg3)].field_0++
                                        sub_989baf69[address(arg3)][sub_989baf69[address(arg3)].field_0].field_0 = address(arg1)
                                    if tokenAddress != msg.sender:
                                        if gateKeeperAddress != msg.sender:
                                            if address(stor0.field_0) != msg.sender:
                                                revert with 0, 'NodeManagerV2: NOT AUTHORIZED'
                                    if stor10[stor11[address(arg1)]].field_0:
                                        if not -referralBonusPercent:
                                            sub_e27e434a[stor11[address(arg1)]][address(arg1)] = 0
                                            if sub_666755bb[stor11[address(arg1)]] > -1:
                                                revert with 0, 17
                                        else:
                                            if referralBonusPercent and nodePrice > -1 / referralBonusPercent:
                                                revert with 0, 17
                                            if not referralBonusPercent:
                                                revert with 0, 18
                                            if referralBonusPercent * nodePrice / referralBonusPercent != nodePrice:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            sub_e27e434a[stor11[address(arg1)]][address(arg1)] = referralBonusPercent * nodePrice / 100
                                            if sub_666755bb[stor11[address(arg1)]] > !(referralBonusPercent * nodePrice / 100):
                                                revert with 0, 17
                                            sub_666755bb[stor11[address(arg1)]] += referralBonusPercent * nodePrice / 100
                    else:
                        if msg.sender == gateKeeperAddress:
                            mem[0] = address(arg1)
                            mem[64] = ceil32(ceil32(arg2.length)) + (32 * stor10[address(arg1)].field_0) + 257
                            mem[ceil32(ceil32(arg2.length)) + 225] = stor10[address(arg1)].field_0
                            s = ceil32(ceil32(arg2.length)) + 257
                            idx = 0
                            while idx < stor10[address(arg1)].field_0:
                                mem[0] = sha3(address(arg1), 10)
                                _22472 = mem[64]
                                mem[64] = mem[64] + 128
                                if stor10[address(arg1)][idx].field_0:
                                    if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                                        revert with 0, 34
                                    _22769 = mem[64]
                                    mem[64] = mem[64] + ceil32(uint255(stor10[address(arg1)][idx].field_0) * 0.5) + 32
                                    mem[_22769] = uint255(stor10[address(arg1)][idx].field_0) * 0.5
                                    if stor10[address(arg1)][idx].field_0:
                                        if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                                            revert with 0, 34
                                        if Mask(256, -1, stor10[address(arg1)][idx].field_0):
                                            if 31 >= uint255(stor10[address(arg1)][idx].field_0) * 0.5:
                                                mem[_22769 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                            else:
                                                mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                                mem[_22769 + 32] = stor10[address(arg1)][idx].field_0
                                                t = _22769 + 32
                                                u = sha3(mem[0])
                                                while _22769 + (uint255(stor10[address(arg1)][idx].field_0) * 0.5) > t:
                                                    mem[t + 32] = uint256(stor1[u])
                                                    t = t + 32
                                                    u = u + 1
                                                    continue 
                                        mem[_22472] = _22769
                                        mem[_22472 + 32] = stor10[address(arg1)][idx].field_256
                                        mem[_22472 + 64] = stor10[address(arg1)][idx].field_512
                                        mem[_22472 + 96] = stor10[address(arg1)][idx].field_768
                                        mem[s] = _22472
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                                        revert with 0, 34
                                    if not stor10[address(arg1)][idx].field_1:
                                        mem[_22472] = _22769
                                        mem[_22472 + 32] = stor10[address(arg1)][idx].field_256
                                        mem[_22472 + 64] = stor10[address(arg1)][idx].field_512
                                        mem[_22472 + 96] = stor10[address(arg1)][idx].field_768
                                        mem[s] = _22472
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    if 31 >= stor10[address(arg1)][idx].field_1:
                                        mem[_22769 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                        mem[_22472] = _22769
                                        mem[_22472 + 32] = stor10[address(arg1)][idx].field_256
                                        mem[_22472 + 64] = stor10[address(arg1)][idx].field_512
                                        mem[_22472 + 96] = stor10[address(arg1)][idx].field_768
                                        mem[s] = _22472
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                    mem[_22769 + 32] = stor10[address(arg1)][idx].field_0
                                    t = _22769 + 32
                                    u = sha3(mem[0])
                                    while _22769 + stor10[address(arg1)][u].field_1 > t:
                                        mem[t + 32] = uint256(stor1[u])
                                        t = t + 32
                                        u = u + 1
                                        continue 
                                    mem[_22472] = _22769
                                    mem[_22472 + 32] = stor10[address(arg1)][u].field_256
                                    mem[_22472 + 64] = stor10[address(arg1)][u].field_512
                                    mem[_22472 + 96] = stor10[address(arg1)][u].field_768
                                    mem[t] = _22472
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                                    revert with 0, 34
                                _22870 = mem[64]
                                mem[64] = mem[64] + ceil32(stor10[address(arg1)][idx].field_1) + 32
                                mem[_22870] = stor10[address(arg1)][idx].field_1
                                if stor10[address(arg1)][idx].field_0:
                                    if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                                        revert with 0, 34
                                    if not Mask(256, -1, stor10[address(arg1)][idx].field_0):
                                        mem[_22472] = _22870
                                        mem[_22472 + 32] = stor10[address(arg1)][idx].field_256
                                        mem[_22472 + 64] = stor10[address(arg1)][idx].field_512
                                        mem[_22472 + 96] = stor10[address(arg1)][idx].field_768
                                        mem[s] = _22472
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    if 31 >= uint255(stor10[address(arg1)][idx].field_0) * 0.5:
                                        mem[_22870 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                        mem[_22472] = _22870
                                        mem[_22472 + 32] = stor10[address(arg1)][idx].field_256
                                        mem[_22472 + 64] = stor10[address(arg1)][idx].field_512
                                        mem[_22472 + 96] = stor10[address(arg1)][idx].field_768
                                        mem[s] = _22472
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                    mem[_22870 + 32] = stor10[address(arg1)][idx].field_0
                                    t = _22870 + 32
                                    u = sha3(mem[0])
                                    while _22870 + (uint255(stor10[address(arg1)][u].field_0) * 0.5) > t:
                                        mem[t + 32] = uint256(stor1[u])
                                        t = t + 32
                                        u = u + 1
                                        continue 
                                    mem[_22472] = _22870
                                    mem[_22472 + 32] = stor10[address(arg1)][u].field_256
                                    mem[_22472 + 64] = stor10[address(arg1)][u].field_512
                                    mem[_22472 + 96] = stor10[address(arg1)][u].field_768
                                    mem[t] = _22472
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                                    revert with 0, 34
                                if stor10[address(arg1)][idx].field_1:
                                    if 31 >= stor10[address(arg1)][idx].field_1:
                                        mem[_22870 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                    else:
                                        mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                        mem[_22870 + 32] = stor10[address(arg1)][idx].field_0
                                        t = _22870 + 32
                                        u = sha3(mem[0])
                                        while _22870 + stor10[address(arg1)][idx].field_1 > t:
                                            mem[t + 32] = uint256(stor1[u])
                                            t = t + 32
                                            u = u + 1
                                            continue 
                                mem[_22472] = _22870
                                mem[_22472 + 32] = stor10[address(arg1)][idx].field_256
                                mem[_22472 + 64] = stor10[address(arg1)][idx].field_512
                                mem[_22472 + 96] = stor10[address(arg1)][idx].field_768
                                mem[s] = _22472
                                s = s + 32
                                idx = idx + 1
                                continue 
                            mem[0] = address(arg3)
                            mem[32] = 10
                            _22470 = mem[64]
                            mem[64] = mem[64] + (32 * stor10[address(arg3)].field_0) + 32
                            mem[_22470] = stor10[address(arg3)].field_0
                            s = _22470 + 32
                            idx = 0
                            while idx < stor10[address(arg3)].field_0:
                                mem[0] = sha3(address(arg3), 10)
                                _29074 = mem[64]
                                mem[64] = mem[64] + 128
                                if stor10[address(arg3)][idx].field_0:
                                    if not stor10[address(arg3)][idx].field_0 - (uint255(stor10[address(arg3)][idx].field_0) * 0.5 < 32):
                                        revert with 0, 34
                                    _29138 = mem[64]
                                    mem[64] = mem[64] + ceil32(uint255(stor10[address(arg3)][idx].field_0) * 0.5) + 32
                                    mem[_29138] = uint255(stor10[address(arg3)][idx].field_0) * 0.5
                                    if stor10[address(arg3)][idx].field_0:
                                        if not stor10[address(arg3)][idx].field_0 - (uint255(stor10[address(arg3)][idx].field_0) * 0.5 < 32):
                                            revert with 0, 34
                                        if Mask(256, -1, stor10[address(arg3)][idx].field_0):
                                            if 31 >= uint255(stor10[address(arg3)][idx].field_0) * 0.5:
                                                mem[_29138 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                            else:
                                                mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                                mem[_29138 + 32] = stor10[address(arg3)][idx].field_0
                                                t = _29138 + 32
                                                u = sha3(mem[0])
                                                while _29138 + (uint255(stor10[address(arg3)][idx].field_0) * 0.5) > t:
                                                    mem[t + 32] = uint256(stor1[u])
                                                    t = t + 32
                                                    u = u + 1
                                                    continue 
                                        mem[_29074] = _29138
                                        mem[_29074 + 32] = stor10[address(arg3)][idx].field_256
                                        mem[_29074 + 64] = stor10[address(arg3)][idx].field_512
                                        mem[_29074 + 96] = stor10[address(arg3)][idx].field_768
                                        mem[s] = _29074
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    if not stor10[address(arg3)][idx].field_0 - (stor10[address(arg3)][idx].field_1 < 32):
                                        revert with 0, 34
                                    if not stor10[address(arg3)][idx].field_1:
                                        mem[_29074] = _29138
                                        mem[_29074 + 32] = stor10[address(arg3)][idx].field_256
                                        mem[_29074 + 64] = stor10[address(arg3)][idx].field_512
                                        mem[_29074 + 96] = stor10[address(arg3)][idx].field_768
                                        mem[s] = _29074
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    if 31 >= stor10[address(arg3)][idx].field_1:
                                        mem[_29138 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                        mem[_29074] = _29138
                                        mem[_29074 + 32] = stor10[address(arg3)][idx].field_256
                                        mem[_29074 + 64] = stor10[address(arg3)][idx].field_512
                                        mem[_29074 + 96] = stor10[address(arg3)][idx].field_768
                                        mem[s] = _29074
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                    mem[_29138 + 32] = stor10[address(arg3)][idx].field_0
                                    t = _29138 + 32
                                    u = sha3(mem[0])
                                    while _29138 + stor10[address(arg3)][u].field_1 > t:
                                        mem[t + 32] = uint256(stor1[u])
                                        t = t + 32
                                        u = u + 1
                                        continue 
                                    mem[_29074] = _29138
                                    mem[_29074 + 32] = stor10[address(arg3)][u].field_256
                                    mem[_29074 + 64] = stor10[address(arg3)][u].field_512
                                    mem[_29074 + 96] = stor10[address(arg3)][u].field_768
                                    mem[t] = _29074
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                if not stor10[address(arg3)][idx].field_0 - (stor10[address(arg3)][idx].field_1 < 32):
                                    revert with 0, 34
                                _29164 = mem[64]
                                mem[64] = mem[64] + ceil32(stor10[address(arg3)][idx].field_1) + 32
                                mem[_29164] = stor10[address(arg3)][idx].field_1
                                if stor10[address(arg3)][idx].field_0:
                                    if not stor10[address(arg3)][idx].field_0 - (uint255(stor10[address(arg3)][idx].field_0) * 0.5 < 32):
                                        revert with 0, 34
                                    if not Mask(256, -1, stor10[address(arg3)][idx].field_0):
                                        mem[_29074] = _29164
                                        mem[_29074 + 32] = stor10[address(arg3)][idx].field_256
                                        mem[_29074 + 64] = stor10[address(arg3)][idx].field_512
                                        mem[_29074 + 96] = stor10[address(arg3)][idx].field_768
                                        mem[s] = _29074
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    if 31 >= uint255(stor10[address(arg3)][idx].field_0) * 0.5:
                                        mem[_29164 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                        mem[_29074] = _29164
                                        mem[_29074 + 32] = stor10[address(arg3)][idx].field_256
                                        mem[_29074 + 64] = stor10[address(arg3)][idx].field_512
                                        mem[_29074 + 96] = stor10[address(arg3)][idx].field_768
                                        mem[s] = _29074
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                    mem[_29164 + 32] = stor10[address(arg3)][idx].field_0
                                    t = _29164 + 32
                                    u = sha3(mem[0])
                                    while _29164 + (uint255(stor10[address(arg3)][u].field_0) * 0.5) > t:
                                        mem[t + 32] = uint256(stor1[u])
                                        t = t + 32
                                        u = u + 1
                                        continue 
                                    mem[_29074] = _29164
                                    mem[_29074 + 32] = stor10[address(arg3)][u].field_256
                                    mem[_29074 + 64] = stor10[address(arg3)][u].field_512
                                    mem[_29074 + 96] = stor10[address(arg3)][u].field_768
                                    mem[t] = _29074
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                if not stor10[address(arg3)][idx].field_0 - (stor10[address(arg3)][idx].field_1 < 32):
                                    revert with 0, 34
                                if stor10[address(arg3)][idx].field_1:
                                    if 31 >= stor10[address(arg3)][idx].field_1:
                                        mem[_29164 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                    else:
                                        mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                        mem[_29164 + 32] = stor10[address(arg3)][idx].field_0
                                        t = _29164 + 32
                                        u = sha3(mem[0])
                                        while _29164 + stor10[address(arg3)][idx].field_1 > t:
                                            mem[t + 32] = uint256(stor1[u])
                                            t = t + 32
                                            u = u + 1
                                            continue 
                                mem[_29074] = _29164
                                mem[_29074 + 32] = stor10[address(arg3)][idx].field_256
                                mem[_29074 + 64] = stor10[address(arg3)][idx].field_512
                                mem[_29074 + 96] = stor10[address(arg3)][idx].field_768
                                mem[s] = _29074
                                s = s + 32
                                idx = idx + 1
                                continue 
                            if address(arg1) != address(arg3):
                                if mem[ceil32(ceil32(arg2.length)) + 225] <= 1:
                                    if mem[_22470] > 0:
                                        if _referrals[address(arg1)] != address(arg3):
                                            _referrals[address(arg1)] = address(arg3)
                                            sub_989baf69[address(arg3)].field_0++
                                            sub_989baf69[address(arg3)][sub_989baf69[address(arg3)].field_0].field_0 = address(arg1)
                                        if tokenAddress != msg.sender:
                                            if gateKeeperAddress != msg.sender:
                                                if address(stor0.field_0) != msg.sender:
                                                    revert with 0, 'NodeManagerV2: NOT AUTHORIZED'
                                        if stor10[stor11[address(arg1)]].field_0:
                                            if not -referralBonusPercent:
                                                sub_e27e434a[stor11[address(arg1)]][address(arg1)] = 0
                                                if sub_666755bb[stor11[address(arg1)]] > -1:
                                                    revert with 0, 17
                                            else:
                                                if referralBonusPercent and nodePrice > -1 / referralBonusPercent:
                                                    revert with 0, 17
                                                if not referralBonusPercent:
                                                    revert with 0, 18
                                                if referralBonusPercent * nodePrice / referralBonusPercent != nodePrice:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                sub_e27e434a[stor11[address(arg1)]][address(arg1)] = referralBonusPercent * nodePrice / 100
                                                if sub_666755bb[stor11[address(arg1)]] > !(referralBonusPercent * nodePrice / 100):
                                                    revert with 0, 17
                                                sub_666755bb[stor11[address(arg1)]] += referralBonusPercent * nodePrice / 100
                        else:
                            if address(stor0.field_0) != msg.sender:
                                revert with 0, 'NodeManagerV2: NOT AUTHORIZED'
                            mem[0] = address(arg1)
                            mem[64] = ceil32(ceil32(arg2.length)) + (32 * stor10[address(arg1)].field_0) + 257
                            mem[ceil32(ceil32(arg2.length)) + 225] = stor10[address(arg1)].field_0
                            s = ceil32(ceil32(arg2.length)) + 257
                            idx = 0
                            while idx < stor10[address(arg1)].field_0:
                                mem[0] = sha3(address(arg1), 10)
                                _22476 = mem[64]
                                mem[64] = mem[64] + 128
                                if stor10[address(arg1)][idx].field_0:
                                    if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                                        revert with 0, 34
                                    _22770 = mem[64]
                                    mem[64] = mem[64] + ceil32(uint255(stor10[address(arg1)][idx].field_0) * 0.5) + 32
                                    mem[_22770] = uint255(stor10[address(arg1)][idx].field_0) * 0.5
                                    if stor10[address(arg1)][idx].field_0:
                                        if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                                            revert with 0, 34
                                        if Mask(256, -1, stor10[address(arg1)][idx].field_0):
                                            if 31 >= uint255(stor10[address(arg1)][idx].field_0) * 0.5:
                                                mem[_22770 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                            else:
                                                mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                                mem[_22770 + 32] = stor10[address(arg1)][idx].field_0
                                                t = _22770 + 32
                                                u = sha3(mem[0])
                                                while _22770 + (uint255(stor10[address(arg1)][idx].field_0) * 0.5) > t:
                                                    mem[t + 32] = uint256(stor1[u])
                                                    t = t + 32
                                                    u = u + 1
                                                    continue 
                                        mem[_22476] = _22770
                                        mem[_22476 + 32] = stor10[address(arg1)][idx].field_256
                                        mem[_22476 + 64] = stor10[address(arg1)][idx].field_512
                                        mem[_22476 + 96] = stor10[address(arg1)][idx].field_768
                                        mem[s] = _22476
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                                        revert with 0, 34
                                    if not stor10[address(arg1)][idx].field_1:
                                        mem[_22476] = _22770
                                        mem[_22476 + 32] = stor10[address(arg1)][idx].field_256
                                        mem[_22476 + 64] = stor10[address(arg1)][idx].field_512
                                        mem[_22476 + 96] = stor10[address(arg1)][idx].field_768
                                        mem[s] = _22476
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    if 31 >= stor10[address(arg1)][idx].field_1:
                                        mem[_22770 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                        mem[_22476] = _22770
                                        mem[_22476 + 32] = stor10[address(arg1)][idx].field_256
                                        mem[_22476 + 64] = stor10[address(arg1)][idx].field_512
                                        mem[_22476 + 96] = stor10[address(arg1)][idx].field_768
                                        mem[s] = _22476
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                    mem[_22770 + 32] = stor10[address(arg1)][idx].field_0
                                    t = _22770 + 32
                                    u = sha3(mem[0])
                                    while _22770 + stor10[address(arg1)][u].field_1 > t:
                                        mem[t + 32] = uint256(stor1[u])
                                        t = t + 32
                                        u = u + 1
                                        continue 
                                    mem[_22476] = _22770
                                    mem[_22476 + 32] = stor10[address(arg1)][u].field_256
                                    mem[_22476 + 64] = stor10[address(arg1)][u].field_512
                                    mem[_22476 + 96] = stor10[address(arg1)][u].field_768
                                    mem[t] = _22476
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                                    revert with 0, 34
                                _22872 = mem[64]
                                mem[64] = mem[64] + ceil32(stor10[address(arg1)][idx].field_1) + 32
                                mem[_22872] = stor10[address(arg1)][idx].field_1
                                if stor10[address(arg1)][idx].field_0:
                                    if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                                        revert with 0, 34
                                    if not Mask(256, -1, stor10[address(arg1)][idx].field_0):
                                        mem[_22476] = _22872
                                        mem[_22476 + 32] = stor10[address(arg1)][idx].field_256
                                        mem[_22476 + 64] = stor10[address(arg1)][idx].field_512
                                        mem[_22476 + 96] = stor10[address(arg1)][idx].field_768
                                        mem[s] = _22476
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    if 31 >= uint255(stor10[address(arg1)][idx].field_0) * 0.5:
                                        mem[_22872 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                        mem[_22476] = _22872
                                        mem[_22476 + 32] = stor10[address(arg1)][idx].field_256
                                        mem[_22476 + 64] = stor10[address(arg1)][idx].field_512
                                        mem[_22476 + 96] = stor10[address(arg1)][idx].field_768
                                        mem[s] = _22476
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                    mem[_22872 + 32] = stor10[address(arg1)][idx].field_0
                                    t = _22872 + 32
                                    u = sha3(mem[0])
                                    while _22872 + (uint255(stor10[address(arg1)][u].field_0) * 0.5) > t:
                                        mem[t + 32] = uint256(stor1[u])
                                        t = t + 32
                                        u = u + 1
                                        continue 
                                    mem[_22476] = _22872
                                    mem[_22476 + 32] = stor10[address(arg1)][u].field_256
                                    mem[_22476 + 64] = stor10[address(arg1)][u].field_512
                                    mem[_22476 + 96] = stor10[address(arg1)][u].field_768
                                    mem[t] = _22476
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                                    revert with 0, 34
                                if stor10[address(arg1)][idx].field_1:
                                    if 31 >= stor10[address(arg1)][idx].field_1:
                                        mem[_22872 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                    else:
                                        mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                        mem[_22872 + 32] = stor10[address(arg1)][idx].field_0
                                        t = _22872 + 32
                                        u = sha3(mem[0])
                                        while _22872 + stor10[address(arg1)][idx].field_1 > t:
                                            mem[t + 32] = uint256(stor1[u])
                                            t = t + 32
                                            u = u + 1
                                            continue 
                                mem[_22476] = _22872
                                mem[_22476 + 32] = stor10[address(arg1)][idx].field_256
                                mem[_22476 + 64] = stor10[address(arg1)][idx].field_512
                                mem[_22476 + 96] = stor10[address(arg1)][idx].field_768
                                mem[s] = _22476
                                s = s + 32
                                idx = idx + 1
                                continue 
                            mem[0] = address(arg3)
                            mem[32] = 10
                            _22474 = mem[64]
                            mem[64] = mem[64] + (32 * stor10[address(arg3)].field_0) + 32
                            mem[_22474] = stor10[address(arg3)].field_0
                            s = _22474 + 32
                            idx = 0
                            while idx < stor10[address(arg3)].field_0:
                                mem[0] = sha3(address(arg3), 10)
                                _29076 = mem[64]
                                mem[64] = mem[64] + 128
                                if stor10[address(arg3)][idx].field_0:
                                    if not stor10[address(arg3)][idx].field_0 - (uint255(stor10[address(arg3)][idx].field_0) * 0.5 < 32):
                                        revert with 0, 34
                                    _29139 = mem[64]
                                    mem[64] = mem[64] + ceil32(uint255(stor10[address(arg3)][idx].field_0) * 0.5) + 32
                                    mem[_29139] = uint255(stor10[address(arg3)][idx].field_0) * 0.5
                                    if stor10[address(arg3)][idx].field_0:
                                        if not stor10[address(arg3)][idx].field_0 - (uint255(stor10[address(arg3)][idx].field_0) * 0.5 < 32):
                                            revert with 0, 34
                                        if Mask(256, -1, stor10[address(arg3)][idx].field_0):
                                            if 31 >= uint255(stor10[address(arg3)][idx].field_0) * 0.5:
                                                mem[_29139 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                            else:
                                                mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                                mem[_29139 + 32] = stor10[address(arg3)][idx].field_0
                                                t = _29139 + 32
                                                u = sha3(mem[0])
                                                while _29139 + (uint255(stor10[address(arg3)][idx].field_0) * 0.5) > t:
                                                    mem[t + 32] = uint256(stor1[u])
                                                    t = t + 32
                                                    u = u + 1
                                                    continue 
                                        mem[_29076] = _29139
                                        mem[_29076 + 32] = stor10[address(arg3)][idx].field_256
                                        mem[_29076 + 64] = stor10[address(arg3)][idx].field_512
                                        mem[_29076 + 96] = stor10[address(arg3)][idx].field_768
                                        mem[s] = _29076
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    if not stor10[address(arg3)][idx].field_0 - (stor10[address(arg3)][idx].field_1 < 32):
                                        revert with 0, 34
                                    if not stor10[address(arg3)][idx].field_1:
                                        mem[_29076] = _29139
                                        mem[_29076 + 32] = stor10[address(arg3)][idx].field_256
                                        mem[_29076 + 64] = stor10[address(arg3)][idx].field_512
                                        mem[_29076 + 96] = stor10[address(arg3)][idx].field_768
                                        mem[s] = _29076
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    if 31 >= stor10[address(arg3)][idx].field_1:
                                        mem[_29139 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                        mem[_29076] = _29139
                                        mem[_29076 + 32] = stor10[address(arg3)][idx].field_256
                                        mem[_29076 + 64] = stor10[address(arg3)][idx].field_512
                                        mem[_29076 + 96] = stor10[address(arg3)][idx].field_768
                                        mem[s] = _29076
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                    mem[_29139 + 32] = stor10[address(arg3)][idx].field_0
                                    t = _29139 + 32
                                    u = sha3(mem[0])
                                    while _29139 + stor10[address(arg3)][u].field_1 > t:
                                        mem[t + 32] = uint256(stor1[u])
                                        t = t + 32
                                        u = u + 1
                                        continue 
                                    mem[_29076] = _29139
                                    mem[_29076 + 32] = stor10[address(arg3)][u].field_256
                                    mem[_29076 + 64] = stor10[address(arg3)][u].field_512
                                    mem[_29076 + 96] = stor10[address(arg3)][u].field_768
                                    mem[t] = _29076
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                if not stor10[address(arg3)][idx].field_0 - (stor10[address(arg3)][idx].field_1 < 32):
                                    revert with 0, 34
                                _29166 = mem[64]
                                mem[64] = mem[64] + ceil32(stor10[address(arg3)][idx].field_1) + 32
                                mem[_29166] = stor10[address(arg3)][idx].field_1
                                if stor10[address(arg3)][idx].field_0:
                                    if not stor10[address(arg3)][idx].field_0 - (uint255(stor10[address(arg3)][idx].field_0) * 0.5 < 32):
                                        revert with 0, 34
                                    if not Mask(256, -1, stor10[address(arg3)][idx].field_0):
                                        mem[_29076] = _29166
                                        mem[_29076 + 32] = stor10[address(arg3)][idx].field_256
                                        mem[_29076 + 64] = stor10[address(arg3)][idx].field_512
                                        mem[_29076 + 96] = stor10[address(arg3)][idx].field_768
                                        mem[s] = _29076
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    if 31 >= uint255(stor10[address(arg3)][idx].field_0) * 0.5:
                                        mem[_29166 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                        mem[_29076] = _29166
                                        mem[_29076 + 32] = stor10[address(arg3)][idx].field_256
                                        mem[_29076 + 64] = stor10[address(arg3)][idx].field_512
                                        mem[_29076 + 96] = stor10[address(arg3)][idx].field_768
                                        mem[s] = _29076
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                    mem[_29166 + 32] = stor10[address(arg3)][idx].field_0
                                    t = _29166 + 32
                                    u = sha3(mem[0])
                                    while _29166 + (uint255(stor10[address(arg3)][u].field_0) * 0.5) > t:
                                        mem[t + 32] = uint256(stor1[u])
                                        t = t + 32
                                        u = u + 1
                                        continue 
                                    mem[_29076] = _29166
                                    mem[_29076 + 32] = stor10[address(arg3)][u].field_256
                                    mem[_29076 + 64] = stor10[address(arg3)][u].field_512
                                    mem[_29076 + 96] = stor10[address(arg3)][u].field_768
                                    mem[t] = _29076
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                if not stor10[address(arg3)][idx].field_0 - (stor10[address(arg3)][idx].field_1 < 32):
                                    revert with 0, 34
                                if stor10[address(arg3)][idx].field_1:
                                    if 31 >= stor10[address(arg3)][idx].field_1:
                                        mem[_29166 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                    else:
                                        mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                        mem[_29166 + 32] = stor10[address(arg3)][idx].field_0
                                        t = _29166 + 32
                                        u = sha3(mem[0])
                                        while _29166 + stor10[address(arg3)][idx].field_1 > t:
                                            mem[t + 32] = uint256(stor1[u])
                                            t = t + 32
                                            u = u + 1
                                            continue 
                                mem[_29076] = _29166
                                mem[_29076 + 32] = stor10[address(arg3)][idx].field_256
                                mem[_29076 + 64] = stor10[address(arg3)][idx].field_512
                                mem[_29076 + 96] = stor10[address(arg3)][idx].field_768
                                mem[s] = _29076
                                s = s + 32
                                idx = idx + 1
                                continue 
                            if address(arg1) != address(arg3):
                                if mem[ceil32(ceil32(arg2.length)) + 225] <= 1:
                                    if mem[_22474] > 0:
                                        if _referrals[address(arg1)] != address(arg3):
                                            _referrals[address(arg1)] = address(arg3)
                                            sub_989baf69[address(arg3)].field_0++
                                            sub_989baf69[address(arg3)][sub_989baf69[address(arg3)].field_0].field_0 = address(arg1)
                                        if tokenAddress != msg.sender:
                                            if gateKeeperAddress != msg.sender:
                                                if address(stor0.field_0) != msg.sender:
                                                    revert with 0, 'NodeManagerV2: NOT AUTHORIZED'
                                        if stor10[stor11[address(arg1)]].field_0:
                                            if not -referralBonusPercent:
                                                sub_e27e434a[stor11[address(arg1)]][address(arg1)] = 0
                                                if sub_666755bb[stor11[address(arg1)]] > -1:
                                                    revert with 0, 17
                                            else:
                                                if referralBonusPercent and nodePrice > -1 / referralBonusPercent:
                                                    revert with 0, 17
                                                if not referralBonusPercent:
                                                    revert with 0, 18
                                                if referralBonusPercent * nodePrice / referralBonusPercent != nodePrice:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                sub_e27e434a[stor11[address(arg1)]][address(arg1)] = referralBonusPercent * nodePrice / 100
                                                if sub_666755bb[stor11[address(arg1)]] > !(referralBonusPercent * nodePrice / 100):
                                                    revert with 0, 17
                                                sub_666755bb[stor11[address(arg1)]] += referralBonusPercent * nodePrice / 100
                else:
                    stor10[address(arg1)][stor10[address(arg1)].field_0].field_0 = 0
                    idx = 0
                    while (uint255(stor10[address(arg1)][stor10[address(arg1)].field_0].field_0) * 0.5) + 31 / 32 > idx:
                        stor10[address(arg1)][(4 * stor10[address(arg1)].field_0) + idx].field_0 = 0
                        idx = idx + 1
                        continue 
                    stor10[address(arg1)][stor10[address(arg1)].field_0].field_256 = block.timestamp
                    stor10[address(arg1)][stor10[address(arg1)].field_0].field_512 = block.timestamp
                    stor10[address(arg1)][stor10[address(arg1)].field_0].field_768 = 0
                    mem[ceil32(ceil32(arg2.length)) + 229] = 6
                    mem[ceil32(ceil32(arg2.length)) + 261] = address(arg1)
                    mem[ceil32(ceil32(arg2.length)) + 293] = stor10[address(arg1)].field_0
                    require ext_code.size(0x4b7a346b17572634bdbd85b98abae32c5fa837bb)
                    delegate 0x4b7a346b17572634bdbd85b98abae32c5fa837bb.0xbc2b405c with:
                         gas gas_remaining wei
                        args 6, address(arg1), stor10[address(arg1)].field_0
                    if not delegate.return_code:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not totalNodesCreated + 1:
                        revert with 0, 17
                    totalNodesCreated++
                    if msg.sender == tokenAddress:
                        mem[0] = address(arg1)
                        mem[64] = ceil32(ceil32(arg2.length)) + (32 * stor10[address(arg1)].field_0) + 257
                        mem[ceil32(ceil32(arg2.length)) + 225] = stor10[address(arg1)].field_0
                        s = ceil32(ceil32(arg2.length)) + 257
                        idx = 0
                        while idx < stor10[address(arg1)].field_0:
                            mem[0] = sha3(address(arg1), 10)
                            _15214 = mem[64]
                            mem[64] = mem[64] + 128
                            if stor10[address(arg1)][idx].field_0:
                                if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                                    revert with 0, 34
                                _15553 = mem[64]
                                mem[64] = mem[64] + ceil32(uint255(stor10[address(arg1)][idx].field_0) * 0.5) + 32
                                mem[_15553] = uint255(stor10[address(arg1)][idx].field_0) * 0.5
                                if stor10[address(arg1)][idx].field_0:
                                    if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                                        revert with 0, 34
                                    if Mask(256, -1, stor10[address(arg1)][idx].field_0):
                                        if 31 >= uint255(stor10[address(arg1)][idx].field_0) * 0.5:
                                            mem[_15553 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                        else:
                                            mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                            mem[_15553 + 32] = stor10[address(arg1)][idx].field_0
                                            t = _15553 + 32
                                            u = sha3(mem[0])
                                            while _15553 + (uint255(stor10[address(arg1)][idx].field_0) * 0.5) > t:
                                                mem[t + 32] = uint256(stor1[u])
                                                t = t + 32
                                                u = u + 1
                                                continue 
                                    mem[_15214] = _15553
                                    mem[_15214 + 32] = stor10[address(arg1)][idx].field_256
                                    mem[_15214 + 64] = stor10[address(arg1)][idx].field_512
                                    mem[_15214 + 96] = stor10[address(arg1)][idx].field_768
                                    mem[s] = _15214
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                                    revert with 0, 34
                                if not stor10[address(arg1)][idx].field_1:
                                    mem[_15214] = _15553
                                    mem[_15214 + 32] = stor10[address(arg1)][idx].field_256
                                    mem[_15214 + 64] = stor10[address(arg1)][idx].field_512
                                    mem[_15214 + 96] = stor10[address(arg1)][idx].field_768
                                    mem[s] = _15214
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                if 31 >= stor10[address(arg1)][idx].field_1:
                                    mem[_15553 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                    mem[_15214] = _15553
                                    mem[_15214 + 32] = stor10[address(arg1)][idx].field_256
                                    mem[_15214 + 64] = stor10[address(arg1)][idx].field_512
                                    mem[_15214 + 96] = stor10[address(arg1)][idx].field_768
                                    mem[s] = _15214
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                mem[_15553 + 32] = stor10[address(arg1)][idx].field_0
                                t = _15553 + 32
                                u = sha3(mem[0])
                                while _15553 + stor10[address(arg1)][u].field_1 > t:
                                    mem[t + 32] = uint256(stor1[u])
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                mem[_15214] = _15553
                                mem[_15214 + 32] = stor10[address(arg1)][u].field_256
                                mem[_15214 + 64] = stor10[address(arg1)][u].field_512
                                mem[_15214 + 96] = stor10[address(arg1)][u].field_768
                                mem[t] = _15214
                                t = t + 32
                                u = u + 1
                                continue 
                            if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                                revert with 0, 34
                            _15632 = mem[64]
                            mem[64] = mem[64] + ceil32(stor10[address(arg1)][idx].field_1) + 32
                            mem[_15632] = stor10[address(arg1)][idx].field_1
                            if stor10[address(arg1)][idx].field_0:
                                if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                                    revert with 0, 34
                                if not Mask(256, -1, stor10[address(arg1)][idx].field_0):
                                    mem[_15214] = _15632
                                    mem[_15214 + 32] = stor10[address(arg1)][idx].field_256
                                    mem[_15214 + 64] = stor10[address(arg1)][idx].field_512
                                    mem[_15214 + 96] = stor10[address(arg1)][idx].field_768
                                    mem[s] = _15214
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                if 31 >= uint255(stor10[address(arg1)][idx].field_0) * 0.5:
                                    mem[_15632 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                    mem[_15214] = _15632
                                    mem[_15214 + 32] = stor10[address(arg1)][idx].field_256
                                    mem[_15214 + 64] = stor10[address(arg1)][idx].field_512
                                    mem[_15214 + 96] = stor10[address(arg1)][idx].field_768
                                    mem[s] = _15214
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                mem[_15632 + 32] = stor10[address(arg1)][idx].field_0
                                t = _15632 + 32
                                u = sha3(mem[0])
                                while _15632 + (uint255(stor10[address(arg1)][u].field_0) * 0.5) > t:
                                    mem[t + 32] = uint256(stor1[u])
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                mem[_15214] = _15632
                                mem[_15214 + 32] = stor10[address(arg1)][u].field_256
                                mem[_15214 + 64] = stor10[address(arg1)][u].field_512
                                mem[_15214 + 96] = stor10[address(arg1)][u].field_768
                                mem[t] = _15214
                                t = t + 32
                                u = u + 1
                                continue 
                            if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                                revert with 0, 34
                            if stor10[address(arg1)][idx].field_1:
                                if 31 >= stor10[address(arg1)][idx].field_1:
                                    mem[_15632 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                else:
                                    mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                    mem[_15632 + 32] = stor10[address(arg1)][idx].field_0
                                    t = _15632 + 32
                                    u = sha3(mem[0])
                                    while _15632 + stor10[address(arg1)][idx].field_1 > t:
                                        mem[t + 32] = uint256(stor1[u])
                                        t = t + 32
                                        u = u + 1
                                        continue 
                            mem[_15214] = _15632
                            mem[_15214 + 32] = stor10[address(arg1)][idx].field_256
                            mem[_15214 + 64] = stor10[address(arg1)][idx].field_512
                            mem[_15214 + 96] = stor10[address(arg1)][idx].field_768
                            mem[s] = _15214
                            s = s + 32
                            idx = idx + 1
                            continue 
                        mem[0] = address(arg3)
                        mem[32] = 10
                        _15212 = mem[64]
                        mem[64] = mem[64] + (32 * stor10[address(arg3)].field_0) + 32
                        mem[_15212] = stor10[address(arg3)].field_0
                        s = _15212 + 32
                        idx = 0
                        while idx < stor10[address(arg3)].field_0:
                            mem[0] = sha3(address(arg3), 10)
                            _22484 = mem[64]
                            mem[64] = mem[64] + 128
                            if stor10[address(arg3)][idx].field_0:
                                if not stor10[address(arg3)][idx].field_0 - (uint255(stor10[address(arg3)][idx].field_0) * 0.5 < 32):
                                    revert with 0, 34
                                _22774 = mem[64]
                                mem[64] = mem[64] + ceil32(uint255(stor10[address(arg3)][idx].field_0) * 0.5) + 32
                                mem[_22774] = uint255(stor10[address(arg3)][idx].field_0) * 0.5
                                if stor10[address(arg3)][idx].field_0:
                                    if not stor10[address(arg3)][idx].field_0 - (uint255(stor10[address(arg3)][idx].field_0) * 0.5 < 32):
                                        revert with 0, 34
                                    if Mask(256, -1, stor10[address(arg3)][idx].field_0):
                                        if 31 >= uint255(stor10[address(arg3)][idx].field_0) * 0.5:
                                            mem[_22774 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                        else:
                                            mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                            mem[_22774 + 32] = stor10[address(arg3)][idx].field_0
                                            t = _22774 + 32
                                            u = sha3(mem[0])
                                            while _22774 + (uint255(stor10[address(arg3)][idx].field_0) * 0.5) > t:
                                                mem[t + 32] = uint256(stor1[u])
                                                t = t + 32
                                                u = u + 1
                                                continue 
                                    mem[_22484] = _22774
                                    mem[_22484 + 32] = stor10[address(arg3)][idx].field_256
                                    mem[_22484 + 64] = stor10[address(arg3)][idx].field_512
                                    mem[_22484 + 96] = stor10[address(arg3)][idx].field_768
                                    mem[s] = _22484
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                if not stor10[address(arg3)][idx].field_0 - (stor10[address(arg3)][idx].field_1 < 32):
                                    revert with 0, 34
                                if not stor10[address(arg3)][idx].field_1:
                                    mem[_22484] = _22774
                                    mem[_22484 + 32] = stor10[address(arg3)][idx].field_256
                                    mem[_22484 + 64] = stor10[address(arg3)][idx].field_512
                                    mem[_22484 + 96] = stor10[address(arg3)][idx].field_768
                                    mem[s] = _22484
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                if 31 >= stor10[address(arg3)][idx].field_1:
                                    mem[_22774 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                    mem[_22484] = _22774
                                    mem[_22484 + 32] = stor10[address(arg3)][idx].field_256
                                    mem[_22484 + 64] = stor10[address(arg3)][idx].field_512
                                    mem[_22484 + 96] = stor10[address(arg3)][idx].field_768
                                    mem[s] = _22484
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                mem[_22774 + 32] = stor10[address(arg3)][idx].field_0
                                t = _22774 + 32
                                u = sha3(mem[0])
                                while _22774 + stor10[address(arg3)][u].field_1 > t:
                                    mem[t + 32] = uint256(stor1[u])
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                mem[_22484] = _22774
                                mem[_22484 + 32] = stor10[address(arg3)][u].field_256
                                mem[_22484 + 64] = stor10[address(arg3)][u].field_512
                                mem[_22484 + 96] = stor10[address(arg3)][u].field_768
                                mem[t] = _22484
                                t = t + 32
                                u = u + 1
                                continue 
                            if not stor10[address(arg3)][idx].field_0 - (stor10[address(arg3)][idx].field_1 < 32):
                                revert with 0, 34
                            _22880 = mem[64]
                            mem[64] = mem[64] + ceil32(stor10[address(arg3)][idx].field_1) + 32
                            mem[_22880] = stor10[address(arg3)][idx].field_1
                            if stor10[address(arg3)][idx].field_0:
                                if not stor10[address(arg3)][idx].field_0 - (uint255(stor10[address(arg3)][idx].field_0) * 0.5 < 32):
                                    revert with 0, 34
                                if not Mask(256, -1, stor10[address(arg3)][idx].field_0):
                                    mem[_22484] = _22880
                                    mem[_22484 + 32] = stor10[address(arg3)][idx].field_256
                                    mem[_22484 + 64] = stor10[address(arg3)][idx].field_512
                                    mem[_22484 + 96] = stor10[address(arg3)][idx].field_768
                                    mem[s] = _22484
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                if 31 >= uint255(stor10[address(arg3)][idx].field_0) * 0.5:
                                    mem[_22880 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                    mem[_22484] = _22880
                                    mem[_22484 + 32] = stor10[address(arg3)][idx].field_256
                                    mem[_22484 + 64] = stor10[address(arg3)][idx].field_512
                                    mem[_22484 + 96] = stor10[address(arg3)][idx].field_768
                                    mem[s] = _22484
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                mem[_22880 + 32] = stor10[address(arg3)][idx].field_0
                                t = _22880 + 32
                                u = sha3(mem[0])
                                while _22880 + (uint255(stor10[address(arg3)][u].field_0) * 0.5) > t:
                                    mem[t + 32] = uint256(stor1[u])
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                mem[_22484] = _22880
                                mem[_22484 + 32] = stor10[address(arg3)][u].field_256
                                mem[_22484 + 64] = stor10[address(arg3)][u].field_512
                                mem[_22484 + 96] = stor10[address(arg3)][u].field_768
                                mem[t] = _22484
                                t = t + 32
                                u = u + 1
                                continue 
                            if not stor10[address(arg3)][idx].field_0 - (stor10[address(arg3)][idx].field_1 < 32):
                                revert with 0, 34
                            if stor10[address(arg3)][idx].field_1:
                                if 31 >= stor10[address(arg3)][idx].field_1:
                                    mem[_22880 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                else:
                                    mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                    mem[_22880 + 32] = stor10[address(arg3)][idx].field_0
                                    t = _22880 + 32
                                    u = sha3(mem[0])
                                    while _22880 + stor10[address(arg3)][idx].field_1 > t:
                                        mem[t + 32] = uint256(stor1[u])
                                        t = t + 32
                                        u = u + 1
                                        continue 
                            mem[_22484] = _22880
                            mem[_22484 + 32] = stor10[address(arg3)][idx].field_256
                            mem[_22484 + 64] = stor10[address(arg3)][idx].field_512
                            mem[_22484 + 96] = stor10[address(arg3)][idx].field_768
                            mem[s] = _22484
                            s = s + 32
                            idx = idx + 1
                            continue 
                        if address(arg1) != address(arg3):
                            if mem[ceil32(ceil32(arg2.length)) + 225] <= 1:
                                if mem[_15212] > 0:
                                    if _referrals[address(arg1)] != address(arg3):
                                        _referrals[address(arg1)] = address(arg3)
                                        sub_989baf69[address(arg3)].field_0++
                                        sub_989baf69[address(arg3)][sub_989baf69[address(arg3)].field_0].field_0 = address(arg1)
                                    if tokenAddress != msg.sender:
                                        if gateKeeperAddress != msg.sender:
                                            if address(stor0.field_0) != msg.sender:
                                                revert with 0, 'NodeManagerV2: NOT AUTHORIZED'
                                    if stor10[stor11[address(arg1)]].field_0:
                                        if not -referralBonusPercent:
                                            sub_e27e434a[stor11[address(arg1)]][address(arg1)] = 0
                                            if sub_666755bb[stor11[address(arg1)]] > -1:
                                                revert with 0, 17
                                        else:
                                            if referralBonusPercent and nodePrice > -1 / referralBonusPercent:
                                                revert with 0, 17
                                            if not referralBonusPercent:
                                                revert with 0, 18
                                            if referralBonusPercent * nodePrice / referralBonusPercent != nodePrice:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            sub_e27e434a[stor11[address(arg1)]][address(arg1)] = referralBonusPercent * nodePrice / 100
                                            if sub_666755bb[stor11[address(arg1)]] > !(referralBonusPercent * nodePrice / 100):
                                                revert with 0, 17
                                            sub_666755bb[stor11[address(arg1)]] += referralBonusPercent * nodePrice / 100
                    else:
                        if msg.sender == gateKeeperAddress:
                            mem[0] = address(arg1)
                            mem[64] = ceil32(ceil32(arg2.length)) + (32 * stor10[address(arg1)].field_0) + 257
                            mem[ceil32(ceil32(arg2.length)) + 225] = stor10[address(arg1)].field_0
                            s = ceil32(ceil32(arg2.length)) + 257
                            idx = 0
                            while idx < stor10[address(arg1)].field_0:
                                mem[0] = sha3(address(arg1), 10)
                                _15218 = mem[64]
                                mem[64] = mem[64] + 128
                                if stor10[address(arg1)][idx].field_0:
                                    if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                                        revert with 0, 34
                                    _15554 = mem[64]
                                    mem[64] = mem[64] + ceil32(uint255(stor10[address(arg1)][idx].field_0) * 0.5) + 32
                                    mem[_15554] = uint255(stor10[address(arg1)][idx].field_0) * 0.5
                                    if stor10[address(arg1)][idx].field_0:
                                        if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                                            revert with 0, 34
                                        if Mask(256, -1, stor10[address(arg1)][idx].field_0):
                                            if 31 >= uint255(stor10[address(arg1)][idx].field_0) * 0.5:
                                                mem[_15554 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                            else:
                                                mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                                mem[_15554 + 32] = stor10[address(arg1)][idx].field_0
                                                t = _15554 + 32
                                                u = sha3(mem[0])
                                                while _15554 + (uint255(stor10[address(arg1)][idx].field_0) * 0.5) > t:
                                                    mem[t + 32] = uint256(stor1[u])
                                                    t = t + 32
                                                    u = u + 1
                                                    continue 
                                        mem[_15218] = _15554
                                        mem[_15218 + 32] = stor10[address(arg1)][idx].field_256
                                        mem[_15218 + 64] = stor10[address(arg1)][idx].field_512
                                        mem[_15218 + 96] = stor10[address(arg1)][idx].field_768
                                        mem[s] = _15218
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                                        revert with 0, 34
                                    if not stor10[address(arg1)][idx].field_1:
                                        mem[_15218] = _15554
                                        mem[_15218 + 32] = stor10[address(arg1)][idx].field_256
                                        mem[_15218 + 64] = stor10[address(arg1)][idx].field_512
                                        mem[_15218 + 96] = stor10[address(arg1)][idx].field_768
                                        mem[s] = _15218
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    if 31 >= stor10[address(arg1)][idx].field_1:
                                        mem[_15554 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                        mem[_15218] = _15554
                                        mem[_15218 + 32] = stor10[address(arg1)][idx].field_256
                                        mem[_15218 + 64] = stor10[address(arg1)][idx].field_512
                                        mem[_15218 + 96] = stor10[address(arg1)][idx].field_768
                                        mem[s] = _15218
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                    mem[_15554 + 32] = stor10[address(arg1)][idx].field_0
                                    t = _15554 + 32
                                    u = sha3(mem[0])
                                    while _15554 + stor10[address(arg1)][u].field_1 > t:
                                        mem[t + 32] = uint256(stor1[u])
                                        t = t + 32
                                        u = u + 1
                                        continue 
                                    mem[_15218] = _15554
                                    mem[_15218 + 32] = stor10[address(arg1)][u].field_256
                                    mem[_15218 + 64] = stor10[address(arg1)][u].field_512
                                    mem[_15218 + 96] = stor10[address(arg1)][u].field_768
                                    mem[t] = _15218
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                                    revert with 0, 34
                                _15634 = mem[64]
                                mem[64] = mem[64] + ceil32(stor10[address(arg1)][idx].field_1) + 32
                                mem[_15634] = stor10[address(arg1)][idx].field_1
                                if stor10[address(arg1)][idx].field_0:
                                    if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                                        revert with 0, 34
                                    if not Mask(256, -1, stor10[address(arg1)][idx].field_0):
                                        mem[_15218] = _15634
                                        mem[_15218 + 32] = stor10[address(arg1)][idx].field_256
                                        mem[_15218 + 64] = stor10[address(arg1)][idx].field_512
                                        mem[_15218 + 96] = stor10[address(arg1)][idx].field_768
                                        mem[s] = _15218
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    if 31 >= uint255(stor10[address(arg1)][idx].field_0) * 0.5:
                                        mem[_15634 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                        mem[_15218] = _15634
                                        mem[_15218 + 32] = stor10[address(arg1)][idx].field_256
                                        mem[_15218 + 64] = stor10[address(arg1)][idx].field_512
                                        mem[_15218 + 96] = stor10[address(arg1)][idx].field_768
                                        mem[s] = _15218
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                    mem[_15634 + 32] = stor10[address(arg1)][idx].field_0
                                    t = _15634 + 32
                                    u = sha3(mem[0])
                                    while _15634 + (uint255(stor10[address(arg1)][u].field_0) * 0.5) > t:
                                        mem[t + 32] = uint256(stor1[u])
                                        t = t + 32
                                        u = u + 1
                                        continue 
                                    mem[_15218] = _15634
                                    mem[_15218 + 32] = stor10[address(arg1)][u].field_256
                                    mem[_15218 + 64] = stor10[address(arg1)][u].field_512
                                    mem[_15218 + 96] = stor10[address(arg1)][u].field_768
                                    mem[t] = _15218
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                                    revert with 0, 34
                                if stor10[address(arg1)][idx].field_1:
                                    if 31 >= stor10[address(arg1)][idx].field_1:
                                        mem[_15634 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                    else:
                                        mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                        mem[_15634 + 32] = stor10[address(arg1)][idx].field_0
                                        t = _15634 + 32
                                        u = sha3(mem[0])
                                        while _15634 + stor10[address(arg1)][idx].field_1 > t:
                                            mem[t + 32] = uint256(stor1[u])
                                            t = t + 32
                                            u = u + 1
                                            continue 
                                mem[_15218] = _15634
                                mem[_15218 + 32] = stor10[address(arg1)][idx].field_256
                                mem[_15218 + 64] = stor10[address(arg1)][idx].field_512
                                mem[_15218 + 96] = stor10[address(arg1)][idx].field_768
                                mem[s] = _15218
                                s = s + 32
                                idx = idx + 1
                                continue 
                            mem[0] = address(arg3)
                            mem[32] = 10
                            _15216 = mem[64]
                            mem[64] = mem[64] + (32 * stor10[address(arg3)].field_0) + 32
                            mem[_15216] = stor10[address(arg3)].field_0
                            s = _15216 + 32
                            idx = 0
                            while idx < stor10[address(arg3)].field_0:
                                mem[0] = sha3(address(arg3), 10)
                                _22486 = mem[64]
                                mem[64] = mem[64] + 128
                                if stor10[address(arg3)][idx].field_0:
                                    if not stor10[address(arg3)][idx].field_0 - (uint255(stor10[address(arg3)][idx].field_0) * 0.5 < 32):
                                        revert with 0, 34
                                    _22775 = mem[64]
                                    mem[64] = mem[64] + ceil32(uint255(stor10[address(arg3)][idx].field_0) * 0.5) + 32
                                    mem[_22775] = uint255(stor10[address(arg3)][idx].field_0) * 0.5
                                    if stor10[address(arg3)][idx].field_0:
                                        if not stor10[address(arg3)][idx].field_0 - (uint255(stor10[address(arg3)][idx].field_0) * 0.5 < 32):
                                            revert with 0, 34
                                        if Mask(256, -1, stor10[address(arg3)][idx].field_0):
                                            if 31 >= uint255(stor10[address(arg3)][idx].field_0) * 0.5:
                                                mem[_22775 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                            else:
                                                mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                                mem[_22775 + 32] = stor10[address(arg3)][idx].field_0
                                                t = _22775 + 32
                                                u = sha3(mem[0])
                                                while _22775 + (uint255(stor10[address(arg3)][idx].field_0) * 0.5) > t:
                                                    mem[t + 32] = uint256(stor1[u])
                                                    t = t + 32
                                                    u = u + 1
                                                    continue 
                                        mem[_22486] = _22775
                                        mem[_22486 + 32] = stor10[address(arg3)][idx].field_256
                                        mem[_22486 + 64] = stor10[address(arg3)][idx].field_512
                                        mem[_22486 + 96] = stor10[address(arg3)][idx].field_768
                                        mem[s] = _22486
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    if not stor10[address(arg3)][idx].field_0 - (stor10[address(arg3)][idx].field_1 < 32):
                                        revert with 0, 34
                                    if not stor10[address(arg3)][idx].field_1:
                                        mem[_22486] = _22775
                                        mem[_22486 + 32] = stor10[address(arg3)][idx].field_256
                                        mem[_22486 + 64] = stor10[address(arg3)][idx].field_512
                                        mem[_22486 + 96] = stor10[address(arg3)][idx].field_768
                                        mem[s] = _22486
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    if 31 >= stor10[address(arg3)][idx].field_1:
                                        mem[_22775 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                        mem[_22486] = _22775
                                        mem[_22486 + 32] = stor10[address(arg3)][idx].field_256
                                        mem[_22486 + 64] = stor10[address(arg3)][idx].field_512
                                        mem[_22486 + 96] = stor10[address(arg3)][idx].field_768
                                        mem[s] = _22486
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                    mem[_22775 + 32] = stor10[address(arg3)][idx].field_0
                                    t = _22775 + 32
                                    u = sha3(mem[0])
                                    while _22775 + stor10[address(arg3)][u].field_1 > t:
                                        mem[t + 32] = uint256(stor1[u])
                                        t = t + 32
                                        u = u + 1
                                        continue 
                                    mem[_22486] = _22775
                                    mem[_22486 + 32] = stor10[address(arg3)][u].field_256
                                    mem[_22486 + 64] = stor10[address(arg3)][u].field_512
                                    mem[_22486 + 96] = stor10[address(arg3)][u].field_768
                                    mem[t] = _22486
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                if not stor10[address(arg3)][idx].field_0 - (stor10[address(arg3)][idx].field_1 < 32):
                                    revert with 0, 34
                                _22882 = mem[64]
                                mem[64] = mem[64] + ceil32(stor10[address(arg3)][idx].field_1) + 32
                                mem[_22882] = stor10[address(arg3)][idx].field_1
                                if stor10[address(arg3)][idx].field_0:
                                    if not stor10[address(arg3)][idx].field_0 - (uint255(stor10[address(arg3)][idx].field_0) * 0.5 < 32):
                                        revert with 0, 34
                                    if not Mask(256, -1, stor10[address(arg3)][idx].field_0):
                                        mem[_22486] = _22882
                                        mem[_22486 + 32] = stor10[address(arg3)][idx].field_256
                                        mem[_22486 + 64] = stor10[address(arg3)][idx].field_512
                                        mem[_22486 + 96] = stor10[address(arg3)][idx].field_768
                                        mem[s] = _22486
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    if 31 >= uint255(stor10[address(arg3)][idx].field_0) * 0.5:
                                        mem[_22882 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                        mem[_22486] = _22882
                                        mem[_22486 + 32] = stor10[address(arg3)][idx].field_256
                                        mem[_22486 + 64] = stor10[address(arg3)][idx].field_512
                                        mem[_22486 + 96] = stor10[address(arg3)][idx].field_768
                                        mem[s] = _22486
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                    mem[_22882 + 32] = stor10[address(arg3)][idx].field_0
                                    t = _22882 + 32
                                    u = sha3(mem[0])
                                    while _22882 + (uint255(stor10[address(arg3)][u].field_0) * 0.5) > t:
                                        mem[t + 32] = uint256(stor1[u])
                                        t = t + 32
                                        u = u + 1
                                        continue 
                                    mem[_22486] = _22882
                                    mem[_22486 + 32] = stor10[address(arg3)][u].field_256
                                    mem[_22486 + 64] = stor10[address(arg3)][u].field_512
                                    mem[_22486 + 96] = stor10[address(arg3)][u].field_768
                                    mem[t] = _22486
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                if not stor10[address(arg3)][idx].field_0 - (stor10[address(arg3)][idx].field_1 < 32):
                                    revert with 0, 34
                                if stor10[address(arg3)][idx].field_1:
                                    if 31 >= stor10[address(arg3)][idx].field_1:
                                        mem[_22882 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                    else:
                                        mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                        mem[_22882 + 32] = stor10[address(arg3)][idx].field_0
                                        t = _22882 + 32
                                        u = sha3(mem[0])
                                        while _22882 + stor10[address(arg3)][idx].field_1 > t:
                                            mem[t + 32] = uint256(stor1[u])
                                            t = t + 32
                                            u = u + 1
                                            continue 
                                mem[_22486] = _22882
                                mem[_22486 + 32] = stor10[address(arg3)][idx].field_256
                                mem[_22486 + 64] = stor10[address(arg3)][idx].field_512
                                mem[_22486 + 96] = stor10[address(arg3)][idx].field_768
                                mem[s] = _22486
                                s = s + 32
                                idx = idx + 1
                                continue 
                            if address(arg1) != address(arg3):
                                if mem[ceil32(ceil32(arg2.length)) + 225] <= 1:
                                    if mem[_15216] > 0:
                                        if _referrals[address(arg1)] != address(arg3):
                                            _referrals[address(arg1)] = address(arg3)
                                            sub_989baf69[address(arg3)].field_0++
                                            sub_989baf69[address(arg3)][sub_989baf69[address(arg3)].field_0].field_0 = address(arg1)
                                        if tokenAddress != msg.sender:
                                            if gateKeeperAddress != msg.sender:
                                                if address(stor0.field_0) != msg.sender:
                                                    revert with 0, 'NodeManagerV2: NOT AUTHORIZED'
                                        if stor10[stor11[address(arg1)]].field_0:
                                            if not -referralBonusPercent:
                                                sub_e27e434a[stor11[address(arg1)]][address(arg1)] = 0
                                                if sub_666755bb[stor11[address(arg1)]] > -1:
                                                    revert with 0, 17
                                            else:
                                                if referralBonusPercent and nodePrice > -1 / referralBonusPercent:
                                                    revert with 0, 17
                                                if not referralBonusPercent:
                                                    revert with 0, 18
                                                if referralBonusPercent * nodePrice / referralBonusPercent != nodePrice:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                sub_e27e434a[stor11[address(arg1)]][address(arg1)] = referralBonusPercent * nodePrice / 100
                                                if sub_666755bb[stor11[address(arg1)]] > !(referralBonusPercent * nodePrice / 100):
                                                    revert with 0, 17
                                                sub_666755bb[stor11[address(arg1)]] += referralBonusPercent * nodePrice / 100
                        else:
                            if address(stor0.field_0) != msg.sender:
                                revert with 0, 'NodeManagerV2: NOT AUTHORIZED'
                            mem[0] = address(arg1)
                            mem[64] = ceil32(ceil32(arg2.length)) + (32 * stor10[address(arg1)].field_0) + 257
                            mem[ceil32(ceil32(arg2.length)) + 225] = stor10[address(arg1)].field_0
                            s = ceil32(ceil32(arg2.length)) + 257
                            idx = 0
                            while idx < stor10[address(arg1)].field_0:
                                mem[0] = sha3(address(arg1), 10)
                                _15222 = mem[64]
                                mem[64] = mem[64] + 128
                                if stor10[address(arg1)][idx].field_0:
                                    if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                                        revert with 0, 34
                                    _15555 = mem[64]
                                    mem[64] = mem[64] + ceil32(uint255(stor10[address(arg1)][idx].field_0) * 0.5) + 32
                                    mem[_15555] = uint255(stor10[address(arg1)][idx].field_0) * 0.5
                                    if stor10[address(arg1)][idx].field_0:
                                        if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                                            revert with 0, 34
                                        if Mask(256, -1, stor10[address(arg1)][idx].field_0):
                                            if 31 >= uint255(stor10[address(arg1)][idx].field_0) * 0.5:
                                                mem[_15555 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                            else:
                                                mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                                mem[_15555 + 32] = stor10[address(arg1)][idx].field_0
                                                t = _15555 + 32
                                                u = sha3(mem[0])
                                                while _15555 + (uint255(stor10[address(arg1)][idx].field_0) * 0.5) > t:
                                                    mem[t + 32] = uint256(stor1[u])
                                                    t = t + 32
                                                    u = u + 1
                                                    continue 
                                        mem[_15222] = _15555
                                        mem[_15222 + 32] = stor10[address(arg1)][idx].field_256
                                        mem[_15222 + 64] = stor10[address(arg1)][idx].field_512
                                        mem[_15222 + 96] = stor10[address(arg1)][idx].field_768
                                        mem[s] = _15222
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                                        revert with 0, 34
                                    if not stor10[address(arg1)][idx].field_1:
                                        mem[_15222] = _15555
                                        mem[_15222 + 32] = stor10[address(arg1)][idx].field_256
                                        mem[_15222 + 64] = stor10[address(arg1)][idx].field_512
                                        mem[_15222 + 96] = stor10[address(arg1)][idx].field_768
                                        mem[s] = _15222
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    if 31 >= stor10[address(arg1)][idx].field_1:
                                        mem[_15555 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                        mem[_15222] = _15555
                                        mem[_15222 + 32] = stor10[address(arg1)][idx].field_256
                                        mem[_15222 + 64] = stor10[address(arg1)][idx].field_512
                                        mem[_15222 + 96] = stor10[address(arg1)][idx].field_768
                                        mem[s] = _15222
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                    mem[_15555 + 32] = stor10[address(arg1)][idx].field_0
                                    t = _15555 + 32
                                    u = sha3(mem[0])
                                    while _15555 + stor10[address(arg1)][u].field_1 > t:
                                        mem[t + 32] = uint256(stor1[u])
                                        t = t + 32
                                        u = u + 1
                                        continue 
                                    mem[_15222] = _15555
                                    mem[_15222 + 32] = stor10[address(arg1)][u].field_256
                                    mem[_15222 + 64] = stor10[address(arg1)][u].field_512
                                    mem[_15222 + 96] = stor10[address(arg1)][u].field_768
                                    mem[t] = _15222
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                                    revert with 0, 34
                                _15636 = mem[64]
                                mem[64] = mem[64] + ceil32(stor10[address(arg1)][idx].field_1) + 32
                                mem[_15636] = stor10[address(arg1)][idx].field_1
                                if stor10[address(arg1)][idx].field_0:
                                    if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                                        revert with 0, 34
                                    if not Mask(256, -1, stor10[address(arg1)][idx].field_0):
                                        mem[_15222] = _15636
                                        mem[_15222 + 32] = stor10[address(arg1)][idx].field_256
                                        mem[_15222 + 64] = stor10[address(arg1)][idx].field_512
                                        mem[_15222 + 96] = stor10[address(arg1)][idx].field_768
                                        mem[s] = _15222
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    if 31 >= uint255(stor10[address(arg1)][idx].field_0) * 0.5:
                                        mem[_15636 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                        mem[_15222] = _15636
                                        mem[_15222 + 32] = stor10[address(arg1)][idx].field_256
                                        mem[_15222 + 64] = stor10[address(arg1)][idx].field_512
                                        mem[_15222 + 96] = stor10[address(arg1)][idx].field_768
                                        mem[s] = _15222
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                    mem[_15636 + 32] = stor10[address(arg1)][idx].field_0
                                    t = _15636 + 32
                                    u = sha3(mem[0])
                                    while _15636 + (uint255(stor10[address(arg1)][u].field_0) * 0.5) > t:
                                        mem[t + 32] = uint256(stor1[u])
                                        t = t + 32
                                        u = u + 1
                                        continue 
                                    mem[_15222] = _15636
                                    mem[_15222 + 32] = stor10[address(arg1)][u].field_256
                                    mem[_15222 + 64] = stor10[address(arg1)][u].field_512
                                    mem[_15222 + 96] = stor10[address(arg1)][u].field_768
                                    mem[t] = _15222
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                                    revert with 0, 34
                                if stor10[address(arg1)][idx].field_1:
                                    if 31 >= stor10[address(arg1)][idx].field_1:
                                        mem[_15636 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                    else:
                                        mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                        mem[_15636 + 32] = stor10[address(arg1)][idx].field_0
                                        t = _15636 + 32
                                        u = sha3(mem[0])
                                        while _15636 + stor10[address(arg1)][idx].field_1 > t:
                                            mem[t + 32] = uint256(stor1[u])
                                            t = t + 32
                                            u = u + 1
                                            continue 
                                mem[_15222] = _15636
                                mem[_15222 + 32] = stor10[address(arg1)][idx].field_256
                                mem[_15222 + 64] = stor10[address(arg1)][idx].field_512
                                mem[_15222 + 96] = stor10[address(arg1)][idx].field_768
                                mem[s] = _15222
                                s = s + 32
                                idx = idx + 1
                                continue 
                            mem[0] = address(arg3)
                            mem[32] = 10
                            _15220 = mem[64]
                            mem[64] = mem[64] + (32 * stor10[address(arg3)].field_0) + 32
                            mem[_15220] = stor10[address(arg3)].field_0
                            s = _15220 + 32
                            idx = 0
                            while idx < stor10[address(arg3)].field_0:
                                mem[0] = sha3(address(arg3), 10)
                                _22488 = mem[64]
                                mem[64] = mem[64] + 128
                                if stor10[address(arg3)][idx].field_0:
                                    if not stor10[address(arg3)][idx].field_0 - (uint255(stor10[address(arg3)][idx].field_0) * 0.5 < 32):
                                        revert with 0, 34
                                    _22776 = mem[64]
                                    mem[64] = mem[64] + ceil32(uint255(stor10[address(arg3)][idx].field_0) * 0.5) + 32
                                    mem[_22776] = uint255(stor10[address(arg3)][idx].field_0) * 0.5
                                    if stor10[address(arg3)][idx].field_0:
                                        if not stor10[address(arg3)][idx].field_0 - (uint255(stor10[address(arg3)][idx].field_0) * 0.5 < 32):
                                            revert with 0, 34
                                        if Mask(256, -1, stor10[address(arg3)][idx].field_0):
                                            if 31 >= uint255(stor10[address(arg3)][idx].field_0) * 0.5:
                                                mem[_22776 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                            else:
                                                mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                                mem[_22776 + 32] = stor10[address(arg3)][idx].field_0
                                                t = _22776 + 32
                                                u = sha3(mem[0])
                                                while _22776 + (uint255(stor10[address(arg3)][idx].field_0) * 0.5) > t:
                                                    mem[t + 32] = uint256(stor1[u])
                                                    t = t + 32
                                                    u = u + 1
                                                    continue 
                                        mem[_22488] = _22776
                                        mem[_22488 + 32] = stor10[address(arg3)][idx].field_256
                                        mem[_22488 + 64] = stor10[address(arg3)][idx].field_512
                                        mem[_22488 + 96] = stor10[address(arg3)][idx].field_768
                                        mem[s] = _22488
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    if not stor10[address(arg3)][idx].field_0 - (stor10[address(arg3)][idx].field_1 < 32):
                                        revert with 0, 34
                                    if not stor10[address(arg3)][idx].field_1:
                                        mem[_22488] = _22776
                                        mem[_22488 + 32] = stor10[address(arg3)][idx].field_256
                                        mem[_22488 + 64] = stor10[address(arg3)][idx].field_512
                                        mem[_22488 + 96] = stor10[address(arg3)][idx].field_768
                                        mem[s] = _22488
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    if 31 >= stor10[address(arg3)][idx].field_1:
                                        mem[_22776 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                        mem[_22488] = _22776
                                        mem[_22488 + 32] = stor10[address(arg3)][idx].field_256
                                        mem[_22488 + 64] = stor10[address(arg3)][idx].field_512
                                        mem[_22488 + 96] = stor10[address(arg3)][idx].field_768
                                        mem[s] = _22488
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                    mem[_22776 + 32] = stor10[address(arg3)][idx].field_0
                                    t = _22776 + 32
                                    u = sha3(mem[0])
                                    while _22776 + stor10[address(arg3)][u].field_1 > t:
                                        mem[t + 32] = uint256(stor1[u])
                                        t = t + 32
                                        u = u + 1
                                        continue 
                                    mem[_22488] = _22776
                                    mem[_22488 + 32] = stor10[address(arg3)][u].field_256
                                    mem[_22488 + 64] = stor10[address(arg3)][u].field_512
                                    mem[_22488 + 96] = stor10[address(arg3)][u].field_768
                                    mem[t] = _22488
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                if not stor10[address(arg3)][idx].field_0 - (stor10[address(arg3)][idx].field_1 < 32):
                                    revert with 0, 34
                                _22884 = mem[64]
                                mem[64] = mem[64] + ceil32(stor10[address(arg3)][idx].field_1) + 32
                                mem[_22884] = stor10[address(arg3)][idx].field_1
                                if stor10[address(arg3)][idx].field_0:
                                    if not stor10[address(arg3)][idx].field_0 - (uint255(stor10[address(arg3)][idx].field_0) * 0.5 < 32):
                                        revert with 0, 34
                                    if not Mask(256, -1, stor10[address(arg3)][idx].field_0):
                                        mem[_22488] = _22884
                                        mem[_22488 + 32] = stor10[address(arg3)][idx].field_256
                                        mem[_22488 + 64] = stor10[address(arg3)][idx].field_512
                                        mem[_22488 + 96] = stor10[address(arg3)][idx].field_768
                                        mem[s] = _22488
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    if 31 >= uint255(stor10[address(arg3)][idx].field_0) * 0.5:
                                        mem[_22884 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                        mem[_22488] = _22884
                                        mem[_22488 + 32] = stor10[address(arg3)][idx].field_256
                                        mem[_22488 + 64] = stor10[address(arg3)][idx].field_512
                                        mem[_22488 + 96] = stor10[address(arg3)][idx].field_768
                                        mem[s] = _22488
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                    mem[_22884 + 32] = stor10[address(arg3)][idx].field_0
                                    t = _22884 + 32
                                    u = sha3(mem[0])
                                    while _22884 + (uint255(stor10[address(arg3)][u].field_0) * 0.5) > t:
                                        mem[t + 32] = uint256(stor1[u])
                                        t = t + 32
                                        u = u + 1
                                        continue 
                                    mem[_22488] = _22884
                                    mem[_22488 + 32] = stor10[address(arg3)][u].field_256
                                    mem[_22488 + 64] = stor10[address(arg3)][u].field_512
                                    mem[_22488 + 96] = stor10[address(arg3)][u].field_768
                                    mem[t] = _22488
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                if not stor10[address(arg3)][idx].field_0 - (stor10[address(arg3)][idx].field_1 < 32):
                                    revert with 0, 34
                                if stor10[address(arg3)][idx].field_1:
                                    if 31 >= stor10[address(arg3)][idx].field_1:
                                        mem[_22884 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                    else:
                                        mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                        mem[_22884 + 32] = stor10[address(arg3)][idx].field_0
                                        t = _22884 + 32
                                        u = sha3(mem[0])
                                        while _22884 + stor10[address(arg3)][idx].field_1 > t:
                                            mem[t + 32] = uint256(stor1[u])
                                            t = t + 32
                                            u = u + 1
                                            continue 
                                mem[_22488] = _22884
                                mem[_22488 + 32] = stor10[address(arg3)][idx].field_256
                                mem[_22488 + 64] = stor10[address(arg3)][idx].field_512
                                mem[_22488 + 96] = stor10[address(arg3)][idx].field_768
                                mem[s] = _22488
                                s = s + 32
                                idx = idx + 1
                                continue 
                            if address(arg1) != address(arg3):
                                if mem[ceil32(ceil32(arg2.length)) + 225] <= 1:
                                    if mem[_15220] > 0:
                                        if _referrals[address(arg1)] != address(arg3):
                                            _referrals[address(arg1)] = address(arg3)
                                            sub_989baf69[address(arg3)].field_0++
                                            sub_989baf69[address(arg3)][sub_989baf69[address(arg3)].field_0].field_0 = address(arg1)
                                        if tokenAddress != msg.sender:
                                            if gateKeeperAddress != msg.sender:
                                                if address(stor0.field_0) != msg.sender:
                                                    revert with 0, 'NodeManagerV2: NOT AUTHORIZED'
                                        if stor10[stor11[address(arg1)]].field_0:
                                            if not -referralBonusPercent:
                                                sub_e27e434a[stor11[address(arg1)]][address(arg1)] = 0
                                                if sub_666755bb[stor11[address(arg1)]] > -1:
                                                    revert with 0, 17
                                            else:
                                                if referralBonusPercent and nodePrice > -1 / referralBonusPercent:
                                                    revert with 0, 17
                                                if not referralBonusPercent:
                                                    revert with 0, 18
                                                if referralBonusPercent * nodePrice / referralBonusPercent != nodePrice:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                sub_e27e434a[stor11[address(arg1)]][address(arg1)] = referralBonusPercent * nodePrice / 100
                                                if sub_666755bb[stor11[address(arg1)]] > !(referralBonusPercent * nodePrice / 100):
                                                    revert with 0, 17
                                                sub_666755bb[stor11[address(arg1)]] += referralBonusPercent * nodePrice / 100
            else:
                if not stor10[address(arg1)][stor10[address(arg1)].field_0].field_0 - (stor10[address(arg1)][stor10[address(arg1)].field_0].field_1 < 32):
                    revert with 0, 34
                if arg2.length:
                    stor10[address(arg1)][stor10[address(arg1)].field_0][].field_0 = Array(len=arg2.length, data=arg2[all])
                    stor10[address(arg1)][stor10[address(arg1)].field_0].field_256 = block.timestamp
                    stor10[address(arg1)][stor10[address(arg1)].field_0].field_512 = block.timestamp
                    stor10[address(arg1)][stor10[address(arg1)].field_0].field_768 = 0
                    mem[ceil32(ceil32(arg2.length)) + 229] = 6
                    mem[ceil32(ceil32(arg2.length)) + 261] = address(arg1)
                    mem[ceil32(ceil32(arg2.length)) + 293] = stor10[address(arg1)].field_0
                    require ext_code.size(0x4b7a346b17572634bdbd85b98abae32c5fa837bb)
                    delegate 0x4b7a346b17572634bdbd85b98abae32c5fa837bb.0xbc2b405c with:
                         gas gas_remaining wei
                        args 6, address(arg1), stor10[address(arg1)].field_0
                    if not delegate.return_code:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not totalNodesCreated + 1:
                        revert with 0, 17
                    totalNodesCreated++
                    if msg.sender == tokenAddress:
                        mem[0] = address(arg1)
                        mem[64] = ceil32(ceil32(arg2.length)) + (32 * stor10[address(arg1)].field_0) + 257
                        mem[ceil32(ceil32(arg2.length)) + 225] = stor10[address(arg1)].field_0
                        s = ceil32(ceil32(arg2.length)) + 257
                        idx = 0
                        while idx < stor10[address(arg1)].field_0:
                            mem[0] = sha3(address(arg1), 10)
                            _22498 = mem[64]
                            mem[64] = mem[64] + 128
                            if stor10[address(arg1)][idx].field_0:
                                if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                                    revert with 0, 34
                                _22780 = mem[64]
                                mem[64] = mem[64] + ceil32(uint255(stor10[address(arg1)][idx].field_0) * 0.5) + 32
                                mem[_22780] = uint255(stor10[address(arg1)][idx].field_0) * 0.5
                                if stor10[address(arg1)][idx].field_0:
                                    if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                                        revert with 0, 34
                                    if Mask(256, -1, stor10[address(arg1)][idx].field_0):
                                        if 31 >= uint255(stor10[address(arg1)][idx].field_0) * 0.5:
                                            mem[_22780 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                        else:
                                            mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                            mem[_22780 + 32] = stor10[address(arg1)][idx].field_0
                                            t = _22780 + 32
                                            u = sha3(mem[0])
                                            while _22780 + (uint255(stor10[address(arg1)][idx].field_0) * 0.5) > t:
                                                mem[t + 32] = uint256(stor1[u])
                                                t = t + 32
                                                u = u + 1
                                                continue 
                                    mem[_22498] = _22780
                                    mem[_22498 + 32] = stor10[address(arg1)][idx].field_256
                                    mem[_22498 + 64] = stor10[address(arg1)][idx].field_512
                                    mem[_22498 + 96] = stor10[address(arg1)][idx].field_768
                                    mem[s] = _22498
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                                    revert with 0, 34
                                if not stor10[address(arg1)][idx].field_1:
                                    mem[_22498] = _22780
                                    mem[_22498 + 32] = stor10[address(arg1)][idx].field_256
                                    mem[_22498 + 64] = stor10[address(arg1)][idx].field_512
                                    mem[_22498 + 96] = stor10[address(arg1)][idx].field_768
                                    mem[s] = _22498
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                if 31 >= stor10[address(arg1)][idx].field_1:
                                    mem[_22780 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                    mem[_22498] = _22780
                                    mem[_22498 + 32] = stor10[address(arg1)][idx].field_256
                                    mem[_22498 + 64] = stor10[address(arg1)][idx].field_512
                                    mem[_22498 + 96] = stor10[address(arg1)][idx].field_768
                                    mem[s] = _22498
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                mem[_22780 + 32] = stor10[address(arg1)][idx].field_0
                                t = _22780 + 32
                                u = sha3(mem[0])
                                while _22780 + stor10[address(arg1)][u].field_1 > t:
                                    mem[t + 32] = uint256(stor1[u])
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                mem[_22498] = _22780
                                mem[_22498 + 32] = stor10[address(arg1)][u].field_256
                                mem[_22498 + 64] = stor10[address(arg1)][u].field_512
                                mem[_22498 + 96] = stor10[address(arg1)][u].field_768
                                mem[t] = _22498
                                t = t + 32
                                u = u + 1
                                continue 
                            if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                                revert with 0, 34
                            _22892 = mem[64]
                            mem[64] = mem[64] + ceil32(stor10[address(arg1)][idx].field_1) + 32
                            mem[_22892] = stor10[address(arg1)][idx].field_1
                            if stor10[address(arg1)][idx].field_0:
                                if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                                    revert with 0, 34
                                if not Mask(256, -1, stor10[address(arg1)][idx].field_0):
                                    mem[_22498] = _22892
                                    mem[_22498 + 32] = stor10[address(arg1)][idx].field_256
                                    mem[_22498 + 64] = stor10[address(arg1)][idx].field_512
                                    mem[_22498 + 96] = stor10[address(arg1)][idx].field_768
                                    mem[s] = _22498
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                if 31 >= uint255(stor10[address(arg1)][idx].field_0) * 0.5:
                                    mem[_22892 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                    mem[_22498] = _22892
                                    mem[_22498 + 32] = stor10[address(arg1)][idx].field_256
                                    mem[_22498 + 64] = stor10[address(arg1)][idx].field_512
                                    mem[_22498 + 96] = stor10[address(arg1)][idx].field_768
                                    mem[s] = _22498
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                mem[_22892 + 32] = stor10[address(arg1)][idx].field_0
                                t = _22892 + 32
                                u = sha3(mem[0])
                                while _22892 + (uint255(stor10[address(arg1)][u].field_0) * 0.5) > t:
                                    mem[t + 32] = uint256(stor1[u])
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                mem[_22498] = _22892
                                mem[_22498 + 32] = stor10[address(arg1)][u].field_256
                                mem[_22498 + 64] = stor10[address(arg1)][u].field_512
                                mem[_22498 + 96] = stor10[address(arg1)][u].field_768
                                mem[t] = _22498
                                t = t + 32
                                u = u + 1
                                continue 
                            if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                                revert with 0, 34
                            if stor10[address(arg1)][idx].field_1:
                                if 31 >= stor10[address(arg1)][idx].field_1:
                                    mem[_22892 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                else:
                                    mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                    mem[_22892 + 32] = stor10[address(arg1)][idx].field_0
                                    t = _22892 + 32
                                    u = sha3(mem[0])
                                    while _22892 + stor10[address(arg1)][idx].field_1 > t:
                                        mem[t + 32] = uint256(stor1[u])
                                        t = t + 32
                                        u = u + 1
                                        continue 
                            mem[_22498] = _22892
                            mem[_22498 + 32] = stor10[address(arg1)][idx].field_256
                            mem[_22498 + 64] = stor10[address(arg1)][idx].field_512
                            mem[_22498 + 96] = stor10[address(arg1)][idx].field_768
                            mem[s] = _22498
                            s = s + 32
                            idx = idx + 1
                            continue 
                        mem[0] = address(arg3)
                        mem[32] = 10
                        _22496 = mem[64]
                        mem[64] = mem[64] + (32 * stor10[address(arg3)].field_0) + 32
                        mem[_22496] = stor10[address(arg3)].field_0
                        s = _22496 + 32
                        idx = 0
                        while idx < stor10[address(arg3)].field_0:
                            mem[0] = sha3(address(arg3), 10)
                            _29078 = mem[64]
                            mem[64] = mem[64] + 128
                            if stor10[address(arg3)][idx].field_0:
                                if not stor10[address(arg3)][idx].field_0 - (uint255(stor10[address(arg3)][idx].field_0) * 0.5 < 32):
                                    revert with 0, 34
                                _29140 = mem[64]
                                mem[64] = mem[64] + ceil32(uint255(stor10[address(arg3)][idx].field_0) * 0.5) + 32
                                mem[_29140] = uint255(stor10[address(arg3)][idx].field_0) * 0.5
                                if stor10[address(arg3)][idx].field_0:
                                    if not stor10[address(arg3)][idx].field_0 - (uint255(stor10[address(arg3)][idx].field_0) * 0.5 < 32):
                                        revert with 0, 34
                                    if Mask(256, -1, stor10[address(arg3)][idx].field_0):
                                        if 31 >= uint255(stor10[address(arg3)][idx].field_0) * 0.5:
                                            mem[_29140 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                        else:
                                            mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                            mem[_29140 + 32] = stor10[address(arg3)][idx].field_0
                                            t = _29140 + 32
                                            u = sha3(mem[0])
                                            while _29140 + (uint255(stor10[address(arg3)][idx].field_0) * 0.5) > t:
                                                mem[t + 32] = uint256(stor1[u])
                                                t = t + 32
                                                u = u + 1
                                                continue 
                                    mem[_29078] = _29140
                                    mem[_29078 + 32] = stor10[address(arg3)][idx].field_256
                                    mem[_29078 + 64] = stor10[address(arg3)][idx].field_512
                                    mem[_29078 + 96] = stor10[address(arg3)][idx].field_768
                                    mem[s] = _29078
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                if not stor10[address(arg3)][idx].field_0 - (stor10[address(arg3)][idx].field_1 < 32):
                                    revert with 0, 34
                                if not stor10[address(arg3)][idx].field_1:
                                    mem[_29078] = _29140
                                    mem[_29078 + 32] = stor10[address(arg3)][idx].field_256
                                    mem[_29078 + 64] = stor10[address(arg3)][idx].field_512
                                    mem[_29078 + 96] = stor10[address(arg3)][idx].field_768
                                    mem[s] = _29078
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                if 31 >= stor10[address(arg3)][idx].field_1:
                                    mem[_29140 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                    mem[_29078] = _29140
                                    mem[_29078 + 32] = stor10[address(arg3)][idx].field_256
                                    mem[_29078 + 64] = stor10[address(arg3)][idx].field_512
                                    mem[_29078 + 96] = stor10[address(arg3)][idx].field_768
                                    mem[s] = _29078
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                mem[_29140 + 32] = stor10[address(arg3)][idx].field_0
                                t = _29140 + 32
                                u = sha3(mem[0])
                                while _29140 + stor10[address(arg3)][u].field_1 > t:
                                    mem[t + 32] = uint256(stor1[u])
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                mem[_29078] = _29140
                                mem[_29078 + 32] = stor10[address(arg3)][u].field_256
                                mem[_29078 + 64] = stor10[address(arg3)][u].field_512
                                mem[_29078 + 96] = stor10[address(arg3)][u].field_768
                                mem[t] = _29078
                                t = t + 32
                                u = u + 1
                                continue 
                            if not stor10[address(arg3)][idx].field_0 - (stor10[address(arg3)][idx].field_1 < 32):
                                revert with 0, 34
                            _29168 = mem[64]
                            mem[64] = mem[64] + ceil32(stor10[address(arg3)][idx].field_1) + 32
                            mem[_29168] = stor10[address(arg3)][idx].field_1
                            if stor10[address(arg3)][idx].field_0:
                                if not stor10[address(arg3)][idx].field_0 - (uint255(stor10[address(arg3)][idx].field_0) * 0.5 < 32):
                                    revert with 0, 34
                                if not Mask(256, -1, stor10[address(arg3)][idx].field_0):
                                    mem[_29078] = _29168
                                    mem[_29078 + 32] = stor10[address(arg3)][idx].field_256
                                    mem[_29078 + 64] = stor10[address(arg3)][idx].field_512
                                    mem[_29078 + 96] = stor10[address(arg3)][idx].field_768
                                    mem[s] = _29078
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                if 31 >= uint255(stor10[address(arg3)][idx].field_0) * 0.5:
                                    mem[_29168 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                    mem[_29078] = _29168
                                    mem[_29078 + 32] = stor10[address(arg3)][idx].field_256
                                    mem[_29078 + 64] = stor10[address(arg3)][idx].field_512
                                    mem[_29078 + 96] = stor10[address(arg3)][idx].field_768
                                    mem[s] = _29078
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                mem[_29168 + 32] = stor10[address(arg3)][idx].field_0
                                t = _29168 + 32
                                u = sha3(mem[0])
                                while _29168 + (uint255(stor10[address(arg3)][u].field_0) * 0.5) > t:
                                    mem[t + 32] = uint256(stor1[u])
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                mem[_29078] = _29168
                                mem[_29078 + 32] = stor10[address(arg3)][u].field_256
                                mem[_29078 + 64] = stor10[address(arg3)][u].field_512
                                mem[_29078 + 96] = stor10[address(arg3)][u].field_768
                                mem[t] = _29078
                                t = t + 32
                                u = u + 1
                                continue 
                            if not stor10[address(arg3)][idx].field_0 - (stor10[address(arg3)][idx].field_1 < 32):
                                revert with 0, 34
                            if stor10[address(arg3)][idx].field_1:
                                if 31 >= stor10[address(arg3)][idx].field_1:
                                    mem[_29168 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                else:
                                    mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                    mem[_29168 + 32] = stor10[address(arg3)][idx].field_0
                                    t = _29168 + 32
                                    u = sha3(mem[0])
                                    while _29168 + stor10[address(arg3)][idx].field_1 > t:
                                        mem[t + 32] = uint256(stor1[u])
                                        t = t + 32
                                        u = u + 1
                                        continue 
                            mem[_29078] = _29168
                            mem[_29078 + 32] = stor10[address(arg3)][idx].field_256
                            mem[_29078 + 64] = stor10[address(arg3)][idx].field_512
                            mem[_29078 + 96] = stor10[address(arg3)][idx].field_768
                            mem[s] = _29078
                            s = s + 32
                            idx = idx + 1
                            continue 
                        if address(arg1) != address(arg3):
                            if mem[ceil32(ceil32(arg2.length)) + 225] <= 1:
                                if mem[_22496] > 0:
                                    if _referrals[address(arg1)] != address(arg3):
                                        _referrals[address(arg1)] = address(arg3)
                                        sub_989baf69[address(arg3)].field_0++
                                        sub_989baf69[address(arg3)][sub_989baf69[address(arg3)].field_0].field_0 = address(arg1)
                                    if tokenAddress != msg.sender:
                                        if gateKeeperAddress != msg.sender:
                                            if address(stor0.field_0) != msg.sender:
                                                revert with 0, 'NodeManagerV2: NOT AUTHORIZED'
                                    if stor10[stor11[address(arg1)]].field_0:
                                        if not -referralBonusPercent:
                                            sub_e27e434a[stor11[address(arg1)]][address(arg1)] = 0
                                            if sub_666755bb[stor11[address(arg1)]] > -1:
                                                revert with 0, 17
                                        else:
                                            if referralBonusPercent and nodePrice > -1 / referralBonusPercent:
                                                revert with 0, 17
                                            if not referralBonusPercent:
                                                revert with 0, 18
                                            if referralBonusPercent * nodePrice / referralBonusPercent != nodePrice:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            sub_e27e434a[stor11[address(arg1)]][address(arg1)] = referralBonusPercent * nodePrice / 100
                                            if sub_666755bb[stor11[address(arg1)]] > !(referralBonusPercent * nodePrice / 100):
                                                revert with 0, 17
                                            sub_666755bb[stor11[address(arg1)]] += referralBonusPercent * nodePrice / 100
                    else:
                        if msg.sender == gateKeeperAddress:
                            mem[0] = address(arg1)
                            mem[64] = ceil32(ceil32(arg2.length)) + (32 * stor10[address(arg1)].field_0) + 257
                            mem[ceil32(ceil32(arg2.length)) + 225] = stor10[address(arg1)].field_0
                            s = ceil32(ceil32(arg2.length)) + 257
                            idx = 0
                            while idx < stor10[address(arg1)].field_0:
                                mem[0] = sha3(address(arg1), 10)
                                _22502 = mem[64]
                                mem[64] = mem[64] + 128
                                if stor10[address(arg1)][idx].field_0:
                                    if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                                        revert with 0, 34
                                    _22781 = mem[64]
                                    mem[64] = mem[64] + ceil32(uint255(stor10[address(arg1)][idx].field_0) * 0.5) + 32
                                    mem[_22781] = uint255(stor10[address(arg1)][idx].field_0) * 0.5
                                    if stor10[address(arg1)][idx].field_0:
                                        if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                                            revert with 0, 34
                                        if Mask(256, -1, stor10[address(arg1)][idx].field_0):
                                            if 31 >= uint255(stor10[address(arg1)][idx].field_0) * 0.5:
                                                mem[_22781 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                            else:
                                                mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                                mem[_22781 + 32] = stor10[address(arg1)][idx].field_0
                                                t = _22781 + 32
                                                u = sha3(mem[0])
                                                while _22781 + (uint255(stor10[address(arg1)][idx].field_0) * 0.5) > t:
                                                    mem[t + 32] = uint256(stor1[u])
                                                    t = t + 32
                                                    u = u + 1
                                                    continue 
                                        mem[_22502] = _22781
                                        mem[_22502 + 32] = stor10[address(arg1)][idx].field_256
                                        mem[_22502 + 64] = stor10[address(arg1)][idx].field_512
                                        mem[_22502 + 96] = stor10[address(arg1)][idx].field_768
                                        mem[s] = _22502
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                                        revert with 0, 34
                                    if not stor10[address(arg1)][idx].field_1:
                                        mem[_22502] = _22781
                                        mem[_22502 + 32] = stor10[address(arg1)][idx].field_256
                                        mem[_22502 + 64] = stor10[address(arg1)][idx].field_512
                                        mem[_22502 + 96] = stor10[address(arg1)][idx].field_768
                                        mem[s] = _22502
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    if 31 >= stor10[address(arg1)][idx].field_1:
                                        mem[_22781 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                        mem[_22502] = _22781
                                        mem[_22502 + 32] = stor10[address(arg1)][idx].field_256
                                        mem[_22502 + 64] = stor10[address(arg1)][idx].field_512
                                        mem[_22502 + 96] = stor10[address(arg1)][idx].field_768
                                        mem[s] = _22502
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                    mem[_22781 + 32] = stor10[address(arg1)][idx].field_0
                                    t = _22781 + 32
                                    u = sha3(mem[0])
                                    while _22781 + stor10[address(arg1)][u].field_1 > t:
                                        mem[t + 32] = uint256(stor1[u])
                                        t = t + 32
                                        u = u + 1
                                        continue 
                                    mem[_22502] = _22781
                                    mem[_22502 + 32] = stor10[address(arg1)][u].field_256
                                    mem[_22502 + 64] = stor10[address(arg1)][u].field_512
                                    mem[_22502 + 96] = stor10[address(arg1)][u].field_768
                                    mem[t] = _22502
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                                    revert with 0, 34
                                _22894 = mem[64]
                                mem[64] = mem[64] + ceil32(stor10[address(arg1)][idx].field_1) + 32
                                mem[_22894] = stor10[address(arg1)][idx].field_1
                                if stor10[address(arg1)][idx].field_0:
                                    if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                                        revert with 0, 34
                                    if not Mask(256, -1, stor10[address(arg1)][idx].field_0):
                                        mem[_22502] = _22894
                                        mem[_22502 + 32] = stor10[address(arg1)][idx].field_256
                                        mem[_22502 + 64] = stor10[address(arg1)][idx].field_512
                                        mem[_22502 + 96] = stor10[address(arg1)][idx].field_768
                                        mem[s] = _22502
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    if 31 >= uint255(stor10[address(arg1)][idx].field_0) * 0.5:
                                        mem[_22894 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                        mem[_22502] = _22894
                                        mem[_22502 + 32] = stor10[address(arg1)][idx].field_256
                                        mem[_22502 + 64] = stor10[address(arg1)][idx].field_512
                                        mem[_22502 + 96] = stor10[address(arg1)][idx].field_768
                                        mem[s] = _22502
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                    mem[_22894 + 32] = stor10[address(arg1)][idx].field_0
                                    t = _22894 + 32
                                    u = sha3(mem[0])
                                    while _22894 + (uint255(stor10[address(arg1)][u].field_0) * 0.5) > t:
                                        mem[t + 32] = uint256(stor1[u])
                                        t = t + 32
                                        u = u + 1
                                        continue 
                                    mem[_22502] = _22894
                                    mem[_22502 + 32] = stor10[address(arg1)][u].field_256
                                    mem[_22502 + 64] = stor10[address(arg1)][u].field_512
                                    mem[_22502 + 96] = stor10[address(arg1)][u].field_768
                                    mem[t] = _22502
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                                    revert with 0, 34
                                if stor10[address(arg1)][idx].field_1:
                                    if 31 >= stor10[address(arg1)][idx].field_1:
                                        mem[_22894 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                    else:
                                        mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                        mem[_22894 + 32] = stor10[address(arg1)][idx].field_0
                                        t = _22894 + 32
                                        u = sha3(mem[0])
                                        while _22894 + stor10[address(arg1)][idx].field_1 > t:
                                            mem[t + 32] = uint256(stor1[u])
                                            t = t + 32
                                            u = u + 1
                                            continue 
                                mem[_22502] = _22894
                                mem[_22502 + 32] = stor10[address(arg1)][idx].field_256
                                mem[_22502 + 64] = stor10[address(arg1)][idx].field_512
                                mem[_22502 + 96] = stor10[address(arg1)][idx].field_768
                                mem[s] = _22502
                                s = s + 32
                                idx = idx + 1
                                continue 
                            mem[0] = address(arg3)
                            mem[32] = 10
                            _22500 = mem[64]
                            mem[64] = mem[64] + (32 * stor10[address(arg3)].field_0) + 32
                            mem[_22500] = stor10[address(arg3)].field_0
                            s = _22500 + 32
                            idx = 0
                            while idx < stor10[address(arg3)].field_0:
                                mem[0] = sha3(address(arg3), 10)
                                _29080 = mem[64]
                                mem[64] = mem[64] + 128
                                if stor10[address(arg3)][idx].field_0:
                                    if not stor10[address(arg3)][idx].field_0 - (uint255(stor10[address(arg3)][idx].field_0) * 0.5 < 32):
                                        revert with 0, 34
                                    _29141 = mem[64]
                                    mem[64] = mem[64] + ceil32(uint255(stor10[address(arg3)][idx].field_0) * 0.5) + 32
                                    mem[_29141] = uint255(stor10[address(arg3)][idx].field_0) * 0.5
                                    if stor10[address(arg3)][idx].field_0:
                                        if not stor10[address(arg3)][idx].field_0 - (uint255(stor10[address(arg3)][idx].field_0) * 0.5 < 32):
                                            revert with 0, 34
                                        if Mask(256, -1, stor10[address(arg3)][idx].field_0):
                                            if 31 >= uint255(stor10[address(arg3)][idx].field_0) * 0.5:
                                                mem[_29141 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                            else:
                                                mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                                mem[_29141 + 32] = stor10[address(arg3)][idx].field_0
                                                t = _29141 + 32
                                                u = sha3(mem[0])
                                                while _29141 + (uint255(stor10[address(arg3)][idx].field_0) * 0.5) > t:
                                                    mem[t + 32] = uint256(stor1[u])
                                                    t = t + 32
                                                    u = u + 1
                                                    continue 
                                        mem[_29080] = _29141
                                        mem[_29080 + 32] = stor10[address(arg3)][idx].field_256
                                        mem[_29080 + 64] = stor10[address(arg3)][idx].field_512
                                        mem[_29080 + 96] = stor10[address(arg3)][idx].field_768
                                        mem[s] = _29080
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    if not stor10[address(arg3)][idx].field_0 - (stor10[address(arg3)][idx].field_1 < 32):
                                        revert with 0, 34
                                    if not stor10[address(arg3)][idx].field_1:
                                        mem[_29080] = _29141
                                        mem[_29080 + 32] = stor10[address(arg3)][idx].field_256
                                        mem[_29080 + 64] = stor10[address(arg3)][idx].field_512
                                        mem[_29080 + 96] = stor10[address(arg3)][idx].field_768
                                        mem[s] = _29080
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    if 31 >= stor10[address(arg3)][idx].field_1:
                                        mem[_29141 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                        mem[_29080] = _29141
                                        mem[_29080 + 32] = stor10[address(arg3)][idx].field_256
                                        mem[_29080 + 64] = stor10[address(arg3)][idx].field_512
                                        mem[_29080 + 96] = stor10[address(arg3)][idx].field_768
                                        mem[s] = _29080
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                    mem[_29141 + 32] = stor10[address(arg3)][idx].field_0
                                    t = _29141 + 32
                                    u = sha3(mem[0])
                                    while _29141 + stor10[address(arg3)][u].field_1 > t:
                                        mem[t + 32] = uint256(stor1[u])
                                        t = t + 32
                                        u = u + 1
                                        continue 
                                    mem[_29080] = _29141
                                    mem[_29080 + 32] = stor10[address(arg3)][u].field_256
                                    mem[_29080 + 64] = stor10[address(arg3)][u].field_512
                                    mem[_29080 + 96] = stor10[address(arg3)][u].field_768
                                    mem[t] = _29080
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                if not stor10[address(arg3)][idx].field_0 - (stor10[address(arg3)][idx].field_1 < 32):
                                    revert with 0, 34
                                _29170 = mem[64]
                                mem[64] = mem[64] + ceil32(stor10[address(arg3)][idx].field_1) + 32
                                mem[_29170] = stor10[address(arg3)][idx].field_1
                                if stor10[address(arg3)][idx].field_0:
                                    if not stor10[address(arg3)][idx].field_0 - (uint255(stor10[address(arg3)][idx].field_0) * 0.5 < 32):
                                        revert with 0, 34
                                    if not Mask(256, -1, stor10[address(arg3)][idx].field_0):
                                        mem[_29080] = _29170
                                        mem[_29080 + 32] = stor10[address(arg3)][idx].field_256
                                        mem[_29080 + 64] = stor10[address(arg3)][idx].field_512
                                        mem[_29080 + 96] = stor10[address(arg3)][idx].field_768
                                        mem[s] = _29080
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    if 31 >= uint255(stor10[address(arg3)][idx].field_0) * 0.5:
                                        mem[_29170 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                        mem[_29080] = _29170
                                        mem[_29080 + 32] = stor10[address(arg3)][idx].field_256
                                        mem[_29080 + 64] = stor10[address(arg3)][idx].field_512
                                        mem[_29080 + 96] = stor10[address(arg3)][idx].field_768
                                        mem[s] = _29080
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                    mem[_29170 + 32] = stor10[address(arg3)][idx].field_0
                                    t = _29170 + 32
                                    u = sha3(mem[0])
                                    while _29170 + (uint255(stor10[address(arg3)][u].field_0) * 0.5) > t:
                                        mem[t + 32] = uint256(stor1[u])
                                        t = t + 32
                                        u = u + 1
                                        continue 
                                    mem[_29080] = _29170
                                    mem[_29080 + 32] = stor10[address(arg3)][u].field_256
                                    mem[_29080 + 64] = stor10[address(arg3)][u].field_512
                                    mem[_29080 + 96] = stor10[address(arg3)][u].field_768
                                    mem[t] = _29080
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                if not stor10[address(arg3)][idx].field_0 - (stor10[address(arg3)][idx].field_1 < 32):
                                    revert with 0, 34
                                if stor10[address(arg3)][idx].field_1:
                                    if 31 >= stor10[address(arg3)][idx].field_1:
                                        mem[_29170 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                    else:
                                        mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                        mem[_29170 + 32] = stor10[address(arg3)][idx].field_0
                                        t = _29170 + 32
                                        u = sha3(mem[0])
                                        while _29170 + stor10[address(arg3)][idx].field_1 > t:
                                            mem[t + 32] = uint256(stor1[u])
                                            t = t + 32
                                            u = u + 1
                                            continue 
                                mem[_29080] = _29170
                                mem[_29080 + 32] = stor10[address(arg3)][idx].field_256
                                mem[_29080 + 64] = stor10[address(arg3)][idx].field_512
                                mem[_29080 + 96] = stor10[address(arg3)][idx].field_768
                                mem[s] = _29080
                                s = s + 32
                                idx = idx + 1
                                continue 
                            if address(arg1) != address(arg3):
                                if mem[ceil32(ceil32(arg2.length)) + 225] <= 1:
                                    if mem[_22500] > 0:
                                        if _referrals[address(arg1)] != address(arg3):
                                            _referrals[address(arg1)] = address(arg3)
                                            sub_989baf69[address(arg3)].field_0++
                                            sub_989baf69[address(arg3)][sub_989baf69[address(arg3)].field_0].field_0 = address(arg1)
                                        if tokenAddress != msg.sender:
                                            if gateKeeperAddress != msg.sender:
                                                if address(stor0.field_0) != msg.sender:
                                                    revert with 0, 'NodeManagerV2: NOT AUTHORIZED'
                                        if stor10[stor11[address(arg1)]].field_0:
                                            if not -referralBonusPercent:
                                                sub_e27e434a[stor11[address(arg1)]][address(arg1)] = 0
                                                if sub_666755bb[stor11[address(arg1)]] > -1:
                                                    revert with 0, 17
                                            else:
                                                if referralBonusPercent and nodePrice > -1 / referralBonusPercent:
                                                    revert with 0, 17
                                                if not referralBonusPercent:
                                                    revert with 0, 18
                                                if referralBonusPercent * nodePrice / referralBonusPercent != nodePrice:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                sub_e27e434a[stor11[address(arg1)]][address(arg1)] = referralBonusPercent * nodePrice / 100
                                                if sub_666755bb[stor11[address(arg1)]] > !(referralBonusPercent * nodePrice / 100):
                                                    revert with 0, 17
                                                sub_666755bb[stor11[address(arg1)]] += referralBonusPercent * nodePrice / 100
                        else:
                            if address(stor0.field_0) != msg.sender:
                                revert with 0, 'NodeManagerV2: NOT AUTHORIZED'
                            mem[0] = address(arg1)
                            mem[64] = ceil32(ceil32(arg2.length)) + (32 * stor10[address(arg1)].field_0) + 257
                            mem[ceil32(ceil32(arg2.length)) + 225] = stor10[address(arg1)].field_0
                            s = ceil32(ceil32(arg2.length)) + 257
                            idx = 0
                            while idx < stor10[address(arg1)].field_0:
                                mem[0] = sha3(address(arg1), 10)
                                _22506 = mem[64]
                                mem[64] = mem[64] + 128
                                if stor10[address(arg1)][idx].field_0:
                                    if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                                        revert with 0, 34
                                    _22782 = mem[64]
                                    mem[64] = mem[64] + ceil32(uint255(stor10[address(arg1)][idx].field_0) * 0.5) + 32
                                    mem[_22782] = uint255(stor10[address(arg1)][idx].field_0) * 0.5
                                    if stor10[address(arg1)][idx].field_0:
                                        if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                                            revert with 0, 34
                                        if Mask(256, -1, stor10[address(arg1)][idx].field_0):
                                            if 31 >= uint255(stor10[address(arg1)][idx].field_0) * 0.5:
                                                mem[_22782 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                            else:
                                                mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                                mem[_22782 + 32] = stor10[address(arg1)][idx].field_0
                                                t = _22782 + 32
                                                u = sha3(mem[0])
                                                while _22782 + (uint255(stor10[address(arg1)][idx].field_0) * 0.5) > t:
                                                    mem[t + 32] = uint256(stor1[u])
                                                    t = t + 32
                                                    u = u + 1
                                                    continue 
                                        mem[_22506] = _22782
                                        mem[_22506 + 32] = stor10[address(arg1)][idx].field_256
                                        mem[_22506 + 64] = stor10[address(arg1)][idx].field_512
                                        mem[_22506 + 96] = stor10[address(arg1)][idx].field_768
                                        mem[s] = _22506
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                                        revert with 0, 34
                                    if not stor10[address(arg1)][idx].field_1:
                                        mem[_22506] = _22782
                                        mem[_22506 + 32] = stor10[address(arg1)][idx].field_256
                                        mem[_22506 + 64] = stor10[address(arg1)][idx].field_512
                                        mem[_22506 + 96] = stor10[address(arg1)][idx].field_768
                                        mem[s] = _22506
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    if 31 >= stor10[address(arg1)][idx].field_1:
                                        mem[_22782 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                        mem[_22506] = _22782
                                        mem[_22506 + 32] = stor10[address(arg1)][idx].field_256
                                        mem[_22506 + 64] = stor10[address(arg1)][idx].field_512
                                        mem[_22506 + 96] = stor10[address(arg1)][idx].field_768
                                        mem[s] = _22506
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                    mem[_22782 + 32] = stor10[address(arg1)][idx].field_0
                                    t = _22782 + 32
                                    u = sha3(mem[0])
                                    while _22782 + stor10[address(arg1)][u].field_1 > t:
                                        mem[t + 32] = uint256(stor1[u])
                                        t = t + 32
                                        u = u + 1
                                        continue 
                                    mem[_22506] = _22782
                                    mem[_22506 + 32] = stor10[address(arg1)][u].field_256
                                    mem[_22506 + 64] = stor10[address(arg1)][u].field_512
                                    mem[_22506 + 96] = stor10[address(arg1)][u].field_768
                                    mem[t] = _22506
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                                    revert with 0, 34
                                _22896 = mem[64]
                                mem[64] = mem[64] + ceil32(stor10[address(arg1)][idx].field_1) + 32
                                mem[_22896] = stor10[address(arg1)][idx].field_1
                                if stor10[address(arg1)][idx].field_0:
                                    if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                                        revert with 0, 34
                                    if not Mask(256, -1, stor10[address(arg1)][idx].field_0):
                                        mem[_22506] = _22896
                                        mem[_22506 + 32] = stor10[address(arg1)][idx].field_256
                                        mem[_22506 + 64] = stor10[address(arg1)][idx].field_512
                                        mem[_22506 + 96] = stor10[address(arg1)][idx].field_768
                                        mem[s] = _22506
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    if 31 >= uint255(stor10[address(arg1)][idx].field_0) * 0.5:
                                        mem[_22896 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                        mem[_22506] = _22896
                                        mem[_22506 + 32] = stor10[address(arg1)][idx].field_256
                                        mem[_22506 + 64] = stor10[address(arg1)][idx].field_512
                                        mem[_22506 + 96] = stor10[address(arg1)][idx].field_768
                                        mem[s] = _22506
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                    mem[_22896 + 32] = stor10[address(arg1)][idx].field_0
                                    t = _22896 + 32
                                    u = sha3(mem[0])
                                    while _22896 + (uint255(stor10[address(arg1)][u].field_0) * 0.5) > t:
                                        mem[t + 32] = uint256(stor1[u])
                                        t = t + 32
                                        u = u + 1
                                        continue 
                                    mem[_22506] = _22896
                                    mem[_22506 + 32] = stor10[address(arg1)][u].field_256
                                    mem[_22506 + 64] = stor10[address(arg1)][u].field_512
                                    mem[_22506 + 96] = stor10[address(arg1)][u].field_768
                                    mem[t] = _22506
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                                    revert with 0, 34
                                if stor10[address(arg1)][idx].field_1:
                                    if 31 >= stor10[address(arg1)][idx].field_1:
                                        mem[_22896 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                    else:
                                        mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                        mem[_22896 + 32] = stor10[address(arg1)][idx].field_0
                                        t = _22896 + 32
                                        u = sha3(mem[0])
                                        while _22896 + stor10[address(arg1)][idx].field_1 > t:
                                            mem[t + 32] = uint256(stor1[u])
                                            t = t + 32
                                            u = u + 1
                                            continue 
                                mem[_22506] = _22896
                                mem[_22506 + 32] = stor10[address(arg1)][idx].field_256
                                mem[_22506 + 64] = stor10[address(arg1)][idx].field_512
                                mem[_22506 + 96] = stor10[address(arg1)][idx].field_768
                                mem[s] = _22506
                                s = s + 32
                                idx = idx + 1
                                continue 
                            mem[0] = address(arg3)
                            mem[32] = 10
                            _22504 = mem[64]
                            mem[64] = mem[64] + (32 * stor10[address(arg3)].field_0) + 32
                            mem[_22504] = stor10[address(arg3)].field_0
                            s = _22504 + 32
                            idx = 0
                            while idx < stor10[address(arg3)].field_0:
                                mem[0] = sha3(address(arg3), 10)
                                _29082 = mem[64]
                                mem[64] = mem[64] + 128
                                if stor10[address(arg3)][idx].field_0:
                                    if not stor10[address(arg3)][idx].field_0 - (uint255(stor10[address(arg3)][idx].field_0) * 0.5 < 32):
                                        revert with 0, 34
                                    _29142 = mem[64]
                                    mem[64] = mem[64] + ceil32(uint255(stor10[address(arg3)][idx].field_0) * 0.5) + 32
                                    mem[_29142] = uint255(stor10[address(arg3)][idx].field_0) * 0.5
                                    if stor10[address(arg3)][idx].field_0:
                                        if not stor10[address(arg3)][idx].field_0 - (uint255(stor10[address(arg3)][idx].field_0) * 0.5 < 32):
                                            revert with 0, 34
                                        if Mask(256, -1, stor10[address(arg3)][idx].field_0):
                                            if 31 >= uint255(stor10[address(arg3)][idx].field_0) * 0.5:
                                                mem[_29142 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                            else:
                                                mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                                mem[_29142 + 32] = stor10[address(arg3)][idx].field_0
                                                t = _29142 + 32
                                                u = sha3(mem[0])
                                                while _29142 + (uint255(stor10[address(arg3)][idx].field_0) * 0.5) > t:
                                                    mem[t + 32] = uint256(stor1[u])
                                                    t = t + 32
                                                    u = u + 1
                                                    continue 
                                        mem[_29082] = _29142
                                        mem[_29082 + 32] = stor10[address(arg3)][idx].field_256
                                        mem[_29082 + 64] = stor10[address(arg3)][idx].field_512
                                        mem[_29082 + 96] = stor10[address(arg3)][idx].field_768
                                        mem[s] = _29082
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    if not stor10[address(arg3)][idx].field_0 - (stor10[address(arg3)][idx].field_1 < 32):
                                        revert with 0, 34
                                    if not stor10[address(arg3)][idx].field_1:
                                        mem[_29082] = _29142
                                        mem[_29082 + 32] = stor10[address(arg3)][idx].field_256
                                        mem[_29082 + 64] = stor10[address(arg3)][idx].field_512
                                        mem[_29082 + 96] = stor10[address(arg3)][idx].field_768
                                        mem[s] = _29082
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    if 31 >= stor10[address(arg3)][idx].field_1:
                                        mem[_29142 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                        mem[_29082] = _29142
                                        mem[_29082 + 32] = stor10[address(arg3)][idx].field_256
                                        mem[_29082 + 64] = stor10[address(arg3)][idx].field_512
                                        mem[_29082 + 96] = stor10[address(arg3)][idx].field_768
                                        mem[s] = _29082
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                    mem[_29142 + 32] = stor10[address(arg3)][idx].field_0
                                    t = _29142 + 32
                                    u = sha3(mem[0])
                                    while _29142 + stor10[address(arg3)][u].field_1 > t:
                                        mem[t + 32] = uint256(stor1[u])
                                        t = t + 32
                                        u = u + 1
                                        continue 
                                    mem[_29082] = _29142
                                    mem[_29082 + 32] = stor10[address(arg3)][u].field_256
                                    mem[_29082 + 64] = stor10[address(arg3)][u].field_512
                                    mem[_29082 + 96] = stor10[address(arg3)][u].field_768
                                    mem[t] = _29082
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                if not stor10[address(arg3)][idx].field_0 - (stor10[address(arg3)][idx].field_1 < 32):
                                    revert with 0, 34
                                _29172 = mem[64]
                                mem[64] = mem[64] + ceil32(stor10[address(arg3)][idx].field_1) + 32
                                mem[_29172] = stor10[address(arg3)][idx].field_1
                                if stor10[address(arg3)][idx].field_0:
                                    if not stor10[address(arg3)][idx].field_0 - (uint255(stor10[address(arg3)][idx].field_0) * 0.5 < 32):
                                        revert with 0, 34
                                    if not Mask(256, -1, stor10[address(arg3)][idx].field_0):
                                        mem[_29082] = _29172
                                        mem[_29082 + 32] = stor10[address(arg3)][idx].field_256
                                        mem[_29082 + 64] = stor10[address(arg3)][idx].field_512
                                        mem[_29082 + 96] = stor10[address(arg3)][idx].field_768
                                        mem[s] = _29082
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    if 31 >= uint255(stor10[address(arg3)][idx].field_0) * 0.5:
                                        mem[_29172 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                        mem[_29082] = _29172
                                        mem[_29082 + 32] = stor10[address(arg3)][idx].field_256
                                        mem[_29082 + 64] = stor10[address(arg3)][idx].field_512
                                        mem[_29082 + 96] = stor10[address(arg3)][idx].field_768
                                        mem[s] = _29082
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                    mem[_29172 + 32] = stor10[address(arg3)][idx].field_0
                                    t = _29172 + 32
                                    u = sha3(mem[0])
                                    while _29172 + (uint255(stor10[address(arg3)][u].field_0) * 0.5) > t:
                                        mem[t + 32] = uint256(stor1[u])
                                        t = t + 32
                                        u = u + 1
                                        continue 
                                    mem[_29082] = _29172
                                    mem[_29082 + 32] = stor10[address(arg3)][u].field_256
                                    mem[_29082 + 64] = stor10[address(arg3)][u].field_512
                                    mem[_29082 + 96] = stor10[address(arg3)][u].field_768
                                    mem[t] = _29082
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                if not stor10[address(arg3)][idx].field_0 - (stor10[address(arg3)][idx].field_1 < 32):
                                    revert with 0, 34
                                if stor10[address(arg3)][idx].field_1:
                                    if 31 >= stor10[address(arg3)][idx].field_1:
                                        mem[_29172 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                    else:
                                        mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                        mem[_29172 + 32] = stor10[address(arg3)][idx].field_0
                                        t = _29172 + 32
                                        u = sha3(mem[0])
                                        while _29172 + stor10[address(arg3)][idx].field_1 > t:
                                            mem[t + 32] = uint256(stor1[u])
                                            t = t + 32
                                            u = u + 1
                                            continue 
                                mem[_29082] = _29172
                                mem[_29082 + 32] = stor10[address(arg3)][idx].field_256
                                mem[_29082 + 64] = stor10[address(arg3)][idx].field_512
                                mem[_29082 + 96] = stor10[address(arg3)][idx].field_768
                                mem[s] = _29082
                                s = s + 32
                                idx = idx + 1
                                continue 
                            if address(arg1) != address(arg3):
                                if mem[ceil32(ceil32(arg2.length)) + 225] <= 1:
                                    if mem[_22504] > 0:
                                        if _referrals[address(arg1)] != address(arg3):
                                            _referrals[address(arg1)] = address(arg3)
                                            sub_989baf69[address(arg3)].field_0++
                                            sub_989baf69[address(arg3)][sub_989baf69[address(arg3)].field_0].field_0 = address(arg1)
                                        if tokenAddress != msg.sender:
                                            if gateKeeperAddress != msg.sender:
                                                if address(stor0.field_0) != msg.sender:
                                                    revert with 0, 'NodeManagerV2: NOT AUTHORIZED'
                                        if stor10[stor11[address(arg1)]].field_0:
                                            if not -referralBonusPercent:
                                                sub_e27e434a[stor11[address(arg1)]][address(arg1)] = 0
                                                if sub_666755bb[stor11[address(arg1)]] > -1:
                                                    revert with 0, 17
                                            else:
                                                if referralBonusPercent and nodePrice > -1 / referralBonusPercent:
                                                    revert with 0, 17
                                                if not referralBonusPercent:
                                                    revert with 0, 18
                                                if referralBonusPercent * nodePrice / referralBonusPercent != nodePrice:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                sub_e27e434a[stor11[address(arg1)]][address(arg1)] = referralBonusPercent * nodePrice / 100
                                                if sub_666755bb[stor11[address(arg1)]] > !(referralBonusPercent * nodePrice / 100):
                                                    revert with 0, 17
                                                sub_666755bb[stor11[address(arg1)]] += referralBonusPercent * nodePrice / 100
                else:
                    stor10[address(arg1)][stor10[address(arg1)].field_0].field_0 = 0
                    idx = 0
                    while stor10[address(arg1)][stor10[address(arg1)].field_0].field_1 + 31 / 32 > idx:
                        stor10[address(arg1)][(4 * stor10[address(arg1)].field_0) + idx].field_0 = 0
                        idx = idx + 1
                        continue 
                    stor10[address(arg1)][stor10[address(arg1)].field_0].field_256 = block.timestamp
                    stor10[address(arg1)][stor10[address(arg1)].field_0].field_512 = block.timestamp
                    stor10[address(arg1)][stor10[address(arg1)].field_0].field_768 = 0
                    mem[ceil32(ceil32(arg2.length)) + 229] = 6
                    mem[ceil32(ceil32(arg2.length)) + 261] = address(arg1)
                    mem[ceil32(ceil32(arg2.length)) + 293] = stor10[address(arg1)].field_0
                    require ext_code.size(0x4b7a346b17572634bdbd85b98abae32c5fa837bb)
                    delegate 0x4b7a346b17572634bdbd85b98abae32c5fa837bb.0xbc2b405c with:
                         gas gas_remaining wei
                        args 6, address(arg1), stor10[address(arg1)].field_0
                    if not delegate.return_code:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not totalNodesCreated + 1:
                        revert with 0, 17
                    totalNodesCreated++
                    if msg.sender == tokenAddress:
                        mem[0] = address(arg1)
                        mem[64] = ceil32(ceil32(arg2.length)) + (32 * stor10[address(arg1)].field_0) + 257
                        mem[ceil32(ceil32(arg2.length)) + 225] = stor10[address(arg1)].field_0
                        s = ceil32(ceil32(arg2.length)) + 257
                        idx = 0
                        while idx < stor10[address(arg1)].field_0:
                            mem[0] = sha3(address(arg1), 10)
                            _15250 = mem[64]
                            mem[64] = mem[64] + 128
                            if stor10[address(arg1)][idx].field_0:
                                if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                                    revert with 0, 34
                                _15562 = mem[64]
                                mem[64] = mem[64] + ceil32(uint255(stor10[address(arg1)][idx].field_0) * 0.5) + 32
                                mem[_15562] = uint255(stor10[address(arg1)][idx].field_0) * 0.5
                                if stor10[address(arg1)][idx].field_0:
                                    if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                                        revert with 0, 34
                                    if Mask(256, -1, stor10[address(arg1)][idx].field_0):
                                        if 31 >= uint255(stor10[address(arg1)][idx].field_0) * 0.5:
                                            mem[_15562 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                        else:
                                            mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                            mem[_15562 + 32] = stor10[address(arg1)][idx].field_0
                                            t = _15562 + 32
                                            u = sha3(mem[0])
                                            while _15562 + (uint255(stor10[address(arg1)][idx].field_0) * 0.5) > t:
                                                mem[t + 32] = uint256(stor1[u])
                                                t = t + 32
                                                u = u + 1
                                                continue 
                                    mem[_15250] = _15562
                                    mem[_15250 + 32] = stor10[address(arg1)][idx].field_256
                                    mem[_15250 + 64] = stor10[address(arg1)][idx].field_512
                                    mem[_15250 + 96] = stor10[address(arg1)][idx].field_768
                                    mem[s] = _15250
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                                    revert with 0, 34
                                if not stor10[address(arg1)][idx].field_1:
                                    mem[_15250] = _15562
                                    mem[_15250 + 32] = stor10[address(arg1)][idx].field_256
                                    mem[_15250 + 64] = stor10[address(arg1)][idx].field_512
                                    mem[_15250 + 96] = stor10[address(arg1)][idx].field_768
                                    mem[s] = _15250
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                if 31 >= stor10[address(arg1)][idx].field_1:
                                    mem[_15562 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                    mem[_15250] = _15562
                                    mem[_15250 + 32] = stor10[address(arg1)][idx].field_256
                                    mem[_15250 + 64] = stor10[address(arg1)][idx].field_512
                                    mem[_15250 + 96] = stor10[address(arg1)][idx].field_768
                                    mem[s] = _15250
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                mem[_15562 + 32] = stor10[address(arg1)][idx].field_0
                                t = _15562 + 32
                                u = sha3(mem[0])
                                while _15562 + stor10[address(arg1)][u].field_1 > t:
                                    mem[t + 32] = uint256(stor1[u])
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                mem[_15250] = _15562
                                mem[_15250 + 32] = stor10[address(arg1)][u].field_256
                                mem[_15250 + 64] = stor10[address(arg1)][u].field_512
                                mem[_15250 + 96] = stor10[address(arg1)][u].field_768
                                mem[t] = _15250
                                t = t + 32
                                u = u + 1
                                continue 
                            if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                                revert with 0, 34
                            _15650 = mem[64]
                            mem[64] = mem[64] + ceil32(stor10[address(arg1)][idx].field_1) + 32
                            mem[_15650] = stor10[address(arg1)][idx].field_1
                            if stor10[address(arg1)][idx].field_0:
                                if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                                    revert with 0, 34
                                if not Mask(256, -1, stor10[address(arg1)][idx].field_0):
                                    mem[_15250] = _15650
                                    mem[_15250 + 32] = stor10[address(arg1)][idx].field_256
                                    mem[_15250 + 64] = stor10[address(arg1)][idx].field_512
                                    mem[_15250 + 96] = stor10[address(arg1)][idx].field_768
                                    mem[s] = _15250
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                if 31 >= uint255(stor10[address(arg1)][idx].field_0) * 0.5:
                                    mem[_15650 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                    mem[_15250] = _15650
                                    mem[_15250 + 32] = stor10[address(arg1)][idx].field_256
                                    mem[_15250 + 64] = stor10[address(arg1)][idx].field_512
                                    mem[_15250 + 96] = stor10[address(arg1)][idx].field_768
                                    mem[s] = _15250
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                mem[_15650 + 32] = stor10[address(arg1)][idx].field_0
                                t = _15650 + 32
                                u = sha3(mem[0])
                                while _15650 + (uint255(stor10[address(arg1)][u].field_0) * 0.5) > t:
                                    mem[t + 32] = uint256(stor1[u])
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                mem[_15250] = _15650
                                mem[_15250 + 32] = stor10[address(arg1)][u].field_256
                                mem[_15250 + 64] = stor10[address(arg1)][u].field_512
                                mem[_15250 + 96] = stor10[address(arg1)][u].field_768
                                mem[t] = _15250
                                t = t + 32
                                u = u + 1
                                continue 
                            if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                                revert with 0, 34
                            if stor10[address(arg1)][idx].field_1:
                                if 31 >= stor10[address(arg1)][idx].field_1:
                                    mem[_15650 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                else:
                                    mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                    mem[_15650 + 32] = stor10[address(arg1)][idx].field_0
                                    t = _15650 + 32
                                    u = sha3(mem[0])
                                    while _15650 + stor10[address(arg1)][idx].field_1 > t:
                                        mem[t + 32] = uint256(stor1[u])
                                        t = t + 32
                                        u = u + 1
                                        continue 
                            mem[_15250] = _15650
                            mem[_15250 + 32] = stor10[address(arg1)][idx].field_256
                            mem[_15250 + 64] = stor10[address(arg1)][idx].field_512
                            mem[_15250 + 96] = stor10[address(arg1)][idx].field_768
                            mem[s] = _15250
                            s = s + 32
                            idx = idx + 1
                            continue 
                        mem[0] = address(arg3)
                        mem[32] = 10
                        _15248 = mem[64]
                        mem[64] = mem[64] + (32 * stor10[address(arg3)].field_0) + 32
                        mem[_15248] = stor10[address(arg3)].field_0
                        s = _15248 + 32
                        idx = 0
                        while idx < stor10[address(arg3)].field_0:
                            mem[0] = sha3(address(arg3), 10)
                            _22514 = mem[64]
                            mem[64] = mem[64] + 128
                            if stor10[address(arg3)][idx].field_0:
                                if not stor10[address(arg3)][idx].field_0 - (uint255(stor10[address(arg3)][idx].field_0) * 0.5 < 32):
                                    revert with 0, 34
                                _22786 = mem[64]
                                mem[64] = mem[64] + ceil32(uint255(stor10[address(arg3)][idx].field_0) * 0.5) + 32
                                mem[_22786] = uint255(stor10[address(arg3)][idx].field_0) * 0.5
                                if stor10[address(arg3)][idx].field_0:
                                    if not stor10[address(arg3)][idx].field_0 - (uint255(stor10[address(arg3)][idx].field_0) * 0.5 < 32):
                                        revert with 0, 34
                                    if Mask(256, -1, stor10[address(arg3)][idx].field_0):
                                        if 31 >= uint255(stor10[address(arg3)][idx].field_0) * 0.5:
                                            mem[_22786 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                        else:
                                            mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                            mem[_22786 + 32] = stor10[address(arg3)][idx].field_0
                                            t = _22786 + 32
                                            u = sha3(mem[0])
                                            while _22786 + (uint255(stor10[address(arg3)][idx].field_0) * 0.5) > t:
                                                mem[t + 32] = uint256(stor1[u])
                                                t = t + 32
                                                u = u + 1
                                                continue 
                                    mem[_22514] = _22786
                                    mem[_22514 + 32] = stor10[address(arg3)][idx].field_256
                                    mem[_22514 + 64] = stor10[address(arg3)][idx].field_512
                                    mem[_22514 + 96] = stor10[address(arg3)][idx].field_768
                                    mem[s] = _22514
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                if not stor10[address(arg3)][idx].field_0 - (stor10[address(arg3)][idx].field_1 < 32):
                                    revert with 0, 34
                                if not stor10[address(arg3)][idx].field_1:
                                    mem[_22514] = _22786
                                    mem[_22514 + 32] = stor10[address(arg3)][idx].field_256
                                    mem[_22514 + 64] = stor10[address(arg3)][idx].field_512
                                    mem[_22514 + 96] = stor10[address(arg3)][idx].field_768
                                    mem[s] = _22514
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                if 31 >= stor10[address(arg3)][idx].field_1:
                                    mem[_22786 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                    mem[_22514] = _22786
                                    mem[_22514 + 32] = stor10[address(arg3)][idx].field_256
                                    mem[_22514 + 64] = stor10[address(arg3)][idx].field_512
                                    mem[_22514 + 96] = stor10[address(arg3)][idx].field_768
                                    mem[s] = _22514
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                mem[_22786 + 32] = stor10[address(arg3)][idx].field_0
                                t = _22786 + 32
                                u = sha3(mem[0])
                                while _22786 + stor10[address(arg3)][u].field_1 > t:
                                    mem[t + 32] = uint256(stor1[u])
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                mem[_22514] = _22786
                                mem[_22514 + 32] = stor10[address(arg3)][u].field_256
                                mem[_22514 + 64] = stor10[address(arg3)][u].field_512
                                mem[_22514 + 96] = stor10[address(arg3)][u].field_768
                                mem[t] = _22514
                                t = t + 32
                                u = u + 1
                                continue 
                            if not stor10[address(arg3)][idx].field_0 - (stor10[address(arg3)][idx].field_1 < 32):
                                revert with 0, 34
                            _22904 = mem[64]
                            mem[64] = mem[64] + ceil32(stor10[address(arg3)][idx].field_1) + 32
                            mem[_22904] = stor10[address(arg3)][idx].field_1
                            if stor10[address(arg3)][idx].field_0:
                                if not stor10[address(arg3)][idx].field_0 - (uint255(stor10[address(arg3)][idx].field_0) * 0.5 < 32):
                                    revert with 0, 34
                                if not Mask(256, -1, stor10[address(arg3)][idx].field_0):
                                    mem[_22514] = _22904
                                    mem[_22514 + 32] = stor10[address(arg3)][idx].field_256
                                    mem[_22514 + 64] = stor10[address(arg3)][idx].field_512
                                    mem[_22514 + 96] = stor10[address(arg3)][idx].field_768
                                    mem[s] = _22514
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                if 31 >= uint255(stor10[address(arg3)][idx].field_0) * 0.5:
                                    mem[_22904 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                    mem[_22514] = _22904
                                    mem[_22514 + 32] = stor10[address(arg3)][idx].field_256
                                    mem[_22514 + 64] = stor10[address(arg3)][idx].field_512
                                    mem[_22514 + 96] = stor10[address(arg3)][idx].field_768
                                    mem[s] = _22514
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                mem[_22904 + 32] = stor10[address(arg3)][idx].field_0
                                t = _22904 + 32
                                u = sha3(mem[0])
                                while _22904 + (uint255(stor10[address(arg3)][u].field_0) * 0.5) > t:
                                    mem[t + 32] = uint256(stor1[u])
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                mem[_22514] = _22904
                                mem[_22514 + 32] = stor10[address(arg3)][u].field_256
                                mem[_22514 + 64] = stor10[address(arg3)][u].field_512
                                mem[_22514 + 96] = stor10[address(arg3)][u].field_768
                                mem[t] = _22514
                                t = t + 32
                                u = u + 1
                                continue 
                            if not stor10[address(arg3)][idx].field_0 - (stor10[address(arg3)][idx].field_1 < 32):
                                revert with 0, 34
                            if stor10[address(arg3)][idx].field_1:
                                if 31 >= stor10[address(arg3)][idx].field_1:
                                    mem[_22904 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                else:
                                    mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                    mem[_22904 + 32] = stor10[address(arg3)][idx].field_0
                                    t = _22904 + 32
                                    u = sha3(mem[0])
                                    while _22904 + stor10[address(arg3)][idx].field_1 > t:
                                        mem[t + 32] = uint256(stor1[u])
                                        t = t + 32
                                        u = u + 1
                                        continue 
                            mem[_22514] = _22904
                            mem[_22514 + 32] = stor10[address(arg3)][idx].field_256
                            mem[_22514 + 64] = stor10[address(arg3)][idx].field_512
                            mem[_22514 + 96] = stor10[address(arg3)][idx].field_768
                            mem[s] = _22514
                            s = s + 32
                            idx = idx + 1
                            continue 
                        if address(arg1) != address(arg3):
                            if mem[ceil32(ceil32(arg2.length)) + 225] <= 1:
                                if mem[_15248] > 0:
                                    if _referrals[address(arg1)] != address(arg3):
                                        _referrals[address(arg1)] = address(arg3)
                                        sub_989baf69[address(arg3)].field_0++
                                        sub_989baf69[address(arg3)][sub_989baf69[address(arg3)].field_0].field_0 = address(arg1)
                                    if tokenAddress != msg.sender:
                                        if gateKeeperAddress != msg.sender:
                                            if address(stor0.field_0) != msg.sender:
                                                revert with 0, 'NodeManagerV2: NOT AUTHORIZED'
                                    if stor10[stor11[address(arg1)]].field_0:
                                        if not -referralBonusPercent:
                                            sub_e27e434a[stor11[address(arg1)]][address(arg1)] = 0
                                            if sub_666755bb[stor11[address(arg1)]] > -1:
                                                revert with 0, 17
                                        else:
                                            if referralBonusPercent and nodePrice > -1 / referralBonusPercent:
                                                revert with 0, 17
                                            if not referralBonusPercent:
                                                revert with 0, 18
                                            if referralBonusPercent * nodePrice / referralBonusPercent != nodePrice:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            sub_e27e434a[stor11[address(arg1)]][address(arg1)] = referralBonusPercent * nodePrice / 100
                                            if sub_666755bb[stor11[address(arg1)]] > !(referralBonusPercent * nodePrice / 100):
                                                revert with 0, 17
                                            sub_666755bb[stor11[address(arg1)]] += referralBonusPercent * nodePrice / 100
                    else:
                        if msg.sender == gateKeeperAddress:
                            mem[0] = address(arg1)
                            mem[64] = ceil32(ceil32(arg2.length)) + (32 * stor10[address(arg1)].field_0) + 257
                            mem[ceil32(ceil32(arg2.length)) + 225] = stor10[address(arg1)].field_0
                            s = ceil32(ceil32(arg2.length)) + 257
                            idx = 0
                            while idx < stor10[address(arg1)].field_0:
                                mem[0] = sha3(address(arg1), 10)
                                _15254 = mem[64]
                                mem[64] = mem[64] + 128
                                if stor10[address(arg1)][idx].field_0:
                                    if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                                        revert with 0, 34
                                    _15563 = mem[64]
                                    mem[64] = mem[64] + ceil32(uint255(stor10[address(arg1)][idx].field_0) * 0.5) + 32
                                    mem[_15563] = uint255(stor10[address(arg1)][idx].field_0) * 0.5
                                    if stor10[address(arg1)][idx].field_0:
                                        if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                                            revert with 0, 34
                                        if Mask(256, -1, stor10[address(arg1)][idx].field_0):
                                            if 31 >= uint255(stor10[address(arg1)][idx].field_0) * 0.5:
                                                mem[_15563 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                            else:
                                                mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                                mem[_15563 + 32] = stor10[address(arg1)][idx].field_0
                                                t = _15563 + 32
                                                u = sha3(mem[0])
                                                while _15563 + (uint255(stor10[address(arg1)][idx].field_0) * 0.5) > t:
                                                    mem[t + 32] = uint256(stor1[u])
                                                    t = t + 32
                                                    u = u + 1
                                                    continue 
                                        mem[_15254] = _15563
                                        mem[_15254 + 32] = stor10[address(arg1)][idx].field_256
                                        mem[_15254 + 64] = stor10[address(arg1)][idx].field_512
                                        mem[_15254 + 96] = stor10[address(arg1)][idx].field_768
                                        mem[s] = _15254
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                                        revert with 0, 34
                                    if not stor10[address(arg1)][idx].field_1:
                                        mem[_15254] = _15563
                                        mem[_15254 + 32] = stor10[address(arg1)][idx].field_256
                                        mem[_15254 + 64] = stor10[address(arg1)][idx].field_512
                                        mem[_15254 + 96] = stor10[address(arg1)][idx].field_768
                                        mem[s] = _15254
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    if 31 >= stor10[address(arg1)][idx].field_1:
                                        mem[_15563 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                        mem[_15254] = _15563
                                        mem[_15254 + 32] = stor10[address(arg1)][idx].field_256
                                        mem[_15254 + 64] = stor10[address(arg1)][idx].field_512
                                        mem[_15254 + 96] = stor10[address(arg1)][idx].field_768
                                        mem[s] = _15254
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                    mem[_15563 + 32] = stor10[address(arg1)][idx].field_0
                                    t = _15563 + 32
                                    u = sha3(mem[0])
                                    while _15563 + stor10[address(arg1)][u].field_1 > t:
                                        mem[t + 32] = uint256(stor1[u])
                                        t = t + 32
                                        u = u + 1
                                        continue 
                                    mem[_15254] = _15563
                                    mem[_15254 + 32] = stor10[address(arg1)][u].field_256
                                    mem[_15254 + 64] = stor10[address(arg1)][u].field_512
                                    mem[_15254 + 96] = stor10[address(arg1)][u].field_768
                                    mem[t] = _15254
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                                    revert with 0, 34
                                _15652 = mem[64]
                                mem[64] = mem[64] + ceil32(stor10[address(arg1)][idx].field_1) + 32
                                mem[_15652] = stor10[address(arg1)][idx].field_1
                                if stor10[address(arg1)][idx].field_0:
                                    if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                                        revert with 0, 34
                                    if not Mask(256, -1, stor10[address(arg1)][idx].field_0):
                                        mem[_15254] = _15652
                                        mem[_15254 + 32] = stor10[address(arg1)][idx].field_256
                                        mem[_15254 + 64] = stor10[address(arg1)][idx].field_512
                                        mem[_15254 + 96] = stor10[address(arg1)][idx].field_768
                                        mem[s] = _15254
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    if 31 >= uint255(stor10[address(arg1)][idx].field_0) * 0.5:
                                        mem[_15652 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                        mem[_15254] = _15652
                                        mem[_15254 + 32] = stor10[address(arg1)][idx].field_256
                                        mem[_15254 + 64] = stor10[address(arg1)][idx].field_512
                                        mem[_15254 + 96] = stor10[address(arg1)][idx].field_768
                                        mem[s] = _15254
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                    mem[_15652 + 32] = stor10[address(arg1)][idx].field_0
                                    t = _15652 + 32
                                    u = sha3(mem[0])
                                    while _15652 + (uint255(stor10[address(arg1)][u].field_0) * 0.5) > t:
                                        mem[t + 32] = uint256(stor1[u])
                                        t = t + 32
                                        u = u + 1
                                        continue 
                                    mem[_15254] = _15652
                                    mem[_15254 + 32] = stor10[address(arg1)][u].field_256
                                    mem[_15254 + 64] = stor10[address(arg1)][u].field_512
                                    mem[_15254 + 96] = stor10[address(arg1)][u].field_768
                                    mem[t] = _15254
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                                    revert with 0, 34
                                if stor10[address(arg1)][idx].field_1:
                                    if 31 >= stor10[address(arg1)][idx].field_1:
                                        mem[_15652 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                    else:
                                        mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                        mem[_15652 + 32] = stor10[address(arg1)][idx].field_0
                                        t = _15652 + 32
                                        u = sha3(mem[0])
                                        while _15652 + stor10[address(arg1)][idx].field_1 > t:
                                            mem[t + 32] = uint256(stor1[u])
                                            t = t + 32
                                            u = u + 1
                                            continue 
                                mem[_15254] = _15652
                                mem[_15254 + 32] = stor10[address(arg1)][idx].field_256
                                mem[_15254 + 64] = stor10[address(arg1)][idx].field_512
                                mem[_15254 + 96] = stor10[address(arg1)][idx].field_768
                                mem[s] = _15254
                                s = s + 32
                                idx = idx + 1
                                continue 
                            mem[0] = address(arg3)
                            mem[32] = 10
                            _15252 = mem[64]
                            mem[64] = mem[64] + (32 * stor10[address(arg3)].field_0) + 32
                            mem[_15252] = stor10[address(arg3)].field_0
                            s = _15252 + 32
                            idx = 0
                            while idx < stor10[address(arg3)].field_0:
                                mem[0] = sha3(address(arg3), 10)
                                _22516 = mem[64]
                                mem[64] = mem[64] + 128
                                if stor10[address(arg3)][idx].field_0:
                                    if not stor10[address(arg3)][idx].field_0 - (uint255(stor10[address(arg3)][idx].field_0) * 0.5 < 32):
                                        revert with 0, 34
                                    _22787 = mem[64]
                                    mem[64] = mem[64] + ceil32(uint255(stor10[address(arg3)][idx].field_0) * 0.5) + 32
                                    mem[_22787] = uint255(stor10[address(arg3)][idx].field_0) * 0.5
                                    if stor10[address(arg3)][idx].field_0:
                                        if not stor10[address(arg3)][idx].field_0 - (uint255(stor10[address(arg3)][idx].field_0) * 0.5 < 32):
                                            revert with 0, 34
                                        if Mask(256, -1, stor10[address(arg3)][idx].field_0):
                                            if 31 >= uint255(stor10[address(arg3)][idx].field_0) * 0.5:
                                                mem[_22787 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                            else:
                                                mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                                mem[_22787 + 32] = stor10[address(arg3)][idx].field_0
                                                t = _22787 + 32
                                                u = sha3(mem[0])
                                                while _22787 + (uint255(stor10[address(arg3)][idx].field_0) * 0.5) > t:
                                                    mem[t + 32] = uint256(stor1[u])
                                                    t = t + 32
                                                    u = u + 1
                                                    continue 
                                        mem[_22516] = _22787
                                        mem[_22516 + 32] = stor10[address(arg3)][idx].field_256
                                        mem[_22516 + 64] = stor10[address(arg3)][idx].field_512
                                        mem[_22516 + 96] = stor10[address(arg3)][idx].field_768
                                        mem[s] = _22516
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    if not stor10[address(arg3)][idx].field_0 - (stor10[address(arg3)][idx].field_1 < 32):
                                        revert with 0, 34
                                    if not stor10[address(arg3)][idx].field_1:
                                        mem[_22516] = _22787
                                        mem[_22516 + 32] = stor10[address(arg3)][idx].field_256
                                        mem[_22516 + 64] = stor10[address(arg3)][idx].field_512
                                        mem[_22516 + 96] = stor10[address(arg3)][idx].field_768
                                        mem[s] = _22516
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    if 31 >= stor10[address(arg3)][idx].field_1:
                                        mem[_22787 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                        mem[_22516] = _22787
                                        mem[_22516 + 32] = stor10[address(arg3)][idx].field_256
                                        mem[_22516 + 64] = stor10[address(arg3)][idx].field_512
                                        mem[_22516 + 96] = stor10[address(arg3)][idx].field_768
                                        mem[s] = _22516
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                    mem[_22787 + 32] = stor10[address(arg3)][idx].field_0
                                    t = _22787 + 32
                                    u = sha3(mem[0])
                                    while _22787 + stor10[address(arg3)][u].field_1 > t:
                                        mem[t + 32] = uint256(stor1[u])
                                        t = t + 32
                                        u = u + 1
                                        continue 
                                    mem[_22516] = _22787
                                    mem[_22516 + 32] = stor10[address(arg3)][u].field_256
                                    mem[_22516 + 64] = stor10[address(arg3)][u].field_512
                                    mem[_22516 + 96] = stor10[address(arg3)][u].field_768
                                    mem[t] = _22516
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                if not stor10[address(arg3)][idx].field_0 - (stor10[address(arg3)][idx].field_1 < 32):
                                    revert with 0, 34
                                _22906 = mem[64]
                                mem[64] = mem[64] + ceil32(stor10[address(arg3)][idx].field_1) + 32
                                mem[_22906] = stor10[address(arg3)][idx].field_1
                                if stor10[address(arg3)][idx].field_0:
                                    if not stor10[address(arg3)][idx].field_0 - (uint255(stor10[address(arg3)][idx].field_0) * 0.5 < 32):
                                        revert with 0, 34
                                    if not Mask(256, -1, stor10[address(arg3)][idx].field_0):
                                        mem[_22516] = _22906
                                        mem[_22516 + 32] = stor10[address(arg3)][idx].field_256
                                        mem[_22516 + 64] = stor10[address(arg3)][idx].field_512
                                        mem[_22516 + 96] = stor10[address(arg3)][idx].field_768
                                        mem[s] = _22516
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    if 31 >= uint255(stor10[address(arg3)][idx].field_0) * 0.5:
                                        mem[_22906 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                        mem[_22516] = _22906
                                        mem[_22516 + 32] = stor10[address(arg3)][idx].field_256
                                        mem[_22516 + 64] = stor10[address(arg3)][idx].field_512
                                        mem[_22516 + 96] = stor10[address(arg3)][idx].field_768
                                        mem[s] = _22516
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                    mem[_22906 + 32] = stor10[address(arg3)][idx].field_0
                                    t = _22906 + 32
                                    u = sha3(mem[0])
                                    while _22906 + (uint255(stor10[address(arg3)][u].field_0) * 0.5) > t:
                                        mem[t + 32] = uint256(stor1[u])
                                        t = t + 32
                                        u = u + 1
                                        continue 
                                    mem[_22516] = _22906
                                    mem[_22516 + 32] = stor10[address(arg3)][u].field_256
                                    mem[_22516 + 64] = stor10[address(arg3)][u].field_512
                                    mem[_22516 + 96] = stor10[address(arg3)][u].field_768
                                    mem[t] = _22516
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                if not stor10[address(arg3)][idx].field_0 - (stor10[address(arg3)][idx].field_1 < 32):
                                    revert with 0, 34
                                if stor10[address(arg3)][idx].field_1:
                                    if 31 >= stor10[address(arg3)][idx].field_1:
                                        mem[_22906 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                    else:
                                        mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                        mem[_22906 + 32] = stor10[address(arg3)][idx].field_0
                                        t = _22906 + 32
                                        u = sha3(mem[0])
                                        while _22906 + stor10[address(arg3)][idx].field_1 > t:
                                            mem[t + 32] = uint256(stor1[u])
                                            t = t + 32
                                            u = u + 1
                                            continue 
                                mem[_22516] = _22906
                                mem[_22516 + 32] = stor10[address(arg3)][idx].field_256
                                mem[_22516 + 64] = stor10[address(arg3)][idx].field_512
                                mem[_22516 + 96] = stor10[address(arg3)][idx].field_768
                                mem[s] = _22516
                                s = s + 32
                                idx = idx + 1
                                continue 
                            if address(arg1) != address(arg3):
                                if mem[ceil32(ceil32(arg2.length)) + 225] <= 1:
                                    if mem[_15252] > 0:
                                        if _referrals[address(arg1)] != address(arg3):
                                            _referrals[address(arg1)] = address(arg3)
                                            sub_989baf69[address(arg3)].field_0++
                                            sub_989baf69[address(arg3)][sub_989baf69[address(arg3)].field_0].field_0 = address(arg1)
                                        if tokenAddress != msg.sender:
                                            if gateKeeperAddress != msg.sender:
                                                if address(stor0.field_0) != msg.sender:
                                                    revert with 0, 'NodeManagerV2: NOT AUTHORIZED'
                                        if stor10[stor11[address(arg1)]].field_0:
                                            if not -referralBonusPercent:
                                                sub_e27e434a[stor11[address(arg1)]][address(arg1)] = 0
                                                if sub_666755bb[stor11[address(arg1)]] > -1:
                                                    revert with 0, 17
                                            else:
                                                if referralBonusPercent and nodePrice > -1 / referralBonusPercent:
                                                    revert with 0, 17
                                                if not referralBonusPercent:
                                                    revert with 0, 18
                                                if referralBonusPercent * nodePrice / referralBonusPercent != nodePrice:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                sub_e27e434a[stor11[address(arg1)]][address(arg1)] = referralBonusPercent * nodePrice / 100
                                                if sub_666755bb[stor11[address(arg1)]] > !(referralBonusPercent * nodePrice / 100):
                                                    revert with 0, 17
                                                sub_666755bb[stor11[address(arg1)]] += referralBonusPercent * nodePrice / 100
                        else:
                            if address(stor0.field_0) != msg.sender:
                                revert with 0, 'NodeManagerV2: NOT AUTHORIZED'
                            mem[0] = address(arg1)
                            mem[64] = ceil32(ceil32(arg2.length)) + (32 * stor10[address(arg1)].field_0) + 257
                            mem[ceil32(ceil32(arg2.length)) + 225] = stor10[address(arg1)].field_0
                            s = ceil32(ceil32(arg2.length)) + 257
                            idx = 0
                            while idx < stor10[address(arg1)].field_0:
                                mem[0] = sha3(address(arg1), 10)
                                _15258 = mem[64]
                                mem[64] = mem[64] + 128
                                if stor10[address(arg1)][idx].field_0:
                                    if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                                        revert with 0, 34
                                    _15564 = mem[64]
                                    mem[64] = mem[64] + ceil32(uint255(stor10[address(arg1)][idx].field_0) * 0.5) + 32
                                    mem[_15564] = uint255(stor10[address(arg1)][idx].field_0) * 0.5
                                    if stor10[address(arg1)][idx].field_0:
                                        if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                                            revert with 0, 34
                                        if Mask(256, -1, stor10[address(arg1)][idx].field_0):
                                            if 31 >= uint255(stor10[address(arg1)][idx].field_0) * 0.5:
                                                mem[_15564 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                            else:
                                                mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                                mem[_15564 + 32] = stor10[address(arg1)][idx].field_0
                                                t = _15564 + 32
                                                u = sha3(mem[0])
                                                while _15564 + (uint255(stor10[address(arg1)][idx].field_0) * 0.5) > t:
                                                    mem[t + 32] = uint256(stor1[u])
                                                    t = t + 32
                                                    u = u + 1
                                                    continue 
                                        mem[_15258] = _15564
                                        mem[_15258 + 32] = stor10[address(arg1)][idx].field_256
                                        mem[_15258 + 64] = stor10[address(arg1)][idx].field_512
                                        mem[_15258 + 96] = stor10[address(arg1)][idx].field_768
                                        mem[s] = _15258
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                                        revert with 0, 34
                                    if not stor10[address(arg1)][idx].field_1:
                                        mem[_15258] = _15564
                                        mem[_15258 + 32] = stor10[address(arg1)][idx].field_256
                                        mem[_15258 + 64] = stor10[address(arg1)][idx].field_512
                                        mem[_15258 + 96] = stor10[address(arg1)][idx].field_768
                                        mem[s] = _15258
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    if 31 >= stor10[address(arg1)][idx].field_1:
                                        mem[_15564 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                        mem[_15258] = _15564
                                        mem[_15258 + 32] = stor10[address(arg1)][idx].field_256
                                        mem[_15258 + 64] = stor10[address(arg1)][idx].field_512
                                        mem[_15258 + 96] = stor10[address(arg1)][idx].field_768
                                        mem[s] = _15258
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                    mem[_15564 + 32] = stor10[address(arg1)][idx].field_0
                                    t = _15564 + 32
                                    u = sha3(mem[0])
                                    while _15564 + stor10[address(arg1)][u].field_1 > t:
                                        mem[t + 32] = uint256(stor1[u])
                                        t = t + 32
                                        u = u + 1
                                        continue 
                                    mem[_15258] = _15564
                                    mem[_15258 + 32] = stor10[address(arg1)][u].field_256
                                    mem[_15258 + 64] = stor10[address(arg1)][u].field_512
                                    mem[_15258 + 96] = stor10[address(arg1)][u].field_768
                                    mem[t] = _15258
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                                    revert with 0, 34
                                _15654 = mem[64]
                                mem[64] = mem[64] + ceil32(stor10[address(arg1)][idx].field_1) + 32
                                mem[_15654] = stor10[address(arg1)][idx].field_1
                                if stor10[address(arg1)][idx].field_0:
                                    if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                                        revert with 0, 34
                                    if not Mask(256, -1, stor10[address(arg1)][idx].field_0):
                                        mem[_15258] = _15654
                                        mem[_15258 + 32] = stor10[address(arg1)][idx].field_256
                                        mem[_15258 + 64] = stor10[address(arg1)][idx].field_512
                                        mem[_15258 + 96] = stor10[address(arg1)][idx].field_768
                                        mem[s] = _15258
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    if 31 >= uint255(stor10[address(arg1)][idx].field_0) * 0.5:
                                        mem[_15654 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                        mem[_15258] = _15654
                                        mem[_15258 + 32] = stor10[address(arg1)][idx].field_256
                                        mem[_15258 + 64] = stor10[address(arg1)][idx].field_512
                                        mem[_15258 + 96] = stor10[address(arg1)][idx].field_768
                                        mem[s] = _15258
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                    mem[_15654 + 32] = stor10[address(arg1)][idx].field_0
                                    t = _15654 + 32
                                    u = sha3(mem[0])
                                    while _15654 + (uint255(stor10[address(arg1)][u].field_0) * 0.5) > t:
                                        mem[t + 32] = uint256(stor1[u])
                                        t = t + 32
                                        u = u + 1
                                        continue 
                                    mem[_15258] = _15654
                                    mem[_15258 + 32] = stor10[address(arg1)][u].field_256
                                    mem[_15258 + 64] = stor10[address(arg1)][u].field_512
                                    mem[_15258 + 96] = stor10[address(arg1)][u].field_768
                                    mem[t] = _15258
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                                    revert with 0, 34
                                if stor10[address(arg1)][idx].field_1:
                                    if 31 >= stor10[address(arg1)][idx].field_1:
                                        mem[_15654 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                    else:
                                        mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                        mem[_15654 + 32] = stor10[address(arg1)][idx].field_0
                                        t = _15654 + 32
                                        u = sha3(mem[0])
                                        while _15654 + stor10[address(arg1)][idx].field_1 > t:
                                            mem[t + 32] = uint256(stor1[u])
                                            t = t + 32
                                            u = u + 1
                                            continue 
                                mem[_15258] = _15654
                                mem[_15258 + 32] = stor10[address(arg1)][idx].field_256
                                mem[_15258 + 64] = stor10[address(arg1)][idx].field_512
                                mem[_15258 + 96] = stor10[address(arg1)][idx].field_768
                                mem[s] = _15258
                                s = s + 32
                                idx = idx + 1
                                continue 
                            mem[0] = address(arg3)
                            mem[32] = 10
                            _15256 = mem[64]
                            mem[64] = mem[64] + (32 * stor10[address(arg3)].field_0) + 32
                            mem[_15256] = stor10[address(arg3)].field_0
                            s = _15256 + 32
                            idx = 0
                            while idx < stor10[address(arg3)].field_0:
                                mem[0] = sha3(address(arg3), 10)
                                _22518 = mem[64]
                                mem[64] = mem[64] + 128
                                if stor10[address(arg3)][idx].field_0:
                                    if not stor10[address(arg3)][idx].field_0 - (uint255(stor10[address(arg3)][idx].field_0) * 0.5 < 32):
                                        revert with 0, 34
                                    _22788 = mem[64]
                                    mem[64] = mem[64] + ceil32(uint255(stor10[address(arg3)][idx].field_0) * 0.5) + 32
                                    mem[_22788] = uint255(stor10[address(arg3)][idx].field_0) * 0.5
                                    if stor10[address(arg3)][idx].field_0:
                                        if not stor10[address(arg3)][idx].field_0 - (uint255(stor10[address(arg3)][idx].field_0) * 0.5 < 32):
                                            revert with 0, 34
                                        if Mask(256, -1, stor10[address(arg3)][idx].field_0):
                                            if 31 >= uint255(stor10[address(arg3)][idx].field_0) * 0.5:
                                                mem[_22788 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                            else:
                                                mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                                mem[_22788 + 32] = stor10[address(arg3)][idx].field_0
                                                t = _22788 + 32
                                                u = sha3(mem[0])
                                                while _22788 + (uint255(stor10[address(arg3)][idx].field_0) * 0.5) > t:
                                                    mem[t + 32] = uint256(stor1[u])
                                                    t = t + 32
                                                    u = u + 1
                                                    continue 
                                        mem[_22518] = _22788
                                        mem[_22518 + 32] = stor10[address(arg3)][idx].field_256
                                        mem[_22518 + 64] = stor10[address(arg3)][idx].field_512
                                        mem[_22518 + 96] = stor10[address(arg3)][idx].field_768
                                        mem[s] = _22518
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    if not stor10[address(arg3)][idx].field_0 - (stor10[address(arg3)][idx].field_1 < 32):
                                        revert with 0, 34
                                    if not stor10[address(arg3)][idx].field_1:
                                        mem[_22518] = _22788
                                        mem[_22518 + 32] = stor10[address(arg3)][idx].field_256
                                        mem[_22518 + 64] = stor10[address(arg3)][idx].field_512
                                        mem[_22518 + 96] = stor10[address(arg3)][idx].field_768
                                        mem[s] = _22518
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    if 31 >= stor10[address(arg3)][idx].field_1:
                                        mem[_22788 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                        mem[_22518] = _22788
                                        mem[_22518 + 32] = stor10[address(arg3)][idx].field_256
                                        mem[_22518 + 64] = stor10[address(arg3)][idx].field_512
                                        mem[_22518 + 96] = stor10[address(arg3)][idx].field_768
                                        mem[s] = _22518
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                    mem[_22788 + 32] = stor10[address(arg3)][idx].field_0
                                    t = _22788 + 32
                                    u = sha3(mem[0])
                                    while _22788 + stor10[address(arg3)][u].field_1 > t:
                                        mem[t + 32] = uint256(stor1[u])
                                        t = t + 32
                                        u = u + 1
                                        continue 
                                    mem[_22518] = _22788
                                    mem[_22518 + 32] = stor10[address(arg3)][u].field_256
                                    mem[_22518 + 64] = stor10[address(arg3)][u].field_512
                                    mem[_22518 + 96] = stor10[address(arg3)][u].field_768
                                    mem[t] = _22518
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                if not stor10[address(arg3)][idx].field_0 - (stor10[address(arg3)][idx].field_1 < 32):
                                    revert with 0, 34
                                _22908 = mem[64]
                                mem[64] = mem[64] + ceil32(stor10[address(arg3)][idx].field_1) + 32
                                mem[_22908] = stor10[address(arg3)][idx].field_1
                                if stor10[address(arg3)][idx].field_0:
                                    if not stor10[address(arg3)][idx].field_0 - (uint255(stor10[address(arg3)][idx].field_0) * 0.5 < 32):
                                        revert with 0, 34
                                    if not Mask(256, -1, stor10[address(arg3)][idx].field_0):
                                        mem[_22518] = _22908
                                        mem[_22518 + 32] = stor10[address(arg3)][idx].field_256
                                        mem[_22518 + 64] = stor10[address(arg3)][idx].field_512
                                        mem[_22518 + 96] = stor10[address(arg3)][idx].field_768
                                        mem[s] = _22518
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    if 31 >= uint255(stor10[address(arg3)][idx].field_0) * 0.5:
                                        mem[_22908 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                        mem[_22518] = _22908
                                        mem[_22518 + 32] = stor10[address(arg3)][idx].field_256
                                        mem[_22518 + 64] = stor10[address(arg3)][idx].field_512
                                        mem[_22518 + 96] = stor10[address(arg3)][idx].field_768
                                        mem[s] = _22518
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                    mem[_22908 + 32] = stor10[address(arg3)][idx].field_0
                                    t = _22908 + 32
                                    u = sha3(mem[0])
                                    while _22908 + (uint255(stor10[address(arg3)][u].field_0) * 0.5) > t:
                                        mem[t + 32] = uint256(stor1[u])
                                        t = t + 32
                                        u = u + 1
                                        continue 
                                    mem[_22518] = _22908
                                    mem[_22518 + 32] = stor10[address(arg3)][u].field_256
                                    mem[_22518 + 64] = stor10[address(arg3)][u].field_512
                                    mem[_22518 + 96] = stor10[address(arg3)][u].field_768
                                    mem[t] = _22518
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                if not stor10[address(arg3)][idx].field_0 - (stor10[address(arg3)][idx].field_1 < 32):
                                    revert with 0, 34
                                if stor10[address(arg3)][idx].field_1:
                                    if 31 >= stor10[address(arg3)][idx].field_1:
                                        mem[_22908 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                    else:
                                        mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                        mem[_22908 + 32] = stor10[address(arg3)][idx].field_0
                                        t = _22908 + 32
                                        u = sha3(mem[0])
                                        while _22908 + stor10[address(arg3)][idx].field_1 > t:
                                            mem[t + 32] = uint256(stor1[u])
                                            t = t + 32
                                            u = u + 1
                                            continue 
                                mem[_22518] = _22908
                                mem[_22518 + 32] = stor10[address(arg3)][idx].field_256
                                mem[_22518 + 64] = stor10[address(arg3)][idx].field_512
                                mem[_22518 + 96] = stor10[address(arg3)][idx].field_768
                                mem[s] = _22518
                                s = s + 32
                                idx = idx + 1
                                continue 
                            if address(arg1) != address(arg3):
                                if mem[ceil32(ceil32(arg2.length)) + 225] <= 1:
                                    if mem[_15256] > 0:
                                        if _referrals[address(arg1)] != address(arg3):
                                            _referrals[address(arg1)] = address(arg3)
                                            sub_989baf69[address(arg3)].field_0++
                                            sub_989baf69[address(arg3)][sub_989baf69[address(arg3)].field_0].field_0 = address(arg1)
                                        if tokenAddress != msg.sender:
                                            if gateKeeperAddress != msg.sender:
                                                if address(stor0.field_0) != msg.sender:
                                                    revert with 0, 'NodeManagerV2: NOT AUTHORIZED'
                                        if stor10[stor11[address(arg1)]].field_0:
                                            if not -referralBonusPercent:
                                                sub_e27e434a[stor11[address(arg1)]][address(arg1)] = 0
                                                if sub_666755bb[stor11[address(arg1)]] > -1:
                                                    revert with 0, 17
                                            else:
                                                if referralBonusPercent and nodePrice > -1 / referralBonusPercent:
                                                    revert with 0, 17
                                                if not referralBonusPercent:
                                                    revert with 0, 18
                                                if referralBonusPercent * nodePrice / referralBonusPercent != nodePrice:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                sub_e27e434a[stor11[address(arg1)]][address(arg1)] = referralBonusPercent * nodePrice / 100
                                                if sub_666755bb[stor11[address(arg1)]] > !(referralBonusPercent * nodePrice / 100):
                                                    revert with 0, 17
                                                sub_666755bb[stor11[address(arg1)]] += referralBonusPercent * nodePrice / 100
        else:
            if address(stor0.field_0) != msg.sender:
                revert with 0, 'NodeManagerV2: NOT AUTHORIZED'
            mem[ceil32(ceil32(arg2.length)) + 97] = 96
            mem[ceil32(ceil32(arg2.length)) + 129] = block.timestamp
            mem[ceil32(ceil32(arg2.length)) + 161] = block.timestamp
            mem[ceil32(ceil32(arg2.length)) + 193] = 0
            stor10[address(arg1)].field_0++
            if stor10[address(arg1)][stor10[address(arg1)].field_0].field_0:
                if not stor10[address(arg1)][stor10[address(arg1)].field_0].field_0 - (uint255(stor10[address(arg1)][stor10[address(arg1)].field_0].field_0) * 0.5 < 32):
                    revert with 0, 34
                if arg2.length:
                    stor10[address(arg1)][stor10[address(arg1)].field_0][].field_0 = Array(len=arg2.length, data=arg2[all])
                    stor10[address(arg1)][stor10[address(arg1)].field_0].field_256 = block.timestamp
                    stor10[address(arg1)][stor10[address(arg1)].field_0].field_512 = block.timestamp
                    stor10[address(arg1)][stor10[address(arg1)].field_0].field_768 = 0
                    mem[ceil32(ceil32(arg2.length)) + 229] = 6
                    mem[ceil32(ceil32(arg2.length)) + 261] = address(arg1)
                    mem[ceil32(ceil32(arg2.length)) + 293] = stor10[address(arg1)].field_0
                    require ext_code.size(0x4b7a346b17572634bdbd85b98abae32c5fa837bb)
                    delegate 0x4b7a346b17572634bdbd85b98abae32c5fa837bb.0xbc2b405c with:
                         gas gas_remaining wei
                        args 6, address(arg1), stor10[address(arg1)].field_0
                    if not delegate.return_code:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not totalNodesCreated + 1:
                        revert with 0, 17
                    totalNodesCreated++
                    if msg.sender == tokenAddress:
                        mem[0] = address(arg1)
                        mem[64] = ceil32(ceil32(arg2.length)) + (32 * stor10[address(arg1)].field_0) + 257
                        mem[ceil32(ceil32(arg2.length)) + 225] = stor10[address(arg1)].field_0
                        s = ceil32(ceil32(arg2.length)) + 257
                        idx = 0
                        while idx < stor10[address(arg1)].field_0:
                            mem[0] = sha3(address(arg1), 10)
                            _22528 = mem[64]
                            mem[64] = mem[64] + 128
                            if stor10[address(arg1)][idx].field_0:
                                if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                                    revert with 0, 34
                                _22792 = mem[64]
                                mem[64] = mem[64] + ceil32(uint255(stor10[address(arg1)][idx].field_0) * 0.5) + 32
                                mem[_22792] = uint255(stor10[address(arg1)][idx].field_0) * 0.5
                                if stor10[address(arg1)][idx].field_0:
                                    if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                                        revert with 0, 34
                                    if Mask(256, -1, stor10[address(arg1)][idx].field_0):
                                        if 31 >= uint255(stor10[address(arg1)][idx].field_0) * 0.5:
                                            mem[_22792 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                        else:
                                            mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                            mem[_22792 + 32] = stor10[address(arg1)][idx].field_0
                                            t = _22792 + 32
                                            u = sha3(mem[0])
                                            while _22792 + (uint255(stor10[address(arg1)][idx].field_0) * 0.5) > t:
                                                mem[t + 32] = uint256(stor1[u])
                                                t = t + 32
                                                u = u + 1
                                                continue 
                                    mem[_22528] = _22792
                                    mem[_22528 + 32] = stor10[address(arg1)][idx].field_256
                                    mem[_22528 + 64] = stor10[address(arg1)][idx].field_512
                                    mem[_22528 + 96] = stor10[address(arg1)][idx].field_768
                                    mem[s] = _22528
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                                    revert with 0, 34
                                if not stor10[address(arg1)][idx].field_1:
                                    mem[_22528] = _22792
                                    mem[_22528 + 32] = stor10[address(arg1)][idx].field_256
                                    mem[_22528 + 64] = stor10[address(arg1)][idx].field_512
                                    mem[_22528 + 96] = stor10[address(arg1)][idx].field_768
                                    mem[s] = _22528
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                if 31 >= stor10[address(arg1)][idx].field_1:
                                    mem[_22792 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                    mem[_22528] = _22792
                                    mem[_22528 + 32] = stor10[address(arg1)][idx].field_256
                                    mem[_22528 + 64] = stor10[address(arg1)][idx].field_512
                                    mem[_22528 + 96] = stor10[address(arg1)][idx].field_768
                                    mem[s] = _22528
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                mem[_22792 + 32] = stor10[address(arg1)][idx].field_0
                                t = _22792 + 32
                                u = sha3(mem[0])
                                while _22792 + stor10[address(arg1)][u].field_1 > t:
                                    mem[t + 32] = uint256(stor1[u])
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                mem[_22528] = _22792
                                mem[_22528 + 32] = stor10[address(arg1)][u].field_256
                                mem[_22528 + 64] = stor10[address(arg1)][u].field_512
                                mem[_22528 + 96] = stor10[address(arg1)][u].field_768
                                mem[t] = _22528
                                t = t + 32
                                u = u + 1
                                continue 
                            if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                                revert with 0, 34
                            _22916 = mem[64]
                            mem[64] = mem[64] + ceil32(stor10[address(arg1)][idx].field_1) + 32
                            mem[_22916] = stor10[address(arg1)][idx].field_1
                            if stor10[address(arg1)][idx].field_0:
                                if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                                    revert with 0, 34
                                if not Mask(256, -1, stor10[address(arg1)][idx].field_0):
                                    mem[_22528] = _22916
                                    mem[_22528 + 32] = stor10[address(arg1)][idx].field_256
                                    mem[_22528 + 64] = stor10[address(arg1)][idx].field_512
                                    mem[_22528 + 96] = stor10[address(arg1)][idx].field_768
                                    mem[s] = _22528
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                if 31 >= uint255(stor10[address(arg1)][idx].field_0) * 0.5:
                                    mem[_22916 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                    mem[_22528] = _22916
                                    mem[_22528 + 32] = stor10[address(arg1)][idx].field_256
                                    mem[_22528 + 64] = stor10[address(arg1)][idx].field_512
                                    mem[_22528 + 96] = stor10[address(arg1)][idx].field_768
                                    mem[s] = _22528
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                mem[_22916 + 32] = stor10[address(arg1)][idx].field_0
                                t = _22916 + 32
                                u = sha3(mem[0])
                                while _22916 + (uint255(stor10[address(arg1)][u].field_0) * 0.5) > t:
                                    mem[t + 32] = uint256(stor1[u])
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                mem[_22528] = _22916
                                mem[_22528 + 32] = stor10[address(arg1)][u].field_256
                                mem[_22528 + 64] = stor10[address(arg1)][u].field_512
                                mem[_22528 + 96] = stor10[address(arg1)][u].field_768
                                mem[t] = _22528
                                t = t + 32
                                u = u + 1
                                continue 
                            if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                                revert with 0, 34
                            if stor10[address(arg1)][idx].field_1:
                                if 31 >= stor10[address(arg1)][idx].field_1:
                                    mem[_22916 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                else:
                                    mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                    mem[_22916 + 32] = stor10[address(arg1)][idx].field_0
                                    t = _22916 + 32
                                    u = sha3(mem[0])
                                    while _22916 + stor10[address(arg1)][idx].field_1 > t:
                                        mem[t + 32] = uint256(stor1[u])
                                        t = t + 32
                                        u = u + 1
                                        continue 
                            mem[_22528] = _22916
                            mem[_22528 + 32] = stor10[address(arg1)][idx].field_256
                            mem[_22528 + 64] = stor10[address(arg1)][idx].field_512
                            mem[_22528 + 96] = stor10[address(arg1)][idx].field_768
                            mem[s] = _22528
                            s = s + 32
                            idx = idx + 1
                            continue 
                        mem[0] = address(arg3)
                        mem[32] = 10
                        _22526 = mem[64]
                        mem[64] = mem[64] + (32 * stor10[address(arg3)].field_0) + 32
                        mem[_22526] = stor10[address(arg3)].field_0
                        s = _22526 + 32
                        idx = 0
                        while idx < stor10[address(arg3)].field_0:
                            mem[0] = sha3(address(arg3), 10)
                            _29084 = mem[64]
                            mem[64] = mem[64] + 128
                            if stor10[address(arg3)][idx].field_0:
                                if not stor10[address(arg3)][idx].field_0 - (uint255(stor10[address(arg3)][idx].field_0) * 0.5 < 32):
                                    revert with 0, 34
                                _29143 = mem[64]
                                mem[64] = mem[64] + ceil32(uint255(stor10[address(arg3)][idx].field_0) * 0.5) + 32
                                mem[_29143] = uint255(stor10[address(arg3)][idx].field_0) * 0.5
                                if stor10[address(arg3)][idx].field_0:
                                    if not stor10[address(arg3)][idx].field_0 - (uint255(stor10[address(arg3)][idx].field_0) * 0.5 < 32):
                                        revert with 0, 34
                                    if Mask(256, -1, stor10[address(arg3)][idx].field_0):
                                        if 31 >= uint255(stor10[address(arg3)][idx].field_0) * 0.5:
                                            mem[_29143 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                        else:
                                            mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                            mem[_29143 + 32] = stor10[address(arg3)][idx].field_0
                                            t = _29143 + 32
                                            u = sha3(mem[0])
                                            while _29143 + (uint255(stor10[address(arg3)][idx].field_0) * 0.5) > t:
                                                mem[t + 32] = uint256(stor1[u])
                                                t = t + 32
                                                u = u + 1
                                                continue 
                                    mem[_29084] = _29143
                                    mem[_29084 + 32] = stor10[address(arg3)][idx].field_256
                                    mem[_29084 + 64] = stor10[address(arg3)][idx].field_512
                                    mem[_29084 + 96] = stor10[address(arg3)][idx].field_768
                                    mem[s] = _29084
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                if not stor10[address(arg3)][idx].field_0 - (stor10[address(arg3)][idx].field_1 < 32):
                                    revert with 0, 34
                                if not stor10[address(arg3)][idx].field_1:
                                    mem[_29084] = _29143
                                    mem[_29084 + 32] = stor10[address(arg3)][idx].field_256
                                    mem[_29084 + 64] = stor10[address(arg3)][idx].field_512
                                    mem[_29084 + 96] = stor10[address(arg3)][idx].field_768
                                    mem[s] = _29084
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                if 31 >= stor10[address(arg3)][idx].field_1:
                                    mem[_29143 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                    mem[_29084] = _29143
                                    mem[_29084 + 32] = stor10[address(arg3)][idx].field_256
                                    mem[_29084 + 64] = stor10[address(arg3)][idx].field_512
                                    mem[_29084 + 96] = stor10[address(arg3)][idx].field_768
                                    mem[s] = _29084
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                mem[_29143 + 32] = stor10[address(arg3)][idx].field_0
                                t = _29143 + 32
                                u = sha3(mem[0])
                                while _29143 + stor10[address(arg3)][u].field_1 > t:
                                    mem[t + 32] = uint256(stor1[u])
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                mem[_29084] = _29143
                                mem[_29084 + 32] = stor10[address(arg3)][u].field_256
                                mem[_29084 + 64] = stor10[address(arg3)][u].field_512
                                mem[_29084 + 96] = stor10[address(arg3)][u].field_768
                                mem[t] = _29084
                                t = t + 32
                                u = u + 1
                                continue 
                            if not stor10[address(arg3)][idx].field_0 - (stor10[address(arg3)][idx].field_1 < 32):
                                revert with 0, 34
                            _29174 = mem[64]
                            mem[64] = mem[64] + ceil32(stor10[address(arg3)][idx].field_1) + 32
                            mem[_29174] = stor10[address(arg3)][idx].field_1
                            if stor10[address(arg3)][idx].field_0:
                                if not stor10[address(arg3)][idx].field_0 - (uint255(stor10[address(arg3)][idx].field_0) * 0.5 < 32):
                                    revert with 0, 34
                                if not Mask(256, -1, stor10[address(arg3)][idx].field_0):
                                    mem[_29084] = _29174
                                    mem[_29084 + 32] = stor10[address(arg3)][idx].field_256
                                    mem[_29084 + 64] = stor10[address(arg3)][idx].field_512
                                    mem[_29084 + 96] = stor10[address(arg3)][idx].field_768
                                    mem[s] = _29084
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                if 31 >= uint255(stor10[address(arg3)][idx].field_0) * 0.5:
                                    mem[_29174 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                    mem[_29084] = _29174
                                    mem[_29084 + 32] = stor10[address(arg3)][idx].field_256
                                    mem[_29084 + 64] = stor10[address(arg3)][idx].field_512
                                    mem[_29084 + 96] = stor10[address(arg3)][idx].field_768
                                    mem[s] = _29084
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                mem[_29174 + 32] = stor10[address(arg3)][idx].field_0
                                t = _29174 + 32
                                u = sha3(mem[0])
                                while _29174 + (uint255(stor10[address(arg3)][u].field_0) * 0.5) > t:
                                    mem[t + 32] = uint256(stor1[u])
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                mem[_29084] = _29174
                                mem[_29084 + 32] = stor10[address(arg3)][u].field_256
                                mem[_29084 + 64] = stor10[address(arg3)][u].field_512
                                mem[_29084 + 96] = stor10[address(arg3)][u].field_768
                                mem[t] = _29084
                                t = t + 32
                                u = u + 1
                                continue 
                            if not stor10[address(arg3)][idx].field_0 - (stor10[address(arg3)][idx].field_1 < 32):
                                revert with 0, 34
                            if stor10[address(arg3)][idx].field_1:
                                if 31 >= stor10[address(arg3)][idx].field_1:
                                    mem[_29174 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                else:
                                    mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                    mem[_29174 + 32] = stor10[address(arg3)][idx].field_0
                                    t = _29174 + 32
                                    u = sha3(mem[0])
                                    while _29174 + stor10[address(arg3)][idx].field_1 > t:
                                        mem[t + 32] = uint256(stor1[u])
                                        t = t + 32
                                        u = u + 1
                                        continue 
                            mem[_29084] = _29174
                            mem[_29084 + 32] = stor10[address(arg3)][idx].field_256
                            mem[_29084 + 64] = stor10[address(arg3)][idx].field_512
                            mem[_29084 + 96] = stor10[address(arg3)][idx].field_768
                            mem[s] = _29084
                            s = s + 32
                            idx = idx + 1
                            continue 
                        if address(arg1) != address(arg3):
                            if mem[ceil32(ceil32(arg2.length)) + 225] <= 1:
                                if mem[_22526] > 0:
                                    if _referrals[address(arg1)] != address(arg3):
                                        _referrals[address(arg1)] = address(arg3)
                                        sub_989baf69[address(arg3)].field_0++
                                        sub_989baf69[address(arg3)][sub_989baf69[address(arg3)].field_0].field_0 = address(arg1)
                                    if tokenAddress != msg.sender:
                                        if gateKeeperAddress != msg.sender:
                                            if address(stor0.field_0) != msg.sender:
                                                revert with 0, 'NodeManagerV2: NOT AUTHORIZED'
                                    if stor10[stor11[address(arg1)]].field_0:
                                        if not -referralBonusPercent:
                                            sub_e27e434a[stor11[address(arg1)]][address(arg1)] = 0
                                            if sub_666755bb[stor11[address(arg1)]] > -1:
                                                revert with 0, 17
                                        else:
                                            if referralBonusPercent and nodePrice > -1 / referralBonusPercent:
                                                revert with 0, 17
                                            if not referralBonusPercent:
                                                revert with 0, 18
                                            if referralBonusPercent * nodePrice / referralBonusPercent != nodePrice:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            sub_e27e434a[stor11[address(arg1)]][address(arg1)] = referralBonusPercent * nodePrice / 100
                                            if sub_666755bb[stor11[address(arg1)]] > !(referralBonusPercent * nodePrice / 100):
                                                revert with 0, 17
                                            sub_666755bb[stor11[address(arg1)]] += referralBonusPercent * nodePrice / 100
                    else:
                        if msg.sender == gateKeeperAddress:
                            mem[0] = address(arg1)
                            mem[64] = ceil32(ceil32(arg2.length)) + (32 * stor10[address(arg1)].field_0) + 257
                            mem[ceil32(ceil32(arg2.length)) + 225] = stor10[address(arg1)].field_0
                            s = ceil32(ceil32(arg2.length)) + 257
                            idx = 0
                            while idx < stor10[address(arg1)].field_0:
                                mem[0] = sha3(address(arg1), 10)
                                _22532 = mem[64]
                                mem[64] = mem[64] + 128
                                if stor10[address(arg1)][idx].field_0:
                                    if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                                        revert with 0, 34
                                    _22793 = mem[64]
                                    mem[64] = mem[64] + ceil32(uint255(stor10[address(arg1)][idx].field_0) * 0.5) + 32
                                    mem[_22793] = uint255(stor10[address(arg1)][idx].field_0) * 0.5
                                    if stor10[address(arg1)][idx].field_0:
                                        if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                                            revert with 0, 34
                                        if Mask(256, -1, stor10[address(arg1)][idx].field_0):
                                            if 31 >= uint255(stor10[address(arg1)][idx].field_0) * 0.5:
                                                mem[_22793 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                            else:
                                                mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                                mem[_22793 + 32] = stor10[address(arg1)][idx].field_0
                                                t = _22793 + 32
                                                u = sha3(mem[0])
                                                while _22793 + (uint255(stor10[address(arg1)][idx].field_0) * 0.5) > t:
                                                    mem[t + 32] = uint256(stor1[u])
                                                    t = t + 32
                                                    u = u + 1
                                                    continue 
                                        mem[_22532] = _22793
                                        mem[_22532 + 32] = stor10[address(arg1)][idx].field_256
                                        mem[_22532 + 64] = stor10[address(arg1)][idx].field_512
                                        mem[_22532 + 96] = stor10[address(arg1)][idx].field_768
                                        mem[s] = _22532
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                                        revert with 0, 34
                                    if not stor10[address(arg1)][idx].field_1:
                                        mem[_22532] = _22793
                                        mem[_22532 + 32] = stor10[address(arg1)][idx].field_256
                                        mem[_22532 + 64] = stor10[address(arg1)][idx].field_512
                                        mem[_22532 + 96] = stor10[address(arg1)][idx].field_768
                                        mem[s] = _22532
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    if 31 >= stor10[address(arg1)][idx].field_1:
                                        mem[_22793 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                        mem[_22532] = _22793
                                        mem[_22532 + 32] = stor10[address(arg1)][idx].field_256
                                        mem[_22532 + 64] = stor10[address(arg1)][idx].field_512
                                        mem[_22532 + 96] = stor10[address(arg1)][idx].field_768
                                        mem[s] = _22532
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                    mem[_22793 + 32] = stor10[address(arg1)][idx].field_0
                                    t = _22793 + 32
                                    u = sha3(mem[0])
                                    while _22793 + stor10[address(arg1)][u].field_1 > t:
                                        mem[t + 32] = uint256(stor1[u])
                                        t = t + 32
                                        u = u + 1
                                        continue 
                                    mem[_22532] = _22793
                                    mem[_22532 + 32] = stor10[address(arg1)][u].field_256
                                    mem[_22532 + 64] = stor10[address(arg1)][u].field_512
                                    mem[_22532 + 96] = stor10[address(arg1)][u].field_768
                                    mem[t] = _22532
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                                    revert with 0, 34
                                _22918 = mem[64]
                                mem[64] = mem[64] + ceil32(stor10[address(arg1)][idx].field_1) + 32
                                mem[_22918] = stor10[address(arg1)][idx].field_1
                                if stor10[address(arg1)][idx].field_0:
                                    if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                                        revert with 0, 34
                                    if not Mask(256, -1, stor10[address(arg1)][idx].field_0):
                                        mem[_22532] = _22918
                                        mem[_22532 + 32] = stor10[address(arg1)][idx].field_256
                                        mem[_22532 + 64] = stor10[address(arg1)][idx].field_512
                                        mem[_22532 + 96] = stor10[address(arg1)][idx].field_768
                                        mem[s] = _22532
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    if 31 >= uint255(stor10[address(arg1)][idx].field_0) * 0.5:
                                        mem[_22918 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                        mem[_22532] = _22918
                                        mem[_22532 + 32] = stor10[address(arg1)][idx].field_256
                                        mem[_22532 + 64] = stor10[address(arg1)][idx].field_512
                                        mem[_22532 + 96] = stor10[address(arg1)][idx].field_768
                                        mem[s] = _22532
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                    mem[_22918 + 32] = stor10[address(arg1)][idx].field_0
                                    t = _22918 + 32
                                    u = sha3(mem[0])
                                    while _22918 + (uint255(stor10[address(arg1)][u].field_0) * 0.5) > t:
                                        mem[t + 32] = uint256(stor1[u])
                                        t = t + 32
                                        u = u + 1
                                        continue 
                                    mem[_22532] = _22918
                                    mem[_22532 + 32] = stor10[address(arg1)][u].field_256
                                    mem[_22532 + 64] = stor10[address(arg1)][u].field_512
                                    mem[_22532 + 96] = stor10[address(arg1)][u].field_768
                                    mem[t] = _22532
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                                    revert with 0, 34
                                if stor10[address(arg1)][idx].field_1:
                                    if 31 >= stor10[address(arg1)][idx].field_1:
                                        mem[_22918 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                    else:
                                        mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                        mem[_22918 + 32] = stor10[address(arg1)][idx].field_0
                                        t = _22918 + 32
                                        u = sha3(mem[0])
                                        while _22918 + stor10[address(arg1)][idx].field_1 > t:
                                            mem[t + 32] = uint256(stor1[u])
                                            t = t + 32
                                            u = u + 1
                                            continue 
                                mem[_22532] = _22918
                                mem[_22532 + 32] = stor10[address(arg1)][idx].field_256
                                mem[_22532 + 64] = stor10[address(arg1)][idx].field_512
                                mem[_22532 + 96] = stor10[address(arg1)][idx].field_768
                                mem[s] = _22532
                                s = s + 32
                                idx = idx + 1
                                continue 
                            mem[0] = address(arg3)
                            mem[32] = 10
                            _22530 = mem[64]
                            mem[64] = mem[64] + (32 * stor10[address(arg3)].field_0) + 32
                            mem[_22530] = stor10[address(arg3)].field_0
                            s = _22530 + 32
                            idx = 0
                            while idx < stor10[address(arg3)].field_0:
                                mem[0] = sha3(address(arg3), 10)
                                _29086 = mem[64]
                                mem[64] = mem[64] + 128
                                if stor10[address(arg3)][idx].field_0:
                                    if not stor10[address(arg3)][idx].field_0 - (uint255(stor10[address(arg3)][idx].field_0) * 0.5 < 32):
                                        revert with 0, 34
                                    _29144 = mem[64]
                                    mem[64] = mem[64] + ceil32(uint255(stor10[address(arg3)][idx].field_0) * 0.5) + 32
                                    mem[_29144] = uint255(stor10[address(arg3)][idx].field_0) * 0.5
                                    if stor10[address(arg3)][idx].field_0:
                                        if not stor10[address(arg3)][idx].field_0 - (uint255(stor10[address(arg3)][idx].field_0) * 0.5 < 32):
                                            revert with 0, 34
                                        if Mask(256, -1, stor10[address(arg3)][idx].field_0):
                                            if 31 >= uint255(stor10[address(arg3)][idx].field_0) * 0.5:
                                                mem[_29144 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                            else:
                                                mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                                mem[_29144 + 32] = stor10[address(arg3)][idx].field_0
                                                t = _29144 + 32
                                                u = sha3(mem[0])
                                                while _29144 + (uint255(stor10[address(arg3)][idx].field_0) * 0.5) > t:
                                                    mem[t + 32] = uint256(stor1[u])
                                                    t = t + 32
                                                    u = u + 1
                                                    continue 
                                        mem[_29086] = _29144
                                        mem[_29086 + 32] = stor10[address(arg3)][idx].field_256
                                        mem[_29086 + 64] = stor10[address(arg3)][idx].field_512
                                        mem[_29086 + 96] = stor10[address(arg3)][idx].field_768
                                        mem[s] = _29086
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    if not stor10[address(arg3)][idx].field_0 - (stor10[address(arg3)][idx].field_1 < 32):
                                        revert with 0, 34
                                    if not stor10[address(arg3)][idx].field_1:
                                        mem[_29086] = _29144
                                        mem[_29086 + 32] = stor10[address(arg3)][idx].field_256
                                        mem[_29086 + 64] = stor10[address(arg3)][idx].field_512
                                        mem[_29086 + 96] = stor10[address(arg3)][idx].field_768
                                        mem[s] = _29086
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    if 31 >= stor10[address(arg3)][idx].field_1:
                                        mem[_29144 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                        mem[_29086] = _29144
                                        mem[_29086 + 32] = stor10[address(arg3)][idx].field_256
                                        mem[_29086 + 64] = stor10[address(arg3)][idx].field_512
                                        mem[_29086 + 96] = stor10[address(arg3)][idx].field_768
                                        mem[s] = _29086
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                    mem[_29144 + 32] = stor10[address(arg3)][idx].field_0
                                    t = _29144 + 32
                                    u = sha3(mem[0])
                                    while _29144 + stor10[address(arg3)][u].field_1 > t:
                                        mem[t + 32] = uint256(stor1[u])
                                        t = t + 32
                                        u = u + 1
                                        continue 
                                    mem[_29086] = _29144
                                    mem[_29086 + 32] = stor10[address(arg3)][u].field_256
                                    mem[_29086 + 64] = stor10[address(arg3)][u].field_512
                                    mem[_29086 + 96] = stor10[address(arg3)][u].field_768
                                    mem[t] = _29086
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                if not stor10[address(arg3)][idx].field_0 - (stor10[address(arg3)][idx].field_1 < 32):
                                    revert with 0, 34
                                _29176 = mem[64]
                                mem[64] = mem[64] + ceil32(stor10[address(arg3)][idx].field_1) + 32
                                mem[_29176] = stor10[address(arg3)][idx].field_1
                                if stor10[address(arg3)][idx].field_0:
                                    if not stor10[address(arg3)][idx].field_0 - (uint255(stor10[address(arg3)][idx].field_0) * 0.5 < 32):
                                        revert with 0, 34
                                    if not Mask(256, -1, stor10[address(arg3)][idx].field_0):
                                        mem[_29086] = _29176
                                        mem[_29086 + 32] = stor10[address(arg3)][idx].field_256
                                        mem[_29086 + 64] = stor10[address(arg3)][idx].field_512
                                        mem[_29086 + 96] = stor10[address(arg3)][idx].field_768
                                        mem[s] = _29086
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    if 31 >= uint255(stor10[address(arg3)][idx].field_0) * 0.5:
                                        mem[_29176 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                        mem[_29086] = _29176
                                        mem[_29086 + 32] = stor10[address(arg3)][idx].field_256
                                        mem[_29086 + 64] = stor10[address(arg3)][idx].field_512
                                        mem[_29086 + 96] = stor10[address(arg3)][idx].field_768
                                        mem[s] = _29086
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                    mem[_29176 + 32] = stor10[address(arg3)][idx].field_0
                                    t = _29176 + 32
                                    u = sha3(mem[0])
                                    while _29176 + (uint255(stor10[address(arg3)][u].field_0) * 0.5) > t:
                                        mem[t + 32] = uint256(stor1[u])
                                        t = t + 32
                                        u = u + 1
                                        continue 
                                    mem[_29086] = _29176
                                    mem[_29086 + 32] = stor10[address(arg3)][u].field_256
                                    mem[_29086 + 64] = stor10[address(arg3)][u].field_512
                                    mem[_29086 + 96] = stor10[address(arg3)][u].field_768
                                    mem[t] = _29086
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                if not stor10[address(arg3)][idx].field_0 - (stor10[address(arg3)][idx].field_1 < 32):
                                    revert with 0, 34
                                if stor10[address(arg3)][idx].field_1:
                                    if 31 >= stor10[address(arg3)][idx].field_1:
                                        mem[_29176 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                    else:
                                        mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                        mem[_29176 + 32] = stor10[address(arg3)][idx].field_0
                                        t = _29176 + 32
                                        u = sha3(mem[0])
                                        while _29176 + stor10[address(arg3)][idx].field_1 > t:
                                            mem[t + 32] = uint256(stor1[u])
                                            t = t + 32
                                            u = u + 1
                                            continue 
                                mem[_29086] = _29176
                                mem[_29086 + 32] = stor10[address(arg3)][idx].field_256
                                mem[_29086 + 64] = stor10[address(arg3)][idx].field_512
                                mem[_29086 + 96] = stor10[address(arg3)][idx].field_768
                                mem[s] = _29086
                                s = s + 32
                                idx = idx + 1
                                continue 
                            if address(arg1) != address(arg3):
                                if mem[ceil32(ceil32(arg2.length)) + 225] <= 1:
                                    if mem[_22530] > 0:
                                        if _referrals[address(arg1)] != address(arg3):
                                            _referrals[address(arg1)] = address(arg3)
                                            sub_989baf69[address(arg3)].field_0++
                                            sub_989baf69[address(arg3)][sub_989baf69[address(arg3)].field_0].field_0 = address(arg1)
                                        if tokenAddress != msg.sender:
                                            if gateKeeperAddress != msg.sender:
                                                if address(stor0.field_0) != msg.sender:
                                                    revert with 0, 'NodeManagerV2: NOT AUTHORIZED'
                                        if stor10[stor11[address(arg1)]].field_0:
                                            if not -referralBonusPercent:
                                                sub_e27e434a[stor11[address(arg1)]][address(arg1)] = 0
                                                if sub_666755bb[stor11[address(arg1)]] > -1:
                                                    revert with 0, 17
                                            else:
                                                if referralBonusPercent and nodePrice > -1 / referralBonusPercent:
                                                    revert with 0, 17
                                                if not referralBonusPercent:
                                                    revert with 0, 18
                                                if referralBonusPercent * nodePrice / referralBonusPercent != nodePrice:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                sub_e27e434a[stor11[address(arg1)]][address(arg1)] = referralBonusPercent * nodePrice / 100
                                                if sub_666755bb[stor11[address(arg1)]] > !(referralBonusPercent * nodePrice / 100):
                                                    revert with 0, 17
                                                sub_666755bb[stor11[address(arg1)]] += referralBonusPercent * nodePrice / 100
                        else:
                            if address(stor0.field_0) != msg.sender:
                                revert with 0, 'NodeManagerV2: NOT AUTHORIZED'
                            mem[0] = address(arg1)
                            mem[64] = ceil32(ceil32(arg2.length)) + (32 * stor10[address(arg1)].field_0) + 257
                            mem[ceil32(ceil32(arg2.length)) + 225] = stor10[address(arg1)].field_0
                            s = ceil32(ceil32(arg2.length)) + 257
                            idx = 0
                            while idx < stor10[address(arg1)].field_0:
                                mem[0] = sha3(address(arg1), 10)
                                _22536 = mem[64]
                                mem[64] = mem[64] + 128
                                if stor10[address(arg1)][idx].field_0:
                                    if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                                        revert with 0, 34
                                    _22794 = mem[64]
                                    mem[64] = mem[64] + ceil32(uint255(stor10[address(arg1)][idx].field_0) * 0.5) + 32
                                    mem[_22794] = uint255(stor10[address(arg1)][idx].field_0) * 0.5
                                    if stor10[address(arg1)][idx].field_0:
                                        if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                                            revert with 0, 34
                                        if Mask(256, -1, stor10[address(arg1)][idx].field_0):
                                            if 31 >= uint255(stor10[address(arg1)][idx].field_0) * 0.5:
                                                mem[_22794 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                            else:
                                                mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                                mem[_22794 + 32] = stor10[address(arg1)][idx].field_0
                                                t = _22794 + 32
                                                u = sha3(mem[0])
                                                while _22794 + (uint255(stor10[address(arg1)][idx].field_0) * 0.5) > t:
                                                    mem[t + 32] = uint256(stor1[u])
                                                    t = t + 32
                                                    u = u + 1
                                                    continue 
                                        mem[_22536] = _22794
                                        mem[_22536 + 32] = stor10[address(arg1)][idx].field_256
                                        mem[_22536 + 64] = stor10[address(arg1)][idx].field_512
                                        mem[_22536 + 96] = stor10[address(arg1)][idx].field_768
                                        mem[s] = _22536
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                                        revert with 0, 34
                                    if not stor10[address(arg1)][idx].field_1:
                                        mem[_22536] = _22794
                                        mem[_22536 + 32] = stor10[address(arg1)][idx].field_256
                                        mem[_22536 + 64] = stor10[address(arg1)][idx].field_512
                                        mem[_22536 + 96] = stor10[address(arg1)][idx].field_768
                                        mem[s] = _22536
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    if 31 >= stor10[address(arg1)][idx].field_1:
                                        mem[_22794 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                        mem[_22536] = _22794
                                        mem[_22536 + 32] = stor10[address(arg1)][idx].field_256
                                        mem[_22536 + 64] = stor10[address(arg1)][idx].field_512
                                        mem[_22536 + 96] = stor10[address(arg1)][idx].field_768
                                        mem[s] = _22536
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                    mem[_22794 + 32] = stor10[address(arg1)][idx].field_0
                                    t = _22794 + 32
                                    u = sha3(mem[0])
                                    while _22794 + stor10[address(arg1)][u].field_1 > t:
                                        mem[t + 32] = uint256(stor1[u])
                                        t = t + 32
                                        u = u + 1
                                        continue 
                                    mem[_22536] = _22794
                                    mem[_22536 + 32] = stor10[address(arg1)][u].field_256
                                    mem[_22536 + 64] = stor10[address(arg1)][u].field_512
                                    mem[_22536 + 96] = stor10[address(arg1)][u].field_768
                                    mem[t] = _22536
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                                    revert with 0, 34
                                _22920 = mem[64]
                                mem[64] = mem[64] + ceil32(stor10[address(arg1)][idx].field_1) + 32
                                mem[_22920] = stor10[address(arg1)][idx].field_1
                                if stor10[address(arg1)][idx].field_0:
                                    if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                                        revert with 0, 34
                                    if not Mask(256, -1, stor10[address(arg1)][idx].field_0):
                                        mem[_22536] = _22920
                                        mem[_22536 + 32] = stor10[address(arg1)][idx].field_256
                                        mem[_22536 + 64] = stor10[address(arg1)][idx].field_512
                                        mem[_22536 + 96] = stor10[address(arg1)][idx].field_768
                                        mem[s] = _22536
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    if 31 >= uint255(stor10[address(arg1)][idx].field_0) * 0.5:
                                        mem[_22920 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                        mem[_22536] = _22920
                                        mem[_22536 + 32] = stor10[address(arg1)][idx].field_256
                                        mem[_22536 + 64] = stor10[address(arg1)][idx].field_512
                                        mem[_22536 + 96] = stor10[address(arg1)][idx].field_768
                                        mem[s] = _22536
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                    mem[_22920 + 32] = stor10[address(arg1)][idx].field_0
                                    t = _22920 + 32
                                    u = sha3(mem[0])
                                    while _22920 + (uint255(stor10[address(arg1)][u].field_0) * 0.5) > t:
                                        mem[t + 32] = uint256(stor1[u])
                                        t = t + 32
                                        u = u + 1
                                        continue 
                                    mem[_22536] = _22920
                                    mem[_22536 + 32] = stor10[address(arg1)][u].field_256
                                    mem[_22536 + 64] = stor10[address(arg1)][u].field_512
                                    mem[_22536 + 96] = stor10[address(arg1)][u].field_768
                                    mem[t] = _22536
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                                    revert with 0, 34
                                if stor10[address(arg1)][idx].field_1:
                                    if 31 >= stor10[address(arg1)][idx].field_1:
                                        mem[_22920 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                    else:
                                        mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                        mem[_22920 + 32] = stor10[address(arg1)][idx].field_0
                                        t = _22920 + 32
                                        u = sha3(mem[0])
                                        while _22920 + stor10[address(arg1)][idx].field_1 > t:
                                            mem[t + 32] = uint256(stor1[u])
                                            t = t + 32
                                            u = u + 1
                                            continue 
                                mem[_22536] = _22920
                                mem[_22536 + 32] = stor10[address(arg1)][idx].field_256
                                mem[_22536 + 64] = stor10[address(arg1)][idx].field_512
                                mem[_22536 + 96] = stor10[address(arg1)][idx].field_768
                                mem[s] = _22536
                                s = s + 32
                                idx = idx + 1
                                continue 
                            mem[0] = address(arg3)
                            mem[32] = 10
                            _22534 = mem[64]
                            mem[64] = mem[64] + (32 * stor10[address(arg3)].field_0) + 32
                            mem[_22534] = stor10[address(arg3)].field_0
                            s = _22534 + 32
                            idx = 0
                            while idx < stor10[address(arg3)].field_0:
                                mem[0] = sha3(address(arg3), 10)
                                _29088 = mem[64]
                                mem[64] = mem[64] + 128
                                if stor10[address(arg3)][idx].field_0:
                                    if not stor10[address(arg3)][idx].field_0 - (uint255(stor10[address(arg3)][idx].field_0) * 0.5 < 32):
                                        revert with 0, 34
                                    _29145 = mem[64]
                                    mem[64] = mem[64] + ceil32(uint255(stor10[address(arg3)][idx].field_0) * 0.5) + 32
                                    mem[_29145] = uint255(stor10[address(arg3)][idx].field_0) * 0.5
                                    if stor10[address(arg3)][idx].field_0:
                                        if not stor10[address(arg3)][idx].field_0 - (uint255(stor10[address(arg3)][idx].field_0) * 0.5 < 32):
                                            revert with 0, 34
                                        if Mask(256, -1, stor10[address(arg3)][idx].field_0):
                                            if 31 >= uint255(stor10[address(arg3)][idx].field_0) * 0.5:
                                                mem[_29145 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                            else:
                                                mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                                mem[_29145 + 32] = stor10[address(arg3)][idx].field_0
                                                t = _29145 + 32
                                                u = sha3(mem[0])
                                                while _29145 + (uint255(stor10[address(arg3)][idx].field_0) * 0.5) > t:
                                                    mem[t + 32] = uint256(stor1[u])
                                                    t = t + 32
                                                    u = u + 1
                                                    continue 
                                        mem[_29088] = _29145
                                        mem[_29088 + 32] = stor10[address(arg3)][idx].field_256
                                        mem[_29088 + 64] = stor10[address(arg3)][idx].field_512
                                        mem[_29088 + 96] = stor10[address(arg3)][idx].field_768
                                        mem[s] = _29088
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    if not stor10[address(arg3)][idx].field_0 - (stor10[address(arg3)][idx].field_1 < 32):
                                        revert with 0, 34
                                    if not stor10[address(arg3)][idx].field_1:
                                        mem[_29088] = _29145
                                        mem[_29088 + 32] = stor10[address(arg3)][idx].field_256
                                        mem[_29088 + 64] = stor10[address(arg3)][idx].field_512
                                        mem[_29088 + 96] = stor10[address(arg3)][idx].field_768
                                        mem[s] = _29088
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    if 31 >= stor10[address(arg3)][idx].field_1:
                                        mem[_29145 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                        mem[_29088] = _29145
                                        mem[_29088 + 32] = stor10[address(arg3)][idx].field_256
                                        mem[_29088 + 64] = stor10[address(arg3)][idx].field_512
                                        mem[_29088 + 96] = stor10[address(arg3)][idx].field_768
                                        mem[s] = _29088
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                    mem[_29145 + 32] = stor10[address(arg3)][idx].field_0
                                    t = _29145 + 32
                                    u = sha3(mem[0])
                                    while _29145 + stor10[address(arg3)][u].field_1 > t:
                                        mem[t + 32] = uint256(stor1[u])
                                        t = t + 32
                                        u = u + 1
                                        continue 
                                    mem[_29088] = _29145
                                    mem[_29088 + 32] = stor10[address(arg3)][u].field_256
                                    mem[_29088 + 64] = stor10[address(arg3)][u].field_512
                                    mem[_29088 + 96] = stor10[address(arg3)][u].field_768
                                    mem[t] = _29088
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                if not stor10[address(arg3)][idx].field_0 - (stor10[address(arg3)][idx].field_1 < 32):
                                    revert with 0, 34
                                _29178 = mem[64]
                                mem[64] = mem[64] + ceil32(stor10[address(arg3)][idx].field_1) + 32
                                mem[_29178] = stor10[address(arg3)][idx].field_1
                                if stor10[address(arg3)][idx].field_0:
                                    if not stor10[address(arg3)][idx].field_0 - (uint255(stor10[address(arg3)][idx].field_0) * 0.5 < 32):
                                        revert with 0, 34
                                    if not Mask(256, -1, stor10[address(arg3)][idx].field_0):
                                        mem[_29088] = _29178
                                        mem[_29088 + 32] = stor10[address(arg3)][idx].field_256
                                        mem[_29088 + 64] = stor10[address(arg3)][idx].field_512
                                        mem[_29088 + 96] = stor10[address(arg3)][idx].field_768
                                        mem[s] = _29088
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    if 31 >= uint255(stor10[address(arg3)][idx].field_0) * 0.5:
                                        mem[_29178 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                        mem[_29088] = _29178
                                        mem[_29088 + 32] = stor10[address(arg3)][idx].field_256
                                        mem[_29088 + 64] = stor10[address(arg3)][idx].field_512
                                        mem[_29088 + 96] = stor10[address(arg3)][idx].field_768
                                        mem[s] = _29088
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                    mem[_29178 + 32] = stor10[address(arg3)][idx].field_0
                                    t = _29178 + 32
                                    u = sha3(mem[0])
                                    while _29178 + (uint255(stor10[address(arg3)][u].field_0) * 0.5) > t:
                                        mem[t + 32] = uint256(stor1[u])
                                        t = t + 32
                                        u = u + 1
                                        continue 
                                    mem[_29088] = _29178
                                    mem[_29088 + 32] = stor10[address(arg3)][u].field_256
                                    mem[_29088 + 64] = stor10[address(arg3)][u].field_512
                                    mem[_29088 + 96] = stor10[address(arg3)][u].field_768
                                    mem[t] = _29088
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                if not stor10[address(arg3)][idx].field_0 - (stor10[address(arg3)][idx].field_1 < 32):
                                    revert with 0, 34
                                if stor10[address(arg3)][idx].field_1:
                                    if 31 >= stor10[address(arg3)][idx].field_1:
                                        mem[_29178 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                    else:
                                        mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                        mem[_29178 + 32] = stor10[address(arg3)][idx].field_0
                                        t = _29178 + 32
                                        u = sha3(mem[0])
                                        while _29178 + stor10[address(arg3)][idx].field_1 > t:
                                            mem[t + 32] = uint256(stor1[u])
                                            t = t + 32
                                            u = u + 1
                                            continue 
                                mem[_29088] = _29178
                                mem[_29088 + 32] = stor10[address(arg3)][idx].field_256
                                mem[_29088 + 64] = stor10[address(arg3)][idx].field_512
                                mem[_29088 + 96] = stor10[address(arg3)][idx].field_768
                                mem[s] = _29088
                                s = s + 32
                                idx = idx + 1
                                continue 
                            if address(arg1) != address(arg3):
                                if mem[ceil32(ceil32(arg2.length)) + 225] <= 1:
                                    if mem[_22534] > 0:
                                        if _referrals[address(arg1)] != address(arg3):
                                            _referrals[address(arg1)] = address(arg3)
                                            sub_989baf69[address(arg3)].field_0++
                                            sub_989baf69[address(arg3)][sub_989baf69[address(arg3)].field_0].field_0 = address(arg1)
                                        if tokenAddress != msg.sender:
                                            if gateKeeperAddress != msg.sender:
                                                if address(stor0.field_0) != msg.sender:
                                                    revert with 0, 'NodeManagerV2: NOT AUTHORIZED'
                                        if stor10[stor11[address(arg1)]].field_0:
                                            if not -referralBonusPercent:
                                                sub_e27e434a[stor11[address(arg1)]][address(arg1)] = 0
                                                if sub_666755bb[stor11[address(arg1)]] > -1:
                                                    revert with 0, 17
                                            else:
                                                if referralBonusPercent and nodePrice > -1 / referralBonusPercent:
                                                    revert with 0, 17
                                                if not referralBonusPercent:
                                                    revert with 0, 18
                                                if referralBonusPercent * nodePrice / referralBonusPercent != nodePrice:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                sub_e27e434a[stor11[address(arg1)]][address(arg1)] = referralBonusPercent * nodePrice / 100
                                                if sub_666755bb[stor11[address(arg1)]] > !(referralBonusPercent * nodePrice / 100):
                                                    revert with 0, 17
                                                sub_666755bb[stor11[address(arg1)]] += referralBonusPercent * nodePrice / 100
                else:
                    stor10[address(arg1)][stor10[address(arg1)].field_0].field_0 = 0
                    idx = 0
                    while (uint255(stor10[address(arg1)][stor10[address(arg1)].field_0].field_0) * 0.5) + 31 / 32 > idx:
                        stor10[address(arg1)][(4 * stor10[address(arg1)].field_0) + idx].field_0 = 0
                        idx = idx + 1
                        continue 
                    stor10[address(arg1)][stor10[address(arg1)].field_0].field_256 = block.timestamp
                    stor10[address(arg1)][stor10[address(arg1)].field_0].field_512 = block.timestamp
                    stor10[address(arg1)][stor10[address(arg1)].field_0].field_768 = 0
                    mem[ceil32(ceil32(arg2.length)) + 229] = 6
                    mem[ceil32(ceil32(arg2.length)) + 261] = address(arg1)
                    mem[ceil32(ceil32(arg2.length)) + 293] = stor10[address(arg1)].field_0
                    require ext_code.size(0x4b7a346b17572634bdbd85b98abae32c5fa837bb)
                    delegate 0x4b7a346b17572634bdbd85b98abae32c5fa837bb.0xbc2b405c with:
                         gas gas_remaining wei
                        args 6, address(arg1), stor10[address(arg1)].field_0
                    if not delegate.return_code:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not totalNodesCreated + 1:
                        revert with 0, 17
                    totalNodesCreated++
                    if msg.sender == tokenAddress:
                        mem[0] = address(arg1)
                        mem[64] = ceil32(ceil32(arg2.length)) + (32 * stor10[address(arg1)].field_0) + 257
                        mem[ceil32(ceil32(arg2.length)) + 225] = stor10[address(arg1)].field_0
                        s = ceil32(ceil32(arg2.length)) + 257
                        idx = 0
                        while idx < stor10[address(arg1)].field_0:
                            mem[0] = sha3(address(arg1), 10)
                            _15286 = mem[64]
                            mem[64] = mem[64] + 128
                            if stor10[address(arg1)][idx].field_0:
                                if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                                    revert with 0, 34
                                _15571 = mem[64]
                                mem[64] = mem[64] + ceil32(uint255(stor10[address(arg1)][idx].field_0) * 0.5) + 32
                                mem[_15571] = uint255(stor10[address(arg1)][idx].field_0) * 0.5
                                if stor10[address(arg1)][idx].field_0:
                                    if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                                        revert with 0, 34
                                    if Mask(256, -1, stor10[address(arg1)][idx].field_0):
                                        if 31 >= uint255(stor10[address(arg1)][idx].field_0) * 0.5:
                                            mem[_15571 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                        else:
                                            mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                            mem[_15571 + 32] = stor10[address(arg1)][idx].field_0
                                            t = _15571 + 32
                                            u = sha3(mem[0])
                                            while _15571 + (uint255(stor10[address(arg1)][idx].field_0) * 0.5) > t:
                                                mem[t + 32] = uint256(stor1[u])
                                                t = t + 32
                                                u = u + 1
                                                continue 
                                    mem[_15286] = _15571
                                    mem[_15286 + 32] = stor10[address(arg1)][idx].field_256
                                    mem[_15286 + 64] = stor10[address(arg1)][idx].field_512
                                    mem[_15286 + 96] = stor10[address(arg1)][idx].field_768
                                    mem[s] = _15286
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                                    revert with 0, 34
                                if not stor10[address(arg1)][idx].field_1:
                                    mem[_15286] = _15571
                                    mem[_15286 + 32] = stor10[address(arg1)][idx].field_256
                                    mem[_15286 + 64] = stor10[address(arg1)][idx].field_512
                                    mem[_15286 + 96] = stor10[address(arg1)][idx].field_768
                                    mem[s] = _15286
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                if 31 >= stor10[address(arg1)][idx].field_1:
                                    mem[_15571 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                    mem[_15286] = _15571
                                    mem[_15286 + 32] = stor10[address(arg1)][idx].field_256
                                    mem[_15286 + 64] = stor10[address(arg1)][idx].field_512
                                    mem[_15286 + 96] = stor10[address(arg1)][idx].field_768
                                    mem[s] = _15286
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                mem[_15571 + 32] = stor10[address(arg1)][idx].field_0
                                t = _15571 + 32
                                u = sha3(mem[0])
                                while _15571 + stor10[address(arg1)][u].field_1 > t:
                                    mem[t + 32] = uint256(stor1[u])
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                mem[_15286] = _15571
                                mem[_15286 + 32] = stor10[address(arg1)][u].field_256
                                mem[_15286 + 64] = stor10[address(arg1)][u].field_512
                                mem[_15286 + 96] = stor10[address(arg1)][u].field_768
                                mem[t] = _15286
                                t = t + 32
                                u = u + 1
                                continue 
                            if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                                revert with 0, 34
                            _15668 = mem[64]
                            mem[64] = mem[64] + ceil32(stor10[address(arg1)][idx].field_1) + 32
                            mem[_15668] = stor10[address(arg1)][idx].field_1
                            if stor10[address(arg1)][idx].field_0:
                                if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                                    revert with 0, 34
                                if not Mask(256, -1, stor10[address(arg1)][idx].field_0):
                                    mem[_15286] = _15668
                                    mem[_15286 + 32] = stor10[address(arg1)][idx].field_256
                                    mem[_15286 + 64] = stor10[address(arg1)][idx].field_512
                                    mem[_15286 + 96] = stor10[address(arg1)][idx].field_768
                                    mem[s] = _15286
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                if 31 >= uint255(stor10[address(arg1)][idx].field_0) * 0.5:
                                    mem[_15668 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                    mem[_15286] = _15668
                                    mem[_15286 + 32] = stor10[address(arg1)][idx].field_256
                                    mem[_15286 + 64] = stor10[address(arg1)][idx].field_512
                                    mem[_15286 + 96] = stor10[address(arg1)][idx].field_768
                                    mem[s] = _15286
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                mem[_15668 + 32] = stor10[address(arg1)][idx].field_0
                                t = _15668 + 32
                                u = sha3(mem[0])
                                while _15668 + (uint255(stor10[address(arg1)][u].field_0) * 0.5) > t:
                                    mem[t + 32] = uint256(stor1[u])
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                mem[_15286] = _15668
                                mem[_15286 + 32] = stor10[address(arg1)][u].field_256
                                mem[_15286 + 64] = stor10[address(arg1)][u].field_512
                                mem[_15286 + 96] = stor10[address(arg1)][u].field_768
                                mem[t] = _15286
                                t = t + 32
                                u = u + 1
                                continue 
                            if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                                revert with 0, 34
                            if stor10[address(arg1)][idx].field_1:
                                if 31 >= stor10[address(arg1)][idx].field_1:
                                    mem[_15668 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                else:
                                    mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                    mem[_15668 + 32] = stor10[address(arg1)][idx].field_0
                                    t = _15668 + 32
                                    u = sha3(mem[0])
                                    while _15668 + stor10[address(arg1)][idx].field_1 > t:
                                        mem[t + 32] = uint256(stor1[u])
                                        t = t + 32
                                        u = u + 1
                                        continue 
                            mem[_15286] = _15668
                            mem[_15286 + 32] = stor10[address(arg1)][idx].field_256
                            mem[_15286 + 64] = stor10[address(arg1)][idx].field_512
                            mem[_15286 + 96] = stor10[address(arg1)][idx].field_768
                            mem[s] = _15286
                            s = s + 32
                            idx = idx + 1
                            continue 
                        mem[0] = address(arg3)
                        mem[32] = 10
                        _15284 = mem[64]
                        mem[64] = mem[64] + (32 * stor10[address(arg3)].field_0) + 32
                        mem[_15284] = stor10[address(arg3)].field_0
                        s = _15284 + 32
                        idx = 0
                        while idx < stor10[address(arg3)].field_0:
                            mem[0] = sha3(address(arg3), 10)
                            _22544 = mem[64]
                            mem[64] = mem[64] + 128
                            if stor10[address(arg3)][idx].field_0:
                                if not stor10[address(arg3)][idx].field_0 - (uint255(stor10[address(arg3)][idx].field_0) * 0.5 < 32):
                                    revert with 0, 34
                                _22798 = mem[64]
                                mem[64] = mem[64] + ceil32(uint255(stor10[address(arg3)][idx].field_0) * 0.5) + 32
                                mem[_22798] = uint255(stor10[address(arg3)][idx].field_0) * 0.5
                                if stor10[address(arg3)][idx].field_0:
                                    if not stor10[address(arg3)][idx].field_0 - (uint255(stor10[address(arg3)][idx].field_0) * 0.5 < 32):
                                        revert with 0, 34
                                    if Mask(256, -1, stor10[address(arg3)][idx].field_0):
                                        if 31 >= uint255(stor10[address(arg3)][idx].field_0) * 0.5:
                                            mem[_22798 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                        else:
                                            mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                            mem[_22798 + 32] = stor10[address(arg3)][idx].field_0
                                            t = _22798 + 32
                                            u = sha3(mem[0])
                                            while _22798 + (uint255(stor10[address(arg3)][idx].field_0) * 0.5) > t:
                                                mem[t + 32] = uint256(stor1[u])
                                                t = t + 32
                                                u = u + 1
                                                continue 
                                    mem[_22544] = _22798
                                    mem[_22544 + 32] = stor10[address(arg3)][idx].field_256
                                    mem[_22544 + 64] = stor10[address(arg3)][idx].field_512
                                    mem[_22544 + 96] = stor10[address(arg3)][idx].field_768
                                    mem[s] = _22544
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                if not stor10[address(arg3)][idx].field_0 - (stor10[address(arg3)][idx].field_1 < 32):
                                    revert with 0, 34
                                if not stor10[address(arg3)][idx].field_1:
                                    mem[_22544] = _22798
                                    mem[_22544 + 32] = stor10[address(arg3)][idx].field_256
                                    mem[_22544 + 64] = stor10[address(arg3)][idx].field_512
                                    mem[_22544 + 96] = stor10[address(arg3)][idx].field_768
                                    mem[s] = _22544
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                if 31 >= stor10[address(arg3)][idx].field_1:
                                    mem[_22798 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                    mem[_22544] = _22798
                                    mem[_22544 + 32] = stor10[address(arg3)][idx].field_256
                                    mem[_22544 + 64] = stor10[address(arg3)][idx].field_512
                                    mem[_22544 + 96] = stor10[address(arg3)][idx].field_768
                                    mem[s] = _22544
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                mem[_22798 + 32] = stor10[address(arg3)][idx].field_0
                                t = _22798 + 32
                                u = sha3(mem[0])
                                while _22798 + stor10[address(arg3)][u].field_1 > t:
                                    mem[t + 32] = uint256(stor1[u])
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                mem[_22544] = _22798
                                mem[_22544 + 32] = stor10[address(arg3)][u].field_256
                                mem[_22544 + 64] = stor10[address(arg3)][u].field_512
                                mem[_22544 + 96] = stor10[address(arg3)][u].field_768
                                mem[t] = _22544
                                t = t + 32
                                u = u + 1
                                continue 
                            if not stor10[address(arg3)][idx].field_0 - (stor10[address(arg3)][idx].field_1 < 32):
                                revert with 0, 34
                            _22928 = mem[64]
                            mem[64] = mem[64] + ceil32(stor10[address(arg3)][idx].field_1) + 32
                            mem[_22928] = stor10[address(arg3)][idx].field_1
                            if stor10[address(arg3)][idx].field_0:
                                if not stor10[address(arg3)][idx].field_0 - (uint255(stor10[address(arg3)][idx].field_0) * 0.5 < 32):
                                    revert with 0, 34
                                if not Mask(256, -1, stor10[address(arg3)][idx].field_0):
                                    mem[_22544] = _22928
                                    mem[_22544 + 32] = stor10[address(arg3)][idx].field_256
                                    mem[_22544 + 64] = stor10[address(arg3)][idx].field_512
                                    mem[_22544 + 96] = stor10[address(arg3)][idx].field_768
                                    mem[s] = _22544
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                if 31 >= uint255(stor10[address(arg3)][idx].field_0) * 0.5:
                                    mem[_22928 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                    mem[_22544] = _22928
                                    mem[_22544 + 32] = stor10[address(arg3)][idx].field_256
                                    mem[_22544 + 64] = stor10[address(arg3)][idx].field_512
                                    mem[_22544 + 96] = stor10[address(arg3)][idx].field_768
                                    mem[s] = _22544
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                mem[_22928 + 32] = stor10[address(arg3)][idx].field_0
                                t = _22928 + 32
                                u = sha3(mem[0])
                                while _22928 + (uint255(stor10[address(arg3)][u].field_0) * 0.5) > t:
                                    mem[t + 32] = uint256(stor1[u])
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                mem[_22544] = _22928
                                mem[_22544 + 32] = stor10[address(arg3)][u].field_256
                                mem[_22544 + 64] = stor10[address(arg3)][u].field_512
                                mem[_22544 + 96] = stor10[address(arg3)][u].field_768
                                mem[t] = _22544
                                t = t + 32
                                u = u + 1
                                continue 
                            if not stor10[address(arg3)][idx].field_0 - (stor10[address(arg3)][idx].field_1 < 32):
                                revert with 0, 34
                            if stor10[address(arg3)][idx].field_1:
                                if 31 >= stor10[address(arg3)][idx].field_1:
                                    mem[_22928 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                else:
                                    mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                    mem[_22928 + 32] = stor10[address(arg3)][idx].field_0
                                    t = _22928 + 32
                                    u = sha3(mem[0])
                                    while _22928 + stor10[address(arg3)][idx].field_1 > t:
                                        mem[t + 32] = uint256(stor1[u])
                                        t = t + 32
                                        u = u + 1
                                        continue 
                            mem[_22544] = _22928
                            mem[_22544 + 32] = stor10[address(arg3)][idx].field_256
                            mem[_22544 + 64] = stor10[address(arg3)][idx].field_512
                            mem[_22544 + 96] = stor10[address(arg3)][idx].field_768
                            mem[s] = _22544
                            s = s + 32
                            idx = idx + 1
                            continue 
                        if address(arg1) != address(arg3):
                            if mem[ceil32(ceil32(arg2.length)) + 225] <= 1:
                                if mem[_15284] > 0:
                                    if _referrals[address(arg1)] != address(arg3):
                                        _referrals[address(arg1)] = address(arg3)
                                        sub_989baf69[address(arg3)].field_0++
                                        sub_989baf69[address(arg3)][sub_989baf69[address(arg3)].field_0].field_0 = address(arg1)
                                    if tokenAddress != msg.sender:
                                        if gateKeeperAddress != msg.sender:
                                            if address(stor0.field_0) != msg.sender:
                                                revert with 0, 'NodeManagerV2: NOT AUTHORIZED'
                                    if stor10[stor11[address(arg1)]].field_0:
                                        if not -referralBonusPercent:
                                            sub_e27e434a[stor11[address(arg1)]][address(arg1)] = 0
                                            if sub_666755bb[stor11[address(arg1)]] > -1:
                                                revert with 0, 17
                                        else:
                                            if referralBonusPercent and nodePrice > -1 / referralBonusPercent:
                                                revert with 0, 17
                                            if not referralBonusPercent:
                                                revert with 0, 18
                                            if referralBonusPercent * nodePrice / referralBonusPercent != nodePrice:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            sub_e27e434a[stor11[address(arg1)]][address(arg1)] = referralBonusPercent * nodePrice / 100
                                            if sub_666755bb[stor11[address(arg1)]] > !(referralBonusPercent * nodePrice / 100):
                                                revert with 0, 17
                                            sub_666755bb[stor11[address(arg1)]] += referralBonusPercent * nodePrice / 100
                    else:
                        if msg.sender == gateKeeperAddress:
                            mem[0] = address(arg1)
                            mem[64] = ceil32(ceil32(arg2.length)) + (32 * stor10[address(arg1)].field_0) + 257
                            mem[ceil32(ceil32(arg2.length)) + 225] = stor10[address(arg1)].field_0
                            s = ceil32(ceil32(arg2.length)) + 257
                            idx = 0
                            while idx < stor10[address(arg1)].field_0:
                                mem[0] = sha3(address(arg1), 10)
                                _15290 = mem[64]
                                mem[64] = mem[64] + 128
                                if stor10[address(arg1)][idx].field_0:
                                    if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                                        revert with 0, 34
                                    _15572 = mem[64]
                                    mem[64] = mem[64] + ceil32(uint255(stor10[address(arg1)][idx].field_0) * 0.5) + 32
                                    mem[_15572] = uint255(stor10[address(arg1)][idx].field_0) * 0.5
                                    if stor10[address(arg1)][idx].field_0:
                                        if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                                            revert with 0, 34
                                        if Mask(256, -1, stor10[address(arg1)][idx].field_0):
                                            if 31 >= uint255(stor10[address(arg1)][idx].field_0) * 0.5:
                                                mem[_15572 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                            else:
                                                mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                                mem[_15572 + 32] = stor10[address(arg1)][idx].field_0
                                                t = _15572 + 32
                                                u = sha3(mem[0])
                                                while _15572 + (uint255(stor10[address(arg1)][idx].field_0) * 0.5) > t:
                                                    mem[t + 32] = uint256(stor1[u])
                                                    t = t + 32
                                                    u = u + 1
                                                    continue 
                                        mem[_15290] = _15572
                                        mem[_15290 + 32] = stor10[address(arg1)][idx].field_256
                                        mem[_15290 + 64] = stor10[address(arg1)][idx].field_512
                                        mem[_15290 + 96] = stor10[address(arg1)][idx].field_768
                                        mem[s] = _15290
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                                        revert with 0, 34
                                    if not stor10[address(arg1)][idx].field_1:
                                        mem[_15290] = _15572
                                        mem[_15290 + 32] = stor10[address(arg1)][idx].field_256
                                        mem[_15290 + 64] = stor10[address(arg1)][idx].field_512
                                        mem[_15290 + 96] = stor10[address(arg1)][idx].field_768
                                        mem[s] = _15290
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    if 31 >= stor10[address(arg1)][idx].field_1:
                                        mem[_15572 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                        mem[_15290] = _15572
                                        mem[_15290 + 32] = stor10[address(arg1)][idx].field_256
                                        mem[_15290 + 64] = stor10[address(arg1)][idx].field_512
                                        mem[_15290 + 96] = stor10[address(arg1)][idx].field_768
                                        mem[s] = _15290
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                    mem[_15572 + 32] = stor10[address(arg1)][idx].field_0
                                    t = _15572 + 32
                                    u = sha3(mem[0])
                                    while _15572 + stor10[address(arg1)][u].field_1 > t:
                                        mem[t + 32] = uint256(stor1[u])
                                        t = t + 32
                                        u = u + 1
                                        continue 
                                    mem[_15290] = _15572
                                    mem[_15290 + 32] = stor10[address(arg1)][u].field_256
                                    mem[_15290 + 64] = stor10[address(arg1)][u].field_512
                                    mem[_15290 + 96] = stor10[address(arg1)][u].field_768
                                    mem[t] = _15290
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                                    revert with 0, 34
                                _15670 = mem[64]
                                mem[64] = mem[64] + ceil32(stor10[address(arg1)][idx].field_1) + 32
                                mem[_15670] = stor10[address(arg1)][idx].field_1
                                if stor10[address(arg1)][idx].field_0:
                                    if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                                        revert with 0, 34
                                    if not Mask(256, -1, stor10[address(arg1)][idx].field_0):
                                        mem[_15290] = _15670
                                        mem[_15290 + 32] = stor10[address(arg1)][idx].field_256
                                        mem[_15290 + 64] = stor10[address(arg1)][idx].field_512
                                        mem[_15290 + 96] = stor10[address(arg1)][idx].field_768
                                        mem[s] = _15290
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    if 31 >= uint255(stor10[address(arg1)][idx].field_0) * 0.5:
                                        mem[_15670 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                        mem[_15290] = _15670
                                        mem[_15290 + 32] = stor10[address(arg1)][idx].field_256
                                        mem[_15290 + 64] = stor10[address(arg1)][idx].field_512
                                        mem[_15290 + 96] = stor10[address(arg1)][idx].field_768
                                        mem[s] = _15290
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                    mem[_15670 + 32] = stor10[address(arg1)][idx].field_0
                                    t = _15670 + 32
                                    u = sha3(mem[0])
                                    while _15670 + (uint255(stor10[address(arg1)][u].field_0) * 0.5) > t:
                                        mem[t + 32] = uint256(stor1[u])
                                        t = t + 32
                                        u = u + 1
                                        continue 
                                    mem[_15290] = _15670
                                    mem[_15290 + 32] = stor10[address(arg1)][u].field_256
                                    mem[_15290 + 64] = stor10[address(arg1)][u].field_512
                                    mem[_15290 + 96] = stor10[address(arg1)][u].field_768
                                    mem[t] = _15290
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                                    revert with 0, 34
                                if stor10[address(arg1)][idx].field_1:
                                    if 31 >= stor10[address(arg1)][idx].field_1:
                                        mem[_15670 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                    else:
                                        mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                        mem[_15670 + 32] = stor10[address(arg1)][idx].field_0
                                        t = _15670 + 32
                                        u = sha3(mem[0])
                                        while _15670 + stor10[address(arg1)][idx].field_1 > t:
                                            mem[t + 32] = uint256(stor1[u])
                                            t = t + 32
                                            u = u + 1
                                            continue 
                                mem[_15290] = _15670
                                mem[_15290 + 32] = stor10[address(arg1)][idx].field_256
                                mem[_15290 + 64] = stor10[address(arg1)][idx].field_512
                                mem[_15290 + 96] = stor10[address(arg1)][idx].field_768
                                mem[s] = _15290
                                s = s + 32
                                idx = idx + 1
                                continue 
                            mem[0] = address(arg3)
                            mem[32] = 10
                            _15288 = mem[64]
                            mem[64] = mem[64] + (32 * stor10[address(arg3)].field_0) + 32
                            mem[_15288] = stor10[address(arg3)].field_0
                            s = _15288 + 32
                            idx = 0
                            while idx < stor10[address(arg3)].field_0:
                                mem[0] = sha3(address(arg3), 10)
                                _22546 = mem[64]
                                mem[64] = mem[64] + 128
                                if stor10[address(arg3)][idx].field_0:
                                    if not stor10[address(arg3)][idx].field_0 - (uint255(stor10[address(arg3)][idx].field_0) * 0.5 < 32):
                                        revert with 0, 34
                                    _22799 = mem[64]
                                    mem[64] = mem[64] + ceil32(uint255(stor10[address(arg3)][idx].field_0) * 0.5) + 32
                                    mem[_22799] = uint255(stor10[address(arg3)][idx].field_0) * 0.5
                                    if stor10[address(arg3)][idx].field_0:
                                        if not stor10[address(arg3)][idx].field_0 - (uint255(stor10[address(arg3)][idx].field_0) * 0.5 < 32):
                                            revert with 0, 34
                                        if Mask(256, -1, stor10[address(arg3)][idx].field_0):
                                            if 31 >= uint255(stor10[address(arg3)][idx].field_0) * 0.5:
                                                mem[_22799 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                            else:
                                                mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                                mem[_22799 + 32] = stor10[address(arg3)][idx].field_0
                                                t = _22799 + 32
                                                u = sha3(mem[0])
                                                while _22799 + (uint255(stor10[address(arg3)][idx].field_0) * 0.5) > t:
                                                    mem[t + 32] = uint256(stor1[u])
                                                    t = t + 32
                                                    u = u + 1
                                                    continue 
                                        mem[_22546] = _22799
                                        mem[_22546 + 32] = stor10[address(arg3)][idx].field_256
                                        mem[_22546 + 64] = stor10[address(arg3)][idx].field_512
                                        mem[_22546 + 96] = stor10[address(arg3)][idx].field_768
                                        mem[s] = _22546
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    if not stor10[address(arg3)][idx].field_0 - (stor10[address(arg3)][idx].field_1 < 32):
                                        revert with 0, 34
                                    if not stor10[address(arg3)][idx].field_1:
                                        mem[_22546] = _22799
                                        mem[_22546 + 32] = stor10[address(arg3)][idx].field_256
                                        mem[_22546 + 64] = stor10[address(arg3)][idx].field_512
                                        mem[_22546 + 96] = stor10[address(arg3)][idx].field_768
                                        mem[s] = _22546
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    if 31 >= stor10[address(arg3)][idx].field_1:
                                        mem[_22799 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                        mem[_22546] = _22799
                                        mem[_22546 + 32] = stor10[address(arg3)][idx].field_256
                                        mem[_22546 + 64] = stor10[address(arg3)][idx].field_512
                                        mem[_22546 + 96] = stor10[address(arg3)][idx].field_768
                                        mem[s] = _22546
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                    mem[_22799 + 32] = stor10[address(arg3)][idx].field_0
                                    t = _22799 + 32
                                    u = sha3(mem[0])
                                    while _22799 + stor10[address(arg3)][u].field_1 > t:
                                        mem[t + 32] = uint256(stor1[u])
                                        t = t + 32
                                        u = u + 1
                                        continue 
                                    mem[_22546] = _22799
                                    mem[_22546 + 32] = stor10[address(arg3)][u].field_256
                                    mem[_22546 + 64] = stor10[address(arg3)][u].field_512
                                    mem[_22546 + 96] = stor10[address(arg3)][u].field_768
                                    mem[t] = _22546
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                if not stor10[address(arg3)][idx].field_0 - (stor10[address(arg3)][idx].field_1 < 32):
                                    revert with 0, 34
                                _22930 = mem[64]
                                mem[64] = mem[64] + ceil32(stor10[address(arg3)][idx].field_1) + 32
                                mem[_22930] = stor10[address(arg3)][idx].field_1
                                if stor10[address(arg3)][idx].field_0:
                                    if not stor10[address(arg3)][idx].field_0 - (uint255(stor10[address(arg3)][idx].field_0) * 0.5 < 32):
                                        revert with 0, 34
                                    if not Mask(256, -1, stor10[address(arg3)][idx].field_0):
                                        mem[_22546] = _22930
                                        mem[_22546 + 32] = stor10[address(arg3)][idx].field_256
                                        mem[_22546 + 64] = stor10[address(arg3)][idx].field_512
                                        mem[_22546 + 96] = stor10[address(arg3)][idx].field_768
                                        mem[s] = _22546
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    if 31 >= uint255(stor10[address(arg3)][idx].field_0) * 0.5:
                                        mem[_22930 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                        mem[_22546] = _22930
                                        mem[_22546 + 32] = stor10[address(arg3)][idx].field_256
                                        mem[_22546 + 64] = stor10[address(arg3)][idx].field_512
                                        mem[_22546 + 96] = stor10[address(arg3)][idx].field_768
                                        mem[s] = _22546
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                    mem[_22930 + 32] = stor10[address(arg3)][idx].field_0
                                    t = _22930 + 32
                                    u = sha3(mem[0])
                                    while _22930 + (uint255(stor10[address(arg3)][u].field_0) * 0.5) > t:
                                        mem[t + 32] = uint256(stor1[u])
                                        t = t + 32
                                        u = u + 1
                                        continue 
                                    mem[_22546] = _22930
                                    mem[_22546 + 32] = stor10[address(arg3)][u].field_256
                                    mem[_22546 + 64] = stor10[address(arg3)][u].field_512
                                    mem[_22546 + 96] = stor10[address(arg3)][u].field_768
                                    mem[t] = _22546
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                if not stor10[address(arg3)][idx].field_0 - (stor10[address(arg3)][idx].field_1 < 32):
                                    revert with 0, 34
                                if stor10[address(arg3)][idx].field_1:
                                    if 31 >= stor10[address(arg3)][idx].field_1:
                                        mem[_22930 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                    else:
                                        mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                        mem[_22930 + 32] = stor10[address(arg3)][idx].field_0
                                        t = _22930 + 32
                                        u = sha3(mem[0])
                                        while _22930 + stor10[address(arg3)][idx].field_1 > t:
                                            mem[t + 32] = uint256(stor1[u])
                                            t = t + 32
                                            u = u + 1
                                            continue 
                                mem[_22546] = _22930
                                mem[_22546 + 32] = stor10[address(arg3)][idx].field_256
                                mem[_22546 + 64] = stor10[address(arg3)][idx].field_512
                                mem[_22546 + 96] = stor10[address(arg3)][idx].field_768
                                mem[s] = _22546
                                s = s + 32
                                idx = idx + 1
                                continue 
                            if address(arg1) != address(arg3):
                                if mem[ceil32(ceil32(arg2.length)) + 225] <= 1:
                                    if mem[_15288] > 0:
                                        if _referrals[address(arg1)] != address(arg3):
                                            _referrals[address(arg1)] = address(arg3)
                                            sub_989baf69[address(arg3)].field_0++
                                            sub_989baf69[address(arg3)][sub_989baf69[address(arg3)].field_0].field_0 = address(arg1)
                                        if tokenAddress != msg.sender:
                                            if gateKeeperAddress != msg.sender:
                                                if address(stor0.field_0) != msg.sender:
                                                    revert with 0, 'NodeManagerV2: NOT AUTHORIZED'
                                        if stor10[stor11[address(arg1)]].field_0:
                                            if not -referralBonusPercent:
                                                sub_e27e434a[stor11[address(arg1)]][address(arg1)] = 0
                                                if sub_666755bb[stor11[address(arg1)]] > -1:
                                                    revert with 0, 17
                                            else:
                                                if referralBonusPercent and nodePrice > -1 / referralBonusPercent:
                                                    revert with 0, 17
                                                if not referralBonusPercent:
                                                    revert with 0, 18
                                                if referralBonusPercent * nodePrice / referralBonusPercent != nodePrice:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                sub_e27e434a[stor11[address(arg1)]][address(arg1)] = referralBonusPercent * nodePrice / 100
                                                if sub_666755bb[stor11[address(arg1)]] > !(referralBonusPercent * nodePrice / 100):
                                                    revert with 0, 17
                                                sub_666755bb[stor11[address(arg1)]] += referralBonusPercent * nodePrice / 100
                        else:
                            if address(stor0.field_0) != msg.sender:
                                revert with 0, 'NodeManagerV2: NOT AUTHORIZED'
                            mem[0] = address(arg1)
                            mem[64] = ceil32(ceil32(arg2.length)) + (32 * stor10[address(arg1)].field_0) + 257
                            mem[ceil32(ceil32(arg2.length)) + 225] = stor10[address(arg1)].field_0
                            s = ceil32(ceil32(arg2.length)) + 257
                            idx = 0
                            while idx < stor10[address(arg1)].field_0:
                                mem[0] = sha3(address(arg1), 10)
                                _15294 = mem[64]
                                mem[64] = mem[64] + 128
                                if stor10[address(arg1)][idx].field_0:
                                    if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                                        revert with 0, 34
                                    _15573 = mem[64]
                                    mem[64] = mem[64] + ceil32(uint255(stor10[address(arg1)][idx].field_0) * 0.5) + 32
                                    mem[_15573] = uint255(stor10[address(arg1)][idx].field_0) * 0.5
                                    if stor10[address(arg1)][idx].field_0:
                                        if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                                            revert with 0, 34
                                        if Mask(256, -1, stor10[address(arg1)][idx].field_0):
                                            if 31 >= uint255(stor10[address(arg1)][idx].field_0) * 0.5:
                                                mem[_15573 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                            else:
                                                mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                                mem[_15573 + 32] = stor10[address(arg1)][idx].field_0
                                                t = _15573 + 32
                                                u = sha3(mem[0])
                                                while _15573 + (uint255(stor10[address(arg1)][idx].field_0) * 0.5) > t:
                                                    mem[t + 32] = uint256(stor1[u])
                                                    t = t + 32
                                                    u = u + 1
                                                    continue 
                                        mem[_15294] = _15573
                                        mem[_15294 + 32] = stor10[address(arg1)][idx].field_256
                                        mem[_15294 + 64] = stor10[address(arg1)][idx].field_512
                                        mem[_15294 + 96] = stor10[address(arg1)][idx].field_768
                                        mem[s] = _15294
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                                        revert with 0, 34
                                    if not stor10[address(arg1)][idx].field_1:
                                        mem[_15294] = _15573
                                        mem[_15294 + 32] = stor10[address(arg1)][idx].field_256
                                        mem[_15294 + 64] = stor10[address(arg1)][idx].field_512
                                        mem[_15294 + 96] = stor10[address(arg1)][idx].field_768
                                        mem[s] = _15294
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    if 31 >= stor10[address(arg1)][idx].field_1:
                                        mem[_15573 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                        mem[_15294] = _15573
                                        mem[_15294 + 32] = stor10[address(arg1)][idx].field_256
                                        mem[_15294 + 64] = stor10[address(arg1)][idx].field_512
                                        mem[_15294 + 96] = stor10[address(arg1)][idx].field_768
                                        mem[s] = _15294
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                    mem[_15573 + 32] = stor10[address(arg1)][idx].field_0
                                    t = _15573 + 32
                                    u = sha3(mem[0])
                                    while _15573 + stor10[address(arg1)][u].field_1 > t:
                                        mem[t + 32] = uint256(stor1[u])
                                        t = t + 32
                                        u = u + 1
                                        continue 
                                    mem[_15294] = _15573
                                    mem[_15294 + 32] = stor10[address(arg1)][u].field_256
                                    mem[_15294 + 64] = stor10[address(arg1)][u].field_512
                                    mem[_15294 + 96] = stor10[address(arg1)][u].field_768
                                    mem[t] = _15294
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                                    revert with 0, 34
                                _15672 = mem[64]
                                mem[64] = mem[64] + ceil32(stor10[address(arg1)][idx].field_1) + 32
                                mem[_15672] = stor10[address(arg1)][idx].field_1
                                if stor10[address(arg1)][idx].field_0:
                                    if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                                        revert with 0, 34
                                    if not Mask(256, -1, stor10[address(arg1)][idx].field_0):
                                        mem[_15294] = _15672
                                        mem[_15294 + 32] = stor10[address(arg1)][idx].field_256
                                        mem[_15294 + 64] = stor10[address(arg1)][idx].field_512
                                        mem[_15294 + 96] = stor10[address(arg1)][idx].field_768
                                        mem[s] = _15294
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    if 31 >= uint255(stor10[address(arg1)][idx].field_0) * 0.5:
                                        mem[_15672 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                        mem[_15294] = _15672
                                        mem[_15294 + 32] = stor10[address(arg1)][idx].field_256
                                        mem[_15294 + 64] = stor10[address(arg1)][idx].field_512
                                        mem[_15294 + 96] = stor10[address(arg1)][idx].field_768
                                        mem[s] = _15294
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                    mem[_15672 + 32] = stor10[address(arg1)][idx].field_0
                                    t = _15672 + 32
                                    u = sha3(mem[0])
                                    while _15672 + (uint255(stor10[address(arg1)][u].field_0) * 0.5) > t:
                                        mem[t + 32] = uint256(stor1[u])
                                        t = t + 32
                                        u = u + 1
                                        continue 
                                    mem[_15294] = _15672
                                    mem[_15294 + 32] = stor10[address(arg1)][u].field_256
                                    mem[_15294 + 64] = stor10[address(arg1)][u].field_512
                                    mem[_15294 + 96] = stor10[address(arg1)][u].field_768
                                    mem[t] = _15294
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                                    revert with 0, 34
                                if stor10[address(arg1)][idx].field_1:
                                    if 31 >= stor10[address(arg1)][idx].field_1:
                                        mem[_15672 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                    else:
                                        mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                        mem[_15672 + 32] = stor10[address(arg1)][idx].field_0
                                        t = _15672 + 32
                                        u = sha3(mem[0])
                                        while _15672 + stor10[address(arg1)][idx].field_1 > t:
                                            mem[t + 32] = uint256(stor1[u])
                                            t = t + 32
                                            u = u + 1
                                            continue 
                                mem[_15294] = _15672
                                mem[_15294 + 32] = stor10[address(arg1)][idx].field_256
                                mem[_15294 + 64] = stor10[address(arg1)][idx].field_512
                                mem[_15294 + 96] = stor10[address(arg1)][idx].field_768
                                mem[s] = _15294
                                s = s + 32
                                idx = idx + 1
                                continue 
                            mem[0] = address(arg3)
                            mem[32] = 10
                            _15292 = mem[64]
                            mem[64] = mem[64] + (32 * stor10[address(arg3)].field_0) + 32
                            mem[_15292] = stor10[address(arg3)].field_0
                            s = _15292 + 32
                            idx = 0
                            while idx < stor10[address(arg3)].field_0:
                                mem[0] = sha3(address(arg3), 10)
                                _22548 = mem[64]
                                mem[64] = mem[64] + 128
                                if stor10[address(arg3)][idx].field_0:
                                    if not stor10[address(arg3)][idx].field_0 - (uint255(stor10[address(arg3)][idx].field_0) * 0.5 < 32):
                                        revert with 0, 34
                                    _22800 = mem[64]
                                    mem[64] = mem[64] + ceil32(uint255(stor10[address(arg3)][idx].field_0) * 0.5) + 32
                                    mem[_22800] = uint255(stor10[address(arg3)][idx].field_0) * 0.5
                                    if stor10[address(arg3)][idx].field_0:
                                        if not stor10[address(arg3)][idx].field_0 - (uint255(stor10[address(arg3)][idx].field_0) * 0.5 < 32):
                                            revert with 0, 34
                                        if Mask(256, -1, stor10[address(arg3)][idx].field_0):
                                            if 31 >= uint255(stor10[address(arg3)][idx].field_0) * 0.5:
                                                mem[_22800 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                            else:
                                                mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                                mem[_22800 + 32] = stor10[address(arg3)][idx].field_0
                                                t = _22800 + 32
                                                u = sha3(mem[0])
                                                while _22800 + (uint255(stor10[address(arg3)][idx].field_0) * 0.5) > t:
                                                    mem[t + 32] = uint256(stor1[u])
                                                    t = t + 32
                                                    u = u + 1
                                                    continue 
                                        mem[_22548] = _22800
                                        mem[_22548 + 32] = stor10[address(arg3)][idx].field_256
                                        mem[_22548 + 64] = stor10[address(arg3)][idx].field_512
                                        mem[_22548 + 96] = stor10[address(arg3)][idx].field_768
                                        mem[s] = _22548
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    if not stor10[address(arg3)][idx].field_0 - (stor10[address(arg3)][idx].field_1 < 32):
                                        revert with 0, 34
                                    if not stor10[address(arg3)][idx].field_1:
                                        mem[_22548] = _22800
                                        mem[_22548 + 32] = stor10[address(arg3)][idx].field_256
                                        mem[_22548 + 64] = stor10[address(arg3)][idx].field_512
                                        mem[_22548 + 96] = stor10[address(arg3)][idx].field_768
                                        mem[s] = _22548
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    if 31 >= stor10[address(arg3)][idx].field_1:
                                        mem[_22800 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                        mem[_22548] = _22800
                                        mem[_22548 + 32] = stor10[address(arg3)][idx].field_256
                                        mem[_22548 + 64] = stor10[address(arg3)][idx].field_512
                                        mem[_22548 + 96] = stor10[address(arg3)][idx].field_768
                                        mem[s] = _22548
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                    mem[_22800 + 32] = stor10[address(arg3)][idx].field_0
                                    t = _22800 + 32
                                    u = sha3(mem[0])
                                    while _22800 + stor10[address(arg3)][u].field_1 > t:
                                        mem[t + 32] = uint256(stor1[u])
                                        t = t + 32
                                        u = u + 1
                                        continue 
                                    mem[_22548] = _22800
                                    mem[_22548 + 32] = stor10[address(arg3)][u].field_256
                                    mem[_22548 + 64] = stor10[address(arg3)][u].field_512
                                    mem[_22548 + 96] = stor10[address(arg3)][u].field_768
                                    mem[t] = _22548
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                if not stor10[address(arg3)][idx].field_0 - (stor10[address(arg3)][idx].field_1 < 32):
                                    revert with 0, 34
                                _22932 = mem[64]
                                mem[64] = mem[64] + ceil32(stor10[address(arg3)][idx].field_1) + 32
                                mem[_22932] = stor10[address(arg3)][idx].field_1
                                if stor10[address(arg3)][idx].field_0:
                                    if not stor10[address(arg3)][idx].field_0 - (uint255(stor10[address(arg3)][idx].field_0) * 0.5 < 32):
                                        revert with 0, 34
                                    if not Mask(256, -1, stor10[address(arg3)][idx].field_0):
                                        mem[_22548] = _22932
                                        mem[_22548 + 32] = stor10[address(arg3)][idx].field_256
                                        mem[_22548 + 64] = stor10[address(arg3)][idx].field_512
                                        mem[_22548 + 96] = stor10[address(arg3)][idx].field_768
                                        mem[s] = _22548
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    if 31 >= uint255(stor10[address(arg3)][idx].field_0) * 0.5:
                                        mem[_22932 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                        mem[_22548] = _22932
                                        mem[_22548 + 32] = stor10[address(arg3)][idx].field_256
                                        mem[_22548 + 64] = stor10[address(arg3)][idx].field_512
                                        mem[_22548 + 96] = stor10[address(arg3)][idx].field_768
                                        mem[s] = _22548
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                    mem[_22932 + 32] = stor10[address(arg3)][idx].field_0
                                    t = _22932 + 32
                                    u = sha3(mem[0])
                                    while _22932 + (uint255(stor10[address(arg3)][u].field_0) * 0.5) > t:
                                        mem[t + 32] = uint256(stor1[u])
                                        t = t + 32
                                        u = u + 1
                                        continue 
                                    mem[_22548] = _22932
                                    mem[_22548 + 32] = stor10[address(arg3)][u].field_256
                                    mem[_22548 + 64] = stor10[address(arg3)][u].field_512
                                    mem[_22548 + 96] = stor10[address(arg3)][u].field_768
                                    mem[t] = _22548
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                if not stor10[address(arg3)][idx].field_0 - (stor10[address(arg3)][idx].field_1 < 32):
                                    revert with 0, 34
                                if stor10[address(arg3)][idx].field_1:
                                    if 31 >= stor10[address(arg3)][idx].field_1:
                                        mem[_22932 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                    else:
                                        mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                        mem[_22932 + 32] = stor10[address(arg3)][idx].field_0
                                        t = _22932 + 32
                                        u = sha3(mem[0])
                                        while _22932 + stor10[address(arg3)][idx].field_1 > t:
                                            mem[t + 32] = uint256(stor1[u])
                                            t = t + 32
                                            u = u + 1
                                            continue 
                                mem[_22548] = _22932
                                mem[_22548 + 32] = stor10[address(arg3)][idx].field_256
                                mem[_22548 + 64] = stor10[address(arg3)][idx].field_512
                                mem[_22548 + 96] = stor10[address(arg3)][idx].field_768
                                mem[s] = _22548
                                s = s + 32
                                idx = idx + 1
                                continue 
                            if address(arg1) != address(arg3):
                                if mem[ceil32(ceil32(arg2.length)) + 225] <= 1:
                                    if mem[_15292] > 0:
                                        if _referrals[address(arg1)] != address(arg3):
                                            _referrals[address(arg1)] = address(arg3)
                                            sub_989baf69[address(arg3)].field_0++
                                            sub_989baf69[address(arg3)][sub_989baf69[address(arg3)].field_0].field_0 = address(arg1)
                                        if tokenAddress != msg.sender:
                                            if gateKeeperAddress != msg.sender:
                                                if address(stor0.field_0) != msg.sender:
                                                    revert with 0, 'NodeManagerV2: NOT AUTHORIZED'
                                        if stor10[stor11[address(arg1)]].field_0:
                                            if not -referralBonusPercent:
                                                sub_e27e434a[stor11[address(arg1)]][address(arg1)] = 0
                                                if sub_666755bb[stor11[address(arg1)]] > -1:
                                                    revert with 0, 17
                                            else:
                                                if referralBonusPercent and nodePrice > -1 / referralBonusPercent:
                                                    revert with 0, 17
                                                if not referralBonusPercent:
                                                    revert with 0, 18
                                                if referralBonusPercent * nodePrice / referralBonusPercent != nodePrice:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                sub_e27e434a[stor11[address(arg1)]][address(arg1)] = referralBonusPercent * nodePrice / 100
                                                if sub_666755bb[stor11[address(arg1)]] > !(referralBonusPercent * nodePrice / 100):
                                                    revert with 0, 17
                                                sub_666755bb[stor11[address(arg1)]] += referralBonusPercent * nodePrice / 100
            else:
                if not stor10[address(arg1)][stor10[address(arg1)].field_0].field_0 - (stor10[address(arg1)][stor10[address(arg1)].field_0].field_1 < 32):
                    revert with 0, 34
                if arg2.length:
                    stor10[address(arg1)][stor10[address(arg1)].field_0][].field_0 = Array(len=arg2.length, data=arg2[all])
                    stor10[address(arg1)][stor10[address(arg1)].field_0].field_256 = block.timestamp
                    stor10[address(arg1)][stor10[address(arg1)].field_0].field_512 = block.timestamp
                    stor10[address(arg1)][stor10[address(arg1)].field_0].field_768 = 0
                    mem[ceil32(ceil32(arg2.length)) + 229] = 6
                    mem[ceil32(ceil32(arg2.length)) + 261] = address(arg1)
                    mem[ceil32(ceil32(arg2.length)) + 293] = stor10[address(arg1)].field_0
                    require ext_code.size(0x4b7a346b17572634bdbd85b98abae32c5fa837bb)
                    delegate 0x4b7a346b17572634bdbd85b98abae32c5fa837bb.0xbc2b405c with:
                         gas gas_remaining wei
                        args 6, address(arg1), stor10[address(arg1)].field_0
                    if not delegate.return_code:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not totalNodesCreated + 1:
                        revert with 0, 17
                    totalNodesCreated++
                    if msg.sender == tokenAddress:
                        mem[0] = address(arg1)
                        mem[64] = ceil32(ceil32(arg2.length)) + (32 * stor10[address(arg1)].field_0) + 257
                        mem[ceil32(ceil32(arg2.length)) + 225] = stor10[address(arg1)].field_0
                        s = ceil32(ceil32(arg2.length)) + 257
                        idx = 0
                        while idx < stor10[address(arg1)].field_0:
                            mem[0] = sha3(address(arg1), 10)
                            _22558 = mem[64]
                            mem[64] = mem[64] + 128
                            if stor10[address(arg1)][idx].field_0:
                                if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                                    revert with 0, 34
                                _22804 = mem[64]
                                mem[64] = mem[64] + ceil32(uint255(stor10[address(arg1)][idx].field_0) * 0.5) + 32
                                mem[_22804] = uint255(stor10[address(arg1)][idx].field_0) * 0.5
                                if stor10[address(arg1)][idx].field_0:
                                    if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                                        revert with 0, 34
                                    if Mask(256, -1, stor10[address(arg1)][idx].field_0):
                                        if 31 >= uint255(stor10[address(arg1)][idx].field_0) * 0.5:
                                            mem[_22804 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                        else:
                                            mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                            mem[_22804 + 32] = stor10[address(arg1)][idx].field_0
                                            t = _22804 + 32
                                            u = sha3(mem[0])
                                            while _22804 + (uint255(stor10[address(arg1)][idx].field_0) * 0.5) > t:
                                                mem[t + 32] = uint256(stor1[u])
                                                t = t + 32
                                                u = u + 1
                                                continue 
                                    mem[_22558] = _22804
                                    mem[_22558 + 32] = stor10[address(arg1)][idx].field_256
                                    mem[_22558 + 64] = stor10[address(arg1)][idx].field_512
                                    mem[_22558 + 96] = stor10[address(arg1)][idx].field_768
                                    mem[s] = _22558
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                                    revert with 0, 34
                                if not stor10[address(arg1)][idx].field_1:
                                    mem[_22558] = _22804
                                    mem[_22558 + 32] = stor10[address(arg1)][idx].field_256
                                    mem[_22558 + 64] = stor10[address(arg1)][idx].field_512
                                    mem[_22558 + 96] = stor10[address(arg1)][idx].field_768
                                    mem[s] = _22558
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                if 31 >= stor10[address(arg1)][idx].field_1:
                                    mem[_22804 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                    mem[_22558] = _22804
                                    mem[_22558 + 32] = stor10[address(arg1)][idx].field_256
                                    mem[_22558 + 64] = stor10[address(arg1)][idx].field_512
                                    mem[_22558 + 96] = stor10[address(arg1)][idx].field_768
                                    mem[s] = _22558
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                mem[_22804 + 32] = stor10[address(arg1)][idx].field_0
                                t = _22804 + 32
                                u = sha3(mem[0])
                                while _22804 + stor10[address(arg1)][u].field_1 > t:
                                    mem[t + 32] = uint256(stor1[u])
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                mem[_22558] = _22804
                                mem[_22558 + 32] = stor10[address(arg1)][u].field_256
                                mem[_22558 + 64] = stor10[address(arg1)][u].field_512
                                mem[_22558 + 96] = stor10[address(arg1)][u].field_768
                                mem[t] = _22558
                                t = t + 32
                                u = u + 1
                                continue 
                            if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                                revert with 0, 34
                            _22940 = mem[64]
                            mem[64] = mem[64] + ceil32(stor10[address(arg1)][idx].field_1) + 32
                            mem[_22940] = stor10[address(arg1)][idx].field_1
                            if stor10[address(arg1)][idx].field_0:
                                if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                                    revert with 0, 34
                                if not Mask(256, -1, stor10[address(arg1)][idx].field_0):
                                    mem[_22558] = _22940
                                    mem[_22558 + 32] = stor10[address(arg1)][idx].field_256
                                    mem[_22558 + 64] = stor10[address(arg1)][idx].field_512
                                    mem[_22558 + 96] = stor10[address(arg1)][idx].field_768
                                    mem[s] = _22558
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                if 31 >= uint255(stor10[address(arg1)][idx].field_0) * 0.5:
                                    mem[_22940 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                    mem[_22558] = _22940
                                    mem[_22558 + 32] = stor10[address(arg1)][idx].field_256
                                    mem[_22558 + 64] = stor10[address(arg1)][idx].field_512
                                    mem[_22558 + 96] = stor10[address(arg1)][idx].field_768
                                    mem[s] = _22558
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                mem[_22940 + 32] = stor10[address(arg1)][idx].field_0
                                t = _22940 + 32
                                u = sha3(mem[0])
                                while _22940 + (uint255(stor10[address(arg1)][u].field_0) * 0.5) > t:
                                    mem[t + 32] = uint256(stor1[u])
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                mem[_22558] = _22940
                                mem[_22558 + 32] = stor10[address(arg1)][u].field_256
                                mem[_22558 + 64] = stor10[address(arg1)][u].field_512
                                mem[_22558 + 96] = stor10[address(arg1)][u].field_768
                                mem[t] = _22558
                                t = t + 32
                                u = u + 1
                                continue 
                            if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                                revert with 0, 34
                            if stor10[address(arg1)][idx].field_1:
                                if 31 >= stor10[address(arg1)][idx].field_1:
                                    mem[_22940 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                else:
                                    mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                    mem[_22940 + 32] = stor10[address(arg1)][idx].field_0
                                    t = _22940 + 32
                                    u = sha3(mem[0])
                                    while _22940 + stor10[address(arg1)][idx].field_1 > t:
                                        mem[t + 32] = uint256(stor1[u])
                                        t = t + 32
                                        u = u + 1
                                        continue 
                            mem[_22558] = _22940
                            mem[_22558 + 32] = stor10[address(arg1)][idx].field_256
                            mem[_22558 + 64] = stor10[address(arg1)][idx].field_512
                            mem[_22558 + 96] = stor10[address(arg1)][idx].field_768
                            mem[s] = _22558
                            s = s + 32
                            idx = idx + 1
                            continue 
                        mem[0] = address(arg3)
                        mem[32] = 10
                        _22556 = mem[64]
                        mem[64] = mem[64] + (32 * stor10[address(arg3)].field_0) + 32
                        mem[_22556] = stor10[address(arg3)].field_0
                        s = _22556 + 32
                        idx = 0
                        while idx < stor10[address(arg3)].field_0:
                            mem[0] = sha3(address(arg3), 10)
                            _29090 = mem[64]
                            mem[64] = mem[64] + 128
                            if stor10[address(arg3)][idx].field_0:
                                if not stor10[address(arg3)][idx].field_0 - (uint255(stor10[address(arg3)][idx].field_0) * 0.5 < 32):
                                    revert with 0, 34
                                _29146 = mem[64]
                                mem[64] = mem[64] + ceil32(uint255(stor10[address(arg3)][idx].field_0) * 0.5) + 32
                                mem[_29146] = uint255(stor10[address(arg3)][idx].field_0) * 0.5
                                if stor10[address(arg3)][idx].field_0:
                                    if not stor10[address(arg3)][idx].field_0 - (uint255(stor10[address(arg3)][idx].field_0) * 0.5 < 32):
                                        revert with 0, 34
                                    if Mask(256, -1, stor10[address(arg3)][idx].field_0):
                                        if 31 >= uint255(stor10[address(arg3)][idx].field_0) * 0.5:
                                            mem[_29146 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                        else:
                                            mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                            mem[_29146 + 32] = stor10[address(arg3)][idx].field_0
                                            t = _29146 + 32
                                            u = sha3(mem[0])
                                            while _29146 + (uint255(stor10[address(arg3)][idx].field_0) * 0.5) > t:
                                                mem[t + 32] = uint256(stor1[u])
                                                t = t + 32
                                                u = u + 1
                                                continue 
                                    mem[_29090] = _29146
                                    mem[_29090 + 32] = stor10[address(arg3)][idx].field_256
                                    mem[_29090 + 64] = stor10[address(arg3)][idx].field_512
                                    mem[_29090 + 96] = stor10[address(arg3)][idx].field_768
                                    mem[s] = _29090
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                if not stor10[address(arg3)][idx].field_0 - (stor10[address(arg3)][idx].field_1 < 32):
                                    revert with 0, 34
                                if not stor10[address(arg3)][idx].field_1:
                                    mem[_29090] = _29146
                                    mem[_29090 + 32] = stor10[address(arg3)][idx].field_256
                                    mem[_29090 + 64] = stor10[address(arg3)][idx].field_512
                                    mem[_29090 + 96] = stor10[address(arg3)][idx].field_768
                                    mem[s] = _29090
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                if 31 >= stor10[address(arg3)][idx].field_1:
                                    mem[_29146 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                    mem[_29090] = _29146
                                    mem[_29090 + 32] = stor10[address(arg3)][idx].field_256
                                    mem[_29090 + 64] = stor10[address(arg3)][idx].field_512
                                    mem[_29090 + 96] = stor10[address(arg3)][idx].field_768
                                    mem[s] = _29090
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                mem[_29146 + 32] = stor10[address(arg3)][idx].field_0
                                t = _29146 + 32
                                u = sha3(mem[0])
                                while _29146 + stor10[address(arg3)][u].field_1 > t:
                                    mem[t + 32] = uint256(stor1[u])
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                mem[_29090] = _29146
                                mem[_29090 + 32] = stor10[address(arg3)][u].field_256
                                mem[_29090 + 64] = stor10[address(arg3)][u].field_512
                                mem[_29090 + 96] = stor10[address(arg3)][u].field_768
                                mem[t] = _29090
                                t = t + 32
                                u = u + 1
                                continue 
                            if not stor10[address(arg3)][idx].field_0 - (stor10[address(arg3)][idx].field_1 < 32):
                                revert with 0, 34
                            _29180 = mem[64]
                            mem[64] = mem[64] + ceil32(stor10[address(arg3)][idx].field_1) + 32
                            mem[_29180] = stor10[address(arg3)][idx].field_1
                            if stor10[address(arg3)][idx].field_0:
                                if not stor10[address(arg3)][idx].field_0 - (uint255(stor10[address(arg3)][idx].field_0) * 0.5 < 32):
                                    revert with 0, 34
                                if not Mask(256, -1, stor10[address(arg3)][idx].field_0):
                                    mem[_29090] = _29180
                                    mem[_29090 + 32] = stor10[address(arg3)][idx].field_256
                                    mem[_29090 + 64] = stor10[address(arg3)][idx].field_512
                                    mem[_29090 + 96] = stor10[address(arg3)][idx].field_768
                                    mem[s] = _29090
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                if 31 >= uint255(stor10[address(arg3)][idx].field_0) * 0.5:
                                    mem[_29180 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                    mem[_29090] = _29180
                                    mem[_29090 + 32] = stor10[address(arg3)][idx].field_256
                                    mem[_29090 + 64] = stor10[address(arg3)][idx].field_512
                                    mem[_29090 + 96] = stor10[address(arg3)][idx].field_768
                                    mem[s] = _29090
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                mem[_29180 + 32] = stor10[address(arg3)][idx].field_0
                                t = _29180 + 32
                                u = sha3(mem[0])
                                while _29180 + (uint255(stor10[address(arg3)][u].field_0) * 0.5) > t:
                                    mem[t + 32] = uint256(stor1[u])
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                mem[_29090] = _29180
                                mem[_29090 + 32] = stor10[address(arg3)][u].field_256
                                mem[_29090 + 64] = stor10[address(arg3)][u].field_512
                                mem[_29090 + 96] = stor10[address(arg3)][u].field_768
                                mem[t] = _29090
                                t = t + 32
                                u = u + 1
                                continue 
                            if not stor10[address(arg3)][idx].field_0 - (stor10[address(arg3)][idx].field_1 < 32):
                                revert with 0, 34
                            if stor10[address(arg3)][idx].field_1:
                                if 31 >= stor10[address(arg3)][idx].field_1:
                                    mem[_29180 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                else:
                                    mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                    mem[_29180 + 32] = stor10[address(arg3)][idx].field_0
                                    t = _29180 + 32
                                    u = sha3(mem[0])
                                    while _29180 + stor10[address(arg3)][idx].field_1 > t:
                                        mem[t + 32] = uint256(stor1[u])
                                        t = t + 32
                                        u = u + 1
                                        continue 
                            mem[_29090] = _29180
                            mem[_29090 + 32] = stor10[address(arg3)][idx].field_256
                            mem[_29090 + 64] = stor10[address(arg3)][idx].field_512
                            mem[_29090 + 96] = stor10[address(arg3)][idx].field_768
                            mem[s] = _29090
                            s = s + 32
                            idx = idx + 1
                            continue 
                        if address(arg1) != address(arg3):
                            if mem[ceil32(ceil32(arg2.length)) + 225] <= 1:
                                if mem[_22556] > 0:
                                    if _referrals[address(arg1)] != address(arg3):
                                        _referrals[address(arg1)] = address(arg3)
                                        sub_989baf69[address(arg3)].field_0++
                                        sub_989baf69[address(arg3)][sub_989baf69[address(arg3)].field_0].field_0 = address(arg1)
                                    if tokenAddress != msg.sender:
                                        if gateKeeperAddress != msg.sender:
                                            if address(stor0.field_0) != msg.sender:
                                                revert with 0, 'NodeManagerV2: NOT AUTHORIZED'
                                    if stor10[stor11[address(arg1)]].field_0:
                                        if not -referralBonusPercent:
                                            sub_e27e434a[stor11[address(arg1)]][address(arg1)] = 0
                                            if sub_666755bb[stor11[address(arg1)]] > -1:
                                                revert with 0, 17
                                        else:
                                            if referralBonusPercent and nodePrice > -1 / referralBonusPercent:
                                                revert with 0, 17
                                            if not referralBonusPercent:
                                                revert with 0, 18
                                            if referralBonusPercent * nodePrice / referralBonusPercent != nodePrice:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            sub_e27e434a[stor11[address(arg1)]][address(arg1)] = referralBonusPercent * nodePrice / 100
                                            if sub_666755bb[stor11[address(arg1)]] > !(referralBonusPercent * nodePrice / 100):
                                                revert with 0, 17
                                            sub_666755bb[stor11[address(arg1)]] += referralBonusPercent * nodePrice / 100
                    else:
                        if msg.sender == gateKeeperAddress:
                            mem[0] = address(arg1)
                            mem[64] = ceil32(ceil32(arg2.length)) + (32 * stor10[address(arg1)].field_0) + 257
                            mem[ceil32(ceil32(arg2.length)) + 225] = stor10[address(arg1)].field_0
                            s = ceil32(ceil32(arg2.length)) + 257
                            idx = 0
                            while idx < stor10[address(arg1)].field_0:
                                mem[0] = sha3(address(arg1), 10)
                                _22562 = mem[64]
                                mem[64] = mem[64] + 128
                                if stor10[address(arg1)][idx].field_0:
                                    if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                                        revert with 0, 34
                                    _22805 = mem[64]
                                    mem[64] = mem[64] + ceil32(uint255(stor10[address(arg1)][idx].field_0) * 0.5) + 32
                                    mem[_22805] = uint255(stor10[address(arg1)][idx].field_0) * 0.5
                                    if stor10[address(arg1)][idx].field_0:
                                        if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                                            revert with 0, 34
                                        if Mask(256, -1, stor10[address(arg1)][idx].field_0):
                                            if 31 >= uint255(stor10[address(arg1)][idx].field_0) * 0.5:
                                                mem[_22805 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                            else:
                                                mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                                mem[_22805 + 32] = stor10[address(arg1)][idx].field_0
                                                t = _22805 + 32
                                                u = sha3(mem[0])
                                                while _22805 + (uint255(stor10[address(arg1)][idx].field_0) * 0.5) > t:
                                                    mem[t + 32] = uint256(stor1[u])
                                                    t = t + 32
                                                    u = u + 1
                                                    continue 
                                        mem[_22562] = _22805
                                        mem[_22562 + 32] = stor10[address(arg1)][idx].field_256
                                        mem[_22562 + 64] = stor10[address(arg1)][idx].field_512
                                        mem[_22562 + 96] = stor10[address(arg1)][idx].field_768
                                        mem[s] = _22562
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                                        revert with 0, 34
                                    if not stor10[address(arg1)][idx].field_1:
                                        mem[_22562] = _22805
                                        mem[_22562 + 32] = stor10[address(arg1)][idx].field_256
                                        mem[_22562 + 64] = stor10[address(arg1)][idx].field_512
                                        mem[_22562 + 96] = stor10[address(arg1)][idx].field_768
                                        mem[s] = _22562
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    if 31 >= stor10[address(arg1)][idx].field_1:
                                        mem[_22805 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                        mem[_22562] = _22805
                                        mem[_22562 + 32] = stor10[address(arg1)][idx].field_256
                                        mem[_22562 + 64] = stor10[address(arg1)][idx].field_512
                                        mem[_22562 + 96] = stor10[address(arg1)][idx].field_768
                                        mem[s] = _22562
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                    mem[_22805 + 32] = stor10[address(arg1)][idx].field_0
                                    t = _22805 + 32
                                    u = sha3(mem[0])
                                    while _22805 + stor10[address(arg1)][u].field_1 > t:
                                        mem[t + 32] = uint256(stor1[u])
                                        t = t + 32
                                        u = u + 1
                                        continue 
                                    mem[_22562] = _22805
                                    mem[_22562 + 32] = stor10[address(arg1)][u].field_256
                                    mem[_22562 + 64] = stor10[address(arg1)][u].field_512
                                    mem[_22562 + 96] = stor10[address(arg1)][u].field_768
                                    mem[t] = _22562
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                                    revert with 0, 34
                                _22942 = mem[64]
                                mem[64] = mem[64] + ceil32(stor10[address(arg1)][idx].field_1) + 32
                                mem[_22942] = stor10[address(arg1)][idx].field_1
                                if stor10[address(arg1)][idx].field_0:
                                    if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                                        revert with 0, 34
                                    if not Mask(256, -1, stor10[address(arg1)][idx].field_0):
                                        mem[_22562] = _22942
                                        mem[_22562 + 32] = stor10[address(arg1)][idx].field_256
                                        mem[_22562 + 64] = stor10[address(arg1)][idx].field_512
                                        mem[_22562 + 96] = stor10[address(arg1)][idx].field_768
                                        mem[s] = _22562
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    if 31 >= uint255(stor10[address(arg1)][idx].field_0) * 0.5:
                                        mem[_22942 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                        mem[_22562] = _22942
                                        mem[_22562 + 32] = stor10[address(arg1)][idx].field_256
                                        mem[_22562 + 64] = stor10[address(arg1)][idx].field_512
                                        mem[_22562 + 96] = stor10[address(arg1)][idx].field_768
                                        mem[s] = _22562
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                    mem[_22942 + 32] = stor10[address(arg1)][idx].field_0
                                    t = _22942 + 32
                                    u = sha3(mem[0])
                                    while _22942 + (uint255(stor10[address(arg1)][u].field_0) * 0.5) > t:
                                        mem[t + 32] = uint256(stor1[u])
                                        t = t + 32
                                        u = u + 1
                                        continue 
                                    mem[_22562] = _22942
                                    mem[_22562 + 32] = stor10[address(arg1)][u].field_256
                                    mem[_22562 + 64] = stor10[address(arg1)][u].field_512
                                    mem[_22562 + 96] = stor10[address(arg1)][u].field_768
                                    mem[t] = _22562
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                                    revert with 0, 34
                                if stor10[address(arg1)][idx].field_1:
                                    if 31 >= stor10[address(arg1)][idx].field_1:
                                        mem[_22942 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                    else:
                                        mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                        mem[_22942 + 32] = stor10[address(arg1)][idx].field_0
                                        t = _22942 + 32
                                        u = sha3(mem[0])
                                        while _22942 + stor10[address(arg1)][idx].field_1 > t:
                                            mem[t + 32] = uint256(stor1[u])
                                            t = t + 32
                                            u = u + 1
                                            continue 
                                mem[_22562] = _22942
                                mem[_22562 + 32] = stor10[address(arg1)][idx].field_256
                                mem[_22562 + 64] = stor10[address(arg1)][idx].field_512
                                mem[_22562 + 96] = stor10[address(arg1)][idx].field_768
                                mem[s] = _22562
                                s = s + 32
                                idx = idx + 1
                                continue 
                            mem[0] = address(arg3)
                            mem[32] = 10
                            _22560 = mem[64]
                            mem[64] = mem[64] + (32 * stor10[address(arg3)].field_0) + 32
                            mem[_22560] = stor10[address(arg3)].field_0
                            s = _22560 + 32
                            idx = 0
                            while idx < stor10[address(arg3)].field_0:
                                mem[0] = sha3(address(arg3), 10)
                                _29092 = mem[64]
                                mem[64] = mem[64] + 128
                                if stor10[address(arg3)][idx].field_0:
                                    if not stor10[address(arg3)][idx].field_0 - (uint255(stor10[address(arg3)][idx].field_0) * 0.5 < 32):
                                        revert with 0, 34
                                    _29147 = mem[64]
                                    mem[64] = mem[64] + ceil32(uint255(stor10[address(arg3)][idx].field_0) * 0.5) + 32
                                    mem[_29147] = uint255(stor10[address(arg3)][idx].field_0) * 0.5
                                    if stor10[address(arg3)][idx].field_0:
                                        if not stor10[address(arg3)][idx].field_0 - (uint255(stor10[address(arg3)][idx].field_0) * 0.5 < 32):
                                            revert with 0, 34
                                        if Mask(256, -1, stor10[address(arg3)][idx].field_0):
                                            if 31 >= uint255(stor10[address(arg3)][idx].field_0) * 0.5:
                                                mem[_29147 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                            else:
                                                mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                                mem[_29147 + 32] = stor10[address(arg3)][idx].field_0
                                                t = _29147 + 32
                                                u = sha3(mem[0])
                                                while _29147 + (uint255(stor10[address(arg3)][idx].field_0) * 0.5) > t:
                                                    mem[t + 32] = uint256(stor1[u])
                                                    t = t + 32
                                                    u = u + 1
                                                    continue 
                                        mem[_29092] = _29147
                                        mem[_29092 + 32] = stor10[address(arg3)][idx].field_256
                                        mem[_29092 + 64] = stor10[address(arg3)][idx].field_512
                                        mem[_29092 + 96] = stor10[address(arg3)][idx].field_768
                                        mem[s] = _29092
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    if not stor10[address(arg3)][idx].field_0 - (stor10[address(arg3)][idx].field_1 < 32):
                                        revert with 0, 34
                                    if not stor10[address(arg3)][idx].field_1:
                                        mem[_29092] = _29147
                                        mem[_29092 + 32] = stor10[address(arg3)][idx].field_256
                                        mem[_29092 + 64] = stor10[address(arg3)][idx].field_512
                                        mem[_29092 + 96] = stor10[address(arg3)][idx].field_768
                                        mem[s] = _29092
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    if 31 >= stor10[address(arg3)][idx].field_1:
                                        mem[_29147 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                        mem[_29092] = _29147
                                        mem[_29092 + 32] = stor10[address(arg3)][idx].field_256
                                        mem[_29092 + 64] = stor10[address(arg3)][idx].field_512
                                        mem[_29092 + 96] = stor10[address(arg3)][idx].field_768
                                        mem[s] = _29092
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                    mem[_29147 + 32] = stor10[address(arg3)][idx].field_0
                                    t = _29147 + 32
                                    u = sha3(mem[0])
                                    while _29147 + stor10[address(arg3)][u].field_1 > t:
                                        mem[t + 32] = uint256(stor1[u])
                                        t = t + 32
                                        u = u + 1
                                        continue 
                                    mem[_29092] = _29147
                                    mem[_29092 + 32] = stor10[address(arg3)][u].field_256
                                    mem[_29092 + 64] = stor10[address(arg3)][u].field_512
                                    mem[_29092 + 96] = stor10[address(arg3)][u].field_768
                                    mem[t] = _29092
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                if not stor10[address(arg3)][idx].field_0 - (stor10[address(arg3)][idx].field_1 < 32):
                                    revert with 0, 34
                                _29182 = mem[64]
                                mem[64] = mem[64] + ceil32(stor10[address(arg3)][idx].field_1) + 32
                                mem[_29182] = stor10[address(arg3)][idx].field_1
                                if stor10[address(arg3)][idx].field_0:
                                    if not stor10[address(arg3)][idx].field_0 - (uint255(stor10[address(arg3)][idx].field_0) * 0.5 < 32):
                                        revert with 0, 34
                                    if not Mask(256, -1, stor10[address(arg3)][idx].field_0):
                                        mem[_29092] = _29182
                                        mem[_29092 + 32] = stor10[address(arg3)][idx].field_256
                                        mem[_29092 + 64] = stor10[address(arg3)][idx].field_512
                                        mem[_29092 + 96] = stor10[address(arg3)][idx].field_768
                                        mem[s] = _29092
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    if 31 >= uint255(stor10[address(arg3)][idx].field_0) * 0.5:
                                        mem[_29182 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                        mem[_29092] = _29182
                                        mem[_29092 + 32] = stor10[address(arg3)][idx].field_256
                                        mem[_29092 + 64] = stor10[address(arg3)][idx].field_512
                                        mem[_29092 + 96] = stor10[address(arg3)][idx].field_768
                                        mem[s] = _29092
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                    mem[_29182 + 32] = stor10[address(arg3)][idx].field_0
                                    t = _29182 + 32
                                    u = sha3(mem[0])
                                    while _29182 + (uint255(stor10[address(arg3)][u].field_0) * 0.5) > t:
                                        mem[t + 32] = uint256(stor1[u])
                                        t = t + 32
                                        u = u + 1
                                        continue 
                                    mem[_29092] = _29182
                                    mem[_29092 + 32] = stor10[address(arg3)][u].field_256
                                    mem[_29092 + 64] = stor10[address(arg3)][u].field_512
                                    mem[_29092 + 96] = stor10[address(arg3)][u].field_768
                                    mem[t] = _29092
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                if not stor10[address(arg3)][idx].field_0 - (stor10[address(arg3)][idx].field_1 < 32):
                                    revert with 0, 34
                                if stor10[address(arg3)][idx].field_1:
                                    if 31 >= stor10[address(arg3)][idx].field_1:
                                        mem[_29182 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                    else:
                                        mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                        mem[_29182 + 32] = stor10[address(arg3)][idx].field_0
                                        t = _29182 + 32
                                        u = sha3(mem[0])
                                        while _29182 + stor10[address(arg3)][idx].field_1 > t:
                                            mem[t + 32] = uint256(stor1[u])
                                            t = t + 32
                                            u = u + 1
                                            continue 
                                mem[_29092] = _29182
                                mem[_29092 + 32] = stor10[address(arg3)][idx].field_256
                                mem[_29092 + 64] = stor10[address(arg3)][idx].field_512
                                mem[_29092 + 96] = stor10[address(arg3)][idx].field_768
                                mem[s] = _29092
                                s = s + 32
                                idx = idx + 1
                                continue 
                            if address(arg1) != address(arg3):
                                if mem[ceil32(ceil32(arg2.length)) + 225] <= 1:
                                    if mem[_22560] > 0:
                                        if _referrals[address(arg1)] != address(arg3):
                                            _referrals[address(arg1)] = address(arg3)
                                            sub_989baf69[address(arg3)].field_0++
                                            sub_989baf69[address(arg3)][sub_989baf69[address(arg3)].field_0].field_0 = address(arg1)
                                        if tokenAddress != msg.sender:
                                            if gateKeeperAddress != msg.sender:
                                                if address(stor0.field_0) != msg.sender:
                                                    revert with 0, 'NodeManagerV2: NOT AUTHORIZED'
                                        if stor10[stor11[address(arg1)]].field_0:
                                            if not -referralBonusPercent:
                                                sub_e27e434a[stor11[address(arg1)]][address(arg1)] = 0
                                                if sub_666755bb[stor11[address(arg1)]] > -1:
                                                    revert with 0, 17
                                            else:
                                                if referralBonusPercent and nodePrice > -1 / referralBonusPercent:
                                                    revert with 0, 17
                                                if not referralBonusPercent:
                                                    revert with 0, 18
                                                if referralBonusPercent * nodePrice / referralBonusPercent != nodePrice:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                sub_e27e434a[stor11[address(arg1)]][address(arg1)] = referralBonusPercent * nodePrice / 100
                                                if sub_666755bb[stor11[address(arg1)]] > !(referralBonusPercent * nodePrice / 100):
                                                    revert with 0, 17
                                                sub_666755bb[stor11[address(arg1)]] += referralBonusPercent * nodePrice / 100
                        else:
                            if address(stor0.field_0) != msg.sender:
                                revert with 0, 'NodeManagerV2: NOT AUTHORIZED'
                            mem[0] = address(arg1)
                            mem[64] = ceil32(ceil32(arg2.length)) + (32 * stor10[address(arg1)].field_0) + 257
                            mem[ceil32(ceil32(arg2.length)) + 225] = stor10[address(arg1)].field_0
                            s = ceil32(ceil32(arg2.length)) + 257
                            idx = 0
                            while idx < stor10[address(arg1)].field_0:
                                mem[0] = sha3(address(arg1), 10)
                                _22566 = mem[64]
                                mem[64] = mem[64] + 128
                                if stor10[address(arg1)][idx].field_0:
                                    if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                                        revert with 0, 34
                                    _22806 = mem[64]
                                    mem[64] = mem[64] + ceil32(uint255(stor10[address(arg1)][idx].field_0) * 0.5) + 32
                                    mem[_22806] = uint255(stor10[address(arg1)][idx].field_0) * 0.5
                                    if stor10[address(arg1)][idx].field_0:
                                        if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                                            revert with 0, 34
                                        if Mask(256, -1, stor10[address(arg1)][idx].field_0):
                                            if 31 >= uint255(stor10[address(arg1)][idx].field_0) * 0.5:
                                                mem[_22806 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                            else:
                                                mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                                mem[_22806 + 32] = stor10[address(arg1)][idx].field_0
                                                t = _22806 + 32
                                                u = sha3(mem[0])
                                                while _22806 + (uint255(stor10[address(arg1)][idx].field_0) * 0.5) > t:
                                                    mem[t + 32] = uint256(stor1[u])
                                                    t = t + 32
                                                    u = u + 1
                                                    continue 
                                        mem[_22566] = _22806
                                        mem[_22566 + 32] = stor10[address(arg1)][idx].field_256
                                        mem[_22566 + 64] = stor10[address(arg1)][idx].field_512
                                        mem[_22566 + 96] = stor10[address(arg1)][idx].field_768
                                        mem[s] = _22566
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                                        revert with 0, 34
                                    if not stor10[address(arg1)][idx].field_1:
                                        mem[_22566] = _22806
                                        mem[_22566 + 32] = stor10[address(arg1)][idx].field_256
                                        mem[_22566 + 64] = stor10[address(arg1)][idx].field_512
                                        mem[_22566 + 96] = stor10[address(arg1)][idx].field_768
                                        mem[s] = _22566
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    if 31 >= stor10[address(arg1)][idx].field_1:
                                        mem[_22806 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                        mem[_22566] = _22806
                                        mem[_22566 + 32] = stor10[address(arg1)][idx].field_256
                                        mem[_22566 + 64] = stor10[address(arg1)][idx].field_512
                                        mem[_22566 + 96] = stor10[address(arg1)][idx].field_768
                                        mem[s] = _22566
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                    mem[_22806 + 32] = stor10[address(arg1)][idx].field_0
                                    t = _22806 + 32
                                    u = sha3(mem[0])
                                    while _22806 + stor10[address(arg1)][u].field_1 > t:
                                        mem[t + 32] = uint256(stor1[u])
                                        t = t + 32
                                        u = u + 1
                                        continue 
                                    mem[_22566] = _22806
                                    mem[_22566 + 32] = stor10[address(arg1)][u].field_256
                                    mem[_22566 + 64] = stor10[address(arg1)][u].field_512
                                    mem[_22566 + 96] = stor10[address(arg1)][u].field_768
                                    mem[t] = _22566
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                                    revert with 0, 34
                                _22944 = mem[64]
                                mem[64] = mem[64] + ceil32(stor10[address(arg1)][idx].field_1) + 32
                                mem[_22944] = stor10[address(arg1)][idx].field_1
                                if stor10[address(arg1)][idx].field_0:
                                    if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                                        revert with 0, 34
                                    if not Mask(256, -1, stor10[address(arg1)][idx].field_0):
                                        mem[_22566] = _22944
                                        mem[_22566 + 32] = stor10[address(arg1)][idx].field_256
                                        mem[_22566 + 64] = stor10[address(arg1)][idx].field_512
                                        mem[_22566 + 96] = stor10[address(arg1)][idx].field_768
                                        mem[s] = _22566
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    if 31 >= uint255(stor10[address(arg1)][idx].field_0) * 0.5:
                                        mem[_22944 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                        mem[_22566] = _22944
                                        mem[_22566 + 32] = stor10[address(arg1)][idx].field_256
                                        mem[_22566 + 64] = stor10[address(arg1)][idx].field_512
                                        mem[_22566 + 96] = stor10[address(arg1)][idx].field_768
                                        mem[s] = _22566
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                    mem[_22944 + 32] = stor10[address(arg1)][idx].field_0
                                    t = _22944 + 32
                                    u = sha3(mem[0])
                                    while _22944 + (uint255(stor10[address(arg1)][u].field_0) * 0.5) > t:
                                        mem[t + 32] = uint256(stor1[u])
                                        t = t + 32
                                        u = u + 1
                                        continue 
                                    mem[_22566] = _22944
                                    mem[_22566 + 32] = stor10[address(arg1)][u].field_256
                                    mem[_22566 + 64] = stor10[address(arg1)][u].field_512
                                    mem[_22566 + 96] = stor10[address(arg1)][u].field_768
                                    mem[t] = _22566
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                                    revert with 0, 34
                                if stor10[address(arg1)][idx].field_1:
                                    if 31 >= stor10[address(arg1)][idx].field_1:
                                        mem[_22944 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                    else:
                                        mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                        mem[_22944 + 32] = stor10[address(arg1)][idx].field_0
                                        t = _22944 + 32
                                        u = sha3(mem[0])
                                        while _22944 + stor10[address(arg1)][idx].field_1 > t:
                                            mem[t + 32] = uint256(stor1[u])
                                            t = t + 32
                                            u = u + 1
                                            continue 
                                mem[_22566] = _22944
                                mem[_22566 + 32] = stor10[address(arg1)][idx].field_256
                                mem[_22566 + 64] = stor10[address(arg1)][idx].field_512
                                mem[_22566 + 96] = stor10[address(arg1)][idx].field_768
                                mem[s] = _22566
                                s = s + 32
                                idx = idx + 1
                                continue 
                            mem[0] = address(arg3)
                            mem[32] = 10
                            _22564 = mem[64]
                            mem[64] = mem[64] + (32 * stor10[address(arg3)].field_0) + 32
                            mem[_22564] = stor10[address(arg3)].field_0
                            s = _22564 + 32
                            idx = 0
                            while idx < stor10[address(arg3)].field_0:
                                mem[0] = sha3(address(arg3), 10)
                                _29094 = mem[64]
                                mem[64] = mem[64] + 128
                                if stor10[address(arg3)][idx].field_0:
                                    if not stor10[address(arg3)][idx].field_0 - (uint255(stor10[address(arg3)][idx].field_0) * 0.5 < 32):
                                        revert with 0, 34
                                    _29148 = mem[64]
                                    mem[64] = mem[64] + ceil32(uint255(stor10[address(arg3)][idx].field_0) * 0.5) + 32
                                    mem[_29148] = uint255(stor10[address(arg3)][idx].field_0) * 0.5
                                    if stor10[address(arg3)][idx].field_0:
                                        if not stor10[address(arg3)][idx].field_0 - (uint255(stor10[address(arg3)][idx].field_0) * 0.5 < 32):
                                            revert with 0, 34
                                        if Mask(256, -1, stor10[address(arg3)][idx].field_0):
                                            if 31 >= uint255(stor10[address(arg3)][idx].field_0) * 0.5:
                                                mem[_29148 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                            else:
                                                mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                                mem[_29148 + 32] = stor10[address(arg3)][idx].field_0
                                                t = _29148 + 32
                                                u = sha3(mem[0])
                                                while _29148 + (uint255(stor10[address(arg3)][idx].field_0) * 0.5) > t:
                                                    mem[t + 32] = uint256(stor1[u])
                                                    t = t + 32
                                                    u = u + 1
                                                    continue 
                                        mem[_29094] = _29148
                                        mem[_29094 + 32] = stor10[address(arg3)][idx].field_256
                                        mem[_29094 + 64] = stor10[address(arg3)][idx].field_512
                                        mem[_29094 + 96] = stor10[address(arg3)][idx].field_768
                                        mem[s] = _29094
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    if not stor10[address(arg3)][idx].field_0 - (stor10[address(arg3)][idx].field_1 < 32):
                                        revert with 0, 34
                                    if not stor10[address(arg3)][idx].field_1:
                                        mem[_29094] = _29148
                                        mem[_29094 + 32] = stor10[address(arg3)][idx].field_256
                                        mem[_29094 + 64] = stor10[address(arg3)][idx].field_512
                                        mem[_29094 + 96] = stor10[address(arg3)][idx].field_768
                                        mem[s] = _29094
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    if 31 >= stor10[address(arg3)][idx].field_1:
                                        mem[_29148 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                        mem[_29094] = _29148
                                        mem[_29094 + 32] = stor10[address(arg3)][idx].field_256
                                        mem[_29094 + 64] = stor10[address(arg3)][idx].field_512
                                        mem[_29094 + 96] = stor10[address(arg3)][idx].field_768
                                        mem[s] = _29094
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                    mem[_29148 + 32] = stor10[address(arg3)][idx].field_0
                                    t = _29148 + 32
                                    u = sha3(mem[0])
                                    while _29148 + stor10[address(arg3)][u].field_1 > t:
                                        mem[t + 32] = uint256(stor1[u])
                                        t = t + 32
                                        u = u + 1
                                        continue 
                                    mem[_29094] = _29148
                                    mem[_29094 + 32] = stor10[address(arg3)][u].field_256
                                    mem[_29094 + 64] = stor10[address(arg3)][u].field_512
                                    mem[_29094 + 96] = stor10[address(arg3)][u].field_768
                                    mem[t] = _29094
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                if not stor10[address(arg3)][idx].field_0 - (stor10[address(arg3)][idx].field_1 < 32):
                                    revert with 0, 34
                                _29184 = mem[64]
                                mem[64] = mem[64] + ceil32(stor10[address(arg3)][idx].field_1) + 32
                                mem[_29184] = stor10[address(arg3)][idx].field_1
                                if stor10[address(arg3)][idx].field_0:
                                    if not stor10[address(arg3)][idx].field_0 - (uint255(stor10[address(arg3)][idx].field_0) * 0.5 < 32):
                                        revert with 0, 34
                                    if not Mask(256, -1, stor10[address(arg3)][idx].field_0):
                                        mem[_29094] = _29184
                                        mem[_29094 + 32] = stor10[address(arg3)][idx].field_256
                                        mem[_29094 + 64] = stor10[address(arg3)][idx].field_512
                                        mem[_29094 + 96] = stor10[address(arg3)][idx].field_768
                                        mem[s] = _29094
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    if 31 >= uint255(stor10[address(arg3)][idx].field_0) * 0.5:
                                        mem[_29184 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                        mem[_29094] = _29184
                                        mem[_29094 + 32] = stor10[address(arg3)][idx].field_256
                                        mem[_29094 + 64] = stor10[address(arg3)][idx].field_512
                                        mem[_29094 + 96] = stor10[address(arg3)][idx].field_768
                                        mem[s] = _29094
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                    mem[_29184 + 32] = stor10[address(arg3)][idx].field_0
                                    t = _29184 + 32
                                    u = sha3(mem[0])
                                    while _29184 + (uint255(stor10[address(arg3)][u].field_0) * 0.5) > t:
                                        mem[t + 32] = uint256(stor1[u])
                                        t = t + 32
                                        u = u + 1
                                        continue 
                                    mem[_29094] = _29184
                                    mem[_29094 + 32] = stor10[address(arg3)][u].field_256
                                    mem[_29094 + 64] = stor10[address(arg3)][u].field_512
                                    mem[_29094 + 96] = stor10[address(arg3)][u].field_768
                                    mem[t] = _29094
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                if not stor10[address(arg3)][idx].field_0 - (stor10[address(arg3)][idx].field_1 < 32):
                                    revert with 0, 34
                                if stor10[address(arg3)][idx].field_1:
                                    if 31 >= stor10[address(arg3)][idx].field_1:
                                        mem[_29184 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                    else:
                                        mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                        mem[_29184 + 32] = stor10[address(arg3)][idx].field_0
                                        t = _29184 + 32
                                        u = sha3(mem[0])
                                        while _29184 + stor10[address(arg3)][idx].field_1 > t:
                                            mem[t + 32] = uint256(stor1[u])
                                            t = t + 32
                                            u = u + 1
                                            continue 
                                mem[_29094] = _29184
                                mem[_29094 + 32] = stor10[address(arg3)][idx].field_256
                                mem[_29094 + 64] = stor10[address(arg3)][idx].field_512
                                mem[_29094 + 96] = stor10[address(arg3)][idx].field_768
                                mem[s] = _29094
                                s = s + 32
                                idx = idx + 1
                                continue 
                            if address(arg1) != address(arg3):
                                if mem[ceil32(ceil32(arg2.length)) + 225] <= 1:
                                    if mem[_22564] > 0:
                                        if _referrals[address(arg1)] != address(arg3):
                                            _referrals[address(arg1)] = address(arg3)
                                            sub_989baf69[address(arg3)].field_0++
                                            sub_989baf69[address(arg3)][sub_989baf69[address(arg3)].field_0].field_0 = address(arg1)
                                        if tokenAddress != msg.sender:
                                            if gateKeeperAddress != msg.sender:
                                                if address(stor0.field_0) != msg.sender:
                                                    revert with 0, 'NodeManagerV2: NOT AUTHORIZED'
                                        if stor10[stor11[address(arg1)]].field_0:
                                            if not -referralBonusPercent:
                                                sub_e27e434a[stor11[address(arg1)]][address(arg1)] = 0
                                                if sub_666755bb[stor11[address(arg1)]] > -1:
                                                    revert with 0, 17
                                            else:
                                                if referralBonusPercent and nodePrice > -1 / referralBonusPercent:
                                                    revert with 0, 17
                                                if not referralBonusPercent:
                                                    revert with 0, 18
                                                if referralBonusPercent * nodePrice / referralBonusPercent != nodePrice:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                sub_e27e434a[stor11[address(arg1)]][address(arg1)] = referralBonusPercent * nodePrice / 100
                                                if sub_666755bb[stor11[address(arg1)]] > !(referralBonusPercent * nodePrice / 100):
                                                    revert with 0, 17
                                                sub_666755bb[stor11[address(arg1)]] += referralBonusPercent * nodePrice / 100
                else:
                    stor10[address(arg1)][stor10[address(arg1)].field_0].field_0 = 0
                    idx = 0
                    while stor10[address(arg1)][stor10[address(arg1)].field_0].field_1 + 31 / 32 > idx:
                        stor10[address(arg1)][(4 * stor10[address(arg1)].field_0) + idx].field_0 = 0
                        idx = idx + 1
                        continue 
                    stor10[address(arg1)][stor10[address(arg1)].field_0].field_256 = block.timestamp
                    stor10[address(arg1)][stor10[address(arg1)].field_0].field_512 = block.timestamp
                    stor10[address(arg1)][stor10[address(arg1)].field_0].field_768 = 0
                    mem[ceil32(ceil32(arg2.length)) + 229] = 6
                    mem[ceil32(ceil32(arg2.length)) + 261] = address(arg1)
                    mem[ceil32(ceil32(arg2.length)) + 293] = stor10[address(arg1)].field_0
                    require ext_code.size(0x4b7a346b17572634bdbd85b98abae32c5fa837bb)
                    delegate 0x4b7a346b17572634bdbd85b98abae32c5fa837bb.0xbc2b405c with:
                         gas gas_remaining wei
                        args 6, address(arg1), stor10[address(arg1)].field_0
                    if not delegate.return_code:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not totalNodesCreated + 1:
                        revert with 0, 17
                    totalNodesCreated++
                    if msg.sender == tokenAddress:
                        mem[0] = address(arg1)
                        mem[64] = ceil32(ceil32(arg2.length)) + (32 * stor10[address(arg1)].field_0) + 257
                        mem[ceil32(ceil32(arg2.length)) + 225] = stor10[address(arg1)].field_0
                        s = ceil32(ceil32(arg2.length)) + 257
                        idx = 0
                        while idx < stor10[address(arg1)].field_0:
                            mem[0] = sha3(address(arg1), 10)
                            _15322 = mem[64]
                            mem[64] = mem[64] + 128
                            if stor10[address(arg1)][idx].field_0:
                                if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                                    revert with 0, 34
                                _15580 = mem[64]
                                mem[64] = mem[64] + ceil32(uint255(stor10[address(arg1)][idx].field_0) * 0.5) + 32
                                mem[_15580] = uint255(stor10[address(arg1)][idx].field_0) * 0.5
                                if stor10[address(arg1)][idx].field_0:
                                    if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                                        revert with 0, 34
                                    if Mask(256, -1, stor10[address(arg1)][idx].field_0):
                                        if 31 >= uint255(stor10[address(arg1)][idx].field_0) * 0.5:
                                            mem[_15580 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                        else:
                                            mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                            mem[_15580 + 32] = stor10[address(arg1)][idx].field_0
                                            t = _15580 + 32
                                            u = sha3(mem[0])
                                            while _15580 + (uint255(stor10[address(arg1)][idx].field_0) * 0.5) > t:
                                                mem[t + 32] = uint256(stor1[u])
                                                t = t + 32
                                                u = u + 1
                                                continue 
                                    mem[_15322] = _15580
                                    mem[_15322 + 32] = stor10[address(arg1)][idx].field_256
                                    mem[_15322 + 64] = stor10[address(arg1)][idx].field_512
                                    mem[_15322 + 96] = stor10[address(arg1)][idx].field_768
                                    mem[s] = _15322
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                                    revert with 0, 34
                                if not stor10[address(arg1)][idx].field_1:
                                    mem[_15322] = _15580
                                    mem[_15322 + 32] = stor10[address(arg1)][idx].field_256
                                    mem[_15322 + 64] = stor10[address(arg1)][idx].field_512
                                    mem[_15322 + 96] = stor10[address(arg1)][idx].field_768
                                    mem[s] = _15322
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                if 31 >= stor10[address(arg1)][idx].field_1:
                                    mem[_15580 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                    mem[_15322] = _15580
                                    mem[_15322 + 32] = stor10[address(arg1)][idx].field_256
                                    mem[_15322 + 64] = stor10[address(arg1)][idx].field_512
                                    mem[_15322 + 96] = stor10[address(arg1)][idx].field_768
                                    mem[s] = _15322
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                mem[_15580 + 32] = stor10[address(arg1)][idx].field_0
                                t = _15580 + 32
                                u = sha3(mem[0])
                                while _15580 + stor10[address(arg1)][u].field_1 > t:
                                    mem[t + 32] = uint256(stor1[u])
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                mem[_15322] = _15580
                                mem[_15322 + 32] = stor10[address(arg1)][u].field_256
                                mem[_15322 + 64] = stor10[address(arg1)][u].field_512
                                mem[_15322 + 96] = stor10[address(arg1)][u].field_768
                                mem[t] = _15322
                                t = t + 32
                                u = u + 1
                                continue 
                            if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                                revert with 0, 34
                            _15686 = mem[64]
                            mem[64] = mem[64] + ceil32(stor10[address(arg1)][idx].field_1) + 32
                            mem[_15686] = stor10[address(arg1)][idx].field_1
                            if stor10[address(arg1)][idx].field_0:
                                if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                                    revert with 0, 34
                                if not Mask(256, -1, stor10[address(arg1)][idx].field_0):
                                    mem[_15322] = _15686
                                    mem[_15322 + 32] = stor10[address(arg1)][idx].field_256
                                    mem[_15322 + 64] = stor10[address(arg1)][idx].field_512
                                    mem[_15322 + 96] = stor10[address(arg1)][idx].field_768
                                    mem[s] = _15322
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                if 31 >= uint255(stor10[address(arg1)][idx].field_0) * 0.5:
                                    mem[_15686 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                    mem[_15322] = _15686
                                    mem[_15322 + 32] = stor10[address(arg1)][idx].field_256
                                    mem[_15322 + 64] = stor10[address(arg1)][idx].field_512
                                    mem[_15322 + 96] = stor10[address(arg1)][idx].field_768
                                    mem[s] = _15322
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                mem[_15686 + 32] = stor10[address(arg1)][idx].field_0
                                t = _15686 + 32
                                u = sha3(mem[0])
                                while _15686 + (uint255(stor10[address(arg1)][u].field_0) * 0.5) > t:
                                    mem[t + 32] = uint256(stor1[u])
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                mem[_15322] = _15686
                                mem[_15322 + 32] = stor10[address(arg1)][u].field_256
                                mem[_15322 + 64] = stor10[address(arg1)][u].field_512
                                mem[_15322 + 96] = stor10[address(arg1)][u].field_768
                                mem[t] = _15322
                                t = t + 32
                                u = u + 1
                                continue 
                            if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                                revert with 0, 34
                            if stor10[address(arg1)][idx].field_1:
                                if 31 >= stor10[address(arg1)][idx].field_1:
                                    mem[_15686 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                else:
                                    mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                    mem[_15686 + 32] = stor10[address(arg1)][idx].field_0
                                    t = _15686 + 32
                                    u = sha3(mem[0])
                                    while _15686 + stor10[address(arg1)][idx].field_1 > t:
                                        mem[t + 32] = uint256(stor1[u])
                                        t = t + 32
                                        u = u + 1
                                        continue 
                            mem[_15322] = _15686
                            mem[_15322 + 32] = stor10[address(arg1)][idx].field_256
                            mem[_15322 + 64] = stor10[address(arg1)][idx].field_512
                            mem[_15322 + 96] = stor10[address(arg1)][idx].field_768
                            mem[s] = _15322
                            s = s + 32
                            idx = idx + 1
                            continue 
                        mem[0] = address(arg3)
                        mem[32] = 10
                        _15320 = mem[64]
                        mem[64] = mem[64] + (32 * stor10[address(arg3)].field_0) + 32
                        mem[_15320] = stor10[address(arg3)].field_0
                        s = _15320 + 32
                        idx = 0
                        while idx < stor10[address(arg3)].field_0:
                            mem[0] = sha3(address(arg3), 10)
                            _22574 = mem[64]
                            mem[64] = mem[64] + 128
                            if stor10[address(arg3)][idx].field_0:
                                if not stor10[address(arg3)][idx].field_0 - (uint255(stor10[address(arg3)][idx].field_0) * 0.5 < 32):
                                    revert with 0, 34
                                _22810 = mem[64]
                                mem[64] = mem[64] + ceil32(uint255(stor10[address(arg3)][idx].field_0) * 0.5) + 32
                                mem[_22810] = uint255(stor10[address(arg3)][idx].field_0) * 0.5
                                if stor10[address(arg3)][idx].field_0:
                                    if not stor10[address(arg3)][idx].field_0 - (uint255(stor10[address(arg3)][idx].field_0) * 0.5 < 32):
                                        revert with 0, 34
                                    if Mask(256, -1, stor10[address(arg3)][idx].field_0):
                                        if 31 >= uint255(stor10[address(arg3)][idx].field_0) * 0.5:
                                            mem[_22810 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                        else:
                                            mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                            mem[_22810 + 32] = stor10[address(arg3)][idx].field_0
                                            t = _22810 + 32
                                            u = sha3(mem[0])
                                            while _22810 + (uint255(stor10[address(arg3)][idx].field_0) * 0.5) > t:
                                                mem[t + 32] = uint256(stor1[u])
                                                t = t + 32
                                                u = u + 1
                                                continue 
                                    mem[_22574] = _22810
                                    mem[_22574 + 32] = stor10[address(arg3)][idx].field_256
                                    mem[_22574 + 64] = stor10[address(arg3)][idx].field_512
                                    mem[_22574 + 96] = stor10[address(arg3)][idx].field_768
                                    mem[s] = _22574
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                if not stor10[address(arg3)][idx].field_0 - (stor10[address(arg3)][idx].field_1 < 32):
                                    revert with 0, 34
                                if not stor10[address(arg3)][idx].field_1:
                                    mem[_22574] = _22810
                                    mem[_22574 + 32] = stor10[address(arg3)][idx].field_256
                                    mem[_22574 + 64] = stor10[address(arg3)][idx].field_512
                                    mem[_22574 + 96] = stor10[address(arg3)][idx].field_768
                                    mem[s] = _22574
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                if 31 >= stor10[address(arg3)][idx].field_1:
                                    mem[_22810 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                    mem[_22574] = _22810
                                    mem[_22574 + 32] = stor10[address(arg3)][idx].field_256
                                    mem[_22574 + 64] = stor10[address(arg3)][idx].field_512
                                    mem[_22574 + 96] = stor10[address(arg3)][idx].field_768
                                    mem[s] = _22574
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                mem[_22810 + 32] = stor10[address(arg3)][idx].field_0
                                t = _22810 + 32
                                u = sha3(mem[0])
                                while _22810 + stor10[address(arg3)][u].field_1 > t:
                                    mem[t + 32] = uint256(stor1[u])
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                mem[_22574] = _22810
                                mem[_22574 + 32] = stor10[address(arg3)][u].field_256
                                mem[_22574 + 64] = stor10[address(arg3)][u].field_512
                                mem[_22574 + 96] = stor10[address(arg3)][u].field_768
                                mem[t] = _22574
                                t = t + 32
                                u = u + 1
                                continue 
                            if not stor10[address(arg3)][idx].field_0 - (stor10[address(arg3)][idx].field_1 < 32):
                                revert with 0, 34
                            _22952 = mem[64]
                            mem[64] = mem[64] + ceil32(stor10[address(arg3)][idx].field_1) + 32
                            mem[_22952] = stor10[address(arg3)][idx].field_1
                            if stor10[address(arg3)][idx].field_0:
                                if not stor10[address(arg3)][idx].field_0 - (uint255(stor10[address(arg3)][idx].field_0) * 0.5 < 32):
                                    revert with 0, 34
                                if not Mask(256, -1, stor10[address(arg3)][idx].field_0):
                                    mem[_22574] = _22952
                                    mem[_22574 + 32] = stor10[address(arg3)][idx].field_256
                                    mem[_22574 + 64] = stor10[address(arg3)][idx].field_512
                                    mem[_22574 + 96] = stor10[address(arg3)][idx].field_768
                                    mem[s] = _22574
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                if 31 >= uint255(stor10[address(arg3)][idx].field_0) * 0.5:
                                    mem[_22952 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                    mem[_22574] = _22952
                                    mem[_22574 + 32] = stor10[address(arg3)][idx].field_256
                                    mem[_22574 + 64] = stor10[address(arg3)][idx].field_512
                                    mem[_22574 + 96] = stor10[address(arg3)][idx].field_768
                                    mem[s] = _22574
                                    s = s + 32
                                    idx = idx + 1
                                    continue 
                                mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                mem[_22952 + 32] = stor10[address(arg3)][idx].field_0
                                t = _22952 + 32
                                u = sha3(mem[0])
                                while _22952 + (uint255(stor10[address(arg3)][u].field_0) * 0.5) > t:
                                    mem[t + 32] = uint256(stor1[u])
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                mem[_22574] = _22952
                                mem[_22574 + 32] = stor10[address(arg3)][u].field_256
                                mem[_22574 + 64] = stor10[address(arg3)][u].field_512
                                mem[_22574 + 96] = stor10[address(arg3)][u].field_768
                                mem[t] = _22574
                                t = t + 32
                                u = u + 1
                                continue 
                            if not stor10[address(arg3)][idx].field_0 - (stor10[address(arg3)][idx].field_1 < 32):
                                revert with 0, 34
                            if stor10[address(arg3)][idx].field_1:
                                if 31 >= stor10[address(arg3)][idx].field_1:
                                    mem[_22952 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                else:
                                    mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                    mem[_22952 + 32] = stor10[address(arg3)][idx].field_0
                                    t = _22952 + 32
                                    u = sha3(mem[0])
                                    while _22952 + stor10[address(arg3)][idx].field_1 > t:
                                        mem[t + 32] = uint256(stor1[u])
                                        t = t + 32
                                        u = u + 1
                                        continue 
                            mem[_22574] = _22952
                            mem[_22574 + 32] = stor10[address(arg3)][idx].field_256
                            mem[_22574 + 64] = stor10[address(arg3)][idx].field_512
                            mem[_22574 + 96] = stor10[address(arg3)][idx].field_768
                            mem[s] = _22574
                            s = s + 32
                            idx = idx + 1
                            continue 
                        if address(arg1) != address(arg3):
                            if mem[ceil32(ceil32(arg2.length)) + 225] <= 1:
                                if mem[_15320] > 0:
                                    if _referrals[address(arg1)] != address(arg3):
                                        _referrals[address(arg1)] = address(arg3)
                                        sub_989baf69[address(arg3)].field_0++
                                        sub_989baf69[address(arg3)][sub_989baf69[address(arg3)].field_0].field_0 = address(arg1)
                                    if tokenAddress != msg.sender:
                                        if gateKeeperAddress != msg.sender:
                                            if address(stor0.field_0) != msg.sender:
                                                revert with 0, 'NodeManagerV2: NOT AUTHORIZED'
                                    if stor10[stor11[address(arg1)]].field_0:
                                        if not -referralBonusPercent:
                                            sub_e27e434a[stor11[address(arg1)]][address(arg1)] = 0
                                            if sub_666755bb[stor11[address(arg1)]] > -1:
                                                revert with 0, 17
                                        else:
                                            if referralBonusPercent and nodePrice > -1 / referralBonusPercent:
                                                revert with 0, 17
                                            if not referralBonusPercent:
                                                revert with 0, 18
                                            if referralBonusPercent * nodePrice / referralBonusPercent != nodePrice:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            sub_e27e434a[stor11[address(arg1)]][address(arg1)] = referralBonusPercent * nodePrice / 100
                                            if sub_666755bb[stor11[address(arg1)]] > !(referralBonusPercent * nodePrice / 100):
                                                revert with 0, 17
                                            sub_666755bb[stor11[address(arg1)]] += referralBonusPercent * nodePrice / 100
                    else:
                        if msg.sender == gateKeeperAddress:
                            mem[0] = address(arg1)
                            mem[64] = ceil32(ceil32(arg2.length)) + (32 * stor10[address(arg1)].field_0) + 257
                            mem[ceil32(ceil32(arg2.length)) + 225] = stor10[address(arg1)].field_0
                            s = ceil32(ceil32(arg2.length)) + 257
                            idx = 0
                            while idx < stor10[address(arg1)].field_0:
                                mem[0] = sha3(address(arg1), 10)
                                _15326 = mem[64]
                                mem[64] = mem[64] + 128
                                if stor10[address(arg1)][idx].field_0:
                                    if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                                        revert with 0, 34
                                    _15581 = mem[64]
                                    mem[64] = mem[64] + ceil32(uint255(stor10[address(arg1)][idx].field_0) * 0.5) + 32
                                    mem[_15581] = uint255(stor10[address(arg1)][idx].field_0) * 0.5
                                    if stor10[address(arg1)][idx].field_0:
                                        if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                                            revert with 0, 34
                                        if Mask(256, -1, stor10[address(arg1)][idx].field_0):
                                            if 31 >= uint255(stor10[address(arg1)][idx].field_0) * 0.5:
                                                mem[_15581 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                            else:
                                                mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                                mem[_15581 + 32] = stor10[address(arg1)][idx].field_0
                                                t = _15581 + 32
                                                u = sha3(mem[0])
                                                while _15581 + (uint255(stor10[address(arg1)][idx].field_0) * 0.5) > t:
                                                    mem[t + 32] = uint256(stor1[u])
                                                    t = t + 32
                                                    u = u + 1
                                                    continue 
                                        mem[_15326] = _15581
                                        mem[_15326 + 32] = stor10[address(arg1)][idx].field_256
                                        mem[_15326 + 64] = stor10[address(arg1)][idx].field_512
                                        mem[_15326 + 96] = stor10[address(arg1)][idx].field_768
                                        mem[s] = _15326
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                                        revert with 0, 34
                                    if not stor10[address(arg1)][idx].field_1:
                                        mem[_15326] = _15581
                                        mem[_15326 + 32] = stor10[address(arg1)][idx].field_256
                                        mem[_15326 + 64] = stor10[address(arg1)][idx].field_512
                                        mem[_15326 + 96] = stor10[address(arg1)][idx].field_768
                                        mem[s] = _15326
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    if 31 >= stor10[address(arg1)][idx].field_1:
                                        mem[_15581 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                        mem[_15326] = _15581
                                        mem[_15326 + 32] = stor10[address(arg1)][idx].field_256
                                        mem[_15326 + 64] = stor10[address(arg1)][idx].field_512
                                        mem[_15326 + 96] = stor10[address(arg1)][idx].field_768
                                        mem[s] = _15326
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                    mem[_15581 + 32] = stor10[address(arg1)][idx].field_0
                                    t = _15581 + 32
                                    u = sha3(mem[0])
                                    while _15581 + stor10[address(arg1)][u].field_1 > t:
                                        mem[t + 32] = uint256(stor1[u])
                                        t = t + 32
                                        u = u + 1
                                        continue 
                                    mem[_15326] = _15581
                                    mem[_15326 + 32] = stor10[address(arg1)][u].field_256
                                    mem[_15326 + 64] = stor10[address(arg1)][u].field_512
                                    mem[_15326 + 96] = stor10[address(arg1)][u].field_768
                                    mem[t] = _15326
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                                    revert with 0, 34
                                _15688 = mem[64]
                                mem[64] = mem[64] + ceil32(stor10[address(arg1)][idx].field_1) + 32
                                mem[_15688] = stor10[address(arg1)][idx].field_1
                                if stor10[address(arg1)][idx].field_0:
                                    if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                                        revert with 0, 34
                                    if not Mask(256, -1, stor10[address(arg1)][idx].field_0):
                                        mem[_15326] = _15688
                                        mem[_15326 + 32] = stor10[address(arg1)][idx].field_256
                                        mem[_15326 + 64] = stor10[address(arg1)][idx].field_512
                                        mem[_15326 + 96] = stor10[address(arg1)][idx].field_768
                                        mem[s] = _15326
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    if 31 >= uint255(stor10[address(arg1)][idx].field_0) * 0.5:
                                        mem[_15688 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                        mem[_15326] = _15688
                                        mem[_15326 + 32] = stor10[address(arg1)][idx].field_256
                                        mem[_15326 + 64] = stor10[address(arg1)][idx].field_512
                                        mem[_15326 + 96] = stor10[address(arg1)][idx].field_768
                                        mem[s] = _15326
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                    mem[_15688 + 32] = stor10[address(arg1)][idx].field_0
                                    t = _15688 + 32
                                    u = sha3(mem[0])
                                    while _15688 + (uint255(stor10[address(arg1)][u].field_0) * 0.5) > t:
                                        mem[t + 32] = uint256(stor1[u])
                                        t = t + 32
                                        u = u + 1
                                        continue 
                                    mem[_15326] = _15688
                                    mem[_15326 + 32] = stor10[address(arg1)][u].field_256
                                    mem[_15326 + 64] = stor10[address(arg1)][u].field_512
                                    mem[_15326 + 96] = stor10[address(arg1)][u].field_768
                                    mem[t] = _15326
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                                    revert with 0, 34
                                if stor10[address(arg1)][idx].field_1:
                                    if 31 >= stor10[address(arg1)][idx].field_1:
                                        mem[_15688 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                    else:
                                        mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                        mem[_15688 + 32] = stor10[address(arg1)][idx].field_0
                                        t = _15688 + 32
                                        u = sha3(mem[0])
                                        while _15688 + stor10[address(arg1)][idx].field_1 > t:
                                            mem[t + 32] = uint256(stor1[u])
                                            t = t + 32
                                            u = u + 1
                                            continue 
                                mem[_15326] = _15688
                                mem[_15326 + 32] = stor10[address(arg1)][idx].field_256
                                mem[_15326 + 64] = stor10[address(arg1)][idx].field_512
                                mem[_15326 + 96] = stor10[address(arg1)][idx].field_768
                                mem[s] = _15326
                                s = s + 32
                                idx = idx + 1
                                continue 
                            mem[0] = address(arg3)
                            mem[32] = 10
                            _15324 = mem[64]
                            mem[64] = mem[64] + (32 * stor10[address(arg3)].field_0) + 32
                            mem[_15324] = stor10[address(arg3)].field_0
                            s = _15324 + 32
                            idx = 0
                            while idx < stor10[address(arg3)].field_0:
                                mem[0] = sha3(address(arg3), 10)
                                _22576 = mem[64]
                                mem[64] = mem[64] + 128
                                if stor10[address(arg3)][idx].field_0:
                                    if not stor10[address(arg3)][idx].field_0 - (uint255(stor10[address(arg3)][idx].field_0) * 0.5 < 32):
                                        revert with 0, 34
                                    _22811 = mem[64]
                                    mem[64] = mem[64] + ceil32(uint255(stor10[address(arg3)][idx].field_0) * 0.5) + 32
                                    mem[_22811] = uint255(stor10[address(arg3)][idx].field_0) * 0.5
                                    if stor10[address(arg3)][idx].field_0:
                                        if not stor10[address(arg3)][idx].field_0 - (uint255(stor10[address(arg3)][idx].field_0) * 0.5 < 32):
                                            revert with 0, 34
                                        if Mask(256, -1, stor10[address(arg3)][idx].field_0):
                                            if 31 >= uint255(stor10[address(arg3)][idx].field_0) * 0.5:
                                                mem[_22811 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                            else:
                                                mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                                mem[_22811 + 32] = stor10[address(arg3)][idx].field_0
                                                t = _22811 + 32
                                                u = sha3(mem[0])
                                                while _22811 + (uint255(stor10[address(arg3)][idx].field_0) * 0.5) > t:
                                                    mem[t + 32] = uint256(stor1[u])
                                                    t = t + 32
                                                    u = u + 1
                                                    continue 
                                        mem[_22576] = _22811
                                        mem[_22576 + 32] = stor10[address(arg3)][idx].field_256
                                        mem[_22576 + 64] = stor10[address(arg3)][idx].field_512
                                        mem[_22576 + 96] = stor10[address(arg3)][idx].field_768
                                        mem[s] = _22576
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    if not stor10[address(arg3)][idx].field_0 - (stor10[address(arg3)][idx].field_1 < 32):
                                        revert with 0, 34
                                    if not stor10[address(arg3)][idx].field_1:
                                        mem[_22576] = _22811
                                        mem[_22576 + 32] = stor10[address(arg3)][idx].field_256
                                        mem[_22576 + 64] = stor10[address(arg3)][idx].field_512
                                        mem[_22576 + 96] = stor10[address(arg3)][idx].field_768
                                        mem[s] = _22576
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    if 31 >= stor10[address(arg3)][idx].field_1:
                                        mem[_22811 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                        mem[_22576] = _22811
                                        mem[_22576 + 32] = stor10[address(arg3)][idx].field_256
                                        mem[_22576 + 64] = stor10[address(arg3)][idx].field_512
                                        mem[_22576 + 96] = stor10[address(arg3)][idx].field_768
                                        mem[s] = _22576
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                    mem[_22811 + 32] = stor10[address(arg3)][idx].field_0
                                    t = _22811 + 32
                                    u = sha3(mem[0])
                                    while _22811 + stor10[address(arg3)][u].field_1 > t:
                                        mem[t + 32] = uint256(stor1[u])
                                        t = t + 32
                                        u = u + 1
                                        continue 
                                    mem[_22576] = _22811
                                    mem[_22576 + 32] = stor10[address(arg3)][u].field_256
                                    mem[_22576 + 64] = stor10[address(arg3)][u].field_512
                                    mem[_22576 + 96] = stor10[address(arg3)][u].field_768
                                    mem[t] = _22576
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                if not stor10[address(arg3)][idx].field_0 - (stor10[address(arg3)][idx].field_1 < 32):
                                    revert with 0, 34
                                _22954 = mem[64]
                                mem[64] = mem[64] + ceil32(stor10[address(arg3)][idx].field_1) + 32
                                mem[_22954] = stor10[address(arg3)][idx].field_1
                                if stor10[address(arg3)][idx].field_0:
                                    if not stor10[address(arg3)][idx].field_0 - (uint255(stor10[address(arg3)][idx].field_0) * 0.5 < 32):
                                        revert with 0, 34
                                    if not Mask(256, -1, stor10[address(arg3)][idx].field_0):
                                        mem[_22576] = _22954
                                        mem[_22576 + 32] = stor10[address(arg3)][idx].field_256
                                        mem[_22576 + 64] = stor10[address(arg3)][idx].field_512
                                        mem[_22576 + 96] = stor10[address(arg3)][idx].field_768
                                        mem[s] = _22576
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    if 31 >= uint255(stor10[address(arg3)][idx].field_0) * 0.5:
                                        mem[_22954 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                        mem[_22576] = _22954
                                        mem[_22576 + 32] = stor10[address(arg3)][idx].field_256
                                        mem[_22576 + 64] = stor10[address(arg3)][idx].field_512
                                        mem[_22576 + 96] = stor10[address(arg3)][idx].field_768
                                        mem[s] = _22576
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                    mem[_22954 + 32] = stor10[address(arg3)][idx].field_0
                                    t = _22954 + 32
                                    u = sha3(mem[0])
                                    while _22954 + (uint255(stor10[address(arg3)][u].field_0) * 0.5) > t:
                                        mem[t + 32] = uint256(stor1[u])
                                        t = t + 32
                                        u = u + 1
                                        continue 
                                    mem[_22576] = _22954
                                    mem[_22576 + 32] = stor10[address(arg3)][u].field_256
                                    mem[_22576 + 64] = stor10[address(arg3)][u].field_512
                                    mem[_22576 + 96] = stor10[address(arg3)][u].field_768
                                    mem[t] = _22576
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                if not stor10[address(arg3)][idx].field_0 - (stor10[address(arg3)][idx].field_1 < 32):
                                    revert with 0, 34
                                if stor10[address(arg3)][idx].field_1:
                                    if 31 >= stor10[address(arg3)][idx].field_1:
                                        mem[_22954 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                    else:
                                        mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                        mem[_22954 + 32] = stor10[address(arg3)][idx].field_0
                                        t = _22954 + 32
                                        u = sha3(mem[0])
                                        while _22954 + stor10[address(arg3)][idx].field_1 > t:
                                            mem[t + 32] = uint256(stor1[u])
                                            t = t + 32
                                            u = u + 1
                                            continue 
                                mem[_22576] = _22954
                                mem[_22576 + 32] = stor10[address(arg3)][idx].field_256
                                mem[_22576 + 64] = stor10[address(arg3)][idx].field_512
                                mem[_22576 + 96] = stor10[address(arg3)][idx].field_768
                                mem[s] = _22576
                                s = s + 32
                                idx = idx + 1
                                continue 
                            if address(arg1) != address(arg3):
                                if mem[ceil32(ceil32(arg2.length)) + 225] <= 1:
                                    if mem[_15324] > 0:
                                        if _referrals[address(arg1)] != address(arg3):
                                            _referrals[address(arg1)] = address(arg3)
                                            sub_989baf69[address(arg3)].field_0++
                                            sub_989baf69[address(arg3)][sub_989baf69[address(arg3)].field_0].field_0 = address(arg1)
                                        if tokenAddress != msg.sender:
                                            if gateKeeperAddress != msg.sender:
                                                if address(stor0.field_0) != msg.sender:
                                                    revert with 0, 'NodeManagerV2: NOT AUTHORIZED'
                                        if stor10[stor11[address(arg1)]].field_0:
                                            if not -referralBonusPercent:
                                                sub_e27e434a[stor11[address(arg1)]][address(arg1)] = 0
                                                if sub_666755bb[stor11[address(arg1)]] > -1:
                                                    revert with 0, 17
                                            else:
                                                if referralBonusPercent and nodePrice > -1 / referralBonusPercent:
                                                    revert with 0, 17
                                                if not referralBonusPercent:
                                                    revert with 0, 18
                                                if referralBonusPercent * nodePrice / referralBonusPercent != nodePrice:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                sub_e27e434a[stor11[address(arg1)]][address(arg1)] = referralBonusPercent * nodePrice / 100
                                                if sub_666755bb[stor11[address(arg1)]] > !(referralBonusPercent * nodePrice / 100):
                                                    revert with 0, 17
                                                sub_666755bb[stor11[address(arg1)]] += referralBonusPercent * nodePrice / 100
                        else:
                            if address(stor0.field_0) != msg.sender:
                                revert with 0, 'NodeManagerV2: NOT AUTHORIZED'
                            mem[0] = address(arg1)
                            mem[64] = ceil32(ceil32(arg2.length)) + (32 * stor10[address(arg1)].field_0) + 257
                            mem[ceil32(ceil32(arg2.length)) + 225] = stor10[address(arg1)].field_0
                            s = ceil32(ceil32(arg2.length)) + 257
                            idx = 0
                            while idx < stor10[address(arg1)].field_0:
                                mem[0] = sha3(address(arg1), 10)
                                _15330 = mem[64]
                                mem[64] = mem[64] + 128
                                if stor10[address(arg1)][idx].field_0:
                                    if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                                        revert with 0, 34
                                    _15582 = mem[64]
                                    mem[64] = mem[64] + ceil32(uint255(stor10[address(arg1)][idx].field_0) * 0.5) + 32
                                    mem[_15582] = uint255(stor10[address(arg1)][idx].field_0) * 0.5
                                    if stor10[address(arg1)][idx].field_0:
                                        if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                                            revert with 0, 34
                                        if Mask(256, -1, stor10[address(arg1)][idx].field_0):
                                            if 31 >= uint255(stor10[address(arg1)][idx].field_0) * 0.5:
                                                mem[_15582 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                            else:
                                                mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                                mem[_15582 + 32] = stor10[address(arg1)][idx].field_0
                                                t = _15582 + 32
                                                u = sha3(mem[0])
                                                while _15582 + (uint255(stor10[address(arg1)][idx].field_0) * 0.5) > t:
                                                    mem[t + 32] = uint256(stor1[u])
                                                    t = t + 32
                                                    u = u + 1
                                                    continue 
                                        mem[_15330] = _15582
                                        mem[_15330 + 32] = stor10[address(arg1)][idx].field_256
                                        mem[_15330 + 64] = stor10[address(arg1)][idx].field_512
                                        mem[_15330 + 96] = stor10[address(arg1)][idx].field_768
                                        mem[s] = _15330
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                                        revert with 0, 34
                                    if not stor10[address(arg1)][idx].field_1:
                                        mem[_15330] = _15582
                                        mem[_15330 + 32] = stor10[address(arg1)][idx].field_256
                                        mem[_15330 + 64] = stor10[address(arg1)][idx].field_512
                                        mem[_15330 + 96] = stor10[address(arg1)][idx].field_768
                                        mem[s] = _15330
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    if 31 >= stor10[address(arg1)][idx].field_1:
                                        mem[_15582 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                        mem[_15330] = _15582
                                        mem[_15330 + 32] = stor10[address(arg1)][idx].field_256
                                        mem[_15330 + 64] = stor10[address(arg1)][idx].field_512
                                        mem[_15330 + 96] = stor10[address(arg1)][idx].field_768
                                        mem[s] = _15330
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                    mem[_15582 + 32] = stor10[address(arg1)][idx].field_0
                                    t = _15582 + 32
                                    u = sha3(mem[0])
                                    while _15582 + stor10[address(arg1)][u].field_1 > t:
                                        mem[t + 32] = uint256(stor1[u])
                                        t = t + 32
                                        u = u + 1
                                        continue 
                                    mem[_15330] = _15582
                                    mem[_15330 + 32] = stor10[address(arg1)][u].field_256
                                    mem[_15330 + 64] = stor10[address(arg1)][u].field_512
                                    mem[_15330 + 96] = stor10[address(arg1)][u].field_768
                                    mem[t] = _15330
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                                    revert with 0, 34
                                _15690 = mem[64]
                                mem[64] = mem[64] + ceil32(stor10[address(arg1)][idx].field_1) + 32
                                mem[_15690] = stor10[address(arg1)][idx].field_1
                                if stor10[address(arg1)][idx].field_0:
                                    if not stor10[address(arg1)][idx].field_0 - (uint255(stor10[address(arg1)][idx].field_0) * 0.5 < 32):
                                        revert with 0, 34
                                    if not Mask(256, -1, stor10[address(arg1)][idx].field_0):
                                        mem[_15330] = _15690
                                        mem[_15330 + 32] = stor10[address(arg1)][idx].field_256
                                        mem[_15330 + 64] = stor10[address(arg1)][idx].field_512
                                        mem[_15330 + 96] = stor10[address(arg1)][idx].field_768
                                        mem[s] = _15330
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    if 31 >= uint255(stor10[address(arg1)][idx].field_0) * 0.5:
                                        mem[_15690 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                        mem[_15330] = _15690
                                        mem[_15330 + 32] = stor10[address(arg1)][idx].field_256
                                        mem[_15330 + 64] = stor10[address(arg1)][idx].field_512
                                        mem[_15330 + 96] = stor10[address(arg1)][idx].field_768
                                        mem[s] = _15330
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                    mem[_15690 + 32] = stor10[address(arg1)][idx].field_0
                                    t = _15690 + 32
                                    u = sha3(mem[0])
                                    while _15690 + (uint255(stor10[address(arg1)][u].field_0) * 0.5) > t:
                                        mem[t + 32] = uint256(stor1[u])
                                        t = t + 32
                                        u = u + 1
                                        continue 
                                    mem[_15330] = _15690
                                    mem[_15330 + 32] = stor10[address(arg1)][u].field_256
                                    mem[_15330 + 64] = stor10[address(arg1)][u].field_512
                                    mem[_15330 + 96] = stor10[address(arg1)][u].field_768
                                    mem[t] = _15330
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                if not stor10[address(arg1)][idx].field_0 - (stor10[address(arg1)][idx].field_1 < 32):
                                    revert with 0, 34
                                if stor10[address(arg1)][idx].field_1:
                                    if 31 >= stor10[address(arg1)][idx].field_1:
                                        mem[_15690 + 32] = 256 * stor10[address(arg1)][idx].field_8
                                    else:
                                        mem[0] = (4 * idx) + sha3(sha3(address(arg1), 10))
                                        mem[_15690 + 32] = stor10[address(arg1)][idx].field_0
                                        t = _15690 + 32
                                        u = sha3(mem[0])
                                        while _15690 + stor10[address(arg1)][idx].field_1 > t:
                                            mem[t + 32] = uint256(stor1[u])
                                            t = t + 32
                                            u = u + 1
                                            continue 
                                mem[_15330] = _15690
                                mem[_15330 + 32] = stor10[address(arg1)][idx].field_256
                                mem[_15330 + 64] = stor10[address(arg1)][idx].field_512
                                mem[_15330 + 96] = stor10[address(arg1)][idx].field_768
                                mem[s] = _15330
                                s = s + 32
                                idx = idx + 1
                                continue 
                            mem[0] = address(arg3)
                            mem[32] = 10
                            _15328 = mem[64]
                            mem[64] = mem[64] + (32 * stor10[address(arg3)].field_0) + 32
                            mem[_15328] = stor10[address(arg3)].field_0
                            s = _15328 + 32
                            idx = 0
                            while idx < stor10[address(arg3)].field_0:
                                mem[0] = sha3(address(arg3), 10)
                                _22578 = mem[64]
                                mem[64] = mem[64] + 128
                                if stor10[address(arg3)][idx].field_0:
                                    if not stor10[address(arg3)][idx].field_0 - (uint255(stor10[address(arg3)][idx].field_0) * 0.5 < 32):
                                        revert with 0, 34
                                    _22812 = mem[64]
                                    mem[64] = mem[64] + ceil32(uint255(stor10[address(arg3)][idx].field_0) * 0.5) + 32
                                    mem[_22812] = uint255(stor10[address(arg3)][idx].field_0) * 0.5
                                    if stor10[address(arg3)][idx].field_0:
                                        if not stor10[address(arg3)][idx].field_0 - (uint255(stor10[address(arg3)][idx].field_0) * 0.5 < 32):
                                            revert with 0, 34
                                        if Mask(256, -1, stor10[address(arg3)][idx].field_0):
                                            if 31 >= uint255(stor10[address(arg3)][idx].field_0) * 0.5:
                                                mem[_22812 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                            else:
                                                mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                                mem[_22812 + 32] = stor10[address(arg3)][idx].field_0
                                                t = _22812 + 32
                                                u = sha3(mem[0])
                                                while _22812 + (uint255(stor10[address(arg3)][idx].field_0) * 0.5) > t:
                                                    mem[t + 32] = uint256(stor1[u])
                                                    t = t + 32
                                                    u = u + 1
                                                    continue 
                                        mem[_22578] = _22812
                                        mem[_22578 + 32] = stor10[address(arg3)][idx].field_256
                                        mem[_22578 + 64] = stor10[address(arg3)][idx].field_512
                                        mem[_22578 + 96] = stor10[address(arg3)][idx].field_768
                                        mem[s] = _22578
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    if not stor10[address(arg3)][idx].field_0 - (stor10[address(arg3)][idx].field_1 < 32):
                                        revert with 0, 34
                                    if not stor10[address(arg3)][idx].field_1:
                                        mem[_22578] = _22812
                                        mem[_22578 + 32] = stor10[address(arg3)][idx].field_256
                                        mem[_22578 + 64] = stor10[address(arg3)][idx].field_512
                                        mem[_22578 + 96] = stor10[address(arg3)][idx].field_768
                                        mem[s] = _22578
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    if 31 >= stor10[address(arg3)][idx].field_1:
                                        mem[_22812 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                        mem[_22578] = _22812
                                        mem[_22578 + 32] = stor10[address(arg3)][idx].field_256
                                        mem[_22578 + 64] = stor10[address(arg3)][idx].field_512
                                        mem[_22578 + 96] = stor10[address(arg3)][idx].field_768
                                        mem[s] = _22578
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                    mem[_22812 + 32] = stor10[address(arg3)][idx].field_0
                                    t = _22812 + 32
                                    u = sha3(mem[0])
                                    while _22812 + stor10[address(arg3)][u].field_1 > t:
                                        mem[t + 32] = uint256(stor1[u])
                                        t = t + 32
                                        u = u + 1
                                        continue 
                                    mem[_22578] = _22812
                                    mem[_22578 + 32] = stor10[address(arg3)][u].field_256
                                    mem[_22578 + 64] = stor10[address(arg3)][u].field_512
                                    mem[_22578 + 96] = stor10[address(arg3)][u].field_768
                                    mem[t] = _22578
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                if not stor10[address(arg3)][idx].field_0 - (stor10[address(arg3)][idx].field_1 < 32):
                                    revert with 0, 34
                                _22956 = mem[64]
                                mem[64] = mem[64] + ceil32(stor10[address(arg3)][idx].field_1) + 32
                                mem[_22956] = stor10[address(arg3)][idx].field_1
                                if stor10[address(arg3)][idx].field_0:
                                    if not stor10[address(arg3)][idx].field_0 - (uint255(stor10[address(arg3)][idx].field_0) * 0.5 < 32):
                                        revert with 0, 34
                                    if not Mask(256, -1, stor10[address(arg3)][idx].field_0):
                                        mem[_22578] = _22956
                                        mem[_22578 + 32] = stor10[address(arg3)][idx].field_256
                                        mem[_22578 + 64] = stor10[address(arg3)][idx].field_512
                                        mem[_22578 + 96] = stor10[address(arg3)][idx].field_768
                                        mem[s] = _22578
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    if 31 >= uint255(stor10[address(arg3)][idx].field_0) * 0.5:
                                        mem[_22956 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                        mem[_22578] = _22956
                                        mem[_22578 + 32] = stor10[address(arg3)][idx].field_256
                                        mem[_22578 + 64] = stor10[address(arg3)][idx].field_512
                                        mem[_22578 + 96] = stor10[address(arg3)][idx].field_768
                                        mem[s] = _22578
                                        s = s + 32
                                        idx = idx + 1
                                        continue 
                                    mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                    mem[_22956 + 32] = stor10[address(arg3)][idx].field_0
                                    t = _22956 + 32
                                    u = sha3(mem[0])
                                    while _22956 + (uint255(stor10[address(arg3)][u].field_0) * 0.5) > t:
                                        mem[t + 32] = uint256(stor1[u])
                                        t = t + 32
                                        u = u + 1
                                        continue 
                                    mem[_22578] = _22956
                                    mem[_22578 + 32] = stor10[address(arg3)][u].field_256
                                    mem[_22578 + 64] = stor10[address(arg3)][u].field_512
                                    mem[_22578 + 96] = stor10[address(arg3)][u].field_768
                                    mem[t] = _22578
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                if not stor10[address(arg3)][idx].field_0 - (stor10[address(arg3)][idx].field_1 < 32):
                                    revert with 0, 34
                                if stor10[address(arg3)][idx].field_1:
                                    if 31 >= stor10[address(arg3)][idx].field_1:
                                        mem[_22956 + 32] = 256 * stor10[address(arg3)][idx].field_8
                                    else:
                                        mem[0] = (4 * idx) + sha3(sha3(address(arg3), 10))
                                        mem[_22956 + 32] = stor10[address(arg3)][idx].field_0
                                        t = _22956 + 32
                                        u = sha3(mem[0])
                                        while _22956 + stor10[address(arg3)][idx].field_1 > t:
                                            mem[t + 32] = uint256(stor1[u])
                                            t = t + 32
                                            u = u + 1
                                            continue 
                                mem[_22578] = _22956
                                mem[_22578 + 32] = stor10[address(arg3)][idx].field_256
                                mem[_22578 + 64] = stor10[address(arg3)][idx].field_512
                                mem[_22578 + 96] = stor10[address(arg3)][idx].field_768
                                mem[s] = _22578
                                s = s + 32
                                idx = idx + 1
                                continue 
                            if address(arg1) != address(arg3):
                                if mem[ceil32(ceil32(arg2.length)) + 225] <= 1:
                                    if mem[_15328] > 0:
                                        if _referrals[address(arg1)] != address(arg3):
                                            _referrals[address(arg1)] = address(arg3)
                                            sub_989baf69[address(arg3)].field_0++
                                            sub_989baf69[address(arg3)][sub_989baf69[address(arg3)].field_0].field_0 = address(arg1)
                                        if tokenAddress != msg.sender:
                                            if gateKeeperAddress != msg.sender:
                                                if address(stor0.field_0) != msg.sender:
                                                    revert with 0, 'NodeManagerV2: NOT AUTHORIZED'
                                        if stor10[stor11[address(arg1)]].field_0:
                                            if not -referralBonusPercent:
                                                sub_e27e434a[stor11[address(arg1)]][address(arg1)] = 0
                                                if sub_666755bb[stor11[address(arg1)]] > -1:
                                                    revert with 0, 17
                                            else:
                                                if referralBonusPercent and nodePrice > -1 / referralBonusPercent:
                                                    revert with 0, 17
                                                if not referralBonusPercent:
                                                    revert with 0, 18
                                                if referralBonusPercent * nodePrice / referralBonusPercent != nodePrice:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                sub_e27e434a[stor11[address(arg1)]][address(arg1)] = referralBonusPercent * nodePrice / 100
                                                if sub_666755bb[stor11[address(arg1)]] > !(referralBonusPercent * nodePrice / 100):
                                                    revert with 0, 17
                                                sub_666755bb[stor11[address(arg1)]] += referralBonusPercent * nodePrice / 100
}



}

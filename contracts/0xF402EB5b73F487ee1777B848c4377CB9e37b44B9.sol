contract main {




// =====================  Runtime code  =====================


#
#  - sub_0df5eb53(?)
#  - sub_20802c7e(?)
#  - sub_85cd4366(?)
#  - _fallback()
#
address owner;
array of address stor1;
uint256 totalReleased;
mapping of uint256 shares;
mapping of uint256 released;
array of address payee;
mapping of uint256 totalReleased;
mapping of uint256 released;
address uniswapV2RouterAddress;
address stor9;
address uniswapV2PairAddress;
address futurUsePoolAddress;
address distributionPoolAddress;
address deadWalletAddress;
uint256 rewardsFee;
uint256 liquidityPoolFee;
uint256 futurFee;
uint256 totalFees;
uint256 cashoutFee;
uint256 stor19;
uint8 stor20; offset 8
uint256 stor20; offset 8
uint256 swapTokensAmount;
mapping of uint8 stor22;
mapping of uint8 stor23;
mapping of struct stor24;
array of struct stor25;
mapping of struct stor99;
array of struct stor67072331549493647622825787457569556318728415786901242217649037894484240406165;

function totalFees() {
    return totalFees
}

function uniswapV2Router() {
    return uniswapV2RouterAddress
}

function _isBlacklisted(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    return bool(stor22[arg1])
}

function rewardsFee() {
    return rewardsFee
}

function totalShares() {
    return stor1.length
}

function released(address arg1, address arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require arg2 == arg2
    return released[address(arg1)][address(arg2)]
}

function uniswapV2Pair() {
    return uniswapV2PairAddress
}

function liquidityPoolFee() {
    return liquidityPoolFee
}

function swapTokensAmount() {
    return swapTokensAmount
}

function cashoutFee() {
    return cashoutFee
}

function deadWallet() {
    return deadWalletAddress
}

function payee(uint256 arg1) {
    require calldata.size - 4 >= 32
    if arg1 >= payee.length:
        revert with 0, 50
    return payee[arg1]
}

function owner() {
    return owner
}

function released(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    return released[address(arg1)]
}

function futurUsePool() {
    return futurUsePoolAddress
}

function futurFee() {
    return futurFee
}

function automatedMarketMakerPairs(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    return bool(stor23[arg1])
}

function distributionPool() {
    return distributionPoolAddress
}

function shares(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    return shares[address(arg1)]
}

function totalReleased(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    return totalReleased[address(arg1)]
}

function totalReleased() {
    return totalReleased
}

function renounceOwnership() {
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    emit OwnershipTransferred(owner, 0);
    owner = 0
}

function updateRwSwapFee(uint256 arg1) {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    stor19 = arg1
}

function updateCashoutFee(uint256 arg1) {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    cashoutFee = arg1
}

function updateSwapTokensAmount(uint256 arg1) {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    swapTokensAmount = arg1
}

function updateFuturWall(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    futurUsePoolAddress = arg1
}

function updateRewardsWall(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    distributionPoolAddress = arg1
}

function changeSwapLiquify(bool arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    Mask(248, 0, stor20) = Mask(248, 0, arg1)
}

function blacklistMalicious(address arg1, bool arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require arg2 == arg2
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    stor22[address(arg1)] = uint8(arg2)
}

function transferOwnership(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Ownable: new owner is the zero address'
    emit OwnershipTransferred(owner, arg1);
    owner = arg1
}

function boostReward(uint256 arg1) {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if arg1 <= eth.balance(this.address):
        call owner with:
           value arg1 wei
             gas 2300 * is_zero(value) wei
    else:
        call owner with:
           value eth.balance(this.address) wei
             gas 2300 * is_zero(value) wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
}

function updateLiquiditFee(uint256 arg1) {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    liquidityPoolFee = arg1
    if rewardsFee > !arg1:
        revert with 0, 17
    if rewardsFee + arg1 < rewardsFee:
        revert with 0, 'SafeMath: addition overflow'
    if rewardsFee + arg1 > !futurFee:
        revert with 0, 17
    if futurFee < 0:
        revert with 0, 'SafeMath: addition overflow'
    totalFees = rewardsFee + arg1 + futurFee
}

function updateRewardsFee(uint256 arg1) {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    rewardsFee = arg1
    if arg1 > !liquidityPoolFee:
        revert with 0, 17
    if arg1 + liquidityPoolFee < arg1:
        revert with 0, 'SafeMath: addition overflow'
    if arg1 + liquidityPoolFee > !futurFee:
        revert with 0, 17
    if futurFee < 0:
        revert with 0, 'SafeMath: addition overflow'
    totalFees = arg1 + liquidityPoolFee + futurFee
}

function updateFuturFee(uint256 arg1) {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    futurFee = arg1
    if rewardsFee > !liquidityPoolFee:
        revert with 0, 17
    if rewardsFee + liquidityPoolFee < rewardsFee:
        revert with 0, 'SafeMath: addition overflow'
    if rewardsFee + liquidityPoolFee > !arg1:
        revert with 0, 17
    if arg1 < 0:
        revert with 0, 'SafeMath: addition overflow'
    totalFees = rewardsFee + liquidityPoolFee + arg1
}

function setAutomatedMarketMakerPair(address arg1, bool arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require arg2 == arg2
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if uniswapV2PairAddress == arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    'TKN: The PancakeSwap pair cannot be removed from automatedMarketMakerPairs'
    if arg2 == bool(stor23[address(arg1)]):
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    'TKN: Automated market maker pair is already set to that value'
    stor23[address(arg1)] = uint8(arg2)
    emit SetAutomatedMarketMakerPair(arg1, arg2);
}

function updateUniswapV2Router(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if uniswapV2RouterAddress == arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'TKN: The router already has that address'
    emit UpdateUniswapV2Router(arg1, uniswapV2RouterAddress);
    uniswapV2RouterAddress = arg1
    require ext_code.size(arg1)
    staticcall arg1.factory() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    require ext_code.size(uniswapV2RouterAddress)
    staticcall uniswapV2RouterAddress.0x73b295c2 with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    require ext_code.size(address(ext_call.return_data[0]))
    call address(ext_call.return_data[0]).createPair(address arg1, address arg2) with:
         gas gas_remaining wei
        args address(this.address), address(ext_call.return_data[0])
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    uniswapV2PairAddress = ext_call.return_data[12 len 20]
}

function release(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if not shares[address(arg1)]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'PaymentSplitter: account has no shares'
    if eth.balance(this.address) > !totalReleased:
        revert with 0, 17
    if eth.balance(this.address) + totalReleased and shares[address(arg1)] > -1 / eth.balance(this.address) + totalReleased:
        revert with 0, 17
    if not stor1.length:
        revert with 0, 18
    if (eth.balance(this.address) * shares[address(arg1)]) + (totalReleased * shares[address(arg1)]) / stor1.length < released[address(arg1)]:
        revert with 0, 17
    if not ((eth.balance(this.address) * shares[address(arg1)]) + (totalReleased * shares[address(arg1)]) / stor1.length) - released[address(arg1)]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'PaymentSplitter: account is not due payment'
    if released[address(arg1)] > !(((eth.balance(this.address) * shares[address(arg1)]) + (totalReleased * shares[address(arg1)]) / stor1.length) - released[address(arg1)]):
        revert with 0, 17
    released[address(arg1)] = (eth.balance(this.address) * shares[address(arg1)]) + (totalReleased * shares[address(arg1)]) / stor1.length
    if totalReleased > !(((eth.balance(this.address) * shares[address(arg1)]) + (totalReleased * shares[address(arg1)]) / stor1.length) - released[address(arg1)]):
        revert with 0, 17
    totalReleased = totalReleased + ((eth.balance(this.address) * shares[address(arg1)]) + (totalReleased * shares[address(arg1)]) / stor1.length) - released[address(arg1)]
    if eth.balance(this.address) < ((eth.balance(this.address) * shares[address(arg1)]) + (totalReleased * shares[address(arg1)]) / stor1.length) - released[address(arg1)]:
        revert with 0, 'Address: insufficient balance'
    call arg1 with:
       value ((eth.balance(this.address) * shares[address(arg1)]) + (totalReleased * shares[address(arg1)]) / stor1.length) - released[address(arg1)] wei
         gas gas_remaining wei
    if not return_data.size:
        if not ext_call.success:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        'Address: unable to send value, recipient may have reverted'
    else:
        if not ext_call.success:
            revert with 0, 'Address: unable to send value, recipient may have reverted'
    ('bool', 'ext_call.success')
    emit PaymentReleased(address(arg1), ((eth.balance(this.address) * shares[address(arg1)]) + (totalReleased * shares[address(arg1)]) / stor1.length) - released[address(arg1)]);
}

function sub_fe551b05(?) {
    require calldata.size - 4 >= 32
    require arg1 <= test266151307()
    require arg1 + 35 < calldata.size
    if arg1.length > test266151307():
        revert with 0, 65
    if ceil32(ceil32(arg1.length)) + 97 < 96 or ceil32(ceil32(arg1.length)) + 97 > test266151307():
        revert with 0, 65
    require arg1 + arg1.length + 36 <= calldata.size
    mem[arg1.length + 128] = 0
    if bool(stor24[arg1[all]].field_0):
        if bool(stor24[arg1[all]].field_0) == uint255(uint256(stor24[arg1[all]].field_0)) * 0.5 < 32:
            revert with 0, 34
        if bool(stor24[arg1[all]].field_0):
            if bool(stor24[arg1[all]].field_0) == uint255(uint256(stor24[arg1[all]].field_0)) * 0.5 < 32:
                revert with 0, 34
            if Mask(256, -1, uint256(stor24[arg1[all]].field_0)):
                if 31 >= uint255(uint256(stor24[arg1[all]].field_0)) * 0.5:
                    mem[ceil32(ceil32(arg1.length)) + 129] = 256 * Mask(248, 0, stor24[arg1[all]].field_8)
                else:
                    mem[ceil32(ceil32(arg1.length)) + 129] = uint256(stor24[arg1[all]].field_0)
                    idx = ceil32(ceil32(arg1.length)) + 129
                    s = 0
                    while ceil32(ceil32(arg1.length)) + (uint255(uint256(stor24[arg1[all]].field_0)) * 0.5) + 97 > idx:
                        mem[idx + 32] = uint256(stor24[arg1[all]][s].field_256)
                        idx = idx + 32
                        s = s + 1
                        continue 
        else:
            if bool(stor24[arg1[all]].field_0) == stor24[arg1[all]].field_1 % 128 < 32:
                revert with 0, 34
            if stor24[arg1[all]].field_1 % 128:
                if 31 >= stor24[arg1[all]].field_1 % 128:
                    mem[ceil32(ceil32(arg1.length)) + 129] = 256 * Mask(248, 0, stor24[arg1[all]].field_8)
                else:
                    mem[ceil32(ceil32(arg1.length)) + 129] = uint256(stor24[arg1[all]].field_0)
                    idx = ceil32(ceil32(arg1.length)) + 129
                    s = 0
                    while ceil32(ceil32(arg1.length)) + stor24[arg1[all]].field_1 % 128 + 97 > idx:
                        mem[idx + 32] = uint256(stor24[arg1[all]][s].field_256)
                        idx = idx + 32
                        s = s + 1
                        continue 
        return Array(len=2 * Mask(256, -1, uint256(stor24[arg1[all]].field_0)), data=mem[ceil32(ceil32(arg1.length)) + 129 len ceil32(uint255(uint256(stor24[arg1[all]].field_0)) * 0.5)]), 
               address(stor24[arg1[all]].field_256)
    if bool(stor24[arg1[all]].field_0) == stor24[arg1[all]].field_1 % 128 < 32:
        revert with 0, 34
    if bool(stor24[arg1[all]].field_0):
        if bool(stor24[arg1[all]].field_0) == uint255(uint256(stor24[arg1[all]].field_0)) * 0.5 < 32:
            revert with 0, 34
        if Mask(256, -1, uint256(stor24[arg1[all]].field_0)):
            if 31 >= uint255(uint256(stor24[arg1[all]].field_0)) * 0.5:
                mem[ceil32(ceil32(arg1.length)) + 129] = 256 * Mask(248, 0, stor24[arg1[all]].field_8)
            else:
                mem[ceil32(ceil32(arg1.length)) + 129] = uint256(stor24[arg1[all]].field_0)
                idx = ceil32(ceil32(arg1.length)) + 129
                s = 0
                while ceil32(ceil32(arg1.length)) + (uint255(uint256(stor24[arg1[all]].field_0)) * 0.5) + 97 > idx:
                    mem[idx + 32] = uint256(stor24[arg1[all]][s].field_256)
                    idx = idx + 32
                    s = s + 1
                    continue 
    else:
        if bool(stor24[arg1[all]].field_0) == stor24[arg1[all]].field_1 % 128 < 32:
            revert with 0, 34
        if stor24[arg1[all]].field_1 % 128:
            if 31 >= stor24[arg1[all]].field_1 % 128:
                mem[ceil32(ceil32(arg1.length)) + 129] = 256 * Mask(248, 0, stor24[arg1[all]].field_8)
            else:
                mem[ceil32(ceil32(arg1.length)) + 129] = uint256(stor24[arg1[all]].field_0)
                idx = ceil32(ceil32(arg1.length)) + 129
                s = 0
                while ceil32(ceil32(arg1.length)) + stor24[arg1[all]].field_1 % 128 + 97 > idx:
                    mem[idx + 32] = uint256(stor24[arg1[all]][s].field_256)
                    idx = idx + 32
                    s = s + 1
                    continue 
    return Array(len=stor24[arg1[all]].field_0 % 128, data=mem[ceil32(ceil32(arg1.length)) + 129 len ceil32(stor24[arg1[all]].field_1 % 128)]), 
           address(stor24[arg1[all]].field_256)
}

function allTiers(uint256 arg1) {
    require calldata.size - 4 >= 32
    require arg1 < stor25.length
    if bool(stor25[arg1].field_0):
        if bool(stor25[arg1].field_0) == uint255(uint256(stor25[arg1].field_0)) * 0.5 < 32:
            revert with 0, 34
        if bool(stor25[arg1].field_0):
            if bool(stor25[arg1].field_0) == uint255(uint256(stor25[arg1].field_0)) * 0.5 < 32:
                revert with 0, 34
            if Mask(256, -1, uint256(stor25[arg1].field_0)):
                if 31 < uint255(uint256(stor25[arg1].field_0)) * 0.5:
                    mem[128] = uint256(stor25[arg1].field_0)
                    idx = 128
                    s = 0
                    while (uint255(uint256(stor25[arg1].field_0)) * 0.5) + 96 > idx:
                        mem[idx + 32] = uint256(stor25[arg1 + s].field_256)
                        idx = idx + 32
                        s = s + 1
                        continue 
                    return Array(len=2 * Mask(256, -1, uint256(stor25[arg1].field_0)), data=mem[128 len ceil32(uint255(uint256(stor25[arg1].field_0)) * 0.5)]), 
                mem[128] = 256 * Mask(248, 0, stor25[arg1].field_8)
        else:
            if bool(stor25[arg1].field_0) == stor25[arg1].field_1 % 128 < 32:
                revert with 0, 34
            if stor25[arg1].field_1 % 128:
                if 31 < stor25[arg1].field_1 % 128:
                    mem[128] = uint256(stor25[arg1].field_0)
                    idx = 128
                    s = 0
                    while stor25[arg1].field_1 % 128 + 96 > idx:
                        mem[idx + 32] = uint256(stor25[arg1 + s].field_256)
                        idx = idx + 32
                        s = s + 1
                        continue 
                    return Array(len=2 * Mask(256, -1, uint256(stor25[arg1].field_0)), data=mem[128 len ceil32(uint255(uint256(stor25[arg1].field_0)) * 0.5)]), 
                mem[128] = 256 * Mask(248, 0, stor25[arg1].field_8)
        mem[ceil32(uint255(uint256(stor25[arg1].field_0)) * 0.5) + 192 len ceil32(uint255(uint256(stor25[arg1].field_0)) * 0.5)] = mem[128 len ceil32(uint255(uint256(stor25[arg1].field_0)) * 0.5)]
        if ceil32(uint255(uint256(stor25[arg1].field_0)) * 0.5) > uint255(uint256(stor25[arg1].field_0)) * 0.5:
            mem[ceil32(uint255(uint256(stor25[arg1].field_0)) * 0.5) + (uint255(uint256(stor25[arg1].field_0)) * 0.5) + 192] = 0
        return Array(len=2 * Mask(256, -1, uint256(stor25[arg1].field_0)), data=mem[128 len ceil32(uint255(uint256(stor25[arg1].field_0)) * 0.5)], mem[(2 * ceil32(uint255(uint256(stor25[arg1].field_0)) * 0.5)) + 192 len 2 * ceil32(uint255(uint256(stor25[arg1].field_0)) * 0.5)]), 
    if bool(stor25[arg1].field_0) == stor25[arg1].field_1 % 128 < 32:
        revert with 0, 34
    if bool(stor25[arg1].field_0):
        if bool(stor25[arg1].field_0) == uint255(uint256(stor25[arg1].field_0)) * 0.5 < 32:
            revert with 0, 34
        if Mask(256, -1, uint256(stor25[arg1].field_0)):
            if 31 < uint255(uint256(stor25[arg1].field_0)) * 0.5:
                mem[128] = uint256(stor25[arg1].field_0)
                idx = 128
                s = 0
                while (uint255(uint256(stor25[arg1].field_0)) * 0.5) + 96 > idx:
                    mem[idx + 32] = uint256(stor25[arg1 + s].field_256)
                    idx = idx + 32
                    s = s + 1
                    continue 
                return Array(len=stor25[arg1].field_0 % 128, data=mem[128 len ceil32(stor25[arg1].field_1 % 128)])
            mem[128] = 256 * Mask(248, 0, stor25[arg1].field_8)
    else:
        if bool(stor25[arg1].field_0) == stor25[arg1].field_1 % 128 < 32:
            revert with 0, 34
        if stor25[arg1].field_1 % 128:
            if 31 < stor25[arg1].field_1 % 128:
                mem[128] = uint256(stor25[arg1].field_0)
                idx = 128
                s = 0
                while stor25[arg1].field_1 % 128 + 96 > idx:
                    mem[idx + 32] = uint256(stor25[arg1 + s].field_256)
                    idx = idx + 32
                    s = s + 1
                    continue 
                return Array(len=stor25[arg1].field_0 % 128, data=mem[128 len ceil32(stor25[arg1].field_1 % 128)])
            mem[128] = 256 * Mask(248, 0, stor25[arg1].field_8)
    mem[ceil32(stor25[arg1].field_1 % 128) + 192 len ceil32(stor25[arg1].field_1 % 128)] = mem[128 len ceil32(stor25[arg1].field_1 % 128)]
    if ceil32(stor25[arg1].field_1 % 128) > stor25[arg1].field_1 % 128:
        mem[ceil32(stor25[arg1].field_1 % 128) + stor25[arg1].field_1 % 128 + 192] = 0
    return Array(len=stor25[arg1].field_0 % 128, data=mem[128 len ceil32(stor25[arg1].field_1 % 128)], mem[(2 * ceil32(stor25[arg1].field_1 % 128)) + 192 len 2 * ceil32(stor25[arg1].field_1 % 128)]), 
}

function release(address arg1, address arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require arg2 == arg2
    if not shares[address(arg2)]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'PaymentSplitter: account has no shares'
    mem[100] = this.address
    require ext_code.size(arg1)
    staticcall arg1.0x70a08231 with:
            gas gas_remaining wei
           args this.address
    mem[96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if ext_call.return_data[0] > !totalReleased[address(arg1)]:
        revert with 0, 17
    if ext_call.return_data[0] + totalReleased[address(arg1)] and shares[address(arg2)] > -1 / ext_call.return_data[0] + totalReleased[address(arg1)]:
        revert with 0, 17
    if not stor1.length:
        revert with 0, 18
    if (ext_call.return_data[0] * shares[address(arg2)]) + (totalReleased[address(arg1)] * shares[address(arg2)]) / stor1.length < released[address(arg1)][address(arg2)]:
        revert with 0, 17
    if not ((ext_call.return_data[0] * shares[address(arg2)]) + (totalReleased[address(arg1)] * shares[address(arg2)]) / stor1.length) - released[address(arg1)][address(arg2)]:
        revert with 0, 'PaymentSplitter: account is not due payment'
    if released[address(arg1)][address(arg2)] > !(((ext_call.return_data[0] * shares[address(arg2)]) + (totalReleased[address(arg1)] * shares[address(arg2)]) / stor1.length) - released[address(arg1)][address(arg2)]):
        revert with 0, 17
    released[address(arg1)][address(arg2)] = (ext_call.return_data[0] * shares[address(arg2)]) + (totalReleased[address(arg1)] * shares[address(arg2)]) / stor1.length
    if totalReleased[address(arg1)] > !(((ext_call.return_data[0] * shares[address(arg2)]) + (totalReleased[address(arg1)] * shares[address(arg2)]) / stor1.length) - released[address(arg1)][address(arg2)]):
        revert with 0, 17
    totalReleased[address(arg1)] = totalReleased[address(arg1)] + ((ext_call.return_data[0] * shares[address(arg2)]) + (totalReleased[address(arg1)] * shares[address(arg2)]) / stor1.length) - released[address(arg1)][address(arg2)]
    mem[ceil32(return_data.size) + 132] = arg2
    mem[ceil32(return_data.size) + 164] = ((ext_call.return_data[0] * shares[address(arg2)]) + (totalReleased[address(arg1)] * shares[address(arg2)]) / stor1.length) - released[address(arg1)][address(arg2)]
    mem[ceil32(return_data.size) + 96] = 68
    mem[ceil32(return_data.size) + 132 len 28] = address(arg2) << 64
    mem[ceil32(return_data.size) + 128 len 4] = unknown_0xa9059cbb(?????)
    mem[ceil32(return_data.size) + 196] = 32
    mem[ceil32(return_data.size) + 228] = 'SafeERC20: low-level call failed'
    if not ext_code.size(arg1):
        revert with 0, 'Address: call to non-contract'
    mem[ceil32(return_data.size) + 260 len 96] = unknown_0xa9059cbb(?????), address(arg2) << 64, 0, ((ext_call.return_data[0] * shares[address(arg2)]) + (totalReleased[address(arg1)] * shares[address(arg2)]) / stor1.length) - released[address(arg1)][address(arg2)], 0
    mem[ceil32(return_data.size) + 328] = 0
    call arg1 with:
       funct Mask(32, 224, unknown_0xa9059cbb(?????), address(arg2) << 64, 0, ((ext_call.return_data[0] * shares[address(arg2)]) + (totalReleased[address(arg1)] * shares[address(arg2)]) / stor1.length) - released[address(arg1)][address(arg2)], 0) >> 224
         gas gas_remaining wei
        args (Mask(512, -288, unknown_0xa9059cbb(?????), address(arg2) << 64, 0, ((ext_call.return_data[0] * shares[address(arg2)]) + (totalReleased[address(arg1)] * shares[address(arg2)]) / stor1.length) - released[address(arg1)][address(arg2)], 0) << 288)
    if not return_data.size:
        if not ext_call.success:
            if ext_call.return_data[0]:
                revert with memory
                  from 128
                   len ext_call.return_data[0]
            revert with 0, 'SafeERC20: low-level call failed'
        if ext_call.return_data[0]:
            require ext_call.return_data[0] >= 32
            require uint32(this.address), mem[132 len 28] == bool(uint32(this.address), mem[132 len 28])
            if not uint32(this.address), mem[132 len 28]:
                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
    else:
        mem[ceil32(return_data.size) + 292 len return_data.size] = ext_call.return_data[0 len return_data.size]
        if not ext_call.success:
            if return_data.size:
                revert with ext_call.return_data[0 len return_data.size]
            revert with 0, 'SafeERC20: low-level call failed'
        if return_data.size:
            require return_data.size >= 32
            require mem[ceil32(return_data.size) + 292] == bool(mem[ceil32(return_data.size) + 292])
            if not mem[ceil32(return_data.size) + 292]:
                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
    emit ERC20PaymentReleased(address(arg2), ((ext_call.return_data[0] * shares[address(arg2)]) + (totalReleased[address(arg1)] * shares[address(arg2)]) / stor1.length) - released[address(arg1)][address(arg2)], arg1);
}

function sub_ccb0de18(?) {
    require calldata.size - 4 >= 64
    require arg2 <= test266151307()
    require arg2 + 35 < calldata.size
    if arg2.length > test266151307():
        revert with 0, 65
    if ceil32(ceil32(arg2.length)) + 97 < 96 or ceil32(ceil32(arg2.length)) + 97 > test266151307():
        revert with 0, 65
    mem[96] = arg2.length
    require arg2 + arg2.length + 36 <= calldata.size
    mem[128 len arg2.length] = arg2[all]
    mem[arg2.length + 128] = 0
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    mem[ceil32(ceil32(arg2.length)) + 97 len ceil32(arg2.length)] = arg2[all], mem[arg2.length + 128 len ceil32(arg2.length) - arg2.length]
    mem[arg2.length + ceil32(ceil32(arg2.length)) + 97] = 24
    if ceil32(arg2.length) <= arg2.length:
        _99 = sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])
        if bool(stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_0):
            if bool(stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_0) == uint255(uint256(stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_0)) * 0.5 < 32:
                revert with 0, 34
        else:
            if bool(stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_0) == stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_1 % 128 < 32:
                revert with 0, 34
        if bool(stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_0):
            if bool(stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_0) == uint255(uint256(stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_0)) * 0.5 < 32:
                revert with 0, 34
            if not Mask(256, -1, uint256(stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_0)):
                require ext_code.size(address(stor1[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])]))
                call address(stor1[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])])._changeClaimTime(uint256 arg1) with:
                     gas gas_remaining wei
                    args arg1
            else:
                if 31 >= uint255(uint256(stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_0)) * 0.5:
                    require ext_code.size(address(stor1[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])]))
                    call address(stor1[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])])._changeClaimTime(uint256 arg1) with:
                         gas gas_remaining wei
                        args arg1
                else:
                    idx = ceil32(ceil32(arg2.length)) + 193
                    s = 0
                    while ceil32(ceil32(arg2.length)) + (uint255(uint256(stor[_99].field_0)) * 0.5) + 161 > idx:
                        mem[idx + 32] = uint256(stor[s + sha3(_99) + 1].field_0)
                        idx = idx + 32
                        s = s + 1
                        continue 
                    require ext_code.size(address(stor1[_99]))
                    call address(stor1[_99])._changeClaimTime(uint256 arg1) with:
                         gas gas_remaining wei
                        args arg1
        else:
            if bool(stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_0) == stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_1 % 128 < 32:
                revert with 0, 34
            if not stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_1 % 128:
                require ext_code.size(address(stor1[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])]))
                call address(stor1[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])])._changeClaimTime(uint256 arg1) with:
                     gas gas_remaining wei
                    args arg1
            else:
                if 31 >= stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_1 % 128:
                    require ext_code.size(address(stor1[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])]))
                    call address(stor1[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])])._changeClaimTime(uint256 arg1) with:
                         gas gas_remaining wei
                        args arg1
                else:
                    idx = ceil32(ceil32(arg2.length)) + 193
                    s = 0
                    while ceil32(ceil32(arg2.length)) + stor[_99].field_1 % 128 + 161 > idx:
                        mem[idx + 32] = uint256(stor[s + sha3(_99) + 1].field_0)
                        idx = idx + 32
                        s = s + 1
                        continue 
                    require ext_code.size(address(stor1[_99]))
                    call address(stor1[_99])._changeClaimTime(uint256 arg1) with:
                         gas gas_remaining wei
                        args arg1
    else:
        _102 = sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])
        if bool(stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_0):
            if bool(stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_0) == uint255(uint256(stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_0)) * 0.5 < 32:
                revert with 0, 34
        else:
            if bool(stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_0) == stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_1 % 128 < 32:
                revert with 0, 34
        if bool(stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_0):
            if bool(stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_0) == uint255(uint256(stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_0)) * 0.5 < 32:
                revert with 0, 34
            if not Mask(256, -1, uint256(stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_0)):
                require ext_code.size(address(stor1[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])]))
                call address(stor1[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])])._changeClaimTime(uint256 arg1) with:
                     gas gas_remaining wei
                    args arg1
            else:
                if 31 >= uint255(uint256(stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_0)) * 0.5:
                    require ext_code.size(address(stor1[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])]))
                    call address(stor1[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])])._changeClaimTime(uint256 arg1) with:
                         gas gas_remaining wei
                        args arg1
                else:
                    idx = ceil32(ceil32(arg2.length)) + 193
                    s = 0
                    while ceil32(ceil32(arg2.length)) + (uint255(uint256(stor[_102].field_0)) * 0.5) + 161 > idx:
                        mem[idx + 32] = uint256(stor[s + sha3(_102) + 1].field_0)
                        idx = idx + 32
                        s = s + 1
                        continue 
                    require ext_code.size(address(stor1[_102]))
                    call address(stor1[_102])._changeClaimTime(uint256 arg1) with:
                         gas gas_remaining wei
                        args arg1
        else:
            if bool(stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_0) == stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_1 % 128 < 32:
                revert with 0, 34
            if not stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_1 % 128:
                require ext_code.size(address(stor1[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])]))
                call address(stor1[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])])._changeClaimTime(uint256 arg1) with:
                     gas gas_remaining wei
                    args arg1
            else:
                if 31 >= stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_1 % 128:
                    require ext_code.size(address(stor1[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])]))
                    call address(stor1[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])])._changeClaimTime(uint256 arg1) with:
                         gas gas_remaining wei
                        args arg1
                else:
                    idx = ceil32(ceil32(arg2.length)) + 193
                    s = 0
                    while ceil32(ceil32(arg2.length)) + stor[_102].field_1 % 128 + 161 > idx:
                        mem[idx + 32] = uint256(stor[s + sha3(_102) + 1].field_0)
                        idx = idx + 32
                        s = s + 1
                        continue 
                    require ext_code.size(address(stor1[_102]))
                    call address(stor1[_102])._changeClaimTime(uint256 arg1) with:
                         gas gas_remaining wei
                        args arg1
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
}

function sub_ccd3fb60(?) {
    require calldata.size - 4 >= 64
    require arg2 <= test266151307()
    require arg2 + 35 < calldata.size
    if arg2.length > test266151307():
        revert with 0, 65
    if ceil32(ceil32(arg2.length)) + 97 < 96 or ceil32(ceil32(arg2.length)) + 97 > test266151307():
        revert with 0, 65
    mem[96] = arg2.length
    require arg2 + arg2.length + 36 <= calldata.size
    mem[128 len arg2.length] = arg2[all]
    mem[arg2.length + 128] = 0
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    mem[ceil32(ceil32(arg2.length)) + 97 len ceil32(arg2.length)] = arg2[all], mem[arg2.length + 128 len ceil32(arg2.length) - arg2.length]
    mem[arg2.length + ceil32(ceil32(arg2.length)) + 97] = 24
    if ceil32(arg2.length) <= arg2.length:
        _99 = sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])
        if bool(stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_0):
            if bool(stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_0) == uint255(uint256(stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_0)) * 0.5 < 32:
                revert with 0, 34
        else:
            if bool(stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_0) == stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_1 % 128 < 32:
                revert with 0, 34
        if bool(stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_0):
            if bool(stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_0) == uint255(uint256(stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_0)) * 0.5 < 32:
                revert with 0, 34
            if not Mask(256, -1, uint256(stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_0)):
                require ext_code.size(address(stor1[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])]))
                call address(stor1[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])])._changeNodePrice(uint256 arg1) with:
                     gas gas_remaining wei
                    args arg1
            else:
                if 31 >= uint255(uint256(stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_0)) * 0.5:
                    require ext_code.size(address(stor1[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])]))
                    call address(stor1[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])])._changeNodePrice(uint256 arg1) with:
                         gas gas_remaining wei
                        args arg1
                else:
                    idx = ceil32(ceil32(arg2.length)) + 193
                    s = 0
                    while ceil32(ceil32(arg2.length)) + (uint255(uint256(stor[_99].field_0)) * 0.5) + 161 > idx:
                        mem[idx + 32] = uint256(stor[s + sha3(_99) + 1].field_0)
                        idx = idx + 32
                        s = s + 1
                        continue 
                    require ext_code.size(address(stor1[_99]))
                    call address(stor1[_99])._changeNodePrice(uint256 arg1) with:
                         gas gas_remaining wei
                        args arg1
        else:
            if bool(stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_0) == stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_1 % 128 < 32:
                revert with 0, 34
            if not stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_1 % 128:
                require ext_code.size(address(stor1[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])]))
                call address(stor1[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])])._changeNodePrice(uint256 arg1) with:
                     gas gas_remaining wei
                    args arg1
            else:
                if 31 >= stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_1 % 128:
                    require ext_code.size(address(stor1[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])]))
                    call address(stor1[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])])._changeNodePrice(uint256 arg1) with:
                         gas gas_remaining wei
                        args arg1
                else:
                    idx = ceil32(ceil32(arg2.length)) + 193
                    s = 0
                    while ceil32(ceil32(arg2.length)) + stor[_99].field_1 % 128 + 161 > idx:
                        mem[idx + 32] = uint256(stor[s + sha3(_99) + 1].field_0)
                        idx = idx + 32
                        s = s + 1
                        continue 
                    require ext_code.size(address(stor1[_99]))
                    call address(stor1[_99])._changeNodePrice(uint256 arg1) with:
                         gas gas_remaining wei
                        args arg1
    else:
        _102 = sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])
        if bool(stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_0):
            if bool(stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_0) == uint255(uint256(stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_0)) * 0.5 < 32:
                revert with 0, 34
        else:
            if bool(stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_0) == stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_1 % 128 < 32:
                revert with 0, 34
        if bool(stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_0):
            if bool(stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_0) == uint255(uint256(stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_0)) * 0.5 < 32:
                revert with 0, 34
            if not Mask(256, -1, uint256(stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_0)):
                require ext_code.size(address(stor1[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])]))
                call address(stor1[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])])._changeNodePrice(uint256 arg1) with:
                     gas gas_remaining wei
                    args arg1
            else:
                if 31 >= uint255(uint256(stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_0)) * 0.5:
                    require ext_code.size(address(stor1[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])]))
                    call address(stor1[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])])._changeNodePrice(uint256 arg1) with:
                         gas gas_remaining wei
                        args arg1
                else:
                    idx = ceil32(ceil32(arg2.length)) + 193
                    s = 0
                    while ceil32(ceil32(arg2.length)) + (uint255(uint256(stor[_102].field_0)) * 0.5) + 161 > idx:
                        mem[idx + 32] = uint256(stor[s + sha3(_102) + 1].field_0)
                        idx = idx + 32
                        s = s + 1
                        continue 
                    require ext_code.size(address(stor1[_102]))
                    call address(stor1[_102])._changeNodePrice(uint256 arg1) with:
                         gas gas_remaining wei
                        args arg1
        else:
            if bool(stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_0) == stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_1 % 128 < 32:
                revert with 0, 34
            if not stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_1 % 128:
                require ext_code.size(address(stor1[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])]))
                call address(stor1[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])])._changeNodePrice(uint256 arg1) with:
                     gas gas_remaining wei
                    args arg1
            else:
                if 31 >= stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_1 % 128:
                    require ext_code.size(address(stor1[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])]))
                    call address(stor1[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])])._changeNodePrice(uint256 arg1) with:
                         gas gas_remaining wei
                        args arg1
                else:
                    idx = ceil32(ceil32(arg2.length)) + 193
                    s = 0
                    while ceil32(ceil32(arg2.length)) + stor[_102].field_1 % 128 + 161 > idx:
                        mem[idx + 32] = uint256(stor[s + sha3(_102) + 1].field_0)
                        idx = idx + 32
                        s = s + 1
                        continue 
                    require ext_code.size(address(stor1[_102]))
                    call address(stor1[_102])._changeNodePrice(uint256 arg1) with:
                         gas gas_remaining wei
                        args arg1
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
}

function sub_0d3153d0(?) {
    require calldata.size - 4 >= 64
    require arg2 <= test266151307()
    require arg2 + 35 < calldata.size
    if arg2.length > test266151307():
        revert with 0, 65
    if ceil32(ceil32(arg2.length)) + 97 < 96 or ceil32(ceil32(arg2.length)) + 97 > test266151307():
        revert with 0, 65
    mem[96] = arg2.length
    require arg2 + arg2.length + 36 <= calldata.size
    mem[128 len arg2.length] = arg2[all]
    mem[arg2.length + 128] = 0
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    mem[ceil32(ceil32(arg2.length)) + 97 len ceil32(arg2.length)] = arg2[all], mem[arg2.length + 128 len ceil32(arg2.length) - arg2.length]
    mem[arg2.length + ceil32(ceil32(arg2.length)) + 97] = 24
    if ceil32(arg2.length) <= arg2.length:
        _99 = sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])
        if bool(stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_0):
            if bool(stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_0) == uint255(uint256(stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_0)) * 0.5 < 32:
                revert with 0, 34
        else:
            if bool(stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_0) == stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_1 % 128 < 32:
                revert with 0, 34
        if bool(stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_0):
            if bool(stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_0) == uint255(uint256(stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_0)) * 0.5 < 32:
                revert with 0, 34
            if not Mask(256, -1, uint256(stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_0)):
                require ext_code.size(address(stor1[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])]))
                call address(stor1[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])])._changeRewardPerNode(uint256 arg1) with:
                     gas gas_remaining wei
                    args arg1
            else:
                if 31 >= uint255(uint256(stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_0)) * 0.5:
                    require ext_code.size(address(stor1[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])]))
                    call address(stor1[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])])._changeRewardPerNode(uint256 arg1) with:
                         gas gas_remaining wei
                        args arg1
                else:
                    idx = ceil32(ceil32(arg2.length)) + 193
                    s = 0
                    while ceil32(ceil32(arg2.length)) + (uint255(uint256(stor[_99].field_0)) * 0.5) + 161 > idx:
                        mem[idx + 32] = uint256(stor[s + sha3(_99) + 1].field_0)
                        idx = idx + 32
                        s = s + 1
                        continue 
                    require ext_code.size(address(stor1[_99]))
                    call address(stor1[_99])._changeRewardPerNode(uint256 arg1) with:
                         gas gas_remaining wei
                        args arg1
        else:
            if bool(stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_0) == stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_1 % 128 < 32:
                revert with 0, 34
            if not stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_1 % 128:
                require ext_code.size(address(stor1[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])]))
                call address(stor1[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])])._changeRewardPerNode(uint256 arg1) with:
                     gas gas_remaining wei
                    args arg1
            else:
                if 31 >= stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_1 % 128:
                    require ext_code.size(address(stor1[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])]))
                    call address(stor1[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])])._changeRewardPerNode(uint256 arg1) with:
                         gas gas_remaining wei
                        args arg1
                else:
                    idx = ceil32(ceil32(arg2.length)) + 193
                    s = 0
                    while ceil32(ceil32(arg2.length)) + stor[_99].field_1 % 128 + 161 > idx:
                        mem[idx + 32] = uint256(stor[s + sha3(_99) + 1].field_0)
                        idx = idx + 32
                        s = s + 1
                        continue 
                    require ext_code.size(address(stor1[_99]))
                    call address(stor1[_99])._changeRewardPerNode(uint256 arg1) with:
                         gas gas_remaining wei
                        args arg1
    else:
        _102 = sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])
        if bool(stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_0):
            if bool(stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_0) == uint255(uint256(stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_0)) * 0.5 < 32:
                revert with 0, 34
        else:
            if bool(stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_0) == stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_1 % 128 < 32:
                revert with 0, 34
        if bool(stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_0):
            if bool(stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_0) == uint255(uint256(stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_0)) * 0.5 < 32:
                revert with 0, 34
            if not Mask(256, -1, uint256(stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_0)):
                require ext_code.size(address(stor1[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])]))
                call address(stor1[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])])._changeRewardPerNode(uint256 arg1) with:
                     gas gas_remaining wei
                    args arg1
            else:
                if 31 >= uint255(uint256(stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_0)) * 0.5:
                    require ext_code.size(address(stor1[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])]))
                    call address(stor1[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])])._changeRewardPerNode(uint256 arg1) with:
                         gas gas_remaining wei
                        args arg1
                else:
                    idx = ceil32(ceil32(arg2.length)) + 193
                    s = 0
                    while ceil32(ceil32(arg2.length)) + (uint255(uint256(stor[_102].field_0)) * 0.5) + 161 > idx:
                        mem[idx + 32] = uint256(stor[s + sha3(_102) + 1].field_0)
                        idx = idx + 32
                        s = s + 1
                        continue 
                    require ext_code.size(address(stor1[_102]))
                    call address(stor1[_102])._changeRewardPerNode(uint256 arg1) with:
                         gas gas_remaining wei
                        args arg1
        else:
            if bool(stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_0) == stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_1 % 128 < 32:
                revert with 0, 34
            if not stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_1 % 128:
                require ext_code.size(address(stor1[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])]))
                call address(stor1[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])])._changeRewardPerNode(uint256 arg1) with:
                     gas gas_remaining wei
                    args arg1
            else:
                if 31 >= stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_1 % 128:
                    require ext_code.size(address(stor1[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])]))
                    call address(stor1[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])])._changeRewardPerNode(uint256 arg1) with:
                         gas gas_remaining wei
                        args arg1
                else:
                    idx = ceil32(ceil32(arg2.length)) + 193
                    s = 0
                    while ceil32(ceil32(arg2.length)) + stor[_102].field_1 % 128 + 161 > idx:
                        mem[idx + 32] = uint256(stor[s + sha3(_102) + 1].field_0)
                        idx = idx + 32
                        s = s + 1
                        continue 
                    require ext_code.size(address(stor1[_102]))
                    call address(stor1[_102])._changeRewardPerNode(uint256 arg1) with:
                         gas gas_remaining wei
                        args arg1
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
}

function sub_705e4d36(?) {
    require calldata.size - 4 >= 64
    require arg1 <= test266151307()
    require arg1 + 35 < calldata.size
    if arg1.length > test266151307():
        revert with 0, 65
    if ceil32(ceil32(arg1.length)) + 97 < 96 or ceil32(ceil32(arg1.length)) + 97 > test266151307():
        revert with 0, 65
    require arg1 + arg1.length + 36 <= calldata.size
    require arg2 == address(arg2)
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if bool(stor[Mask(8 * -ceil32(arg1.length) + arg1.length + 32, 0, 24)][Mask(8 * ceil32(arg1.length), -(8 * ceil32(arg1.length)) + 256, arg1[all], Mask(8 * ceil32(arg1.length) - arg1.length, -(8 * ceil32(arg1.length) + -ceil32(ceil32(arg1.length)) + 31) + 256, 96) >> 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff08 + (8 * -ceil32(arg1.length)) + (8 * ceil32(ceil32(arg1.length))) + 256) << (8 * ceil32(arg1.length)) - 256].field_0):
        if bool(stor[Mask(8 * -ceil32(arg1.length) + arg1.length + 32, 0, 24)][Mask(8 * ceil32(arg1.length), -(8 * ceil32(arg1.length)) + 256, arg1[all], Mask(8 * ceil32(arg1.length) - arg1.length, -(8 * ceil32(arg1.length) + -ceil32(ceil32(arg1.length)) + 31) + 256, 96) >> 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff08 + (8 * -ceil32(arg1.length)) + (8 * ceil32(ceil32(arg1.length))) + 256) << (8 * ceil32(arg1.length)) - 256].field_0) == uint255(uint256(stor[Mask(8 * -ceil32(arg1.length) + arg1.length + 32, 0, 24)][Mask(8 * ceil32(arg1.length), -(8 * ceil32(arg1.length)) + 256, arg1[all], Mask(8 * ceil32(arg1.length) - arg1.length, -(8 * ceil32(arg1.length) + -ceil32(ceil32(arg1.length)) + 31) + 256, 96) >> 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff08 + (8 * -ceil32(arg1.length)) + (8 * ceil32(ceil32(arg1.length))) + 256) << (8 * ceil32(arg1.length)) - 256].field_0)) * 0.5 < 32:
            revert with 0, 34
        if arg1.length:
            uint256(stor[Mask(8 * -ceil32(arg1.length) + arg1.length + 32, 0, 24)][Mask(8 * ceil32(arg1.length), -(8 * ceil32(arg1.length)) + 256, arg1[all], Mask(8 * ceil32(arg1.length) - arg1.length, -(8 * ceil32(arg1.length) + -ceil32(ceil32(arg1.length)) + 31) + 256, 96) >> 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff08 + (8 * -ceil32(arg1.length)) + (8 * ceil32(ceil32(arg1.length))) + 256) << (8 * ceil32(arg1.length)) - 256][].field_0) = Array(len=arg1.length, data=arg1[all])
        else:
            uint256(stor[Mask(8 * -ceil32(arg1.length) + arg1.length + 32, 0, 24)][Mask(8 * ceil32(arg1.length), -(8 * ceil32(arg1.length)) + 256, arg1[all], Mask(8 * ceil32(arg1.length) - arg1.length, -(8 * ceil32(arg1.length) + -ceil32(ceil32(arg1.length)) + 31) + 256, 96) >> 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff08 + (8 * -ceil32(arg1.length)) + (8 * ceil32(ceil32(arg1.length))) + 256) << (8 * ceil32(arg1.length)) - 256].field_0) = 0
            idx = 0
            while (uint255(uint256(stor[Mask(8 * -ceil32(arg1.length) + arg1.length + 32, 0, 24)][Mask(8 * ceil32(arg1.length), -(8 * ceil32(arg1.length)) + 256, arg1[all], Mask(8 * ceil32(arg1.length) - arg1.length, -(8 * ceil32(arg1.length) + -ceil32(ceil32(arg1.length)) + 31) + 256, 96) >> 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff08 + (8 * -ceil32(arg1.length)) + (8 * ceil32(ceil32(arg1.length))) + 256) << (8 * ceil32(arg1.length)) - 256].field_0)) * 0.5) + 31 / 32 > idx:
                uint256(stor[Mask(8 * -ceil32(arg1.length) + arg1.length + 32, 0, 24)][Mask(8 * ceil32(arg1.length), -(8 * ceil32(arg1.length)) + 256, arg1[all], Mask(8 * ceil32(arg1.length) - arg1.length, -(8 * ceil32(arg1.length) + -ceil32(ceil32(arg1.length)) + 31) + 256, 96) >> 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff08 + (8 * -ceil32(arg1.length)) + (8 * ceil32(ceil32(arg1.length))) + 256) << (8 * ceil32(arg1.length)) - 256][idx].field_0) = 0
                idx = idx + 1
                continue 
    else:
        if bool(stor[Mask(8 * -ceil32(arg1.length) + arg1.length + 32, 0, 24)][Mask(8 * ceil32(arg1.length), -(8 * ceil32(arg1.length)) + 256, arg1[all], Mask(8 * ceil32(arg1.length) - arg1.length, -(8 * ceil32(arg1.length) + -ceil32(ceil32(arg1.length)) + 31) + 256, 96) >> 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff08 + (8 * -ceil32(arg1.length)) + (8 * ceil32(ceil32(arg1.length))) + 256) << (8 * ceil32(arg1.length)) - 256].field_0) == stor[Mask(8 * -ceil32(arg1.length) + arg1.length + 32, 0, 24)][Mask(8 * ceil32(arg1.length), -(8 * ceil32(arg1.length)) + 256, arg1[all], Mask(8 * ceil32(arg1.length) - arg1.length, -(8 * ceil32(arg1.length) + -ceil32(ceil32(arg1.length)) + 31) + 256, 96) >> 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff08 + (8 * -ceil32(arg1.length)) + (8 * ceil32(ceil32(arg1.length))) + 256) << (8 * ceil32(arg1.length)) - 256].field_1 % 128 < 32:
            revert with 0, 34
        if arg1.length:
            uint256(stor[Mask(8 * -ceil32(arg1.length) + arg1.length + 32, 0, 24)][Mask(8 * ceil32(arg1.length), -(8 * ceil32(arg1.length)) + 256, arg1[all], Mask(8 * ceil32(arg1.length) - arg1.length, -(8 * ceil32(arg1.length) + -ceil32(ceil32(arg1.length)) + 31) + 256, 96) >> 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff08 + (8 * -ceil32(arg1.length)) + (8 * ceil32(ceil32(arg1.length))) + 256) << (8 * ceil32(arg1.length)) - 256][].field_0) = Array(len=arg1.length, data=arg1[all])
        else:
            uint256(stor[Mask(8 * -ceil32(arg1.length) + arg1.length + 32, 0, 24)][Mask(8 * ceil32(arg1.length), -(8 * ceil32(arg1.length)) + 256, arg1[all], Mask(8 * ceil32(arg1.length) - arg1.length, -(8 * ceil32(arg1.length) + -ceil32(ceil32(arg1.length)) + 31) + 256, 96) >> 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff08 + (8 * -ceil32(arg1.length)) + (8 * ceil32(ceil32(arg1.length))) + 256) << (8 * ceil32(arg1.length)) - 256].field_0) = 0
            idx = 0
            while stor[Mask(8 * -ceil32(arg1.length) + arg1.length + 32, 0, 24)][Mask(8 * ceil32(arg1.length), -(8 * ceil32(arg1.length)) + 256, arg1[all], Mask(8 * ceil32(arg1.length) - arg1.length, -(8 * ceil32(arg1.length) + -ceil32(ceil32(arg1.length)) + 31) + 256, 96) >> 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff08 + (8 * -ceil32(arg1.length)) + (8 * ceil32(ceil32(arg1.length))) + 256) << (8 * ceil32(arg1.length)) - 256].field_1 % 128 + 31 / 32 > idx:
                uint256(stor[Mask(8 * -ceil32(arg1.length) + arg1.length + 32, 0, 24)][Mask(8 * ceil32(arg1.length), -(8 * ceil32(arg1.length)) + 256, arg1[all], Mask(8 * ceil32(arg1.length) - arg1.length, -(8 * ceil32(arg1.length) + -ceil32(ceil32(arg1.length)) + 31) + 256, 96) >> 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff08 + (8 * -ceil32(arg1.length)) + (8 * ceil32(ceil32(arg1.length))) + 256) << (8 * ceil32(arg1.length)) - 256][idx].field_0) = 0
                idx = idx + 1
                continue 
    address(stor1[('map', ('mask_shl', ('mask_shl', 248, 5, 3, ('add', 31, ('cd', ('add', 4, ('param', 'arg1'))))), ('add', 256, ('mul', -1, ('mask_shl', 248, 5, 3, ('add', 31, ('cd', ('add', 4, ('param', 'arg1'))))))), ('add', -256, ('mask_shl', 248, 5, 3, ('add', 31, ('cd', ('add', 4, ('param', 'arg1')))))), ('data', ('call.data', ('add', 36, ('param', 'arg1')), ('cd', ('add', 4, ('param', 'arg1')))), ('mask_shl', ('mul', 8, ('add', ('mask_shl', 251, 5, 0, ('add', 31, ('cd', ('add', 4, ('param', 'arg1'))))), ('mul', -1, ('cd', ('add', 4, ('param', 'arg1')))))), ('add', 256, ('mul', -1, ('mul', 8, ('add', 31, ('mask_shl', 251, 5, 0, ('add', 31, ('cd', ('add', 4, ('param', 'arg1'))))), ('mul', -1, ('mask_shl', 256, 5, 0, ('add', 31, ('mask_shl', 251, 5, 0, ('add', 31, ('cd', ('add', 4, ('param', 'arg1')))))))))))), ('add', -256, ('mul', 8, ('add', 31, ('mask_shl', 251, 5, 0, ('add', 31, ('cd', ('add', 4, ('param', 'arg1'))))), ('mul', -1, ('mask_shl', 256, 5, 0, ('add', 31, ('mask_shl', 251, 5, 0, ('add', 31, ('cd', ('add', 4, ('param', 'arg1'))))))))))), 96))), ('mask_shl', ('mul', 8, ('add', 32, ('mul', -1, ('mask_shl', 251, 5, 0, ('add', 31, ('cd', ('add', 4, ('param', 'arg1')))))), ('cd', ('add', 4, ('param', 'arg1'))))), 0, 0, 24))]) = uint64(arg2) << 96
    stor25.length++
    if bool(stor9449[stor25.length].field_0):
        if bool(stor9449[stor25.length].field_0) == uint255(uint256(stor9449[stor25.length].field_0)) * 0.5 < 32:
            revert with 0, 34
        if arg1.length:
            uint256(stor[sha3(stor25.length - 0x6bb667d8c1b884b6aebb04786b36ebe680c334b941d6ff0b96702f108bc3696b)][].field_0) = Array(len=arg1.length, data=arg1[all])
        else:
            uint256(stor9449[stor25.length].field_0) = 0
            idx = 0
            while (uint255(uint256(stor9449[stor25.length].field_0)) * 0.5) + 31 / 32 > idx:
                uint256(stor[idx + sha3(stor25.length - 0x6bb667d8c1b884b6aebb04786b36ebe680c334b941d6ff0b96702f108bc3696b)].field_0) = 0
                idx = idx + 1
                continue 
    else:
        if bool(stor9449[stor25.length].field_0) == stor9449[stor25.length].field_1 % 128 < 32:
            revert with 0, 34
        if arg1.length:
            uint256(stor[sha3(stor25.length - 0x6bb667d8c1b884b6aebb04786b36ebe680c334b941d6ff0b96702f108bc3696b)][].field_0) = Array(len=arg1.length, data=arg1[all])
        else:
            uint256(stor9449[stor25.length].field_0) = 0
            idx = 0
            while stor9449[stor25.length].field_1 % 128 + 31 / 32 > idx:
                uint256(stor[idx + sha3(stor25.length - 0x6bb667d8c1b884b6aebb04786b36ebe680c334b941d6ff0b96702f108bc3696b)].field_0) = 0
                idx = idx + 1
                continue 
}

function sub_22ae5174(?) {
    require calldata.size - 4 >= 32
    require arg1 <= test266151307()
    require arg1 + 35 < calldata.size
    if arg1.length > test266151307():
        revert with 0, 65
    if ceil32(ceil32(arg1.length)) + 97 < 96 or ceil32(ceil32(arg1.length)) + 97 > test266151307():
        revert with 0, 65
    mem[96] = arg1.length
    require arg1 + arg1.length + 36 <= calldata.size
    mem[128 len arg1.length] = arg1[all]
    mem[arg1.length + 128] = 0
    mem[ceil32(ceil32(arg1.length)) + 97 len ceil32(arg1.length)] = arg1[all], mem[arg1.length + 128 len ceil32(arg1.length) - arg1.length]
    mem[arg1.length + ceil32(ceil32(arg1.length)) + 97] = 24
    if ceil32(arg1.length) <= arg1.length:
        _193 = sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])
        if bool(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0):
            if bool(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0) == uint255(uint256(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0)) * 0.5 < 32:
                revert with 0, 34
            mem[64] = ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0)) * 0.5) + 193
            mem[ceil32(ceil32(arg1.length)) + 161] = uint255(uint256(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0)) * 0.5
            if bool(stor[_193].field_0):
                if bool(stor[_193].field_0) == uint255(uint256(stor[_193].field_0)) * 0.5 < 32:
                    revert with 0, 34
                if not Mask(256, -1, uint256(stor[_193].field_0)):
                    require ext_code.size(address(stor1[_193]))
                    staticcall address(stor1[_193]).nodePrice() with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                if 31 >= uint255(uint256(stor[_193].field_0)) * 0.5:
                    require ext_code.size(address(stor1[_193]))
                    staticcall address(stor1[_193]).nodePrice() with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                mem[0] = _193
                mem[ceil32(ceil32(arg1.length)) + 193] = uint256(stor[sha3(_193)].field_0)
                idx = ceil32(ceil32(arg1.length)) + 193
                s = 0
                while ceil32(ceil32(arg1.length)) + (uint255(uint256(stor[_193].field_0)) * 0.5) + 161 > idx:
                    mem[idx + 32] = uint256(stor[s + sha3(_193) + 1].field_0)
                    idx = idx + 32
                    s = s + 1
                    continue 
                mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
                mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_193])
                require ext_code.size(address(stor1[_193]))
                staticcall address(stor1[_193]).nodePrice() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _402 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[mem[64]] = mem[_402]
            else:
                if bool(stor[_193].field_0) == stor[_193].field_1 % 128 < 32:
                    revert with 0, 34
                if not stor[_193].field_1 % 128:
                    require ext_code.size(address(stor1[_193]))
                    staticcall address(stor1[_193]).nodePrice() with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                if 31 >= stor[_193].field_1 % 128:
                    require ext_code.size(address(stor1[_193]))
                    staticcall address(stor1[_193]).nodePrice() with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                mem[0] = _193
                mem[ceil32(ceil32(arg1.length)) + 193] = uint256(stor[sha3(_193)].field_0)
                idx = ceil32(ceil32(arg1.length)) + 193
                s = 0
                while ceil32(ceil32(arg1.length)) + stor[_193].field_1 % 128 + 161 > idx:
                    mem[idx + 32] = uint256(stor[s + sha3(_193) + 1].field_0)
                    idx = idx + 32
                    s = s + 1
                    continue 
                mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
                mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_193])
                require ext_code.size(address(stor1[_193]))
                staticcall address(stor1[_193]).nodePrice() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _403 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[mem[64]] = mem[_403]
        else:
            if bool(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0) == stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_1 % 128 < 32:
                revert with 0, 34
            mem[64] = ceil32(ceil32(arg1.length)) + ceil32(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_1 % 128) + 193
            mem[ceil32(ceil32(arg1.length)) + 161] = stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_1 % 128
            if bool(stor[_193].field_0):
                if bool(stor[_193].field_0) == uint255(uint256(stor[_193].field_0)) * 0.5 < 32:
                    revert with 0, 34
                if not Mask(256, -1, uint256(stor[_193].field_0)):
                    require ext_code.size(address(stor1[_193]))
                    staticcall address(stor1[_193]).nodePrice() with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                if 31 >= uint255(uint256(stor[_193].field_0)) * 0.5:
                    require ext_code.size(address(stor1[_193]))
                    staticcall address(stor1[_193]).nodePrice() with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                mem[0] = _193
                mem[ceil32(ceil32(arg1.length)) + 193] = uint256(stor[sha3(_193)].field_0)
                idx = ceil32(ceil32(arg1.length)) + 193
                s = 0
                while ceil32(ceil32(arg1.length)) + (uint255(uint256(stor[_193].field_0)) * 0.5) + 161 > idx:
                    mem[idx + 32] = uint256(stor[s + sha3(_193) + 1].field_0)
                    idx = idx + 32
                    s = s + 1
                    continue 
                mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
                mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_193])
                require ext_code.size(address(stor1[_193]))
                staticcall address(stor1[_193]).nodePrice() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _404 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[mem[64]] = mem[_404]
            else:
                if bool(stor[_193].field_0) == stor[_193].field_1 % 128 < 32:
                    revert with 0, 34
                if not stor[_193].field_1 % 128:
                    require ext_code.size(address(stor1[_193]))
                    staticcall address(stor1[_193]).nodePrice() with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                if 31 >= stor[_193].field_1 % 128:
                    require ext_code.size(address(stor1[_193]))
                    staticcall address(stor1[_193]).nodePrice() with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                mem[0] = _193
                mem[ceil32(ceil32(arg1.length)) + 193] = uint256(stor[sha3(_193)].field_0)
                idx = ceil32(ceil32(arg1.length)) + 193
                s = 0
                while ceil32(ceil32(arg1.length)) + stor[_193].field_1 % 128 + 161 > idx:
                    mem[idx + 32] = uint256(stor[s + sha3(_193) + 1].field_0)
                    idx = idx + 32
                    s = s + 1
                    continue 
                mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
                mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_193])
                require ext_code.size(address(stor1[_193]))
                staticcall address(stor1[_193]).nodePrice() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _405 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[mem[64]] = mem[_405]
    else:
        _196 = sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])
        if bool(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0):
            if bool(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0) == uint255(uint256(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0)) * 0.5 < 32:
                revert with 0, 34
            mem[64] = ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0)) * 0.5) + 193
            mem[ceil32(ceil32(arg1.length)) + 161] = uint255(uint256(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0)) * 0.5
            if bool(stor[_196].field_0):
                if bool(stor[_196].field_0) == uint255(uint256(stor[_196].field_0)) * 0.5 < 32:
                    revert with 0, 34
                if not Mask(256, -1, uint256(stor[_196].field_0)):
                    require ext_code.size(address(stor1[_196]))
                    staticcall address(stor1[_196]).nodePrice() with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                if 31 >= uint255(uint256(stor[_196].field_0)) * 0.5:
                    require ext_code.size(address(stor1[_196]))
                    staticcall address(stor1[_196]).nodePrice() with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                mem[0] = _196
                mem[ceil32(ceil32(arg1.length)) + 193] = uint256(stor[sha3(_196)].field_0)
                idx = ceil32(ceil32(arg1.length)) + 193
                s = 0
                while ceil32(ceil32(arg1.length)) + (uint255(uint256(stor[_196].field_0)) * 0.5) + 161 > idx:
                    mem[idx + 32] = uint256(stor[s + sha3(_196) + 1].field_0)
                    idx = idx + 32
                    s = s + 1
                    continue 
                mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
                mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_196])
                require ext_code.size(address(stor1[_196]))
                staticcall address(stor1[_196]).nodePrice() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _406 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[mem[64]] = mem[_406]
            else:
                if bool(stor[_196].field_0) == stor[_196].field_1 % 128 < 32:
                    revert with 0, 34
                if not stor[_196].field_1 % 128:
                    require ext_code.size(address(stor1[_196]))
                    staticcall address(stor1[_196]).nodePrice() with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                if 31 >= stor[_196].field_1 % 128:
                    require ext_code.size(address(stor1[_196]))
                    staticcall address(stor1[_196]).nodePrice() with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                mem[0] = _196
                mem[ceil32(ceil32(arg1.length)) + 193] = uint256(stor[sha3(_196)].field_0)
                idx = ceil32(ceil32(arg1.length)) + 193
                s = 0
                while ceil32(ceil32(arg1.length)) + stor[_196].field_1 % 128 + 161 > idx:
                    mem[idx + 32] = uint256(stor[s + sha3(_196) + 1].field_0)
                    idx = idx + 32
                    s = s + 1
                    continue 
                mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
                mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_196])
                require ext_code.size(address(stor1[_196]))
                staticcall address(stor1[_196]).nodePrice() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _407 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[mem[64]] = mem[_407]
        else:
            if bool(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0) == stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_1 % 128 < 32:
                revert with 0, 34
            mem[64] = ceil32(ceil32(arg1.length)) + ceil32(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_1 % 128) + 193
            mem[ceil32(ceil32(arg1.length)) + 161] = stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_1 % 128
            if bool(stor[_196].field_0):
                if bool(stor[_196].field_0) == uint255(uint256(stor[_196].field_0)) * 0.5 < 32:
                    revert with 0, 34
                if not Mask(256, -1, uint256(stor[_196].field_0)):
                    require ext_code.size(address(stor1[_196]))
                    staticcall address(stor1[_196]).nodePrice() with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                if 31 >= uint255(uint256(stor[_196].field_0)) * 0.5:
                    require ext_code.size(address(stor1[_196]))
                    staticcall address(stor1[_196]).nodePrice() with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                mem[0] = _196
                mem[ceil32(ceil32(arg1.length)) + 193] = uint256(stor[sha3(_196)].field_0)
                idx = ceil32(ceil32(arg1.length)) + 193
                s = 0
                while ceil32(ceil32(arg1.length)) + (uint255(uint256(stor[_196].field_0)) * 0.5) + 161 > idx:
                    mem[idx + 32] = uint256(stor[s + sha3(_196) + 1].field_0)
                    idx = idx + 32
                    s = s + 1
                    continue 
                mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
                mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_196])
                require ext_code.size(address(stor1[_196]))
                staticcall address(stor1[_196]).nodePrice() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _408 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[mem[64]] = mem[_408]
            else:
                if bool(stor[_196].field_0) == stor[_196].field_1 % 128 < 32:
                    revert with 0, 34
                if not stor[_196].field_1 % 128:
                    require ext_code.size(address(stor1[_196]))
                    staticcall address(stor1[_196]).nodePrice() with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                if 31 >= stor[_196].field_1 % 128:
                    require ext_code.size(address(stor1[_196]))
                    staticcall address(stor1[_196]).nodePrice() with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                mem[0] = _196
                mem[ceil32(ceil32(arg1.length)) + 193] = uint256(stor[sha3(_196)].field_0)
                idx = ceil32(ceil32(arg1.length)) + 193
                s = 0
                while ceil32(ceil32(arg1.length)) + stor[_196].field_1 % 128 + 161 > idx:
                    mem[idx + 32] = uint256(stor[s + sha3(_196) + 1].field_0)
                    idx = idx + 32
                    s = s + 1
                    continue 
                mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
                mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_196])
                require ext_code.size(address(stor1[_196]))
                staticcall address(stor1[_196]).nodePrice() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _409 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[mem[64]] = mem[_409]
    return memory
      from mem[64]
       len 32
}

function sub_cf033519(?) {
    require calldata.size - 4 >= 32
    require arg1 <= test266151307()
    require arg1 + 35 < calldata.size
    if arg1.length > test266151307():
        revert with 0, 65
    if ceil32(ceil32(arg1.length)) + 97 < 96 or ceil32(ceil32(arg1.length)) + 97 > test266151307():
        revert with 0, 65
    mem[96] = arg1.length
    require arg1 + arg1.length + 36 <= calldata.size
    mem[128 len arg1.length] = arg1[all]
    mem[arg1.length + 128] = 0
    mem[ceil32(ceil32(arg1.length)) + 97 len ceil32(arg1.length)] = arg1[all], mem[arg1.length + 128 len ceil32(arg1.length) - arg1.length]
    mem[arg1.length + ceil32(ceil32(arg1.length)) + 97] = 24
    if ceil32(arg1.length) <= arg1.length:
        _193 = sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])
        if bool(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0):
            if bool(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0) == uint255(uint256(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0)) * 0.5 < 32:
                revert with 0, 34
            mem[64] = ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0)) * 0.5) + 193
            mem[ceil32(ceil32(arg1.length)) + 161] = uint255(uint256(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0)) * 0.5
            if bool(stor[_193].field_0):
                if bool(stor[_193].field_0) == uint255(uint256(stor[_193].field_0)) * 0.5 < 32:
                    revert with 0, 34
                if not Mask(256, -1, uint256(stor[_193].field_0)):
                    require ext_code.size(address(stor1[_193]))
                    staticcall address(stor1[_193]).claimTime() with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                if 31 >= uint255(uint256(stor[_193].field_0)) * 0.5:
                    require ext_code.size(address(stor1[_193]))
                    staticcall address(stor1[_193]).claimTime() with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                mem[0] = _193
                mem[ceil32(ceil32(arg1.length)) + 193] = uint256(stor[sha3(_193)].field_0)
                idx = ceil32(ceil32(arg1.length)) + 193
                s = 0
                while ceil32(ceil32(arg1.length)) + (uint255(uint256(stor[_193].field_0)) * 0.5) + 161 > idx:
                    mem[idx + 32] = uint256(stor[s + sha3(_193) + 1].field_0)
                    idx = idx + 32
                    s = s + 1
                    continue 
                mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
                mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_193])
                require ext_code.size(address(stor1[_193]))
                staticcall address(stor1[_193]).claimTime() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _402 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[mem[64]] = mem[_402]
            else:
                if bool(stor[_193].field_0) == stor[_193].field_1 % 128 < 32:
                    revert with 0, 34
                if not stor[_193].field_1 % 128:
                    require ext_code.size(address(stor1[_193]))
                    staticcall address(stor1[_193]).claimTime() with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                if 31 >= stor[_193].field_1 % 128:
                    require ext_code.size(address(stor1[_193]))
                    staticcall address(stor1[_193]).claimTime() with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                mem[0] = _193
                mem[ceil32(ceil32(arg1.length)) + 193] = uint256(stor[sha3(_193)].field_0)
                idx = ceil32(ceil32(arg1.length)) + 193
                s = 0
                while ceil32(ceil32(arg1.length)) + stor[_193].field_1 % 128 + 161 > idx:
                    mem[idx + 32] = uint256(stor[s + sha3(_193) + 1].field_0)
                    idx = idx + 32
                    s = s + 1
                    continue 
                mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
                mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_193])
                require ext_code.size(address(stor1[_193]))
                staticcall address(stor1[_193]).claimTime() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _403 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[mem[64]] = mem[_403]
        else:
            if bool(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0) == stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_1 % 128 < 32:
                revert with 0, 34
            mem[64] = ceil32(ceil32(arg1.length)) + ceil32(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_1 % 128) + 193
            mem[ceil32(ceil32(arg1.length)) + 161] = stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_1 % 128
            if bool(stor[_193].field_0):
                if bool(stor[_193].field_0) == uint255(uint256(stor[_193].field_0)) * 0.5 < 32:
                    revert with 0, 34
                if not Mask(256, -1, uint256(stor[_193].field_0)):
                    require ext_code.size(address(stor1[_193]))
                    staticcall address(stor1[_193]).claimTime() with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                if 31 >= uint255(uint256(stor[_193].field_0)) * 0.5:
                    require ext_code.size(address(stor1[_193]))
                    staticcall address(stor1[_193]).claimTime() with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                mem[0] = _193
                mem[ceil32(ceil32(arg1.length)) + 193] = uint256(stor[sha3(_193)].field_0)
                idx = ceil32(ceil32(arg1.length)) + 193
                s = 0
                while ceil32(ceil32(arg1.length)) + (uint255(uint256(stor[_193].field_0)) * 0.5) + 161 > idx:
                    mem[idx + 32] = uint256(stor[s + sha3(_193) + 1].field_0)
                    idx = idx + 32
                    s = s + 1
                    continue 
                mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
                mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_193])
                require ext_code.size(address(stor1[_193]))
                staticcall address(stor1[_193]).claimTime() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _404 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[mem[64]] = mem[_404]
            else:
                if bool(stor[_193].field_0) == stor[_193].field_1 % 128 < 32:
                    revert with 0, 34
                if not stor[_193].field_1 % 128:
                    require ext_code.size(address(stor1[_193]))
                    staticcall address(stor1[_193]).claimTime() with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                if 31 >= stor[_193].field_1 % 128:
                    require ext_code.size(address(stor1[_193]))
                    staticcall address(stor1[_193]).claimTime() with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                mem[0] = _193
                mem[ceil32(ceil32(arg1.length)) + 193] = uint256(stor[sha3(_193)].field_0)
                idx = ceil32(ceil32(arg1.length)) + 193
                s = 0
                while ceil32(ceil32(arg1.length)) + stor[_193].field_1 % 128 + 161 > idx:
                    mem[idx + 32] = uint256(stor[s + sha3(_193) + 1].field_0)
                    idx = idx + 32
                    s = s + 1
                    continue 
                mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
                mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_193])
                require ext_code.size(address(stor1[_193]))
                staticcall address(stor1[_193]).claimTime() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _405 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[mem[64]] = mem[_405]
    else:
        _196 = sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])
        if bool(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0):
            if bool(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0) == uint255(uint256(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0)) * 0.5 < 32:
                revert with 0, 34
            mem[64] = ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0)) * 0.5) + 193
            mem[ceil32(ceil32(arg1.length)) + 161] = uint255(uint256(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0)) * 0.5
            if bool(stor[_196].field_0):
                if bool(stor[_196].field_0) == uint255(uint256(stor[_196].field_0)) * 0.5 < 32:
                    revert with 0, 34
                if not Mask(256, -1, uint256(stor[_196].field_0)):
                    require ext_code.size(address(stor1[_196]))
                    staticcall address(stor1[_196]).claimTime() with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                if 31 >= uint255(uint256(stor[_196].field_0)) * 0.5:
                    require ext_code.size(address(stor1[_196]))
                    staticcall address(stor1[_196]).claimTime() with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                mem[0] = _196
                mem[ceil32(ceil32(arg1.length)) + 193] = uint256(stor[sha3(_196)].field_0)
                idx = ceil32(ceil32(arg1.length)) + 193
                s = 0
                while ceil32(ceil32(arg1.length)) + (uint255(uint256(stor[_196].field_0)) * 0.5) + 161 > idx:
                    mem[idx + 32] = uint256(stor[s + sha3(_196) + 1].field_0)
                    idx = idx + 32
                    s = s + 1
                    continue 
                mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
                mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_196])
                require ext_code.size(address(stor1[_196]))
                staticcall address(stor1[_196]).claimTime() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _406 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[mem[64]] = mem[_406]
            else:
                if bool(stor[_196].field_0) == stor[_196].field_1 % 128 < 32:
                    revert with 0, 34
                if not stor[_196].field_1 % 128:
                    require ext_code.size(address(stor1[_196]))
                    staticcall address(stor1[_196]).claimTime() with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                if 31 >= stor[_196].field_1 % 128:
                    require ext_code.size(address(stor1[_196]))
                    staticcall address(stor1[_196]).claimTime() with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                mem[0] = _196
                mem[ceil32(ceil32(arg1.length)) + 193] = uint256(stor[sha3(_196)].field_0)
                idx = ceil32(ceil32(arg1.length)) + 193
                s = 0
                while ceil32(ceil32(arg1.length)) + stor[_196].field_1 % 128 + 161 > idx:
                    mem[idx + 32] = uint256(stor[s + sha3(_196) + 1].field_0)
                    idx = idx + 32
                    s = s + 1
                    continue 
                mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
                mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_196])
                require ext_code.size(address(stor1[_196]))
                staticcall address(stor1[_196]).claimTime() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _407 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[mem[64]] = mem[_407]
        else:
            if bool(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0) == stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_1 % 128 < 32:
                revert with 0, 34
            mem[64] = ceil32(ceil32(arg1.length)) + ceil32(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_1 % 128) + 193
            mem[ceil32(ceil32(arg1.length)) + 161] = stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_1 % 128
            if bool(stor[_196].field_0):
                if bool(stor[_196].field_0) == uint255(uint256(stor[_196].field_0)) * 0.5 < 32:
                    revert with 0, 34
                if not Mask(256, -1, uint256(stor[_196].field_0)):
                    require ext_code.size(address(stor1[_196]))
                    staticcall address(stor1[_196]).claimTime() with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                if 31 >= uint255(uint256(stor[_196].field_0)) * 0.5:
                    require ext_code.size(address(stor1[_196]))
                    staticcall address(stor1[_196]).claimTime() with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                mem[0] = _196
                mem[ceil32(ceil32(arg1.length)) + 193] = uint256(stor[sha3(_196)].field_0)
                idx = ceil32(ceil32(arg1.length)) + 193
                s = 0
                while ceil32(ceil32(arg1.length)) + (uint255(uint256(stor[_196].field_0)) * 0.5) + 161 > idx:
                    mem[idx + 32] = uint256(stor[s + sha3(_196) + 1].field_0)
                    idx = idx + 32
                    s = s + 1
                    continue 
                mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
                mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_196])
                require ext_code.size(address(stor1[_196]))
                staticcall address(stor1[_196]).claimTime() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _408 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[mem[64]] = mem[_408]
            else:
                if bool(stor[_196].field_0) == stor[_196].field_1 % 128 < 32:
                    revert with 0, 34
                if not stor[_196].field_1 % 128:
                    require ext_code.size(address(stor1[_196]))
                    staticcall address(stor1[_196]).claimTime() with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                if 31 >= stor[_196].field_1 % 128:
                    require ext_code.size(address(stor1[_196]))
                    staticcall address(stor1[_196]).claimTime() with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                mem[0] = _196
                mem[ceil32(ceil32(arg1.length)) + 193] = uint256(stor[sha3(_196)].field_0)
                idx = ceil32(ceil32(arg1.length)) + 193
                s = 0
                while ceil32(ceil32(arg1.length)) + stor[_196].field_1 % 128 + 161 > idx:
                    mem[idx + 32] = uint256(stor[s + sha3(_196) + 1].field_0)
                    idx = idx + 32
                    s = s + 1
                    continue 
                mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
                mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_196])
                require ext_code.size(address(stor1[_196]))
                staticcall address(stor1[_196]).claimTime() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _409 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[mem[64]] = mem[_409]
    return memory
      from mem[64]
       len 32
}

function sub_9c4cc8b3(?) {
    require calldata.size - 4 >= 32
    require arg1 <= test266151307()
    require arg1 + 35 < calldata.size
    if arg1.length > test266151307():
        revert with 0, 65
    if ceil32(ceil32(arg1.length)) + 97 < 96 or ceil32(ceil32(arg1.length)) + 97 > test266151307():
        revert with 0, 65
    mem[96] = arg1.length
    require arg1 + arg1.length + 36 <= calldata.size
    mem[128 len arg1.length] = arg1[all]
    mem[arg1.length + 128] = 0
    mem[ceil32(ceil32(arg1.length)) + 97 len ceil32(arg1.length)] = arg1[all], mem[arg1.length + 128 len ceil32(arg1.length) - arg1.length]
    mem[arg1.length + ceil32(ceil32(arg1.length)) + 97] = 24
    if ceil32(arg1.length) <= arg1.length:
        _193 = sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])
        if bool(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0):
            if bool(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0) == uint255(uint256(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0)) * 0.5 < 32:
                revert with 0, 34
            mem[64] = ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0)) * 0.5) + 193
            mem[ceil32(ceil32(arg1.length)) + 161] = uint255(uint256(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0)) * 0.5
            if bool(stor[_193].field_0):
                if bool(stor[_193].field_0) == uint255(uint256(stor[_193].field_0)) * 0.5 < 32:
                    revert with 0, 34
                if not Mask(256, -1, uint256(stor[_193].field_0)):
                    require ext_code.size(address(stor1[_193]))
                    staticcall address(stor1[_193]).rewardPerNode() with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                if 31 >= uint255(uint256(stor[_193].field_0)) * 0.5:
                    require ext_code.size(address(stor1[_193]))
                    staticcall address(stor1[_193]).rewardPerNode() with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                mem[0] = _193
                mem[ceil32(ceil32(arg1.length)) + 193] = uint256(stor[sha3(_193)].field_0)
                idx = ceil32(ceil32(arg1.length)) + 193
                s = 0
                while ceil32(ceil32(arg1.length)) + (uint255(uint256(stor[_193].field_0)) * 0.5) + 161 > idx:
                    mem[idx + 32] = uint256(stor[s + sha3(_193) + 1].field_0)
                    idx = idx + 32
                    s = s + 1
                    continue 
                mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
                mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_193])
                require ext_code.size(address(stor1[_193]))
                staticcall address(stor1[_193]).rewardPerNode() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _402 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[mem[64]] = mem[_402]
            else:
                if bool(stor[_193].field_0) == stor[_193].field_1 % 128 < 32:
                    revert with 0, 34
                if not stor[_193].field_1 % 128:
                    require ext_code.size(address(stor1[_193]))
                    staticcall address(stor1[_193]).rewardPerNode() with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                if 31 >= stor[_193].field_1 % 128:
                    require ext_code.size(address(stor1[_193]))
                    staticcall address(stor1[_193]).rewardPerNode() with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                mem[0] = _193
                mem[ceil32(ceil32(arg1.length)) + 193] = uint256(stor[sha3(_193)].field_0)
                idx = ceil32(ceil32(arg1.length)) + 193
                s = 0
                while ceil32(ceil32(arg1.length)) + stor[_193].field_1 % 128 + 161 > idx:
                    mem[idx + 32] = uint256(stor[s + sha3(_193) + 1].field_0)
                    idx = idx + 32
                    s = s + 1
                    continue 
                mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
                mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_193])
                require ext_code.size(address(stor1[_193]))
                staticcall address(stor1[_193]).rewardPerNode() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _403 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[mem[64]] = mem[_403]
        else:
            if bool(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0) == stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_1 % 128 < 32:
                revert with 0, 34
            mem[64] = ceil32(ceil32(arg1.length)) + ceil32(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_1 % 128) + 193
            mem[ceil32(ceil32(arg1.length)) + 161] = stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_1 % 128
            if bool(stor[_193].field_0):
                if bool(stor[_193].field_0) == uint255(uint256(stor[_193].field_0)) * 0.5 < 32:
                    revert with 0, 34
                if not Mask(256, -1, uint256(stor[_193].field_0)):
                    require ext_code.size(address(stor1[_193]))
                    staticcall address(stor1[_193]).rewardPerNode() with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                if 31 >= uint255(uint256(stor[_193].field_0)) * 0.5:
                    require ext_code.size(address(stor1[_193]))
                    staticcall address(stor1[_193]).rewardPerNode() with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                mem[0] = _193
                mem[ceil32(ceil32(arg1.length)) + 193] = uint256(stor[sha3(_193)].field_0)
                idx = ceil32(ceil32(arg1.length)) + 193
                s = 0
                while ceil32(ceil32(arg1.length)) + (uint255(uint256(stor[_193].field_0)) * 0.5) + 161 > idx:
                    mem[idx + 32] = uint256(stor[s + sha3(_193) + 1].field_0)
                    idx = idx + 32
                    s = s + 1
                    continue 
                mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
                mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_193])
                require ext_code.size(address(stor1[_193]))
                staticcall address(stor1[_193]).rewardPerNode() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _404 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[mem[64]] = mem[_404]
            else:
                if bool(stor[_193].field_0) == stor[_193].field_1 % 128 < 32:
                    revert with 0, 34
                if not stor[_193].field_1 % 128:
                    require ext_code.size(address(stor1[_193]))
                    staticcall address(stor1[_193]).rewardPerNode() with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                if 31 >= stor[_193].field_1 % 128:
                    require ext_code.size(address(stor1[_193]))
                    staticcall address(stor1[_193]).rewardPerNode() with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                mem[0] = _193
                mem[ceil32(ceil32(arg1.length)) + 193] = uint256(stor[sha3(_193)].field_0)
                idx = ceil32(ceil32(arg1.length)) + 193
                s = 0
                while ceil32(ceil32(arg1.length)) + stor[_193].field_1 % 128 + 161 > idx:
                    mem[idx + 32] = uint256(stor[s + sha3(_193) + 1].field_0)
                    idx = idx + 32
                    s = s + 1
                    continue 
                mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
                mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_193])
                require ext_code.size(address(stor1[_193]))
                staticcall address(stor1[_193]).rewardPerNode() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _405 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[mem[64]] = mem[_405]
    else:
        _196 = sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])
        if bool(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0):
            if bool(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0) == uint255(uint256(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0)) * 0.5 < 32:
                revert with 0, 34
            mem[64] = ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0)) * 0.5) + 193
            mem[ceil32(ceil32(arg1.length)) + 161] = uint255(uint256(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0)) * 0.5
            if bool(stor[_196].field_0):
                if bool(stor[_196].field_0) == uint255(uint256(stor[_196].field_0)) * 0.5 < 32:
                    revert with 0, 34
                if not Mask(256, -1, uint256(stor[_196].field_0)):
                    require ext_code.size(address(stor1[_196]))
                    staticcall address(stor1[_196]).rewardPerNode() with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                if 31 >= uint255(uint256(stor[_196].field_0)) * 0.5:
                    require ext_code.size(address(stor1[_196]))
                    staticcall address(stor1[_196]).rewardPerNode() with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                mem[0] = _196
                mem[ceil32(ceil32(arg1.length)) + 193] = uint256(stor[sha3(_196)].field_0)
                idx = ceil32(ceil32(arg1.length)) + 193
                s = 0
                while ceil32(ceil32(arg1.length)) + (uint255(uint256(stor[_196].field_0)) * 0.5) + 161 > idx:
                    mem[idx + 32] = uint256(stor[s + sha3(_196) + 1].field_0)
                    idx = idx + 32
                    s = s + 1
                    continue 
                mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
                mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_196])
                require ext_code.size(address(stor1[_196]))
                staticcall address(stor1[_196]).rewardPerNode() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _406 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[mem[64]] = mem[_406]
            else:
                if bool(stor[_196].field_0) == stor[_196].field_1 % 128 < 32:
                    revert with 0, 34
                if not stor[_196].field_1 % 128:
                    require ext_code.size(address(stor1[_196]))
                    staticcall address(stor1[_196]).rewardPerNode() with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                if 31 >= stor[_196].field_1 % 128:
                    require ext_code.size(address(stor1[_196]))
                    staticcall address(stor1[_196]).rewardPerNode() with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                mem[0] = _196
                mem[ceil32(ceil32(arg1.length)) + 193] = uint256(stor[sha3(_196)].field_0)
                idx = ceil32(ceil32(arg1.length)) + 193
                s = 0
                while ceil32(ceil32(arg1.length)) + stor[_196].field_1 % 128 + 161 > idx:
                    mem[idx + 32] = uint256(stor[s + sha3(_196) + 1].field_0)
                    idx = idx + 32
                    s = s + 1
                    continue 
                mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
                mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_196])
                require ext_code.size(address(stor1[_196]))
                staticcall address(stor1[_196]).rewardPerNode() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _407 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[mem[64]] = mem[_407]
        else:
            if bool(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0) == stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_1 % 128 < 32:
                revert with 0, 34
            mem[64] = ceil32(ceil32(arg1.length)) + ceil32(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_1 % 128) + 193
            mem[ceil32(ceil32(arg1.length)) + 161] = stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_1 % 128
            if bool(stor[_196].field_0):
                if bool(stor[_196].field_0) == uint255(uint256(stor[_196].field_0)) * 0.5 < 32:
                    revert with 0, 34
                if not Mask(256, -1, uint256(stor[_196].field_0)):
                    require ext_code.size(address(stor1[_196]))
                    staticcall address(stor1[_196]).rewardPerNode() with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                if 31 >= uint255(uint256(stor[_196].field_0)) * 0.5:
                    require ext_code.size(address(stor1[_196]))
                    staticcall address(stor1[_196]).rewardPerNode() with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                mem[0] = _196
                mem[ceil32(ceil32(arg1.length)) + 193] = uint256(stor[sha3(_196)].field_0)
                idx = ceil32(ceil32(arg1.length)) + 193
                s = 0
                while ceil32(ceil32(arg1.length)) + (uint255(uint256(stor[_196].field_0)) * 0.5) + 161 > idx:
                    mem[idx + 32] = uint256(stor[s + sha3(_196) + 1].field_0)
                    idx = idx + 32
                    s = s + 1
                    continue 
                mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
                mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_196])
                require ext_code.size(address(stor1[_196]))
                staticcall address(stor1[_196]).rewardPerNode() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _408 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[mem[64]] = mem[_408]
            else:
                if bool(stor[_196].field_0) == stor[_196].field_1 % 128 < 32:
                    revert with 0, 34
                if not stor[_196].field_1 % 128:
                    require ext_code.size(address(stor1[_196]))
                    staticcall address(stor1[_196]).rewardPerNode() with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                if 31 >= stor[_196].field_1 % 128:
                    require ext_code.size(address(stor1[_196]))
                    staticcall address(stor1[_196]).rewardPerNode() with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                mem[0] = _196
                mem[ceil32(ceil32(arg1.length)) + 193] = uint256(stor[sha3(_196)].field_0)
                idx = ceil32(ceil32(arg1.length)) + 193
                s = 0
                while ceil32(ceil32(arg1.length)) + stor[_196].field_1 % 128 + 161 > idx:
                    mem[idx + 32] = uint256(stor[s + sha3(_196) + 1].field_0)
                    idx = idx + 32
                    s = s + 1
                    continue 
                mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
                mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_196])
                require ext_code.size(address(stor1[_196]))
                staticcall address(stor1[_196]).rewardPerNode() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _409 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[mem[64]] = mem[_409]
    return memory
      from mem[64]
       len 32
}

function sub_8b98a3d2(?) {
    require calldata.size - 4 >= 32
    require arg1 <= test266151307()
    require arg1 + 35 < calldata.size
    if arg1.length > test266151307():
        revert with 0, 65
    if ceil32(ceil32(arg1.length)) + 97 < 96 or ceil32(ceil32(arg1.length)) + 97 > test266151307():
        revert with 0, 65
    mem[96] = arg1.length
    require arg1 + arg1.length + 36 <= calldata.size
    mem[128 len arg1.length] = arg1[all]
    mem[arg1.length + 128] = 0
    mem[ceil32(ceil32(arg1.length)) + 97 len ceil32(arg1.length)] = arg1[all], mem[arg1.length + 128 len ceil32(arg1.length) - arg1.length]
    mem[arg1.length + ceil32(ceil32(arg1.length)) + 97] = 24
    if ceil32(arg1.length) <= arg1.length:
        _193 = sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])
        if bool(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0):
            if bool(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0) == uint255(uint256(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0)) * 0.5 < 32:
                revert with 0, 34
            mem[64] = ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0)) * 0.5) + 193
            mem[ceil32(ceil32(arg1.length)) + 161] = uint255(uint256(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0)) * 0.5
            if bool(stor[_193].field_0):
                if bool(stor[_193].field_0) == uint255(uint256(stor[_193].field_0)) * 0.5 < 32:
                    revert with 0, 34
                if not Mask(256, -1, uint256(stor[_193].field_0)):
                    require ext_code.size(address(stor1[_193]))
                    staticcall address(stor1[_193]).totalNodesCreated() with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                if 31 >= uint255(uint256(stor[_193].field_0)) * 0.5:
                    require ext_code.size(address(stor1[_193]))
                    staticcall address(stor1[_193]).totalNodesCreated() with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                mem[0] = _193
                mem[ceil32(ceil32(arg1.length)) + 193] = uint256(stor[sha3(_193)].field_0)
                idx = ceil32(ceil32(arg1.length)) + 193
                s = 0
                while ceil32(ceil32(arg1.length)) + (uint255(uint256(stor[_193].field_0)) * 0.5) + 161 > idx:
                    mem[idx + 32] = uint256(stor[s + sha3(_193) + 1].field_0)
                    idx = idx + 32
                    s = s + 1
                    continue 
                mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
                mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_193])
                require ext_code.size(address(stor1[_193]))
                staticcall address(stor1[_193]).totalNodesCreated() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _402 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[mem[64]] = mem[_402]
            else:
                if bool(stor[_193].field_0) == stor[_193].field_1 % 128 < 32:
                    revert with 0, 34
                if not stor[_193].field_1 % 128:
                    require ext_code.size(address(stor1[_193]))
                    staticcall address(stor1[_193]).totalNodesCreated() with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                if 31 >= stor[_193].field_1 % 128:
                    require ext_code.size(address(stor1[_193]))
                    staticcall address(stor1[_193]).totalNodesCreated() with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                mem[0] = _193
                mem[ceil32(ceil32(arg1.length)) + 193] = uint256(stor[sha3(_193)].field_0)
                idx = ceil32(ceil32(arg1.length)) + 193
                s = 0
                while ceil32(ceil32(arg1.length)) + stor[_193].field_1 % 128 + 161 > idx:
                    mem[idx + 32] = uint256(stor[s + sha3(_193) + 1].field_0)
                    idx = idx + 32
                    s = s + 1
                    continue 
                mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
                mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_193])
                require ext_code.size(address(stor1[_193]))
                staticcall address(stor1[_193]).totalNodesCreated() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _403 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[mem[64]] = mem[_403]
        else:
            if bool(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0) == stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_1 % 128 < 32:
                revert with 0, 34
            mem[64] = ceil32(ceil32(arg1.length)) + ceil32(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_1 % 128) + 193
            mem[ceil32(ceil32(arg1.length)) + 161] = stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_1 % 128
            if bool(stor[_193].field_0):
                if bool(stor[_193].field_0) == uint255(uint256(stor[_193].field_0)) * 0.5 < 32:
                    revert with 0, 34
                if not Mask(256, -1, uint256(stor[_193].field_0)):
                    require ext_code.size(address(stor1[_193]))
                    staticcall address(stor1[_193]).totalNodesCreated() with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                if 31 >= uint255(uint256(stor[_193].field_0)) * 0.5:
                    require ext_code.size(address(stor1[_193]))
                    staticcall address(stor1[_193]).totalNodesCreated() with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                mem[0] = _193
                mem[ceil32(ceil32(arg1.length)) + 193] = uint256(stor[sha3(_193)].field_0)
                idx = ceil32(ceil32(arg1.length)) + 193
                s = 0
                while ceil32(ceil32(arg1.length)) + (uint255(uint256(stor[_193].field_0)) * 0.5) + 161 > idx:
                    mem[idx + 32] = uint256(stor[s + sha3(_193) + 1].field_0)
                    idx = idx + 32
                    s = s + 1
                    continue 
                mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
                mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_193])
                require ext_code.size(address(stor1[_193]))
                staticcall address(stor1[_193]).totalNodesCreated() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _404 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[mem[64]] = mem[_404]
            else:
                if bool(stor[_193].field_0) == stor[_193].field_1 % 128 < 32:
                    revert with 0, 34
                if not stor[_193].field_1 % 128:
                    require ext_code.size(address(stor1[_193]))
                    staticcall address(stor1[_193]).totalNodesCreated() with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                if 31 >= stor[_193].field_1 % 128:
                    require ext_code.size(address(stor1[_193]))
                    staticcall address(stor1[_193]).totalNodesCreated() with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                mem[0] = _193
                mem[ceil32(ceil32(arg1.length)) + 193] = uint256(stor[sha3(_193)].field_0)
                idx = ceil32(ceil32(arg1.length)) + 193
                s = 0
                while ceil32(ceil32(arg1.length)) + stor[_193].field_1 % 128 + 161 > idx:
                    mem[idx + 32] = uint256(stor[s + sha3(_193) + 1].field_0)
                    idx = idx + 32
                    s = s + 1
                    continue 
                mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
                mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_193])
                require ext_code.size(address(stor1[_193]))
                staticcall address(stor1[_193]).totalNodesCreated() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _405 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[mem[64]] = mem[_405]
    else:
        _196 = sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])
        if bool(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0):
            if bool(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0) == uint255(uint256(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0)) * 0.5 < 32:
                revert with 0, 34
            mem[64] = ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0)) * 0.5) + 193
            mem[ceil32(ceil32(arg1.length)) + 161] = uint255(uint256(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0)) * 0.5
            if bool(stor[_196].field_0):
                if bool(stor[_196].field_0) == uint255(uint256(stor[_196].field_0)) * 0.5 < 32:
                    revert with 0, 34
                if not Mask(256, -1, uint256(stor[_196].field_0)):
                    require ext_code.size(address(stor1[_196]))
                    staticcall address(stor1[_196]).totalNodesCreated() with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                if 31 >= uint255(uint256(stor[_196].field_0)) * 0.5:
                    require ext_code.size(address(stor1[_196]))
                    staticcall address(stor1[_196]).totalNodesCreated() with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                mem[0] = _196
                mem[ceil32(ceil32(arg1.length)) + 193] = uint256(stor[sha3(_196)].field_0)
                idx = ceil32(ceil32(arg1.length)) + 193
                s = 0
                while ceil32(ceil32(arg1.length)) + (uint255(uint256(stor[_196].field_0)) * 0.5) + 161 > idx:
                    mem[idx + 32] = uint256(stor[s + sha3(_196) + 1].field_0)
                    idx = idx + 32
                    s = s + 1
                    continue 
                mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
                mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_196])
                require ext_code.size(address(stor1[_196]))
                staticcall address(stor1[_196]).totalNodesCreated() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _406 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[mem[64]] = mem[_406]
            else:
                if bool(stor[_196].field_0) == stor[_196].field_1 % 128 < 32:
                    revert with 0, 34
                if not stor[_196].field_1 % 128:
                    require ext_code.size(address(stor1[_196]))
                    staticcall address(stor1[_196]).totalNodesCreated() with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                if 31 >= stor[_196].field_1 % 128:
                    require ext_code.size(address(stor1[_196]))
                    staticcall address(stor1[_196]).totalNodesCreated() with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                mem[0] = _196
                mem[ceil32(ceil32(arg1.length)) + 193] = uint256(stor[sha3(_196)].field_0)
                idx = ceil32(ceil32(arg1.length)) + 193
                s = 0
                while ceil32(ceil32(arg1.length)) + stor[_196].field_1 % 128 + 161 > idx:
                    mem[idx + 32] = uint256(stor[s + sha3(_196) + 1].field_0)
                    idx = idx + 32
                    s = s + 1
                    continue 
                mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
                mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_196])
                require ext_code.size(address(stor1[_196]))
                staticcall address(stor1[_196]).totalNodesCreated() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _407 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[mem[64]] = mem[_407]
        else:
            if bool(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0) == stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_1 % 128 < 32:
                revert with 0, 34
            mem[64] = ceil32(ceil32(arg1.length)) + ceil32(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_1 % 128) + 193
            mem[ceil32(ceil32(arg1.length)) + 161] = stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_1 % 128
            if bool(stor[_196].field_0):
                if bool(stor[_196].field_0) == uint255(uint256(stor[_196].field_0)) * 0.5 < 32:
                    revert with 0, 34
                if not Mask(256, -1, uint256(stor[_196].field_0)):
                    require ext_code.size(address(stor1[_196]))
                    staticcall address(stor1[_196]).totalNodesCreated() with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                if 31 >= uint255(uint256(stor[_196].field_0)) * 0.5:
                    require ext_code.size(address(stor1[_196]))
                    staticcall address(stor1[_196]).totalNodesCreated() with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                mem[0] = _196
                mem[ceil32(ceil32(arg1.length)) + 193] = uint256(stor[sha3(_196)].field_0)
                idx = ceil32(ceil32(arg1.length)) + 193
                s = 0
                while ceil32(ceil32(arg1.length)) + (uint255(uint256(stor[_196].field_0)) * 0.5) + 161 > idx:
                    mem[idx + 32] = uint256(stor[s + sha3(_196) + 1].field_0)
                    idx = idx + 32
                    s = s + 1
                    continue 
                mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
                mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_196])
                require ext_code.size(address(stor1[_196]))
                staticcall address(stor1[_196]).totalNodesCreated() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _408 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[mem[64]] = mem[_408]
            else:
                if bool(stor[_196].field_0) == stor[_196].field_1 % 128 < 32:
                    revert with 0, 34
                if not stor[_196].field_1 % 128:
                    require ext_code.size(address(stor1[_196]))
                    staticcall address(stor1[_196]).totalNodesCreated() with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                if 31 >= stor[_196].field_1 % 128:
                    require ext_code.size(address(stor1[_196]))
                    staticcall address(stor1[_196]).totalNodesCreated() with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                mem[0] = _196
                mem[ceil32(ceil32(arg1.length)) + 193] = uint256(stor[sha3(_196)].field_0)
                idx = ceil32(ceil32(arg1.length)) + 193
                s = 0
                while ceil32(ceil32(arg1.length)) + stor[_196].field_1 % 128 + 161 > idx:
                    mem[idx + 32] = uint256(stor[s + sha3(_196) + 1].field_0)
                    idx = idx + 32
                    s = s + 1
                    continue 
                mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
                mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_196])
                require ext_code.size(address(stor1[_196]))
                staticcall address(stor1[_196]).totalNodesCreated() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _409 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[mem[64]] = mem[_409]
    return memory
      from mem[64]
       len 32
}

function sub_1d394843(?) {
    require calldata.size - 4 >= 64
    require arg1 == address(arg1)
    require arg2 <= test266151307()
    require arg2 + 35 < calldata.size
    if arg2.length > test266151307():
        revert with 0, 65
    if ceil32(ceil32(arg2.length)) + 97 < 96 or ceil32(ceil32(arg2.length)) + 97 > test266151307():
        revert with 0, 65
    mem[96] = arg2.length
    require arg2 + arg2.length + 36 <= calldata.size
    mem[128 len arg2.length] = arg2[all]
    mem[arg2.length + 128] = 0
    mem[ceil32(ceil32(arg2.length)) + 97 len ceil32(arg2.length)] = arg2[all], mem[arg2.length + 128 len ceil32(arg2.length) - arg2.length]
    mem[arg2.length + ceil32(ceil32(arg2.length)) + 97] = 24
    if ceil32(arg2.length) <= arg2.length:
        _193 = sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])
        if bool(stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_0):
            if bool(stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_0) == uint255(uint256(stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_0)) * 0.5 < 32:
                revert with 0, 34
            mem[64] = ceil32(ceil32(arg2.length)) + ceil32(uint255(uint256(stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_0)) * 0.5) + 193
            mem[ceil32(ceil32(arg2.length)) + 161] = uint255(uint256(stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_0)) * 0.5
            if bool(stor[_193].field_0):
                if bool(stor[_193].field_0) == uint255(uint256(stor[_193].field_0)) * 0.5 < 32:
                    revert with 0, 34
                if not Mask(256, -1, uint256(stor[_193].field_0)):
                    require ext_code.size(address(stor1[_193]))
                    staticcall address(stor1[_193])._getNodeNumberOf(address arg1) with:
                            gas gas_remaining wei
                           args address(arg1)
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                if 31 >= uint255(uint256(stor[_193].field_0)) * 0.5:
                    require ext_code.size(address(stor1[_193]))
                    staticcall address(stor1[_193])._getNodeNumberOf(address arg1) with:
                            gas gas_remaining wei
                           args address(arg1)
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                mem[0] = _193
                mem[ceil32(ceil32(arg2.length)) + 193] = uint256(stor[sha3(_193)].field_0)
                idx = ceil32(ceil32(arg2.length)) + 193
                s = 0
                while ceil32(ceil32(arg2.length)) + (uint255(uint256(stor[_193].field_0)) * 0.5) + 161 > idx:
                    mem[idx + 32] = uint256(stor[s + sha3(_193) + 1].field_0)
                    idx = idx + 32
                    s = s + 1
                    continue 
                mem[ceil32(ceil32(arg2.length)) + 97] = ceil32(ceil32(arg2.length)) + 161
                mem[ceil32(ceil32(arg2.length)) + 129] = address(stor1[_193])
                mem[mem[64] + 4] = address(arg1)
                require ext_code.size(address(stor1[_193]))
                staticcall address(stor1[_193])._getNodeNumberOf(address arg1) with:
                        gas gas_remaining wei
                       args address(arg1)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _402 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[mem[64]] = mem[_402]
            else:
                if bool(stor[_193].field_0) == stor[_193].field_1 % 128 < 32:
                    revert with 0, 34
                if not stor[_193].field_1 % 128:
                    require ext_code.size(address(stor1[_193]))
                    staticcall address(stor1[_193])._getNodeNumberOf(address arg1) with:
                            gas gas_remaining wei
                           args address(arg1)
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                if 31 >= stor[_193].field_1 % 128:
                    require ext_code.size(address(stor1[_193]))
                    staticcall address(stor1[_193])._getNodeNumberOf(address arg1) with:
                            gas gas_remaining wei
                           args address(arg1)
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                mem[0] = _193
                mem[ceil32(ceil32(arg2.length)) + 193] = uint256(stor[sha3(_193)].field_0)
                idx = ceil32(ceil32(arg2.length)) + 193
                s = 0
                while ceil32(ceil32(arg2.length)) + stor[_193].field_1 % 128 + 161 > idx:
                    mem[idx + 32] = uint256(stor[s + sha3(_193) + 1].field_0)
                    idx = idx + 32
                    s = s + 1
                    continue 
                mem[ceil32(ceil32(arg2.length)) + 97] = ceil32(ceil32(arg2.length)) + 161
                mem[ceil32(ceil32(arg2.length)) + 129] = address(stor1[_193])
                mem[mem[64] + 4] = address(arg1)
                require ext_code.size(address(stor1[_193]))
                staticcall address(stor1[_193])._getNodeNumberOf(address arg1) with:
                        gas gas_remaining wei
                       args address(arg1)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _403 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[mem[64]] = mem[_403]
        else:
            if bool(stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_0) == stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_1 % 128 < 32:
                revert with 0, 34
            mem[64] = ceil32(ceil32(arg2.length)) + ceil32(stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_1 % 128) + 193
            mem[ceil32(ceil32(arg2.length)) + 161] = stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_1 % 128
            if bool(stor[_193].field_0):
                if bool(stor[_193].field_0) == uint255(uint256(stor[_193].field_0)) * 0.5 < 32:
                    revert with 0, 34
                if not Mask(256, -1, uint256(stor[_193].field_0)):
                    require ext_code.size(address(stor1[_193]))
                    staticcall address(stor1[_193])._getNodeNumberOf(address arg1) with:
                            gas gas_remaining wei
                           args address(arg1)
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                if 31 >= uint255(uint256(stor[_193].field_0)) * 0.5:
                    require ext_code.size(address(stor1[_193]))
                    staticcall address(stor1[_193])._getNodeNumberOf(address arg1) with:
                            gas gas_remaining wei
                           args address(arg1)
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                mem[0] = _193
                mem[ceil32(ceil32(arg2.length)) + 193] = uint256(stor[sha3(_193)].field_0)
                idx = ceil32(ceil32(arg2.length)) + 193
                s = 0
                while ceil32(ceil32(arg2.length)) + (uint255(uint256(stor[_193].field_0)) * 0.5) + 161 > idx:
                    mem[idx + 32] = uint256(stor[s + sha3(_193) + 1].field_0)
                    idx = idx + 32
                    s = s + 1
                    continue 
                mem[ceil32(ceil32(arg2.length)) + 97] = ceil32(ceil32(arg2.length)) + 161
                mem[ceil32(ceil32(arg2.length)) + 129] = address(stor1[_193])
                mem[mem[64] + 4] = address(arg1)
                require ext_code.size(address(stor1[_193]))
                staticcall address(stor1[_193])._getNodeNumberOf(address arg1) with:
                        gas gas_remaining wei
                       args address(arg1)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _404 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[mem[64]] = mem[_404]
            else:
                if bool(stor[_193].field_0) == stor[_193].field_1 % 128 < 32:
                    revert with 0, 34
                if not stor[_193].field_1 % 128:
                    require ext_code.size(address(stor1[_193]))
                    staticcall address(stor1[_193])._getNodeNumberOf(address arg1) with:
                            gas gas_remaining wei
                           args address(arg1)
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                if 31 >= stor[_193].field_1 % 128:
                    require ext_code.size(address(stor1[_193]))
                    staticcall address(stor1[_193])._getNodeNumberOf(address arg1) with:
                            gas gas_remaining wei
                           args address(arg1)
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                mem[0] = _193
                mem[ceil32(ceil32(arg2.length)) + 193] = uint256(stor[sha3(_193)].field_0)
                idx = ceil32(ceil32(arg2.length)) + 193
                s = 0
                while ceil32(ceil32(arg2.length)) + stor[_193].field_1 % 128 + 161 > idx:
                    mem[idx + 32] = uint256(stor[s + sha3(_193) + 1].field_0)
                    idx = idx + 32
                    s = s + 1
                    continue 
                mem[ceil32(ceil32(arg2.length)) + 97] = ceil32(ceil32(arg2.length)) + 161
                mem[ceil32(ceil32(arg2.length)) + 129] = address(stor1[_193])
                mem[mem[64] + 4] = address(arg1)
                require ext_code.size(address(stor1[_193]))
                staticcall address(stor1[_193])._getNodeNumberOf(address arg1) with:
                        gas gas_remaining wei
                       args address(arg1)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _405 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[mem[64]] = mem[_405]
    else:
        _196 = sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])
        if bool(stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_0):
            if bool(stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_0) == uint255(uint256(stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_0)) * 0.5 < 32:
                revert with 0, 34
            mem[64] = ceil32(ceil32(arg2.length)) + ceil32(uint255(uint256(stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_0)) * 0.5) + 193
            mem[ceil32(ceil32(arg2.length)) + 161] = uint255(uint256(stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_0)) * 0.5
            if bool(stor[_196].field_0):
                if bool(stor[_196].field_0) == uint255(uint256(stor[_196].field_0)) * 0.5 < 32:
                    revert with 0, 34
                if not Mask(256, -1, uint256(stor[_196].field_0)):
                    require ext_code.size(address(stor1[_196]))
                    staticcall address(stor1[_196])._getNodeNumberOf(address arg1) with:
                            gas gas_remaining wei
                           args address(arg1)
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                if 31 >= uint255(uint256(stor[_196].field_0)) * 0.5:
                    require ext_code.size(address(stor1[_196]))
                    staticcall address(stor1[_196])._getNodeNumberOf(address arg1) with:
                            gas gas_remaining wei
                           args address(arg1)
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                mem[0] = _196
                mem[ceil32(ceil32(arg2.length)) + 193] = uint256(stor[sha3(_196)].field_0)
                idx = ceil32(ceil32(arg2.length)) + 193
                s = 0
                while ceil32(ceil32(arg2.length)) + (uint255(uint256(stor[_196].field_0)) * 0.5) + 161 > idx:
                    mem[idx + 32] = uint256(stor[s + sha3(_196) + 1].field_0)
                    idx = idx + 32
                    s = s + 1
                    continue 
                mem[ceil32(ceil32(arg2.length)) + 97] = ceil32(ceil32(arg2.length)) + 161
                mem[ceil32(ceil32(arg2.length)) + 129] = address(stor1[_196])
                mem[mem[64] + 4] = address(arg1)
                require ext_code.size(address(stor1[_196]))
                staticcall address(stor1[_196])._getNodeNumberOf(address arg1) with:
                        gas gas_remaining wei
                       args address(arg1)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _406 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[mem[64]] = mem[_406]
            else:
                if bool(stor[_196].field_0) == stor[_196].field_1 % 128 < 32:
                    revert with 0, 34
                if not stor[_196].field_1 % 128:
                    require ext_code.size(address(stor1[_196]))
                    staticcall address(stor1[_196])._getNodeNumberOf(address arg1) with:
                            gas gas_remaining wei
                           args address(arg1)
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                if 31 >= stor[_196].field_1 % 128:
                    require ext_code.size(address(stor1[_196]))
                    staticcall address(stor1[_196])._getNodeNumberOf(address arg1) with:
                            gas gas_remaining wei
                           args address(arg1)
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                mem[0] = _196
                mem[ceil32(ceil32(arg2.length)) + 193] = uint256(stor[sha3(_196)].field_0)
                idx = ceil32(ceil32(arg2.length)) + 193
                s = 0
                while ceil32(ceil32(arg2.length)) + stor[_196].field_1 % 128 + 161 > idx:
                    mem[idx + 32] = uint256(stor[s + sha3(_196) + 1].field_0)
                    idx = idx + 32
                    s = s + 1
                    continue 
                mem[ceil32(ceil32(arg2.length)) + 97] = ceil32(ceil32(arg2.length)) + 161
                mem[ceil32(ceil32(arg2.length)) + 129] = address(stor1[_196])
                mem[mem[64] + 4] = address(arg1)
                require ext_code.size(address(stor1[_196]))
                staticcall address(stor1[_196])._getNodeNumberOf(address arg1) with:
                        gas gas_remaining wei
                       args address(arg1)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _407 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[mem[64]] = mem[_407]
        else:
            if bool(stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_0) == stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_1 % 128 < 32:
                revert with 0, 34
            mem[64] = ceil32(ceil32(arg2.length)) + ceil32(stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_1 % 128) + 193
            mem[ceil32(ceil32(arg2.length)) + 161] = stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_1 % 128
            if bool(stor[_196].field_0):
                if bool(stor[_196].field_0) == uint255(uint256(stor[_196].field_0)) * 0.5 < 32:
                    revert with 0, 34
                if not Mask(256, -1, uint256(stor[_196].field_0)):
                    require ext_code.size(address(stor1[_196]))
                    staticcall address(stor1[_196])._getNodeNumberOf(address arg1) with:
                            gas gas_remaining wei
                           args address(arg1)
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                if 31 >= uint255(uint256(stor[_196].field_0)) * 0.5:
                    require ext_code.size(address(stor1[_196]))
                    staticcall address(stor1[_196])._getNodeNumberOf(address arg1) with:
                            gas gas_remaining wei
                           args address(arg1)
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                mem[0] = _196
                mem[ceil32(ceil32(arg2.length)) + 193] = uint256(stor[sha3(_196)].field_0)
                idx = ceil32(ceil32(arg2.length)) + 193
                s = 0
                while ceil32(ceil32(arg2.length)) + (uint255(uint256(stor[_196].field_0)) * 0.5) + 161 > idx:
                    mem[idx + 32] = uint256(stor[s + sha3(_196) + 1].field_0)
                    idx = idx + 32
                    s = s + 1
                    continue 
                mem[ceil32(ceil32(arg2.length)) + 97] = ceil32(ceil32(arg2.length)) + 161
                mem[ceil32(ceil32(arg2.length)) + 129] = address(stor1[_196])
                mem[mem[64] + 4] = address(arg1)
                require ext_code.size(address(stor1[_196]))
                staticcall address(stor1[_196])._getNodeNumberOf(address arg1) with:
                        gas gas_remaining wei
                       args address(arg1)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _408 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[mem[64]] = mem[_408]
            else:
                if bool(stor[_196].field_0) == stor[_196].field_1 % 128 < 32:
                    revert with 0, 34
                if not stor[_196].field_1 % 128:
                    require ext_code.size(address(stor1[_196]))
                    staticcall address(stor1[_196])._getNodeNumberOf(address arg1) with:
                            gas gas_remaining wei
                           args address(arg1)
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                if 31 >= stor[_196].field_1 % 128:
                    require ext_code.size(address(stor1[_196]))
                    staticcall address(stor1[_196])._getNodeNumberOf(address arg1) with:
                            gas gas_remaining wei
                           args address(arg1)
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                mem[0] = _196
                mem[ceil32(ceil32(arg2.length)) + 193] = uint256(stor[sha3(_196)].field_0)
                idx = ceil32(ceil32(arg2.length)) + 193
                s = 0
                while ceil32(ceil32(arg2.length)) + stor[_196].field_1 % 128 + 161 > idx:
                    mem[idx + 32] = uint256(stor[s + sha3(_196) + 1].field_0)
                    idx = idx + 32
                    s = s + 1
                    continue 
                mem[ceil32(ceil32(arg2.length)) + 97] = ceil32(ceil32(arg2.length)) + 161
                mem[ceil32(ceil32(arg2.length)) + 129] = address(stor1[_196])
                mem[mem[64] + 4] = address(arg1)
                require ext_code.size(address(stor1[_196]))
                staticcall address(stor1[_196])._getNodeNumberOf(address arg1) with:
                        gas gas_remaining wei
                       args address(arg1)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _409 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[mem[64]] = mem[_409]
    return memory
      from mem[64]
       len 32
}

function sub_9da7caf1(?) {
    require calldata.size - 4 >= 64
    require arg1 == address(arg1)
    require arg2 <= test266151307()
    require arg2 + 35 < calldata.size
    if arg2.length > test266151307():
        revert with 0, 65
    if ceil32(ceil32(arg2.length)) + 97 < 96 or ceil32(ceil32(arg2.length)) + 97 > test266151307():
        revert with 0, 65
    mem[96] = arg2.length
    require arg2 + arg2.length + 36 <= calldata.size
    mem[128 len arg2.length] = arg2[all]
    mem[arg2.length + 128] = 0
    mem[ceil32(ceil32(arg2.length)) + 97 len ceil32(arg2.length)] = arg2[all], mem[arg2.length + 128 len ceil32(arg2.length) - arg2.length]
    mem[arg2.length + ceil32(ceil32(arg2.length)) + 97] = 24
    if ceil32(arg2.length) <= arg2.length:
        _193 = sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])
        if bool(stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_0):
            if bool(stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_0) == uint255(uint256(stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_0)) * 0.5 < 32:
                revert with 0, 34
            mem[64] = ceil32(ceil32(arg2.length)) + ceil32(uint255(uint256(stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_0)) * 0.5) + 193
            mem[ceil32(ceil32(arg2.length)) + 161] = uint255(uint256(stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_0)) * 0.5
            if bool(stor[_193].field_0):
                if bool(stor[_193].field_0) == uint255(uint256(stor[_193].field_0)) * 0.5 < 32:
                    revert with 0, 34
                if not Mask(256, -1, uint256(stor[_193].field_0)):
                    require ext_code.size(address(stor1[_193]))
                    staticcall address(stor1[_193])._getRewardAmountOf(address arg1) with:
                            gas gas_remaining wei
                           args address(arg1)
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                if 31 >= uint255(uint256(stor[_193].field_0)) * 0.5:
                    require ext_code.size(address(stor1[_193]))
                    staticcall address(stor1[_193])._getRewardAmountOf(address arg1) with:
                            gas gas_remaining wei
                           args address(arg1)
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                mem[0] = _193
                mem[ceil32(ceil32(arg2.length)) + 193] = uint256(stor[sha3(_193)].field_0)
                idx = ceil32(ceil32(arg2.length)) + 193
                s = 0
                while ceil32(ceil32(arg2.length)) + (uint255(uint256(stor[_193].field_0)) * 0.5) + 161 > idx:
                    mem[idx + 32] = uint256(stor[s + sha3(_193) + 1].field_0)
                    idx = idx + 32
                    s = s + 1
                    continue 
                mem[ceil32(ceil32(arg2.length)) + 97] = ceil32(ceil32(arg2.length)) + 161
                mem[ceil32(ceil32(arg2.length)) + 129] = address(stor1[_193])
                mem[mem[64] + 4] = address(arg1)
                require ext_code.size(address(stor1[_193]))
                staticcall address(stor1[_193])._getRewardAmountOf(address arg1) with:
                        gas gas_remaining wei
                       args address(arg1)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _402 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[mem[64]] = mem[_402]
            else:
                if bool(stor[_193].field_0) == stor[_193].field_1 % 128 < 32:
                    revert with 0, 34
                if not stor[_193].field_1 % 128:
                    require ext_code.size(address(stor1[_193]))
                    staticcall address(stor1[_193])._getRewardAmountOf(address arg1) with:
                            gas gas_remaining wei
                           args address(arg1)
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                if 31 >= stor[_193].field_1 % 128:
                    require ext_code.size(address(stor1[_193]))
                    staticcall address(stor1[_193])._getRewardAmountOf(address arg1) with:
                            gas gas_remaining wei
                           args address(arg1)
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                mem[0] = _193
                mem[ceil32(ceil32(arg2.length)) + 193] = uint256(stor[sha3(_193)].field_0)
                idx = ceil32(ceil32(arg2.length)) + 193
                s = 0
                while ceil32(ceil32(arg2.length)) + stor[_193].field_1 % 128 + 161 > idx:
                    mem[idx + 32] = uint256(stor[s + sha3(_193) + 1].field_0)
                    idx = idx + 32
                    s = s + 1
                    continue 
                mem[ceil32(ceil32(arg2.length)) + 97] = ceil32(ceil32(arg2.length)) + 161
                mem[ceil32(ceil32(arg2.length)) + 129] = address(stor1[_193])
                mem[mem[64] + 4] = address(arg1)
                require ext_code.size(address(stor1[_193]))
                staticcall address(stor1[_193])._getRewardAmountOf(address arg1) with:
                        gas gas_remaining wei
                       args address(arg1)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _403 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[mem[64]] = mem[_403]
        else:
            if bool(stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_0) == stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_1 % 128 < 32:
                revert with 0, 34
            mem[64] = ceil32(ceil32(arg2.length)) + ceil32(stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_1 % 128) + 193
            mem[ceil32(ceil32(arg2.length)) + 161] = stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_1 % 128
            if bool(stor[_193].field_0):
                if bool(stor[_193].field_0) == uint255(uint256(stor[_193].field_0)) * 0.5 < 32:
                    revert with 0, 34
                if not Mask(256, -1, uint256(stor[_193].field_0)):
                    require ext_code.size(address(stor1[_193]))
                    staticcall address(stor1[_193])._getRewardAmountOf(address arg1) with:
                            gas gas_remaining wei
                           args address(arg1)
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                if 31 >= uint255(uint256(stor[_193].field_0)) * 0.5:
                    require ext_code.size(address(stor1[_193]))
                    staticcall address(stor1[_193])._getRewardAmountOf(address arg1) with:
                            gas gas_remaining wei
                           args address(arg1)
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                mem[0] = _193
                mem[ceil32(ceil32(arg2.length)) + 193] = uint256(stor[sha3(_193)].field_0)
                idx = ceil32(ceil32(arg2.length)) + 193
                s = 0
                while ceil32(ceil32(arg2.length)) + (uint255(uint256(stor[_193].field_0)) * 0.5) + 161 > idx:
                    mem[idx + 32] = uint256(stor[s + sha3(_193) + 1].field_0)
                    idx = idx + 32
                    s = s + 1
                    continue 
                mem[ceil32(ceil32(arg2.length)) + 97] = ceil32(ceil32(arg2.length)) + 161
                mem[ceil32(ceil32(arg2.length)) + 129] = address(stor1[_193])
                mem[mem[64] + 4] = address(arg1)
                require ext_code.size(address(stor1[_193]))
                staticcall address(stor1[_193])._getRewardAmountOf(address arg1) with:
                        gas gas_remaining wei
                       args address(arg1)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _404 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[mem[64]] = mem[_404]
            else:
                if bool(stor[_193].field_0) == stor[_193].field_1 % 128 < 32:
                    revert with 0, 34
                if not stor[_193].field_1 % 128:
                    require ext_code.size(address(stor1[_193]))
                    staticcall address(stor1[_193])._getRewardAmountOf(address arg1) with:
                            gas gas_remaining wei
                           args address(arg1)
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                if 31 >= stor[_193].field_1 % 128:
                    require ext_code.size(address(stor1[_193]))
                    staticcall address(stor1[_193])._getRewardAmountOf(address arg1) with:
                            gas gas_remaining wei
                           args address(arg1)
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                mem[0] = _193
                mem[ceil32(ceil32(arg2.length)) + 193] = uint256(stor[sha3(_193)].field_0)
                idx = ceil32(ceil32(arg2.length)) + 193
                s = 0
                while ceil32(ceil32(arg2.length)) + stor[_193].field_1 % 128 + 161 > idx:
                    mem[idx + 32] = uint256(stor[s + sha3(_193) + 1].field_0)
                    idx = idx + 32
                    s = s + 1
                    continue 
                mem[ceil32(ceil32(arg2.length)) + 97] = ceil32(ceil32(arg2.length)) + 161
                mem[ceil32(ceil32(arg2.length)) + 129] = address(stor1[_193])
                mem[mem[64] + 4] = address(arg1)
                require ext_code.size(address(stor1[_193]))
                staticcall address(stor1[_193])._getRewardAmountOf(address arg1) with:
                        gas gas_remaining wei
                       args address(arg1)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _405 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[mem[64]] = mem[_405]
    else:
        _196 = sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])
        if bool(stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_0):
            if bool(stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_0) == uint255(uint256(stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_0)) * 0.5 < 32:
                revert with 0, 34
            mem[64] = ceil32(ceil32(arg2.length)) + ceil32(uint255(uint256(stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_0)) * 0.5) + 193
            mem[ceil32(ceil32(arg2.length)) + 161] = uint255(uint256(stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_0)) * 0.5
            if bool(stor[_196].field_0):
                if bool(stor[_196].field_0) == uint255(uint256(stor[_196].field_0)) * 0.5 < 32:
                    revert with 0, 34
                if not Mask(256, -1, uint256(stor[_196].field_0)):
                    require ext_code.size(address(stor1[_196]))
                    staticcall address(stor1[_196])._getRewardAmountOf(address arg1) with:
                            gas gas_remaining wei
                           args address(arg1)
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                if 31 >= uint255(uint256(stor[_196].field_0)) * 0.5:
                    require ext_code.size(address(stor1[_196]))
                    staticcall address(stor1[_196])._getRewardAmountOf(address arg1) with:
                            gas gas_remaining wei
                           args address(arg1)
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                mem[0] = _196
                mem[ceil32(ceil32(arg2.length)) + 193] = uint256(stor[sha3(_196)].field_0)
                idx = ceil32(ceil32(arg2.length)) + 193
                s = 0
                while ceil32(ceil32(arg2.length)) + (uint255(uint256(stor[_196].field_0)) * 0.5) + 161 > idx:
                    mem[idx + 32] = uint256(stor[s + sha3(_196) + 1].field_0)
                    idx = idx + 32
                    s = s + 1
                    continue 
                mem[ceil32(ceil32(arg2.length)) + 97] = ceil32(ceil32(arg2.length)) + 161
                mem[ceil32(ceil32(arg2.length)) + 129] = address(stor1[_196])
                mem[mem[64] + 4] = address(arg1)
                require ext_code.size(address(stor1[_196]))
                staticcall address(stor1[_196])._getRewardAmountOf(address arg1) with:
                        gas gas_remaining wei
                       args address(arg1)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _406 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[mem[64]] = mem[_406]
            else:
                if bool(stor[_196].field_0) == stor[_196].field_1 % 128 < 32:
                    revert with 0, 34
                if not stor[_196].field_1 % 128:
                    require ext_code.size(address(stor1[_196]))
                    staticcall address(stor1[_196])._getRewardAmountOf(address arg1) with:
                            gas gas_remaining wei
                           args address(arg1)
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                if 31 >= stor[_196].field_1 % 128:
                    require ext_code.size(address(stor1[_196]))
                    staticcall address(stor1[_196])._getRewardAmountOf(address arg1) with:
                            gas gas_remaining wei
                           args address(arg1)
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                mem[0] = _196
                mem[ceil32(ceil32(arg2.length)) + 193] = uint256(stor[sha3(_196)].field_0)
                idx = ceil32(ceil32(arg2.length)) + 193
                s = 0
                while ceil32(ceil32(arg2.length)) + stor[_196].field_1 % 128 + 161 > idx:
                    mem[idx + 32] = uint256(stor[s + sha3(_196) + 1].field_0)
                    idx = idx + 32
                    s = s + 1
                    continue 
                mem[ceil32(ceil32(arg2.length)) + 97] = ceil32(ceil32(arg2.length)) + 161
                mem[ceil32(ceil32(arg2.length)) + 129] = address(stor1[_196])
                mem[mem[64] + 4] = address(arg1)
                require ext_code.size(address(stor1[_196]))
                staticcall address(stor1[_196])._getRewardAmountOf(address arg1) with:
                        gas gas_remaining wei
                       args address(arg1)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _407 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[mem[64]] = mem[_407]
        else:
            if bool(stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_0) == stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_1 % 128 < 32:
                revert with 0, 34
            mem[64] = ceil32(ceil32(arg2.length)) + ceil32(stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_1 % 128) + 193
            mem[ceil32(ceil32(arg2.length)) + 161] = stor[sha3(mem[ceil32(ceil32(arg2.length)) + 97 len arg2.length + 32])].field_1 % 128
            if bool(stor[_196].field_0):
                if bool(stor[_196].field_0) == uint255(uint256(stor[_196].field_0)) * 0.5 < 32:
                    revert with 0, 34
                if not Mask(256, -1, uint256(stor[_196].field_0)):
                    require ext_code.size(address(stor1[_196]))
                    staticcall address(stor1[_196])._getRewardAmountOf(address arg1) with:
                            gas gas_remaining wei
                           args address(arg1)
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                if 31 >= uint255(uint256(stor[_196].field_0)) * 0.5:
                    require ext_code.size(address(stor1[_196]))
                    staticcall address(stor1[_196])._getRewardAmountOf(address arg1) with:
                            gas gas_remaining wei
                           args address(arg1)
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                mem[0] = _196
                mem[ceil32(ceil32(arg2.length)) + 193] = uint256(stor[sha3(_196)].field_0)
                idx = ceil32(ceil32(arg2.length)) + 193
                s = 0
                while ceil32(ceil32(arg2.length)) + (uint255(uint256(stor[_196].field_0)) * 0.5) + 161 > idx:
                    mem[idx + 32] = uint256(stor[s + sha3(_196) + 1].field_0)
                    idx = idx + 32
                    s = s + 1
                    continue 
                mem[ceil32(ceil32(arg2.length)) + 97] = ceil32(ceil32(arg2.length)) + 161
                mem[ceil32(ceil32(arg2.length)) + 129] = address(stor1[_196])
                mem[mem[64] + 4] = address(arg1)
                require ext_code.size(address(stor1[_196]))
                staticcall address(stor1[_196])._getRewardAmountOf(address arg1) with:
                        gas gas_remaining wei
                       args address(arg1)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _408 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[mem[64]] = mem[_408]
            else:
                if bool(stor[_196].field_0) == stor[_196].field_1 % 128 < 32:
                    revert with 0, 34
                if not stor[_196].field_1 % 128:
                    require ext_code.size(address(stor1[_196]))
                    staticcall address(stor1[_196])._getRewardAmountOf(address arg1) with:
                            gas gas_remaining wei
                           args address(arg1)
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                if 31 >= stor[_196].field_1 % 128:
                    require ext_code.size(address(stor1[_196]))
                    staticcall address(stor1[_196])._getRewardAmountOf(address arg1) with:
                            gas gas_remaining wei
                           args address(arg1)
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                mem[0] = _196
                mem[ceil32(ceil32(arg2.length)) + 193] = uint256(stor[sha3(_196)].field_0)
                idx = ceil32(ceil32(arg2.length)) + 193
                s = 0
                while ceil32(ceil32(arg2.length)) + stor[_196].field_1 % 128 + 161 > idx:
                    mem[idx + 32] = uint256(stor[s + sha3(_196) + 1].field_0)
                    idx = idx + 32
                    s = s + 1
                    continue 
                mem[ceil32(ceil32(arg2.length)) + 97] = ceil32(ceil32(arg2.length)) + 161
                mem[ceil32(ceil32(arg2.length)) + 129] = address(stor1[_196])
                mem[mem[64] + 4] = address(arg1)
                require ext_code.size(address(stor1[_196]))
                staticcall address(stor1[_196])._getRewardAmountOf(address arg1) with:
                        gas gas_remaining wei
                       args address(arg1)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _409 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[mem[64]] = mem[_409]
    return memory
      from mem[64]
       len 32
}

function sub_6984bf07(?) {
    require calldata.size - 4 >= 32
    require arg1 <= test266151307()
    require arg1 + 35 < calldata.size
    if arg1.length > test266151307():
        revert with 0, 65
    if ceil32(ceil32(arg1.length)) + 97 < 96 or ceil32(ceil32(arg1.length)) + 97 > test266151307():
        revert with 0, 65
    mem[96] = arg1.length
    require arg1 + arg1.length + 36 <= calldata.size
    mem[128 len arg1.length] = arg1[all]
    mem[arg1.length + 128] = 0
    if not msg.sender:
        revert with 0, 'SENDER CAN'T BE ZERO'
    mem[ceil32(ceil32(arg1.length)) + 97 len ceil32(arg1.length)] = arg1[all], mem[arg1.length + 128 len ceil32(arg1.length) - arg1.length]
    mem[arg1.length + ceil32(ceil32(arg1.length)) + 97] = 24
    if ceil32(arg1.length) <= arg1.length:
        _339 = sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])
        if bool(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0):
            if bool(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0) == uint255(uint256(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0)) * 0.5 < 32:
                revert with 0, 34
            mem[64] = ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0)) * 0.5) + 193
            mem[ceil32(ceil32(arg1.length)) + 161] = uint255(uint256(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0)) * 0.5
            if bool(stor[_339].field_0):
                if bool(stor[_339].field_0) == uint255(uint256(stor[_339].field_0)) * 0.5 < 32:
                    revert with 0, 34
                if not Mask(256, -1, uint256(stor[_339].field_0)):
                    require ext_code.size(address(stor1[_339]))
                    staticcall address(stor1[_339])._isNodeOwner(address arg1) with:
                            gas gas_remaining wei
                           args msg.sender
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                    if not ext_call.return_data[0]:
                        revert with 0, 'NO NODE OWNER'
                    require ext_code.size(address(stor1[_339]))
                    staticcall address(stor1[_339])._getRewardAmountOf(address arg1) with:
                            gas gas_remaining wei
                           args msg.sender
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                if 31 >= uint255(uint256(stor[_339].field_0)) * 0.5:
                    require ext_code.size(address(stor1[_339]))
                    staticcall address(stor1[_339])._isNodeOwner(address arg1) with:
                            gas gas_remaining wei
                           args msg.sender
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                    if not ext_call.return_data[0]:
                        revert with 0, 'NO NODE OWNER'
                    require ext_code.size(address(stor1[_339]))
                    staticcall address(stor1[_339])._getRewardAmountOf(address arg1) with:
                            gas gas_remaining wei
                           args msg.sender
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                mem[0] = _339
                mem[ceil32(ceil32(arg1.length)) + 193] = uint256(stor[sha3(_339)].field_0)
                idx = ceil32(ceil32(arg1.length)) + 193
                s = 0
                while ceil32(ceil32(arg1.length)) + (uint255(uint256(stor[_339].field_0)) * 0.5) + 161 > idx:
                    mem[idx + 32] = uint256(stor[s + sha3(_339) + 1].field_0)
                    idx = idx + 32
                    s = s + 1
                    continue 
                mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
                mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_339])
                mem[mem[64] + 4] = msg.sender
                require ext_code.size(address(stor1[_339]))
                staticcall address(stor1[_339])._isNodeOwner(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _692 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_692] == bool(mem[_692])
                if not mem[_692]:
                    revert with 0, 'NO NODE OWNER'
                mem[mem[64] + 4] = msg.sender
                require ext_code.size(address(stor1[_339]))
                staticcall address(stor1[_339])._getRewardAmountOf(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _732 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[mem[64]] = mem[_732]
            else:
                if bool(stor[_339].field_0) == stor[_339].field_1 % 128 < 32:
                    revert with 0, 34
                if not stor[_339].field_1 % 128:
                    require ext_code.size(address(stor1[_339]))
                    staticcall address(stor1[_339])._isNodeOwner(address arg1) with:
                            gas gas_remaining wei
                           args msg.sender
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                    if not ext_call.return_data[0]:
                        revert with 0, 'NO NODE OWNER'
                    require ext_code.size(address(stor1[_339]))
                    staticcall address(stor1[_339])._getRewardAmountOf(address arg1) with:
                            gas gas_remaining wei
                           args msg.sender
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                if 31 >= stor[_339].field_1 % 128:
                    require ext_code.size(address(stor1[_339]))
                    staticcall address(stor1[_339])._isNodeOwner(address arg1) with:
                            gas gas_remaining wei
                           args msg.sender
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                    if not ext_call.return_data[0]:
                        revert with 0, 'NO NODE OWNER'
                    require ext_code.size(address(stor1[_339]))
                    staticcall address(stor1[_339])._getRewardAmountOf(address arg1) with:
                            gas gas_remaining wei
                           args msg.sender
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                mem[0] = _339
                mem[ceil32(ceil32(arg1.length)) + 193] = uint256(stor[sha3(_339)].field_0)
                idx = ceil32(ceil32(arg1.length)) + 193
                s = 0
                while ceil32(ceil32(arg1.length)) + stor[_339].field_1 % 128 + 161 > idx:
                    mem[idx + 32] = uint256(stor[s + sha3(_339) + 1].field_0)
                    idx = idx + 32
                    s = s + 1
                    continue 
                mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
                mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_339])
                mem[mem[64] + 4] = msg.sender
                require ext_code.size(address(stor1[_339]))
                staticcall address(stor1[_339])._isNodeOwner(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _693 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_693] == bool(mem[_693])
                if not mem[_693]:
                    revert with 0, 'NO NODE OWNER'
                mem[mem[64] + 4] = msg.sender
                require ext_code.size(address(stor1[_339]))
                staticcall address(stor1[_339])._getRewardAmountOf(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _734 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[mem[64]] = mem[_734]
        else:
            if bool(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0) == stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_1 % 128 < 32:
                revert with 0, 34
            mem[64] = ceil32(ceil32(arg1.length)) + ceil32(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_1 % 128) + 193
            mem[ceil32(ceil32(arg1.length)) + 161] = stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_1 % 128
            if bool(stor[_339].field_0):
                if bool(stor[_339].field_0) == uint255(uint256(stor[_339].field_0)) * 0.5 < 32:
                    revert with 0, 34
                if not Mask(256, -1, uint256(stor[_339].field_0)):
                    require ext_code.size(address(stor1[_339]))
                    staticcall address(stor1[_339])._isNodeOwner(address arg1) with:
                            gas gas_remaining wei
                           args msg.sender
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                    if not ext_call.return_data[0]:
                        revert with 0, 'NO NODE OWNER'
                    require ext_code.size(address(stor1[_339]))
                    staticcall address(stor1[_339])._getRewardAmountOf(address arg1) with:
                            gas gas_remaining wei
                           args msg.sender
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                if 31 >= uint255(uint256(stor[_339].field_0)) * 0.5:
                    require ext_code.size(address(stor1[_339]))
                    staticcall address(stor1[_339])._isNodeOwner(address arg1) with:
                            gas gas_remaining wei
                           args msg.sender
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                    if not ext_call.return_data[0]:
                        revert with 0, 'NO NODE OWNER'
                    require ext_code.size(address(stor1[_339]))
                    staticcall address(stor1[_339])._getRewardAmountOf(address arg1) with:
                            gas gas_remaining wei
                           args msg.sender
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                mem[0] = _339
                mem[ceil32(ceil32(arg1.length)) + 193] = uint256(stor[sha3(_339)].field_0)
                idx = ceil32(ceil32(arg1.length)) + 193
                s = 0
                while ceil32(ceil32(arg1.length)) + (uint255(uint256(stor[_339].field_0)) * 0.5) + 161 > idx:
                    mem[idx + 32] = uint256(stor[s + sha3(_339) + 1].field_0)
                    idx = idx + 32
                    s = s + 1
                    continue 
                mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
                mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_339])
                mem[mem[64] + 4] = msg.sender
                require ext_code.size(address(stor1[_339]))
                staticcall address(stor1[_339])._isNodeOwner(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _694 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_694] == bool(mem[_694])
                if not mem[_694]:
                    revert with 0, 'NO NODE OWNER'
                mem[mem[64] + 4] = msg.sender
                require ext_code.size(address(stor1[_339]))
                staticcall address(stor1[_339])._getRewardAmountOf(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _736 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[mem[64]] = mem[_736]
            else:
                if bool(stor[_339].field_0) == stor[_339].field_1 % 128 < 32:
                    revert with 0, 34
                if not stor[_339].field_1 % 128:
                    require ext_code.size(address(stor1[_339]))
                    staticcall address(stor1[_339])._isNodeOwner(address arg1) with:
                            gas gas_remaining wei
                           args msg.sender
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                    if not ext_call.return_data[0]:
                        revert with 0, 'NO NODE OWNER'
                    require ext_code.size(address(stor1[_339]))
                    staticcall address(stor1[_339])._getRewardAmountOf(address arg1) with:
                            gas gas_remaining wei
                           args msg.sender
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                if 31 >= stor[_339].field_1 % 128:
                    require ext_code.size(address(stor1[_339]))
                    staticcall address(stor1[_339])._isNodeOwner(address arg1) with:
                            gas gas_remaining wei
                           args msg.sender
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                    if not ext_call.return_data[0]:
                        revert with 0, 'NO NODE OWNER'
                    require ext_code.size(address(stor1[_339]))
                    staticcall address(stor1[_339])._getRewardAmountOf(address arg1) with:
                            gas gas_remaining wei
                           args msg.sender
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                mem[0] = _339
                mem[ceil32(ceil32(arg1.length)) + 193] = uint256(stor[sha3(_339)].field_0)
                idx = ceil32(ceil32(arg1.length)) + 193
                s = 0
                while ceil32(ceil32(arg1.length)) + stor[_339].field_1 % 128 + 161 > idx:
                    mem[idx + 32] = uint256(stor[s + sha3(_339) + 1].field_0)
                    idx = idx + 32
                    s = s + 1
                    continue 
                mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
                mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_339])
                mem[mem[64] + 4] = msg.sender
                require ext_code.size(address(stor1[_339]))
                staticcall address(stor1[_339])._isNodeOwner(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _695 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_695] == bool(mem[_695])
                if not mem[_695]:
                    revert with 0, 'NO NODE OWNER'
                mem[mem[64] + 4] = msg.sender
                require ext_code.size(address(stor1[_339]))
                staticcall address(stor1[_339])._getRewardAmountOf(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _738 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[mem[64]] = mem[_738]
    else:
        _342 = sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])
        if bool(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0):
            if bool(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0) == uint255(uint256(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0)) * 0.5 < 32:
                revert with 0, 34
            mem[64] = ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0)) * 0.5) + 193
            mem[ceil32(ceil32(arg1.length)) + 161] = uint255(uint256(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0)) * 0.5
            if bool(stor[_342].field_0):
                if bool(stor[_342].field_0) == uint255(uint256(stor[_342].field_0)) * 0.5 < 32:
                    revert with 0, 34
                if not Mask(256, -1, uint256(stor[_342].field_0)):
                    require ext_code.size(address(stor1[_342]))
                    staticcall address(stor1[_342])._isNodeOwner(address arg1) with:
                            gas gas_remaining wei
                           args msg.sender
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                    if not ext_call.return_data[0]:
                        revert with 0, 'NO NODE OWNER'
                    require ext_code.size(address(stor1[_342]))
                    staticcall address(stor1[_342])._getRewardAmountOf(address arg1) with:
                            gas gas_remaining wei
                           args msg.sender
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                if 31 >= uint255(uint256(stor[_342].field_0)) * 0.5:
                    require ext_code.size(address(stor1[_342]))
                    staticcall address(stor1[_342])._isNodeOwner(address arg1) with:
                            gas gas_remaining wei
                           args msg.sender
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                    if not ext_call.return_data[0]:
                        revert with 0, 'NO NODE OWNER'
                    require ext_code.size(address(stor1[_342]))
                    staticcall address(stor1[_342])._getRewardAmountOf(address arg1) with:
                            gas gas_remaining wei
                           args msg.sender
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                mem[0] = _342
                mem[ceil32(ceil32(arg1.length)) + 193] = uint256(stor[sha3(_342)].field_0)
                idx = ceil32(ceil32(arg1.length)) + 193
                s = 0
                while ceil32(ceil32(arg1.length)) + (uint255(uint256(stor[_342].field_0)) * 0.5) + 161 > idx:
                    mem[idx + 32] = uint256(stor[s + sha3(_342) + 1].field_0)
                    idx = idx + 32
                    s = s + 1
                    continue 
                mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
                mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_342])
                mem[mem[64] + 4] = msg.sender
                require ext_code.size(address(stor1[_342]))
                staticcall address(stor1[_342])._isNodeOwner(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _696 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_696] == bool(mem[_696])
                if not mem[_696]:
                    revert with 0, 'NO NODE OWNER'
                mem[mem[64] + 4] = msg.sender
                require ext_code.size(address(stor1[_342]))
                staticcall address(stor1[_342])._getRewardAmountOf(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _740 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[mem[64]] = mem[_740]
            else:
                if bool(stor[_342].field_0) == stor[_342].field_1 % 128 < 32:
                    revert with 0, 34
                if not stor[_342].field_1 % 128:
                    require ext_code.size(address(stor1[_342]))
                    staticcall address(stor1[_342])._isNodeOwner(address arg1) with:
                            gas gas_remaining wei
                           args msg.sender
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                    if not ext_call.return_data[0]:
                        revert with 0, 'NO NODE OWNER'
                    require ext_code.size(address(stor1[_342]))
                    staticcall address(stor1[_342])._getRewardAmountOf(address arg1) with:
                            gas gas_remaining wei
                           args msg.sender
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                if 31 >= stor[_342].field_1 % 128:
                    require ext_code.size(address(stor1[_342]))
                    staticcall address(stor1[_342])._isNodeOwner(address arg1) with:
                            gas gas_remaining wei
                           args msg.sender
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                    if not ext_call.return_data[0]:
                        revert with 0, 'NO NODE OWNER'
                    require ext_code.size(address(stor1[_342]))
                    staticcall address(stor1[_342])._getRewardAmountOf(address arg1) with:
                            gas gas_remaining wei
                           args msg.sender
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                mem[0] = _342
                mem[ceil32(ceil32(arg1.length)) + 193] = uint256(stor[sha3(_342)].field_0)
                idx = ceil32(ceil32(arg1.length)) + 193
                s = 0
                while ceil32(ceil32(arg1.length)) + stor[_342].field_1 % 128 + 161 > idx:
                    mem[idx + 32] = uint256(stor[s + sha3(_342) + 1].field_0)
                    idx = idx + 32
                    s = s + 1
                    continue 
                mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
                mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_342])
                mem[mem[64] + 4] = msg.sender
                require ext_code.size(address(stor1[_342]))
                staticcall address(stor1[_342])._isNodeOwner(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _697 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_697] == bool(mem[_697])
                if not mem[_697]:
                    revert with 0, 'NO NODE OWNER'
                mem[mem[64] + 4] = msg.sender
                require ext_code.size(address(stor1[_342]))
                staticcall address(stor1[_342])._getRewardAmountOf(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _742 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[mem[64]] = mem[_742]
        else:
            if bool(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0) == stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_1 % 128 < 32:
                revert with 0, 34
            mem[64] = ceil32(ceil32(arg1.length)) + ceil32(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_1 % 128) + 193
            mem[ceil32(ceil32(arg1.length)) + 161] = stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_1 % 128
            if bool(stor[_342].field_0):
                if bool(stor[_342].field_0) == uint255(uint256(stor[_342].field_0)) * 0.5 < 32:
                    revert with 0, 34
                if not Mask(256, -1, uint256(stor[_342].field_0)):
                    require ext_code.size(address(stor1[_342]))
                    staticcall address(stor1[_342])._isNodeOwner(address arg1) with:
                            gas gas_remaining wei
                           args msg.sender
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                    if not ext_call.return_data[0]:
                        revert with 0, 'NO NODE OWNER'
                    require ext_code.size(address(stor1[_342]))
                    staticcall address(stor1[_342])._getRewardAmountOf(address arg1) with:
                            gas gas_remaining wei
                           args msg.sender
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                if 31 >= uint255(uint256(stor[_342].field_0)) * 0.5:
                    require ext_code.size(address(stor1[_342]))
                    staticcall address(stor1[_342])._isNodeOwner(address arg1) with:
                            gas gas_remaining wei
                           args msg.sender
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                    if not ext_call.return_data[0]:
                        revert with 0, 'NO NODE OWNER'
                    require ext_code.size(address(stor1[_342]))
                    staticcall address(stor1[_342])._getRewardAmountOf(address arg1) with:
                            gas gas_remaining wei
                           args msg.sender
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                mem[0] = _342
                mem[ceil32(ceil32(arg1.length)) + 193] = uint256(stor[sha3(_342)].field_0)
                idx = ceil32(ceil32(arg1.length)) + 193
                s = 0
                while ceil32(ceil32(arg1.length)) + (uint255(uint256(stor[_342].field_0)) * 0.5) + 161 > idx:
                    mem[idx + 32] = uint256(stor[s + sha3(_342) + 1].field_0)
                    idx = idx + 32
                    s = s + 1
                    continue 
                mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
                mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_342])
                mem[mem[64] + 4] = msg.sender
                require ext_code.size(address(stor1[_342]))
                staticcall address(stor1[_342])._isNodeOwner(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _698 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_698] == bool(mem[_698])
                if not mem[_698]:
                    revert with 0, 'NO NODE OWNER'
                mem[mem[64] + 4] = msg.sender
                require ext_code.size(address(stor1[_342]))
                staticcall address(stor1[_342])._getRewardAmountOf(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _744 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[mem[64]] = mem[_744]
            else:
                if bool(stor[_342].field_0) == stor[_342].field_1 % 128 < 32:
                    revert with 0, 34
                if not stor[_342].field_1 % 128:
                    require ext_code.size(address(stor1[_342]))
                    staticcall address(stor1[_342])._isNodeOwner(address arg1) with:
                            gas gas_remaining wei
                           args msg.sender
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                    if not ext_call.return_data[0]:
                        revert with 0, 'NO NODE OWNER'
                    require ext_code.size(address(stor1[_342]))
                    staticcall address(stor1[_342])._getRewardAmountOf(address arg1) with:
                            gas gas_remaining wei
                           args msg.sender
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                if 31 >= stor[_342].field_1 % 128:
                    require ext_code.size(address(stor1[_342]))
                    staticcall address(stor1[_342])._isNodeOwner(address arg1) with:
                            gas gas_remaining wei
                           args msg.sender
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                    if not ext_call.return_data[0]:
                        revert with 0, 'NO NODE OWNER'
                    require ext_code.size(address(stor1[_342]))
                    staticcall address(stor1[_342])._getRewardAmountOf(address arg1) with:
                            gas gas_remaining wei
                           args msg.sender
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                mem[0] = _342
                mem[ceil32(ceil32(arg1.length)) + 193] = uint256(stor[sha3(_342)].field_0)
                idx = ceil32(ceil32(arg1.length)) + 193
                s = 0
                while ceil32(ceil32(arg1.length)) + stor[_342].field_1 % 128 + 161 > idx:
                    mem[idx + 32] = uint256(stor[s + sha3(_342) + 1].field_0)
                    idx = idx + 32
                    s = s + 1
                    continue 
                mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
                mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_342])
                mem[mem[64] + 4] = msg.sender
                require ext_code.size(address(stor1[_342]))
                staticcall address(stor1[_342])._isNodeOwner(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _699 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_699] == bool(mem[_699])
                if not mem[_699]:
                    revert with 0, 'NO NODE OWNER'
                mem[mem[64] + 4] = msg.sender
                require ext_code.size(address(stor1[_342]))
                staticcall address(stor1[_342])._getRewardAmountOf(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _746 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[mem[64]] = mem[_746]
    return memory
      from mem[64]
       len 32
}

function sub_f2d049b6(?) {
    require calldata.size - 4 >= 32
    require arg1 <= test266151307()
    require arg1 + 35 < calldata.size
    if arg1.length > test266151307():
        revert with 0, 65
    if ceil32(ceil32(arg1.length)) + 97 < 96 or ceil32(ceil32(arg1.length)) + 97 > test266151307():
        revert with 0, 65
    mem[64] = ceil32(ceil32(arg1.length)) + 97
    mem[96] = arg1.length
    require arg1 + arg1.length + 36 <= calldata.size
    mem[128 len arg1.length] = arg1[all]
    mem[arg1.length + 128] = 0
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    mem[ceil32(ceil32(arg1.length)) + 97 len ceil32(arg1.length)] = arg1[all], mem[arg1.length + 128 len ceil32(arg1.length) - arg1.length]
    mem[arg1.length + ceil32(ceil32(arg1.length)) + 97] = 24
    if ceil32(arg1.length) <= arg1.length:
        if bool(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0):
            if bool(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0) == uint255(uint256(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0)) * 0.5 < 32:
                revert with 0, 34
            uint256(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0) = 0
            if 31 >= uint255(uint256(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0)) * 0.5:
                address(stor1[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])]) = 0
                idx = 0
                while idx < stor25.length:
                    _601 = sha3(mem[128 len mem[96]])
                    mem[0] = 25
                    _609 = mem[64]
                    if bool(stor25[idx].field_0):
                        if bool(stor25[idx].field_0) == uint255(uint256(stor25[idx].field_0)) * 0.5 < 32:
                            revert with 0, 34
                        if not bool(stor25[idx].field_0):
                            mem[mem[64]] = Mask(248, 8, uint256(stor25[idx].field_0))
                            if sha3(mem[mem[64] len uint255(uint256(stor25[idx].field_0)) * 0.5]) != _601:
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            if bool(stor25[idx].field_0) != 1:
                                if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[0] = sha3(25) + idx
                                s = 0
                                t = sha3(mem[0])
                                while s < uint255(uint256(stor25[idx].field_0)) * 0.5:
                                    mem[s + _609] = uint256(stor[t].field_0)
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                if sha3(mem[mem[64] len _609 + (uint255(uint256(stor25[idx].field_0)) * 0.5) - mem[64]]) != _601:
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                    else:
                        if bool(stor25[idx].field_0) == stor25[idx].field_1 % 128 < 32:
                            revert with 0, 34
                        if not bool(stor25[idx].field_0):
                            mem[mem[64]] = Mask(248, 8, uint256(stor25[idx].field_0))
                            if sha3(mem[mem[64] len stor25[idx].field_1 % 128]) != _601:
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            if bool(stor25[idx].field_0) != 1:
                                if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[0] = sha3(25) + idx
                                s = 0
                                t = sha3(mem[0])
                                while s < stor25[idx].field_1 % 128:
                                    mem[s + _609] = uint256(stor[t].field_0)
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                if sha3(mem[mem[64] len _609 + stor25[idx].field_1 % 128 - mem[64]]) != _601:
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                    if idx >= stor25.length:
                        revert with 0, 50
                    if bool(stor25[idx].field_0):
                        if bool(stor25[idx].field_0) == uint255(uint256(stor25[idx].field_0)) * 0.5 < 32:
                            revert with 0, 34
                        uint256(stor25[idx].field_0) = 0
                        if 31 < uint255(uint256(stor25[idx].field_0)) * 0.5:
                            s = sha3(sha3(25) + idx)
                            while sha3(sha3(25) + idx) + ((uint255(uint256(stor25[idx].field_0)) * 0.5) + 31 / 32) > s:
                                uint256(stor[s].field_0) = 0
                                s = s + 1
                                continue 
                    else:
                        if bool(stor25[idx].field_0) == stor25[idx].field_1 % 128 < 32:
                            revert with 0, 34
                        uint256(stor25[idx].field_0) = 0
                        if 31 < stor25[idx].field_1 % 128:
                            s = sha3(sha3(25) + idx)
                            while sha3(sha3(25) + idx) + (stor25[idx].field_1 % 128 + 31 / 32) > s:
                                uint256(stor[s].field_0) = 0
                                s = s + 1
                                continue 
            else:
                mem[0] = sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])
                idx = 0
                while (uint255(uint256(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0)) * 0.5) + 31 / 32 > idx:
                    uint256(stor[idx + sha3(sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32]))].field_0) = 0
                    idx = idx + 1
                    continue 
                address(stor1[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])]) = 0
                idx = 0
                while idx < stor25.length:
                    _889 = sha3(mem[128 len mem[96]])
                    mem[0] = 25
                    _897 = mem[64]
                    if bool(stor25[idx].field_0):
                        if bool(stor25[idx].field_0) == uint255(uint256(stor25[idx].field_0)) * 0.5 < 32:
                            revert with 0, 34
                        if not bool(stor25[idx].field_0):
                            mem[mem[64]] = Mask(248, 8, uint256(stor25[idx].field_0))
                            if sha3(mem[mem[64] len uint255(uint256(stor25[idx].field_0)) * 0.5]) != _889:
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            if bool(stor25[idx].field_0) != 1:
                                if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[0] = sha3(25) + idx
                                s = 0
                                t = sha3(mem[0])
                                while s < uint255(uint256(stor25[idx].field_0)) * 0.5:
                                    mem[s + _897] = uint256(stor[t].field_0)
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                if sha3(mem[mem[64] len _897 + (uint255(uint256(stor25[idx].field_0)) * 0.5) - mem[64]]) != _889:
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                    else:
                        if bool(stor25[idx].field_0) == stor25[idx].field_1 % 128 < 32:
                            revert with 0, 34
                        if not bool(stor25[idx].field_0):
                            mem[mem[64]] = Mask(248, 8, uint256(stor25[idx].field_0))
                            if sha3(mem[mem[64] len stor25[idx].field_1 % 128]) != _889:
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            if bool(stor25[idx].field_0) != 1:
                                if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[0] = sha3(25) + idx
                                s = 0
                                t = sha3(mem[0])
                                while s < stor25[idx].field_1 % 128:
                                    mem[s + _897] = uint256(stor[t].field_0)
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                if sha3(mem[mem[64] len _897 + stor25[idx].field_1 % 128 - mem[64]]) != _889:
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                    if idx >= stor25.length:
                        revert with 0, 50
                    if bool(stor25[idx].field_0):
                        if bool(stor25[idx].field_0) == uint255(uint256(stor25[idx].field_0)) * 0.5 < 32:
                            revert with 0, 34
                        uint256(stor25[idx].field_0) = 0
                        if 31 < uint255(uint256(stor25[idx].field_0)) * 0.5:
                            s = sha3(sha3(25) + idx)
                            while sha3(sha3(25) + idx) + ((uint255(uint256(stor25[idx].field_0)) * 0.5) + 31 / 32) > s:
                                uint256(stor[s].field_0) = 0
                                s = s + 1
                                continue 
                    else:
                        if bool(stor25[idx].field_0) == stor25[idx].field_1 % 128 < 32:
                            revert with 0, 34
                        uint256(stor25[idx].field_0) = 0
                        if 31 < stor25[idx].field_1 % 128:
                            s = sha3(sha3(25) + idx)
                            while sha3(sha3(25) + idx) + (stor25[idx].field_1 % 128 + 31 / 32) > s:
                                uint256(stor[s].field_0) = 0
                                s = s + 1
                                continue 
        else:
            if bool(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0) == stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_1 % 128 < 32:
                revert with 0, 34
            uint256(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0) = 0
            if 31 >= stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_1 % 128:
                address(stor1[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])]) = 0
                idx = 0
                while idx < stor25.length:
                    _603 = sha3(mem[128 len mem[96]])
                    mem[0] = 25
                    _611 = mem[64]
                    if bool(stor25[idx].field_0):
                        if bool(stor25[idx].field_0) == uint255(uint256(stor25[idx].field_0)) * 0.5 < 32:
                            revert with 0, 34
                        if not bool(stor25[idx].field_0):
                            mem[mem[64]] = Mask(248, 8, uint256(stor25[idx].field_0))
                            if sha3(mem[mem[64] len uint255(uint256(stor25[idx].field_0)) * 0.5]) != _603:
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            if bool(stor25[idx].field_0) != 1:
                                if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[0] = sha3(25) + idx
                                s = 0
                                t = sha3(mem[0])
                                while s < uint255(uint256(stor25[idx].field_0)) * 0.5:
                                    mem[s + _611] = uint256(stor[t].field_0)
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                if sha3(mem[mem[64] len _611 + (uint255(uint256(stor25[idx].field_0)) * 0.5) - mem[64]]) != _603:
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                    else:
                        if bool(stor25[idx].field_0) == stor25[idx].field_1 % 128 < 32:
                            revert with 0, 34
                        if not bool(stor25[idx].field_0):
                            mem[mem[64]] = Mask(248, 8, uint256(stor25[idx].field_0))
                            if sha3(mem[mem[64] len stor25[idx].field_1 % 128]) != _603:
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            if bool(stor25[idx].field_0) != 1:
                                if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[0] = sha3(25) + idx
                                s = 0
                                t = sha3(mem[0])
                                while s < stor25[idx].field_1 % 128:
                                    mem[s + _611] = uint256(stor[t].field_0)
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                if sha3(mem[mem[64] len _611 + stor25[idx].field_1 % 128 - mem[64]]) != _603:
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                    if idx >= stor25.length:
                        revert with 0, 50
                    if bool(stor25[idx].field_0):
                        if bool(stor25[idx].field_0) == uint255(uint256(stor25[idx].field_0)) * 0.5 < 32:
                            revert with 0, 34
                        uint256(stor25[idx].field_0) = 0
                        if 31 < uint255(uint256(stor25[idx].field_0)) * 0.5:
                            s = sha3(sha3(25) + idx)
                            while sha3(sha3(25) + idx) + ((uint255(uint256(stor25[idx].field_0)) * 0.5) + 31 / 32) > s:
                                uint256(stor[s].field_0) = 0
                                s = s + 1
                                continue 
                    else:
                        if bool(stor25[idx].field_0) == stor25[idx].field_1 % 128 < 32:
                            revert with 0, 34
                        uint256(stor25[idx].field_0) = 0
                        if 31 < stor25[idx].field_1 % 128:
                            s = sha3(sha3(25) + idx)
                            while sha3(sha3(25) + idx) + (stor25[idx].field_1 % 128 + 31 / 32) > s:
                                uint256(stor[s].field_0) = 0
                                s = s + 1
                                continue 
            else:
                mem[0] = sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])
                idx = 0
                while stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_1 % 128 + 31 / 32 > idx:
                    uint256(stor[idx + sha3(sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32]))].field_0) = 0
                    idx = idx + 1
                    continue 
                address(stor1[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])]) = 0
                idx = 0
                while idx < stor25.length:
                    _891 = sha3(mem[128 len mem[96]])
                    mem[0] = 25
                    _899 = mem[64]
                    if bool(stor25[idx].field_0):
                        if bool(stor25[idx].field_0) == uint255(uint256(stor25[idx].field_0)) * 0.5 < 32:
                            revert with 0, 34
                        if not bool(stor25[idx].field_0):
                            mem[mem[64]] = Mask(248, 8, uint256(stor25[idx].field_0))
                            if sha3(mem[mem[64] len uint255(uint256(stor25[idx].field_0)) * 0.5]) != _891:
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            if bool(stor25[idx].field_0) != 1:
                                if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[0] = sha3(25) + idx
                                s = 0
                                t = sha3(mem[0])
                                while s < uint255(uint256(stor25[idx].field_0)) * 0.5:
                                    mem[s + _899] = uint256(stor[t].field_0)
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                if sha3(mem[mem[64] len _899 + (uint255(uint256(stor25[idx].field_0)) * 0.5) - mem[64]]) != _891:
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                    else:
                        if bool(stor25[idx].field_0) == stor25[idx].field_1 % 128 < 32:
                            revert with 0, 34
                        if not bool(stor25[idx].field_0):
                            mem[mem[64]] = Mask(248, 8, uint256(stor25[idx].field_0))
                            if sha3(mem[mem[64] len stor25[idx].field_1 % 128]) != _891:
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            if bool(stor25[idx].field_0) != 1:
                                if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[0] = sha3(25) + idx
                                s = 0
                                t = sha3(mem[0])
                                while s < stor25[idx].field_1 % 128:
                                    mem[s + _899] = uint256(stor[t].field_0)
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                if sha3(mem[mem[64] len _899 + stor25[idx].field_1 % 128 - mem[64]]) != _891:
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                    if idx >= stor25.length:
                        revert with 0, 50
                    if bool(stor25[idx].field_0):
                        if bool(stor25[idx].field_0) == uint255(uint256(stor25[idx].field_0)) * 0.5 < 32:
                            revert with 0, 34
                        uint256(stor25[idx].field_0) = 0
                        if 31 < uint255(uint256(stor25[idx].field_0)) * 0.5:
                            s = sha3(sha3(25) + idx)
                            while sha3(sha3(25) + idx) + ((uint255(uint256(stor25[idx].field_0)) * 0.5) + 31 / 32) > s:
                                uint256(stor[s].field_0) = 0
                                s = s + 1
                                continue 
                    else:
                        if bool(stor25[idx].field_0) == stor25[idx].field_1 % 128 < 32:
                            revert with 0, 34
                        uint256(stor25[idx].field_0) = 0
                        if 31 < stor25[idx].field_1 % 128:
                            s = sha3(sha3(25) + idx)
                            while sha3(sha3(25) + idx) + (stor25[idx].field_1 % 128 + 31 / 32) > s:
                                uint256(stor[s].field_0) = 0
                                s = s + 1
                                continue 
    else:
        if bool(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0):
            if bool(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0) == uint255(uint256(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0)) * 0.5 < 32:
                revert with 0, 34
            uint256(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0) = 0
            if 31 >= uint255(uint256(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0)) * 0.5:
                address(stor1[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])]) = 0
                idx = 0
                while idx < stor25.length:
                    _605 = sha3(mem[128 len mem[96]])
                    mem[0] = 25
                    _613 = mem[64]
                    if bool(stor25[idx].field_0):
                        if bool(stor25[idx].field_0) == uint255(uint256(stor25[idx].field_0)) * 0.5 < 32:
                            revert with 0, 34
                        if not bool(stor25[idx].field_0):
                            mem[mem[64]] = Mask(248, 8, uint256(stor25[idx].field_0))
                            if sha3(mem[mem[64] len uint255(uint256(stor25[idx].field_0)) * 0.5]) != _605:
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            if bool(stor25[idx].field_0) != 1:
                                if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[0] = sha3(25) + idx
                                s = 0
                                t = sha3(mem[0])
                                while s < uint255(uint256(stor25[idx].field_0)) * 0.5:
                                    mem[s + _613] = uint256(stor[t].field_0)
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                if sha3(mem[mem[64] len _613 + (uint255(uint256(stor25[idx].field_0)) * 0.5) - mem[64]]) != _605:
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                    else:
                        if bool(stor25[idx].field_0) == stor25[idx].field_1 % 128 < 32:
                            revert with 0, 34
                        if not bool(stor25[idx].field_0):
                            mem[mem[64]] = Mask(248, 8, uint256(stor25[idx].field_0))
                            if sha3(mem[mem[64] len stor25[idx].field_1 % 128]) != _605:
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            if bool(stor25[idx].field_0) != 1:
                                if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[0] = sha3(25) + idx
                                s = 0
                                t = sha3(mem[0])
                                while s < stor25[idx].field_1 % 128:
                                    mem[s + _613] = uint256(stor[t].field_0)
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                if sha3(mem[mem[64] len _613 + stor25[idx].field_1 % 128 - mem[64]]) != _605:
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                    if idx >= stor25.length:
                        revert with 0, 50
                    if bool(stor25[idx].field_0):
                        if bool(stor25[idx].field_0) == uint255(uint256(stor25[idx].field_0)) * 0.5 < 32:
                            revert with 0, 34
                        uint256(stor25[idx].field_0) = 0
                        if 31 < uint255(uint256(stor25[idx].field_0)) * 0.5:
                            s = sha3(sha3(25) + idx)
                            while sha3(sha3(25) + idx) + ((uint255(uint256(stor25[idx].field_0)) * 0.5) + 31 / 32) > s:
                                uint256(stor[s].field_0) = 0
                                s = s + 1
                                continue 
                    else:
                        if bool(stor25[idx].field_0) == stor25[idx].field_1 % 128 < 32:
                            revert with 0, 34
                        uint256(stor25[idx].field_0) = 0
                        if 31 < stor25[idx].field_1 % 128:
                            s = sha3(sha3(25) + idx)
                            while sha3(sha3(25) + idx) + (stor25[idx].field_1 % 128 + 31 / 32) > s:
                                uint256(stor[s].field_0) = 0
                                s = s + 1
                                continue 
            else:
                mem[0] = sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])
                idx = 0
                while (uint255(uint256(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0)) * 0.5) + 31 / 32 > idx:
                    uint256(stor[idx + sha3(sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32]))].field_0) = 0
                    idx = idx + 1
                    continue 
                address(stor1[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])]) = 0
                idx = 0
                while idx < stor25.length:
                    _893 = sha3(mem[128 len mem[96]])
                    mem[0] = 25
                    _901 = mem[64]
                    if bool(stor25[idx].field_0):
                        if bool(stor25[idx].field_0) == uint255(uint256(stor25[idx].field_0)) * 0.5 < 32:
                            revert with 0, 34
                        if not bool(stor25[idx].field_0):
                            mem[mem[64]] = Mask(248, 8, uint256(stor25[idx].field_0))
                            if sha3(mem[mem[64] len uint255(uint256(stor25[idx].field_0)) * 0.5]) != _893:
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            if bool(stor25[idx].field_0) != 1:
                                if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[0] = sha3(25) + idx
                                s = 0
                                t = sha3(mem[0])
                                while s < uint255(uint256(stor25[idx].field_0)) * 0.5:
                                    mem[s + _901] = uint256(stor[t].field_0)
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                if sha3(mem[mem[64] len _901 + (uint255(uint256(stor25[idx].field_0)) * 0.5) - mem[64]]) != _893:
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                    else:
                        if bool(stor25[idx].field_0) == stor25[idx].field_1 % 128 < 32:
                            revert with 0, 34
                        if not bool(stor25[idx].field_0):
                            mem[mem[64]] = Mask(248, 8, uint256(stor25[idx].field_0))
                            if sha3(mem[mem[64] len stor25[idx].field_1 % 128]) != _893:
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            if bool(stor25[idx].field_0) != 1:
                                if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[0] = sha3(25) + idx
                                s = 0
                                t = sha3(mem[0])
                                while s < stor25[idx].field_1 % 128:
                                    mem[s + _901] = uint256(stor[t].field_0)
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                if sha3(mem[mem[64] len _901 + stor25[idx].field_1 % 128 - mem[64]]) != _893:
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                    if idx >= stor25.length:
                        revert with 0, 50
                    if bool(stor25[idx].field_0):
                        if bool(stor25[idx].field_0) == uint255(uint256(stor25[idx].field_0)) * 0.5 < 32:
                            revert with 0, 34
                        uint256(stor25[idx].field_0) = 0
                        if 31 < uint255(uint256(stor25[idx].field_0)) * 0.5:
                            s = sha3(sha3(25) + idx)
                            while sha3(sha3(25) + idx) + ((uint255(uint256(stor25[idx].field_0)) * 0.5) + 31 / 32) > s:
                                uint256(stor[s].field_0) = 0
                                s = s + 1
                                continue 
                    else:
                        if bool(stor25[idx].field_0) == stor25[idx].field_1 % 128 < 32:
                            revert with 0, 34
                        uint256(stor25[idx].field_0) = 0
                        if 31 < stor25[idx].field_1 % 128:
                            s = sha3(sha3(25) + idx)
                            while sha3(sha3(25) + idx) + (stor25[idx].field_1 % 128 + 31 / 32) > s:
                                uint256(stor[s].field_0) = 0
                                s = s + 1
                                continue 
        else:
            if bool(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0) == stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_1 % 128 < 32:
                revert with 0, 34
            uint256(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0) = 0
            if 31 >= stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_1 % 128:
                address(stor1[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])]) = 0
                idx = 0
                while idx < stor25.length:
                    _607 = sha3(mem[128 len mem[96]])
                    mem[0] = 25
                    _615 = mem[64]
                    if bool(stor25[idx].field_0):
                        if bool(stor25[idx].field_0) == uint255(uint256(stor25[idx].field_0)) * 0.5 < 32:
                            revert with 0, 34
                        if not bool(stor25[idx].field_0):
                            mem[mem[64]] = Mask(248, 8, uint256(stor25[idx].field_0))
                            if sha3(mem[mem[64] len uint255(uint256(stor25[idx].field_0)) * 0.5]) != _607:
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            if bool(stor25[idx].field_0) != 1:
                                if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[0] = sha3(25) + idx
                                s = 0
                                t = sha3(mem[0])
                                while s < uint255(uint256(stor25[idx].field_0)) * 0.5:
                                    mem[s + _615] = uint256(stor[t].field_0)
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                if sha3(mem[mem[64] len _615 + (uint255(uint256(stor25[idx].field_0)) * 0.5) - mem[64]]) != _607:
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                    else:
                        if bool(stor25[idx].field_0) == stor25[idx].field_1 % 128 < 32:
                            revert with 0, 34
                        if not bool(stor25[idx].field_0):
                            mem[mem[64]] = Mask(248, 8, uint256(stor25[idx].field_0))
                            if sha3(mem[mem[64] len stor25[idx].field_1 % 128]) != _607:
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            if bool(stor25[idx].field_0) != 1:
                                if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[0] = sha3(25) + idx
                                s = 0
                                t = sha3(mem[0])
                                while s < stor25[idx].field_1 % 128:
                                    mem[s + _615] = uint256(stor[t].field_0)
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                if sha3(mem[mem[64] len _615 + stor25[idx].field_1 % 128 - mem[64]]) != _607:
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                    if idx >= stor25.length:
                        revert with 0, 50
                    if bool(stor25[idx].field_0):
                        if bool(stor25[idx].field_0) == uint255(uint256(stor25[idx].field_0)) * 0.5 < 32:
                            revert with 0, 34
                        uint256(stor25[idx].field_0) = 0
                        if 31 < uint255(uint256(stor25[idx].field_0)) * 0.5:
                            s = sha3(sha3(25) + idx)
                            while sha3(sha3(25) + idx) + ((uint255(uint256(stor25[idx].field_0)) * 0.5) + 31 / 32) > s:
                                uint256(stor[s].field_0) = 0
                                s = s + 1
                                continue 
                    else:
                        if bool(stor25[idx].field_0) == stor25[idx].field_1 % 128 < 32:
                            revert with 0, 34
                        uint256(stor25[idx].field_0) = 0
                        if 31 < stor25[idx].field_1 % 128:
                            s = sha3(sha3(25) + idx)
                            while sha3(sha3(25) + idx) + (stor25[idx].field_1 % 128 + 31 / 32) > s:
                                uint256(stor[s].field_0) = 0
                                s = s + 1
                                continue 
            else:
                mem[0] = sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])
                idx = 0
                while stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_1 % 128 + 31 / 32 > idx:
                    uint256(stor[idx + sha3(sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32]))].field_0) = 0
                    idx = idx + 1
                    continue 
                address(stor1[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])]) = 0
                idx = 0
                while idx < stor25.length:
                    _895 = sha3(mem[128 len mem[96]])
                    mem[0] = 25
                    _903 = mem[64]
                    if bool(stor25[idx].field_0):
                        if bool(stor25[idx].field_0) == uint255(uint256(stor25[idx].field_0)) * 0.5 < 32:
                            revert with 0, 34
                        if not bool(stor25[idx].field_0):
                            mem[mem[64]] = Mask(248, 8, uint256(stor25[idx].field_0))
                            if sha3(mem[mem[64] len uint255(uint256(stor25[idx].field_0)) * 0.5]) != _895:
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            if bool(stor25[idx].field_0) != 1:
                                if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[0] = sha3(25) + idx
                                s = 0
                                t = sha3(mem[0])
                                while s < uint255(uint256(stor25[idx].field_0)) * 0.5:
                                    mem[s + _903] = uint256(stor[t].field_0)
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                if sha3(mem[mem[64] len _903 + (uint255(uint256(stor25[idx].field_0)) * 0.5) - mem[64]]) != _895:
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                    else:
                        if bool(stor25[idx].field_0) == stor25[idx].field_1 % 128 < 32:
                            revert with 0, 34
                        if not bool(stor25[idx].field_0):
                            mem[mem[64]] = Mask(248, 8, uint256(stor25[idx].field_0))
                            if sha3(mem[mem[64] len stor25[idx].field_1 % 128]) != _895:
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                        else:
                            if bool(stor25[idx].field_0) != 1:
                                if sha3(mem[mem[64] len -mem[64]]) != sha3(mem[128 len mem[96]]):
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                            else:
                                mem[0] = sha3(25) + idx
                                s = 0
                                t = sha3(mem[0])
                                while s < stor25[idx].field_1 % 128:
                                    mem[s + _903] = uint256(stor[t].field_0)
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                if sha3(mem[mem[64] len _903 + stor25[idx].field_1 % 128 - mem[64]]) != _895:
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                    if idx >= stor25.length:
                        revert with 0, 50
                    if bool(stor25[idx].field_0):
                        if bool(stor25[idx].field_0) == uint255(uint256(stor25[idx].field_0)) * 0.5 < 32:
                            revert with 0, 34
                        uint256(stor25[idx].field_0) = 0
                        if 31 < uint255(uint256(stor25[idx].field_0)) * 0.5:
                            s = sha3(sha3(25) + idx)
                            while sha3(sha3(25) + idx) + ((uint255(uint256(stor25[idx].field_0)) * 0.5) + 31 / 32) > s:
                                uint256(stor[s].field_0) = 0
                                s = s + 1
                                continue 
                    else:
                        if bool(stor25[idx].field_0) == stor25[idx].field_1 % 128 < 32:
                            revert with 0, 34
                        uint256(stor25[idx].field_0) = 0
                        if 31 < stor25[idx].field_1 % 128:
                            s = sha3(sha3(25) + idx)
                            while sha3(sha3(25) + idx) + (stor25[idx].field_1 % 128 + 31 / 32) > s:
                                uint256(stor[s].field_0) = 0
                                s = s + 1
                                continue 
}

function getTotalCreatedNodes() payable {
    mem[64] = 96
    require not msg.value
    idx = 0
    s = 0
    while idx < stor25.length:
        mem[0] = 25
        _567 = mem[64]
        if bool(stor25[idx].field_0):
            if bool(stor25[idx].field_0) == uint255(uint256(stor25[idx].field_0)) * 0.5 < 32:
                revert with 0, 34
            if not bool(stor25[idx].field_0):
                mem[mem[64]] = Mask(248, 8, uint256(stor25[idx].field_0))
                mem[mem[64] + (uint255(uint256(stor25[idx].field_0)) * 0.5)] = 24
                _572 = sha3(Mask(248, 8, uint256(stor25[idx].field_0)), mem[mem[64] + 32 len uint255(uint256(stor25[idx].field_0)) * 0.5])
                _573 = mem[64]
                mem[64] = mem[64] + 64
                if bool(stor[_572].field_0):
                    if bool(stor[_572].field_0) == uint255(uint256(stor[_572].field_0)) * 0.5 < 32:
                        revert with 0, 34
                    _586 = mem[64]
                    mem[64] = mem[64] + ceil32(uint255(uint256(stor[_572].field_0)) * 0.5) + 32
                    mem[_586] = uint255(uint256(stor[_572].field_0)) * 0.5
                    if bool(stor[_572].field_0):
                        if bool(stor[_572].field_0) == uint255(uint256(stor[_572].field_0)) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, uint256(stor[_572].field_0)):
                            mem[_573] = _586
                            mem[_573 + 32] = address(stor1[_572])
                            require ext_code.size(address(stor1[_572]))
                            staticcall address(stor1[_572]).totalNodesCreated() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _617 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if s > !mem[_617]:
                                revert with 0, 17
                            if s + mem[_617] < s:
                                revert with 0, 'SafeMath: addition overflow'
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + mem[_617]
                            continue 
                        if 31 >= uint255(uint256(stor[_572].field_0)) * 0.5:
                            mem[_586 + 32] = 256 * Mask(248, 0, stor[_572].field_8)
                            mem[_573] = _586
                            mem[_573 + 32] = address(stor1[_572])
                            require ext_code.size(address(stor1[_572]))
                            staticcall address(stor1[_572]).totalNodesCreated() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _684 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if s > !mem[_684]:
                                revert with 0, 17
                            if s + mem[_684] < s:
                                revert with 0, 'SafeMath: addition overflow'
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + mem[_684]
                            continue 
                        mem[0] = _572
                        mem[_586 + 32] = uint256(stor[sha3(_572)].field_0)
                        t = _586 + 32
                        u = sha3(_572)
                        while _586 + (uint255(uint256(stor[_572].field_0)) * 0.5) > t:
                            mem[t + 32] = uint256(stor1[u])
                            t = t + 32
                            u = u + 1
                            continue 
                        mem[_573] = _586
                        mem[_573 + 32] = address(stor1[_572])
                        require ext_code.size(address(stor1[_572]))
                        staticcall address(stor1[_572]).totalNodesCreated() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1177 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if s > !mem[_1177]:
                            revert with 0, 17
                        if s + mem[_1177] < s:
                            revert with 0, 'SafeMath: addition overflow'
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + mem[_1177]
                        continue 
                    if bool(stor[_572].field_0) == stor[_572].field_1 % 128 < 32:
                        revert with 0, 34
                    if not stor[_572].field_1 % 128:
                        mem[_573] = _586
                        mem[_573 + 32] = address(stor1[_572])
                        require ext_code.size(address(stor1[_572]))
                        staticcall address(stor1[_572]).totalNodesCreated() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _643 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if s > !mem[_643]:
                            revert with 0, 17
                        if s + mem[_643] < s:
                            revert with 0, 'SafeMath: addition overflow'
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + mem[_643]
                        continue 
                    if 31 >= stor[_572].field_1 % 128:
                        mem[_586 + 32] = 256 * Mask(248, 0, stor[_572].field_8)
                        mem[_573] = _586
                        mem[_573 + 32] = address(stor1[_572])
                        require ext_code.size(address(stor1[_572]))
                        staticcall address(stor1[_572]).totalNodesCreated() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _730 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if s > !mem[_730]:
                            revert with 0, 17
                        if s + mem[_730] < s:
                            revert with 0, 'SafeMath: addition overflow'
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + mem[_730]
                        continue 
                    mem[0] = _572
                    mem[_586 + 32] = uint256(stor[sha3(_572)].field_0)
                    t = _586 + 32
                    u = sha3(_572)
                    while _586 + stor[_572].field_1 % 128 > t:
                        mem[t + 32] = uint256(stor1[u])
                        t = t + 32
                        u = u + 1
                        continue 
                    mem[_573] = _586
                    mem[_573 + 32] = address(stor1[_572])
                    require ext_code.size(address(stor1[_572]))
                    staticcall address(stor1[_572]).totalNodesCreated() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1178 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if s > !mem[_1178]:
                        revert with 0, 17
                    if s + mem[_1178] < s:
                        revert with 0, 'SafeMath: addition overflow'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + mem[_1178]
                    continue 
                if bool(stor[_572].field_0) == stor[_572].field_1 % 128 < 32:
                    revert with 0, 34
                _590 = mem[64]
                mem[64] = mem[64] + ceil32(stor[_572].field_1 % 128) + 32
                mem[_590] = stor[_572].field_1 % 128
                if bool(stor[_572].field_0):
                    if bool(stor[_572].field_0) == uint255(uint256(stor[_572].field_0)) * 0.5 < 32:
                        revert with 0, 34
                    if not Mask(256, -1, uint256(stor[_572].field_0)):
                        mem[_573] = _590
                        mem[_573 + 32] = address(stor1[_572])
                        require ext_code.size(address(stor1[_572]))
                        staticcall address(stor1[_572]).totalNodesCreated() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _647 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if s > !mem[_647]:
                            revert with 0, 17
                        if s + mem[_647] < s:
                            revert with 0, 'SafeMath: addition overflow'
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + mem[_647]
                        continue 
                    if 31 >= uint255(uint256(stor[_572].field_0)) * 0.5:
                        mem[_590 + 32] = 256 * Mask(248, 0, stor[_572].field_8)
                        mem[_573] = _590
                        mem[_573 + 32] = address(stor1[_572])
                        require ext_code.size(address(stor1[_572]))
                        staticcall address(stor1[_572]).totalNodesCreated() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _735 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if s > !mem[_735]:
                            revert with 0, 17
                        if s + mem[_735] < s:
                            revert with 0, 'SafeMath: addition overflow'
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + mem[_735]
                        continue 
                    mem[0] = _572
                    mem[_590 + 32] = uint256(stor[sha3(_572)].field_0)
                    t = _590 + 32
                    u = sha3(_572)
                    while _590 + (uint255(uint256(stor[_572].field_0)) * 0.5) > t:
                        mem[t + 32] = uint256(stor1[u])
                        t = t + 32
                        u = u + 1
                        continue 
                    mem[_573] = _590
                    mem[_573 + 32] = address(stor1[_572])
                    require ext_code.size(address(stor1[_572]))
                    staticcall address(stor1[_572]).totalNodesCreated() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1179 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if s > !mem[_1179]:
                        revert with 0, 17
                    if s + mem[_1179] < s:
                        revert with 0, 'SafeMath: addition overflow'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + mem[_1179]
                    continue 
                if bool(stor[_572].field_0) == stor[_572].field_1 % 128 < 32:
                    revert with 0, 34
                if not stor[_572].field_1 % 128:
                    mem[_573] = _590
                    mem[_573 + 32] = address(stor1[_572])
                    require ext_code.size(address(stor1[_572]))
                    staticcall address(stor1[_572]).totalNodesCreated() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _685 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if s > !mem[_685]:
                        revert with 0, 17
                    if s + mem[_685] < s:
                        revert with 0, 'SafeMath: addition overflow'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + mem[_685]
                    continue 
                if 31 >= stor[_572].field_1 % 128:
                    mem[_590 + 32] = 256 * Mask(248, 0, stor[_572].field_8)
                    mem[_573] = _590
                    mem[_573 + 32] = address(stor1[_572])
                    require ext_code.size(address(stor1[_572]))
                    staticcall address(stor1[_572]).totalNodesCreated() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _785 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if s > !mem[_785]:
                        revert with 0, 17
                    if s + mem[_785] < s:
                        revert with 0, 'SafeMath: addition overflow'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + mem[_785]
                    continue 
                mem[0] = _572
                mem[_590 + 32] = uint256(stor[sha3(_572)].field_0)
                t = _590 + 32
                u = sha3(_572)
                while _590 + stor[_572].field_1 % 128 > t:
                    mem[t + 32] = uint256(stor1[u])
                    t = t + 32
                    u = u + 1
                    continue 
                mem[_573] = _590
                mem[_573 + 32] = address(stor1[_572])
                require ext_code.size(address(stor1[_572]))
                staticcall address(stor1[_572]).totalNodesCreated() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1180 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if s > !mem[_1180]:
                    revert with 0, 17
                if s + mem[_1180] < s:
                    revert with 0, 'SafeMath: addition overflow'
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + mem[_1180]
                continue 
            if bool(stor25[idx].field_0) != 1:
                mem[0] = 24
                _575 = sha3(mem[mem[64] len -mem[64] + 32])
                _576 = mem[64]
                mem[64] = mem[64] + 64
                if bool(stor[_575].field_0):
                    if bool(stor[_575].field_0) == uint255(uint256(stor[_575].field_0)) * 0.5 < 32:
                        revert with 0, 34
                    _591 = mem[64]
                    mem[64] = mem[64] + ceil32(uint255(uint256(stor[_575].field_0)) * 0.5) + 32
                    mem[_591] = uint255(uint256(stor[_575].field_0)) * 0.5
                    if bool(stor[_575].field_0):
                        if bool(stor[_575].field_0) == uint255(uint256(stor[_575].field_0)) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, uint256(stor[_575].field_0)):
                            mem[_576] = _591
                            mem[_576 + 32] = address(stor1[_575])
                            require ext_code.size(address(stor1[_575]))
                            staticcall address(stor1[_575]).totalNodesCreated() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _655 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if s > !mem[_655]:
                                revert with 0, 17
                            if s + mem[_655] < s:
                                revert with 0, 'SafeMath: addition overflow'
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + mem[_655]
                            continue 
                        if 31 >= uint255(uint256(stor[_575].field_0)) * 0.5:
                            mem[_591 + 32] = 256 * Mask(248, 0, stor[_575].field_8)
                            mem[_576] = _591
                            mem[_576 + 32] = address(stor1[_575])
                            require ext_code.size(address(stor1[_575]))
                            staticcall address(stor1[_575]).totalNodesCreated() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _749 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if s > !mem[_749]:
                                revert with 0, 17
                            if s + mem[_749] < s:
                                revert with 0, 'SafeMath: addition overflow'
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + mem[_749]
                            continue 
                        mem[0] = _575
                        mem[_591 + 32] = uint256(stor[sha3(_575)].field_0)
                        t = _591 + 32
                        u = sha3(_575)
                        while _591 + (uint255(uint256(stor[_575].field_0)) * 0.5) > t:
                            mem[t + 32] = uint256(stor1[u])
                            t = t + 32
                            u = u + 1
                            continue 
                        mem[_576] = _591
                        mem[_576 + 32] = address(stor1[_575])
                        require ext_code.size(address(stor1[_575]))
                        staticcall address(stor1[_575]).totalNodesCreated() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1184 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if s > !mem[_1184]:
                            revert with 0, 17
                        if s + mem[_1184] < s:
                            revert with 0, 'SafeMath: addition overflow'
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + mem[_1184]
                        continue 
                    if bool(stor[_575].field_0) == stor[_575].field_1 % 128 < 32:
                        revert with 0, 34
                    if not stor[_575].field_1 % 128:
                        mem[_576] = _591
                        mem[_576 + 32] = address(stor1[_575])
                        require ext_code.size(address(stor1[_575]))
                        staticcall address(stor1[_575]).totalNodesCreated() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _696 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if s > !mem[_696]:
                            revert with 0, 17
                        if s + mem[_696] < s:
                            revert with 0, 'SafeMath: addition overflow'
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + mem[_696]
                        continue 
                    if 31 >= stor[_575].field_1 % 128:
                        mem[_591 + 32] = 256 * Mask(248, 0, stor[_575].field_8)
                        mem[_576] = _591
                        mem[_576 + 32] = address(stor1[_575])
                        require ext_code.size(address(stor1[_575]))
                        staticcall address(stor1[_575]).totalNodesCreated() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _799 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if s > !mem[_799]:
                            revert with 0, 17
                        if s + mem[_799] < s:
                            revert with 0, 'SafeMath: addition overflow'
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + mem[_799]
                        continue 
                    mem[0] = _575
                    mem[_591 + 32] = uint256(stor[sha3(_575)].field_0)
                    t = _591 + 32
                    u = sha3(_575)
                    while _591 + stor[_575].field_1 % 128 > t:
                        mem[t + 32] = uint256(stor1[u])
                        t = t + 32
                        u = u + 1
                        continue 
                    mem[_576] = _591
                    mem[_576 + 32] = address(stor1[_575])
                    require ext_code.size(address(stor1[_575]))
                    staticcall address(stor1[_575]).totalNodesCreated() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1185 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if s > !mem[_1185]:
                        revert with 0, 17
                    if s + mem[_1185] < s:
                        revert with 0, 'SafeMath: addition overflow'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + mem[_1185]
                    continue 
                if bool(stor[_575].field_0) == stor[_575].field_1 % 128 < 32:
                    revert with 0, 34
                _593 = mem[64]
                mem[64] = mem[64] + ceil32(stor[_575].field_1 % 128) + 32
                mem[_593] = stor[_575].field_1 % 128
                if bool(stor[_575].field_0):
                    if bool(stor[_575].field_0) == uint255(uint256(stor[_575].field_0)) * 0.5 < 32:
                        revert with 0, 34
                    if not Mask(256, -1, uint256(stor[_575].field_0)):
                        mem[_576] = _593
                        mem[_576 + 32] = address(stor1[_575])
                        require ext_code.size(address(stor1[_575]))
                        staticcall address(stor1[_575]).totalNodesCreated() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _700 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if s > !mem[_700]:
                            revert with 0, 17
                        if s + mem[_700] < s:
                            revert with 0, 'SafeMath: addition overflow'
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + mem[_700]
                        continue 
                    if 31 >= uint255(uint256(stor[_575].field_0)) * 0.5:
                        mem[_593 + 32] = 256 * Mask(248, 0, stor[_575].field_8)
                        mem[_576] = _593
                        mem[_576 + 32] = address(stor1[_575])
                        require ext_code.size(address(stor1[_575]))
                        staticcall address(stor1[_575]).totalNodesCreated() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _804 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if s > !mem[_804]:
                            revert with 0, 17
                        if s + mem[_804] < s:
                            revert with 0, 'SafeMath: addition overflow'
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + mem[_804]
                        continue 
                    mem[0] = _575
                    mem[_593 + 32] = uint256(stor[sha3(_575)].field_0)
                    t = _593 + 32
                    u = sha3(_575)
                    while _593 + (uint255(uint256(stor[_575].field_0)) * 0.5) > t:
                        mem[t + 32] = uint256(stor1[u])
                        t = t + 32
                        u = u + 1
                        continue 
                    mem[_576] = _593
                    mem[_576 + 32] = address(stor1[_575])
                    require ext_code.size(address(stor1[_575]))
                    staticcall address(stor1[_575]).totalNodesCreated() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1186 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if s > !mem[_1186]:
                        revert with 0, 17
                    if s + mem[_1186] < s:
                        revert with 0, 'SafeMath: addition overflow'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + mem[_1186]
                    continue 
                if bool(stor[_575].field_0) == stor[_575].field_1 % 128 < 32:
                    revert with 0, 34
                if not stor[_575].field_1 % 128:
                    mem[_576] = _593
                    mem[_576 + 32] = address(stor1[_575])
                    require ext_code.size(address(stor1[_575]))
                    staticcall address(stor1[_575]).totalNodesCreated() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _750 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if s > !mem[_750]:
                        revert with 0, 17
                    if s + mem[_750] < s:
                        revert with 0, 'SafeMath: addition overflow'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + mem[_750]
                    continue 
                if 31 >= stor[_575].field_1 % 128:
                    mem[_593 + 32] = 256 * Mask(248, 0, stor[_575].field_8)
                    mem[_576] = _593
                    mem[_576 + 32] = address(stor1[_575])
                    require ext_code.size(address(stor1[_575]))
                    staticcall address(stor1[_575]).totalNodesCreated() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _852 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if s > !mem[_852]:
                        revert with 0, 17
                    if s + mem[_852] < s:
                        revert with 0, 'SafeMath: addition overflow'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + mem[_852]
                    continue 
                mem[0] = _575
                mem[_593 + 32] = uint256(stor[sha3(_575)].field_0)
                t = _593 + 32
                u = sha3(_575)
                while _593 + stor[_575].field_1 % 128 > t:
                    mem[t + 32] = uint256(stor1[u])
                    t = t + 32
                    u = u + 1
                    continue 
                mem[_576] = _593
                mem[_576 + 32] = address(stor1[_575])
                require ext_code.size(address(stor1[_575]))
                staticcall address(stor1[_575]).totalNodesCreated() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1187 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if s > !mem[_1187]:
                    revert with 0, 17
                if s + mem[_1187] < s:
                    revert with 0, 'SafeMath: addition overflow'
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + mem[_1187]
                continue 
            mem[0] = sha3(25) + idx
            t = 0
            u = sha3(mem[0])
            while t < uint255(uint256(stor25[idx].field_0)) * 0.5:
                mem[t + _567] = uint256(stor[u].field_0)
                t = t + 32
                u = u + 1
                continue 
            mem[_567 + (uint255(uint256(stor25[idx].field_0)) * 0.5)] = 24
            _1182 = sha3(mem[mem[64] len _567 + (uint255(uint256(stor25[idx].field_0)) * 0.5) + -mem[64] + 32])
            _1183 = mem[64]
            mem[64] = mem[64] + 64
            if bool(stor[_1182].field_0):
                if bool(stor[_1182].field_0) == uint255(uint256(stor[_1182].field_0)) * 0.5 < 32:
                    revert with 0, 34
                _1215 = mem[64]
                mem[64] = mem[64] + ceil32(uint255(uint256(stor[_1182].field_0)) * 0.5) + 32
                mem[_1215] = uint255(uint256(stor[_1182].field_0)) * 0.5
                if bool(stor[_1182].field_0):
                    if bool(stor[_1182].field_0) == uint255(uint256(stor[_1182].field_0)) * 0.5 < 32:
                        revert with 0, 34
                    if not Mask(256, -1, uint256(stor[_1182].field_0)):
                        mem[_1183] = _1215
                        mem[_1183 + 32] = address(stor1[_1182])
                        require ext_code.size(address(stor1[_1182]))
                        staticcall address(stor1[_1182]).totalNodesCreated() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1271 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if s > !mem[_1271]:
                            revert with 0, 17
                        if s + mem[_1271] < s:
                            revert with 0, 'SafeMath: addition overflow'
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + mem[_1271]
                        continue 
                    if 31 >= uint255(uint256(stor[_1182].field_0)) * 0.5:
                        mem[_1215 + 32] = 256 * Mask(248, 0, stor[_1182].field_8)
                        mem[_1183] = _1215
                        mem[_1183 + 32] = address(stor1[_1182])
                        require ext_code.size(address(stor1[_1182]))
                        staticcall address(stor1[_1182]).totalNodesCreated() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1311 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if s > !mem[_1311]:
                            revert with 0, 17
                        if s + mem[_1311] < s:
                            revert with 0, 'SafeMath: addition overflow'
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + mem[_1311]
                        continue 
                    mem[0] = _1182
                    mem[_1215 + 32] = uint256(stor[sha3(_1182)].field_0)
                    t = _1215 + 32
                    u = sha3(_1182)
                    while _1215 + (uint255(uint256(stor[_1182].field_0)) * 0.5) > t:
                        mem[t + 32] = uint256(stor1[u])
                        t = t + 32
                        u = u + 1
                        continue 
                    mem[_1183] = _1215
                    mem[_1183 + 32] = address(stor1[_1182])
                    require ext_code.size(address(stor1[_1182]))
                    staticcall address(stor1[_1182]).totalNodesCreated() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1451 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if s > !mem[_1451]:
                        revert with 0, 17
                    if s + mem[_1451] < s:
                        revert with 0, 'SafeMath: addition overflow'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + mem[_1451]
                    continue 
                if bool(stor[_1182].field_0) == stor[_1182].field_1 % 128 < 32:
                    revert with 0, 34
                if not stor[_1182].field_1 % 128:
                    mem[_1183] = _1215
                    mem[_1183 + 32] = address(stor1[_1182])
                    require ext_code.size(address(stor1[_1182]))
                    staticcall address(stor1[_1182]).totalNodesCreated() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1289 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if s > !mem[_1289]:
                        revert with 0, 17
                    if s + mem[_1289] < s:
                        revert with 0, 'SafeMath: addition overflow'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + mem[_1289]
                    continue 
                if 31 >= stor[_1182].field_1 % 128:
                    mem[_1215 + 32] = 256 * Mask(248, 0, stor[_1182].field_8)
                    mem[_1183] = _1215
                    mem[_1183 + 32] = address(stor1[_1182])
                    require ext_code.size(address(stor1[_1182]))
                    staticcall address(stor1[_1182]).totalNodesCreated() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1329 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if s > !mem[_1329]:
                        revert with 0, 17
                    if s + mem[_1329] < s:
                        revert with 0, 'SafeMath: addition overflow'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + mem[_1329]
                    continue 
                mem[0] = _1182
                mem[_1215 + 32] = uint256(stor[sha3(_1182)].field_0)
                t = _1215 + 32
                u = sha3(_1182)
                while _1215 + stor[_1182].field_1 % 128 > t:
                    mem[t + 32] = uint256(stor1[u])
                    t = t + 32
                    u = u + 1
                    continue 
                mem[_1183] = _1215
                mem[_1183 + 32] = address(stor1[_1182])
                require ext_code.size(address(stor1[_1182]))
                staticcall address(stor1[_1182]).totalNodesCreated() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1452 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if s > !mem[_1452]:
                    revert with 0, 17
                if s + mem[_1452] < s:
                    revert with 0, 'SafeMath: addition overflow'
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + mem[_1452]
                continue 
            if bool(stor[_1182].field_0) == stor[_1182].field_1 % 128 < 32:
                revert with 0, 34
            _1217 = mem[64]
            mem[64] = mem[64] + ceil32(stor[_1182].field_1 % 128) + 32
            mem[_1217] = stor[_1182].field_1 % 128
            if bool(stor[_1182].field_0):
                if bool(stor[_1182].field_0) == uint255(uint256(stor[_1182].field_0)) * 0.5 < 32:
                    revert with 0, 34
                if not Mask(256, -1, uint256(stor[_1182].field_0)):
                    mem[_1183] = _1217
                    mem[_1183 + 32] = address(stor1[_1182])
                    require ext_code.size(address(stor1[_1182]))
                    staticcall address(stor1[_1182]).totalNodesCreated() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1293 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if s > !mem[_1293]:
                        revert with 0, 17
                    if s + mem[_1293] < s:
                        revert with 0, 'SafeMath: addition overflow'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + mem[_1293]
                    continue 
                if 31 >= uint255(uint256(stor[_1182].field_0)) * 0.5:
                    mem[_1217 + 32] = 256 * Mask(248, 0, stor[_1182].field_8)
                    mem[_1183] = _1217
                    mem[_1183 + 32] = address(stor1[_1182])
                    require ext_code.size(address(stor1[_1182]))
                    staticcall address(stor1[_1182]).totalNodesCreated() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1334 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if s > !mem[_1334]:
                        revert with 0, 17
                    if s + mem[_1334] < s:
                        revert with 0, 'SafeMath: addition overflow'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + mem[_1334]
                    continue 
                mem[0] = _1182
                mem[_1217 + 32] = uint256(stor[sha3(_1182)].field_0)
                t = _1217 + 32
                u = sha3(_1182)
                while _1217 + (uint255(uint256(stor[_1182].field_0)) * 0.5) > t:
                    mem[t + 32] = uint256(stor1[u])
                    t = t + 32
                    u = u + 1
                    continue 
                mem[_1183] = _1217
                mem[_1183 + 32] = address(stor1[_1182])
                require ext_code.size(address(stor1[_1182]))
                staticcall address(stor1[_1182]).totalNodesCreated() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1453 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if s > !mem[_1453]:
                    revert with 0, 17
                if s + mem[_1453] < s:
                    revert with 0, 'SafeMath: addition overflow'
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + mem[_1453]
                continue 
            if bool(stor[_1182].field_0) == stor[_1182].field_1 % 128 < 32:
                revert with 0, 34
            if not stor[_1182].field_1 % 128:
                mem[_1183] = _1217
                mem[_1183 + 32] = address(stor1[_1182])
                require ext_code.size(address(stor1[_1182]))
                staticcall address(stor1[_1182]).totalNodesCreated() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1312 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if s > !mem[_1312]:
                    revert with 0, 17
                if s + mem[_1312] < s:
                    revert with 0, 'SafeMath: addition overflow'
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + mem[_1312]
                continue 
            if 31 >= stor[_1182].field_1 % 128:
                mem[_1217 + 32] = 256 * Mask(248, 0, stor[_1182].field_8)
                mem[_1183] = _1217
                mem[_1183 + 32] = address(stor1[_1182])
                require ext_code.size(address(stor1[_1182]))
                staticcall address(stor1[_1182]).totalNodesCreated() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1351 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if s > !mem[_1351]:
                    revert with 0, 17
                if s + mem[_1351] < s:
                    revert with 0, 'SafeMath: addition overflow'
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + mem[_1351]
                continue 
            mem[0] = _1182
            mem[_1217 + 32] = uint256(stor[sha3(_1182)].field_0)
            t = _1217 + 32
            u = sha3(_1182)
            while _1217 + stor[_1182].field_1 % 128 > t:
                mem[t + 32] = uint256(stor1[u])
                t = t + 32
                u = u + 1
                continue 
            mem[_1183] = _1217
            mem[_1183 + 32] = address(stor1[_1182])
            require ext_code.size(address(stor1[_1182]))
            staticcall address(stor1[_1182]).totalNodesCreated() with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1454 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            if s > !mem[_1454]:
                revert with 0, 17
            if s + mem[_1454] < s:
                revert with 0, 'SafeMath: addition overflow'
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s + mem[_1454]
            continue 
        if bool(stor25[idx].field_0) == stor25[idx].field_1 % 128 < 32:
            revert with 0, 34
        if not bool(stor25[idx].field_0):
            mem[mem[64]] = Mask(248, 8, uint256(stor25[idx].field_0))
            mem[mem[64] + stor25[idx].field_1 % 128] = 24
            _578 = sha3(Mask(248, 8, uint256(stor25[idx].field_0)), mem[mem[64] + 32 len stor25[idx].field_1 % 128])
            _579 = mem[64]
            mem[64] = mem[64] + 64
            if bool(stor[_578].field_0):
                if bool(stor[_578].field_0) == uint255(uint256(stor[_578].field_0)) * 0.5 < 32:
                    revert with 0, 34
                _592 = mem[64]
                mem[64] = mem[64] + ceil32(uint255(uint256(stor[_578].field_0)) * 0.5) + 32
                mem[_592] = uint255(uint256(stor[_578].field_0)) * 0.5
                if bool(stor[_578].field_0):
                    if bool(stor[_578].field_0) == uint255(uint256(stor[_578].field_0)) * 0.5 < 32:
                        revert with 0, 34
                    if not Mask(256, -1, uint256(stor[_578].field_0)):
                        mem[_579] = _592
                        mem[_579 + 32] = address(stor1[_578])
                        require ext_code.size(address(stor1[_578]))
                        staticcall address(stor1[_578]).totalNodesCreated() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _664 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if s > !mem[_664]:
                            revert with 0, 17
                        if s + mem[_664] < s:
                            revert with 0, 'SafeMath: addition overflow'
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + mem[_664]
                        continue 
                    if 31 >= uint255(uint256(stor[_578].field_0)) * 0.5:
                        mem[_592 + 32] = 256 * Mask(248, 0, stor[_578].field_8)
                        mem[_579] = _592
                        mem[_579 + 32] = address(stor1[_578])
                        require ext_code.size(address(stor1[_578]))
                        staticcall address(stor1[_578]).totalNodesCreated() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _758 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if s > !mem[_758]:
                            revert with 0, 17
                        if s + mem[_758] < s:
                            revert with 0, 'SafeMath: addition overflow'
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + mem[_758]
                        continue 
                    mem[0] = _578
                    mem[_592 + 32] = uint256(stor[sha3(_578)].field_0)
                    t = _592 + 32
                    u = sha3(_578)
                    while _592 + (uint255(uint256(stor[_578].field_0)) * 0.5) > t:
                        mem[t + 32] = uint256(stor1[u])
                        t = t + 32
                        u = u + 1
                        continue 
                    mem[_579] = _592
                    mem[_579 + 32] = address(stor1[_578])
                    require ext_code.size(address(stor1[_578]))
                    staticcall address(stor1[_578]).totalNodesCreated() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1188 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if s > !mem[_1188]:
                        revert with 0, 17
                    if s + mem[_1188] < s:
                        revert with 0, 'SafeMath: addition overflow'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + mem[_1188]
                    continue 
                if bool(stor[_578].field_0) == stor[_578].field_1 % 128 < 32:
                    revert with 0, 34
                if not stor[_578].field_1 % 128:
                    mem[_579] = _592
                    mem[_579 + 32] = address(stor1[_578])
                    require ext_code.size(address(stor1[_578]))
                    staticcall address(stor1[_578]).totalNodesCreated() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _705 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if s > !mem[_705]:
                        revert with 0, 17
                    if s + mem[_705] < s:
                        revert with 0, 'SafeMath: addition overflow'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + mem[_705]
                    continue 
                if 31 >= stor[_578].field_1 % 128:
                    mem[_592 + 32] = 256 * Mask(248, 0, stor[_578].field_8)
                    mem[_579] = _592
                    mem[_579 + 32] = address(stor1[_578])
                    require ext_code.size(address(stor1[_578]))
                    staticcall address(stor1[_578]).totalNodesCreated() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _809 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if s > !mem[_809]:
                        revert with 0, 17
                    if s + mem[_809] < s:
                        revert with 0, 'SafeMath: addition overflow'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + mem[_809]
                    continue 
                mem[0] = _578
                mem[_592 + 32] = uint256(stor[sha3(_578)].field_0)
                t = _592 + 32
                u = sha3(_578)
                while _592 + stor[_578].field_1 % 128 > t:
                    mem[t + 32] = uint256(stor1[u])
                    t = t + 32
                    u = u + 1
                    continue 
                mem[_579] = _592
                mem[_579 + 32] = address(stor1[_578])
                require ext_code.size(address(stor1[_578]))
                staticcall address(stor1[_578]).totalNodesCreated() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1189 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if s > !mem[_1189]:
                    revert with 0, 17
                if s + mem[_1189] < s:
                    revert with 0, 'SafeMath: addition overflow'
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + mem[_1189]
                continue 
            if bool(stor[_578].field_0) == stor[_578].field_1 % 128 < 32:
                revert with 0, 34
            _594 = mem[64]
            mem[64] = mem[64] + ceil32(stor[_578].field_1 % 128) + 32
            mem[_594] = stor[_578].field_1 % 128
            if bool(stor[_578].field_0):
                if bool(stor[_578].field_0) == uint255(uint256(stor[_578].field_0)) * 0.5 < 32:
                    revert with 0, 34
                if not Mask(256, -1, uint256(stor[_578].field_0)):
                    mem[_579] = _594
                    mem[_579 + 32] = address(stor1[_578])
                    require ext_code.size(address(stor1[_578]))
                    staticcall address(stor1[_578]).totalNodesCreated() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _709 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if s > !mem[_709]:
                        revert with 0, 17
                    if s + mem[_709] < s:
                        revert with 0, 'SafeMath: addition overflow'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + mem[_709]
                    continue 
                if 31 >= uint255(uint256(stor[_578].field_0)) * 0.5:
                    mem[_594 + 32] = 256 * Mask(248, 0, stor[_578].field_8)
                    mem[_579] = _594
                    mem[_579 + 32] = address(stor1[_578])
                    require ext_code.size(address(stor1[_578]))
                    staticcall address(stor1[_578]).totalNodesCreated() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _814 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if s > !mem[_814]:
                        revert with 0, 17
                    if s + mem[_814] < s:
                        revert with 0, 'SafeMath: addition overflow'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + mem[_814]
                    continue 
                mem[0] = _578
                mem[_594 + 32] = uint256(stor[sha3(_578)].field_0)
                t = _594 + 32
                u = sha3(_578)
                while _594 + (uint255(uint256(stor[_578].field_0)) * 0.5) > t:
                    mem[t + 32] = uint256(stor1[u])
                    t = t + 32
                    u = u + 1
                    continue 
                mem[_579] = _594
                mem[_579 + 32] = address(stor1[_578])
                require ext_code.size(address(stor1[_578]))
                staticcall address(stor1[_578]).totalNodesCreated() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1190 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if s > !mem[_1190]:
                    revert with 0, 17
                if s + mem[_1190] < s:
                    revert with 0, 'SafeMath: addition overflow'
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + mem[_1190]
                continue 
            if bool(stor[_578].field_0) == stor[_578].field_1 % 128 < 32:
                revert with 0, 34
            if not stor[_578].field_1 % 128:
                mem[_579] = _594
                mem[_579 + 32] = address(stor1[_578])
                require ext_code.size(address(stor1[_578]))
                staticcall address(stor1[_578]).totalNodesCreated() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _759 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if s > !mem[_759]:
                    revert with 0, 17
                if s + mem[_759] < s:
                    revert with 0, 'SafeMath: addition overflow'
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + mem[_759]
                continue 
            if 31 >= stor[_578].field_1 % 128:
                mem[_594 + 32] = 256 * Mask(248, 0, stor[_578].field_8)
                mem[_579] = _594
                mem[_579 + 32] = address(stor1[_578])
                require ext_code.size(address(stor1[_578]))
                staticcall address(stor1[_578]).totalNodesCreated() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _859 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if s > !mem[_859]:
                    revert with 0, 17
                if s + mem[_859] < s:
                    revert with 0, 'SafeMath: addition overflow'
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + mem[_859]
                continue 
            mem[0] = _578
            mem[_594 + 32] = uint256(stor[sha3(_578)].field_0)
            t = _594 + 32
            u = sha3(_578)
            while _594 + stor[_578].field_1 % 128 > t:
                mem[t + 32] = uint256(stor1[u])
                t = t + 32
                u = u + 1
                continue 
            mem[_579] = _594
            mem[_579 + 32] = address(stor1[_578])
            require ext_code.size(address(stor1[_578]))
            staticcall address(stor1[_578]).totalNodesCreated() with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1191 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            if s > !mem[_1191]:
                revert with 0, 17
            if s + mem[_1191] < s:
                revert with 0, 'SafeMath: addition overflow'
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s + mem[_1191]
            continue 
        if bool(stor25[idx].field_0) != 1:
            mem[0] = 24
            _581 = sha3(mem[mem[64] len -mem[64] + 32])
            _582 = mem[64]
            mem[64] = mem[64] + 64
            if bool(stor[_581].field_0):
                if bool(stor[_581].field_0) == uint255(uint256(stor[_581].field_0)) * 0.5 < 32:
                    revert with 0, 34
                _595 = mem[64]
                mem[64] = mem[64] + ceil32(uint255(uint256(stor[_581].field_0)) * 0.5) + 32
                mem[_595] = uint255(uint256(stor[_581].field_0)) * 0.5
                if bool(stor[_581].field_0):
                    if bool(stor[_581].field_0) == uint255(uint256(stor[_581].field_0)) * 0.5 < 32:
                        revert with 0, 34
                    if not Mask(256, -1, uint256(stor[_581].field_0)):
                        mem[_582] = _595
                        mem[_582 + 32] = address(stor1[_581])
                        require ext_code.size(address(stor1[_581]))
                        staticcall address(stor1[_581]).totalNodesCreated() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _717 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if s > !mem[_717]:
                            revert with 0, 17
                        if s + mem[_717] < s:
                            revert with 0, 'SafeMath: addition overflow'
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + mem[_717]
                        continue 
                    if 31 >= uint255(uint256(stor[_581].field_0)) * 0.5:
                        mem[_595 + 32] = 256 * Mask(248, 0, stor[_581].field_8)
                        mem[_582] = _595
                        mem[_582 + 32] = address(stor1[_581])
                        require ext_code.size(address(stor1[_581]))
                        staticcall address(stor1[_581]).totalNodesCreated() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _828 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if s > !mem[_828]:
                            revert with 0, 17
                        if s + mem[_828] < s:
                            revert with 0, 'SafeMath: addition overflow'
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + mem[_828]
                        continue 
                    mem[0] = _581
                    mem[_595 + 32] = uint256(stor[sha3(_581)].field_0)
                    t = _595 + 32
                    u = sha3(_581)
                    while _595 + (uint255(uint256(stor[_581].field_0)) * 0.5) > t:
                        mem[t + 32] = uint256(stor1[u])
                        t = t + 32
                        u = u + 1
                        continue 
                    mem[_582] = _595
                    mem[_582 + 32] = address(stor1[_581])
                    require ext_code.size(address(stor1[_581]))
                    staticcall address(stor1[_581]).totalNodesCreated() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1195 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if s > !mem[_1195]:
                        revert with 0, 17
                    if s + mem[_1195] < s:
                        revert with 0, 'SafeMath: addition overflow'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + mem[_1195]
                    continue 
                if bool(stor[_581].field_0) == stor[_581].field_1 % 128 < 32:
                    revert with 0, 34
                if not stor[_581].field_1 % 128:
                    mem[_582] = _595
                    mem[_582 + 32] = address(stor1[_581])
                    require ext_code.size(address(stor1[_581]))
                    staticcall address(stor1[_581]).totalNodesCreated() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _770 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if s > !mem[_770]:
                        revert with 0, 17
                    if s + mem[_770] < s:
                        revert with 0, 'SafeMath: addition overflow'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + mem[_770]
                    continue 
                if 31 >= stor[_581].field_1 % 128:
                    mem[_595 + 32] = 256 * Mask(248, 0, stor[_581].field_8)
                    mem[_582] = _595
                    mem[_582 + 32] = address(stor1[_581])
                    require ext_code.size(address(stor1[_581]))
                    staticcall address(stor1[_581]).totalNodesCreated() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _873 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if s > !mem[_873]:
                        revert with 0, 17
                    if s + mem[_873] < s:
                        revert with 0, 'SafeMath: addition overflow'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + mem[_873]
                    continue 
                mem[0] = _581
                mem[_595 + 32] = uint256(stor[sha3(_581)].field_0)
                t = _595 + 32
                u = sha3(_581)
                while _595 + stor[_581].field_1 % 128 > t:
                    mem[t + 32] = uint256(stor1[u])
                    t = t + 32
                    u = u + 1
                    continue 
                mem[_582] = _595
                mem[_582 + 32] = address(stor1[_581])
                require ext_code.size(address(stor1[_581]))
                staticcall address(stor1[_581]).totalNodesCreated() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1196 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if s > !mem[_1196]:
                    revert with 0, 17
                if s + mem[_1196] < s:
                    revert with 0, 'SafeMath: addition overflow'
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + mem[_1196]
                continue 
            if bool(stor[_581].field_0) == stor[_581].field_1 % 128 < 32:
                revert with 0, 34
            _597 = mem[64]
            mem[64] = mem[64] + ceil32(stor[_581].field_1 % 128) + 32
            mem[_597] = stor[_581].field_1 % 128
            if bool(stor[_581].field_0):
                if bool(stor[_581].field_0) == uint255(uint256(stor[_581].field_0)) * 0.5 < 32:
                    revert with 0, 34
                if not Mask(256, -1, uint256(stor[_581].field_0)):
                    mem[_582] = _597
                    mem[_582 + 32] = address(stor1[_581])
                    require ext_code.size(address(stor1[_581]))
                    staticcall address(stor1[_581]).totalNodesCreated() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _774 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if s > !mem[_774]:
                        revert with 0, 17
                    if s + mem[_774] < s:
                        revert with 0, 'SafeMath: addition overflow'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + mem[_774]
                    continue 
                if 31 >= uint255(uint256(stor[_581].field_0)) * 0.5:
                    mem[_597 + 32] = 256 * Mask(248, 0, stor[_581].field_8)
                    mem[_582] = _597
                    mem[_582 + 32] = address(stor1[_581])
                    require ext_code.size(address(stor1[_581]))
                    staticcall address(stor1[_581]).totalNodesCreated() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _878 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if s > !mem[_878]:
                        revert with 0, 17
                    if s + mem[_878] < s:
                        revert with 0, 'SafeMath: addition overflow'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + mem[_878]
                    continue 
                mem[0] = _581
                mem[_597 + 32] = uint256(stor[sha3(_581)].field_0)
                t = _597 + 32
                u = sha3(_581)
                while _597 + (uint255(uint256(stor[_581].field_0)) * 0.5) > t:
                    mem[t + 32] = uint256(stor1[u])
                    t = t + 32
                    u = u + 1
                    continue 
                mem[_582] = _597
                mem[_582 + 32] = address(stor1[_581])
                require ext_code.size(address(stor1[_581]))
                staticcall address(stor1[_581]).totalNodesCreated() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1197 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if s > !mem[_1197]:
                    revert with 0, 17
                if s + mem[_1197] < s:
                    revert with 0, 'SafeMath: addition overflow'
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + mem[_1197]
                continue 
            if bool(stor[_581].field_0) == stor[_581].field_1 % 128 < 32:
                revert with 0, 34
            if not stor[_581].field_1 % 128:
                mem[_582] = _597
                mem[_582 + 32] = address(stor1[_581])
                require ext_code.size(address(stor1[_581]))
                staticcall address(stor1[_581]).totalNodesCreated() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _829 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if s > !mem[_829]:
                    revert with 0, 17
                if s + mem[_829] < s:
                    revert with 0, 'SafeMath: addition overflow'
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + mem[_829]
                continue 
            if 31 >= stor[_581].field_1 % 128:
                mem[_597 + 32] = 256 * Mask(248, 0, stor[_581].field_8)
                mem[_582] = _597
                mem[_582 + 32] = address(stor1[_581])
                require ext_code.size(address(stor1[_581]))
                staticcall address(stor1[_581]).totalNodesCreated() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _915 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if s > !mem[_915]:
                    revert with 0, 17
                if s + mem[_915] < s:
                    revert with 0, 'SafeMath: addition overflow'
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + mem[_915]
                continue 
            mem[0] = _581
            mem[_597 + 32] = uint256(stor[sha3(_581)].field_0)
            t = _597 + 32
            u = sha3(_581)
            while _597 + stor[_581].field_1 % 128 > t:
                mem[t + 32] = uint256(stor1[u])
                t = t + 32
                u = u + 1
                continue 
            mem[_582] = _597
            mem[_582 + 32] = address(stor1[_581])
            require ext_code.size(address(stor1[_581]))
            staticcall address(stor1[_581]).totalNodesCreated() with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1198 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            if s > !mem[_1198]:
                revert with 0, 17
            if s + mem[_1198] < s:
                revert with 0, 'SafeMath: addition overflow'
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s + mem[_1198]
            continue 
        mem[0] = sha3(25) + idx
        t = 0
        u = sha3(mem[0])
        while t < stor25[idx].field_1 % 128:
            mem[t + _567] = uint256(stor[u].field_0)
            t = t + 32
            u = u + 1
            continue 
        mem[_567 + stor25[idx].field_1 % 128] = 24
        _1193 = sha3(mem[mem[64] len _567 + stor25[idx].field_1 % 128 + -mem[64] + 32])
        _1194 = mem[64]
        mem[64] = mem[64] + 64
        if bool(stor[_1193].field_0):
            if bool(stor[_1193].field_0) == uint255(uint256(stor[_1193].field_0)) * 0.5 < 32:
                revert with 0, 34
            _1216 = mem[64]
            mem[64] = mem[64] + ceil32(uint255(uint256(stor[_1193].field_0)) * 0.5) + 32
            mem[_1216] = uint255(uint256(stor[_1193].field_0)) * 0.5
            if bool(stor[_1193].field_0):
                if bool(stor[_1193].field_0) == uint255(uint256(stor[_1193].field_0)) * 0.5 < 32:
                    revert with 0, 34
                if not Mask(256, -1, uint256(stor[_1193].field_0)):
                    mem[_1194] = _1216
                    mem[_1194 + 32] = address(stor1[_1193])
                    require ext_code.size(address(stor1[_1193]))
                    staticcall address(stor1[_1193]).totalNodesCreated() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1280 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if s > !mem[_1280]:
                        revert with 0, 17
                    if s + mem[_1280] < s:
                        revert with 0, 'SafeMath: addition overflow'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + mem[_1280]
                    continue 
                if 31 >= uint255(uint256(stor[_1193].field_0)) * 0.5:
                    mem[_1216 + 32] = 256 * Mask(248, 0, stor[_1193].field_8)
                    mem[_1194] = _1216
                    mem[_1194 + 32] = address(stor1[_1193])
                    require ext_code.size(address(stor1[_1193]))
                    staticcall address(stor1[_1193]).totalNodesCreated() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1320 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if s > !mem[_1320]:
                        revert with 0, 17
                    if s + mem[_1320] < s:
                        revert with 0, 'SafeMath: addition overflow'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + mem[_1320]
                    continue 
                mem[0] = _1193
                mem[_1216 + 32] = uint256(stor[sha3(_1193)].field_0)
                t = _1216 + 32
                u = sha3(_1193)
                while _1216 + (uint255(uint256(stor[_1193].field_0)) * 0.5) > t:
                    mem[t + 32] = uint256(stor1[u])
                    t = t + 32
                    u = u + 1
                    continue 
                mem[_1194] = _1216
                mem[_1194 + 32] = address(stor1[_1193])
                require ext_code.size(address(stor1[_1193]))
                staticcall address(stor1[_1193]).totalNodesCreated() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1455 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if s > !mem[_1455]:
                    revert with 0, 17
                if s + mem[_1455] < s:
                    revert with 0, 'SafeMath: addition overflow'
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + mem[_1455]
                continue 
            if bool(stor[_1193].field_0) == stor[_1193].field_1 % 128 < 32:
                revert with 0, 34
            if not stor[_1193].field_1 % 128:
                mem[_1194] = _1216
                mem[_1194 + 32] = address(stor1[_1193])
                require ext_code.size(address(stor1[_1193]))
                staticcall address(stor1[_1193]).totalNodesCreated() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1298 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if s > !mem[_1298]:
                    revert with 0, 17
                if s + mem[_1298] < s:
                    revert with 0, 'SafeMath: addition overflow'
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + mem[_1298]
                continue 
            if 31 >= stor[_1193].field_1 % 128:
                mem[_1216 + 32] = 256 * Mask(248, 0, stor[_1193].field_8)
                mem[_1194] = _1216
                mem[_1194 + 32] = address(stor1[_1193])
                require ext_code.size(address(stor1[_1193]))
                staticcall address(stor1[_1193]).totalNodesCreated() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1339 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if s > !mem[_1339]:
                    revert with 0, 17
                if s + mem[_1339] < s:
                    revert with 0, 'SafeMath: addition overflow'
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + mem[_1339]
                continue 
            mem[0] = _1193
            mem[_1216 + 32] = uint256(stor[sha3(_1193)].field_0)
            t = _1216 + 32
            u = sha3(_1193)
            while _1216 + stor[_1193].field_1 % 128 > t:
                mem[t + 32] = uint256(stor1[u])
                t = t + 32
                u = u + 1
                continue 
            mem[_1194] = _1216
            mem[_1194 + 32] = address(stor1[_1193])
            require ext_code.size(address(stor1[_1193]))
            staticcall address(stor1[_1193]).totalNodesCreated() with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1456 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            if s > !mem[_1456]:
                revert with 0, 17
            if s + mem[_1456] < s:
                revert with 0, 'SafeMath: addition overflow'
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s + mem[_1456]
            continue 
        if bool(stor[_1193].field_0) == stor[_1193].field_1 % 128 < 32:
            revert with 0, 34
        _1218 = mem[64]
        mem[64] = mem[64] + ceil32(stor[_1193].field_1 % 128) + 32
        mem[_1218] = stor[_1193].field_1 % 128
        if bool(stor[_1193].field_0):
            if bool(stor[_1193].field_0) == uint255(uint256(stor[_1193].field_0)) * 0.5 < 32:
                revert with 0, 34
            if not Mask(256, -1, uint256(stor[_1193].field_0)):
                mem[_1194] = _1218
                mem[_1194 + 32] = address(stor1[_1193])
                require ext_code.size(address(stor1[_1193]))
                staticcall address(stor1[_1193]).totalNodesCreated() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1302 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if s > !mem[_1302]:
                    revert with 0, 17
                if s + mem[_1302] < s:
                    revert with 0, 'SafeMath: addition overflow'
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + mem[_1302]
                continue 
            if 31 >= uint255(uint256(stor[_1193].field_0)) * 0.5:
                mem[_1218 + 32] = 256 * Mask(248, 0, stor[_1193].field_8)
                mem[_1194] = _1218
                mem[_1194 + 32] = address(stor1[_1193])
                require ext_code.size(address(stor1[_1193]))
                staticcall address(stor1[_1193]).totalNodesCreated() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1344 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if s > !mem[_1344]:
                    revert with 0, 17
                if s + mem[_1344] < s:
                    revert with 0, 'SafeMath: addition overflow'
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + mem[_1344]
                continue 
            mem[0] = _1193
            mem[_1218 + 32] = uint256(stor[sha3(_1193)].field_0)
            t = _1218 + 32
            u = sha3(_1193)
            while _1218 + (uint255(uint256(stor[_1193].field_0)) * 0.5) > t:
                mem[t + 32] = uint256(stor1[u])
                t = t + 32
                u = u + 1
                continue 
            mem[_1194] = _1218
            mem[_1194 + 32] = address(stor1[_1193])
            require ext_code.size(address(stor1[_1193]))
            staticcall address(stor1[_1193]).totalNodesCreated() with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1457 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            if s > !mem[_1457]:
                revert with 0, 17
            if s + mem[_1457] < s:
                revert with 0, 'SafeMath: addition overflow'
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s + mem[_1457]
            continue 
        if bool(stor[_1193].field_0) == stor[_1193].field_1 % 128 < 32:
            revert with 0, 34
        if not stor[_1193].field_1 % 128:
            mem[_1194] = _1218
            mem[_1194 + 32] = address(stor1[_1193])
            require ext_code.size(address(stor1[_1193]))
            staticcall address(stor1[_1193]).totalNodesCreated() with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1321 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            if s > !mem[_1321]:
                revert with 0, 17
            if s + mem[_1321] < s:
                revert with 0, 'SafeMath: addition overflow'
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s + mem[_1321]
            continue 
        if 31 >= stor[_1193].field_1 % 128:
            mem[_1218 + 32] = 256 * Mask(248, 0, stor[_1193].field_8)
            mem[_1194] = _1218
            mem[_1194 + 32] = address(stor1[_1193])
            require ext_code.size(address(stor1[_1193]))
            staticcall address(stor1[_1193]).totalNodesCreated() with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1358 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            if s > !mem[_1358]:
                revert with 0, 17
            if s + mem[_1358] < s:
                revert with 0, 'SafeMath: addition overflow'
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s + mem[_1358]
            continue 
        mem[0] = _1193
        mem[_1218 + 32] = uint256(stor[sha3(_1193)].field_0)
        t = _1218 + 32
        u = sha3(_1193)
        while _1218 + stor[_1193].field_1 % 128 > t:
            mem[t + 32] = uint256(stor1[u])
            t = t + 32
            u = u + 1
            continue 
        mem[_1194] = _1218
        mem[_1194 + 32] = address(stor1[_1193])
        require ext_code.size(address(stor1[_1193]))
        staticcall address(stor1[_1193]).totalNodesCreated() with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _1458 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        if s > !mem[_1458]:
            revert with 0, 17
        if s + mem[_1458] < s:
            revert with 0, 'SafeMath: addition overflow'
        if idx == -1:
            revert with 0, 17
        idx = idx + 1
        s = s + mem[_1458]
        continue 
    return s
}

function getRewardAmountOf(address arg1) payable {
    mem[64] = 96
    require not msg.value
    require calldata.size - 4 >= 32
    require arg1 == arg1
    idx = 0
    s = 0
    while idx < stor25.length:
        mem[0] = 25
        _567 = mem[64]
        if bool(stor25[idx].field_0):
            if bool(stor25[idx].field_0) == uint255(uint256(stor25[idx].field_0)) * 0.5 < 32:
                revert with 0, 34
            if not bool(stor25[idx].field_0):
                mem[mem[64]] = Mask(248, 8, uint256(stor25[idx].field_0))
                mem[mem[64] + (uint255(uint256(stor25[idx].field_0)) * 0.5)] = 24
                _572 = sha3(Mask(248, 8, uint256(stor25[idx].field_0)), mem[mem[64] + 32 len uint255(uint256(stor25[idx].field_0)) * 0.5])
                _573 = mem[64]
                mem[64] = mem[64] + 64
                if bool(stor[_572].field_0):
                    if bool(stor[_572].field_0) == uint255(uint256(stor[_572].field_0)) * 0.5 < 32:
                        revert with 0, 34
                    _586 = mem[64]
                    mem[64] = mem[64] + ceil32(uint255(uint256(stor[_572].field_0)) * 0.5) + 32
                    mem[_586] = uint255(uint256(stor[_572].field_0)) * 0.5
                    if bool(stor[_572].field_0):
                        if bool(stor[_572].field_0) == uint255(uint256(stor[_572].field_0)) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, uint256(stor[_572].field_0)):
                            mem[_573] = _586
                            mem[_573 + 32] = address(stor1[_572])
                            mem[mem[64] + 4] = arg1
                            require ext_code.size(address(stor1[_572]))
                            staticcall address(stor1[_572])._getRewardAmountOf(address arg1) with:
                                    gas gas_remaining wei
                                   args address(arg1)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _617 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if s > !mem[_617]:
                                revert with 0, 17
                            if s + mem[_617] < s:
                                revert with 0, 'SafeMath: addition overflow'
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + mem[_617]
                            continue 
                        if 31 >= uint255(uint256(stor[_572].field_0)) * 0.5:
                            mem[_586 + 32] = 256 * Mask(248, 0, stor[_572].field_8)
                            mem[_573] = _586
                            mem[_573 + 32] = address(stor1[_572])
                            mem[mem[64] + 4] = arg1
                            require ext_code.size(address(stor1[_572]))
                            staticcall address(stor1[_572])._getRewardAmountOf(address arg1) with:
                                    gas gas_remaining wei
                                   args address(arg1)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _684 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if s > !mem[_684]:
                                revert with 0, 17
                            if s + mem[_684] < s:
                                revert with 0, 'SafeMath: addition overflow'
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + mem[_684]
                            continue 
                        mem[0] = _572
                        mem[_586 + 32] = uint256(stor[sha3(_572)].field_0)
                        t = _586 + 32
                        u = sha3(_572)
                        while _586 + (uint255(uint256(stor[_572].field_0)) * 0.5) > t:
                            mem[t + 32] = uint256(stor1[u])
                            t = t + 32
                            u = u + 1
                            continue 
                        mem[_573] = _586
                        mem[_573 + 32] = address(stor1[_572])
                        mem[mem[64] + 4] = arg1
                        require ext_code.size(address(stor1[_572]))
                        staticcall address(stor1[_572])._getRewardAmountOf(address arg1) with:
                                gas gas_remaining wei
                               args address(arg1)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1177 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if s > !mem[_1177]:
                            revert with 0, 17
                        if s + mem[_1177] < s:
                            revert with 0, 'SafeMath: addition overflow'
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + mem[_1177]
                        continue 
                    if bool(stor[_572].field_0) == stor[_572].field_1 % 128 < 32:
                        revert with 0, 34
                    if not stor[_572].field_1 % 128:
                        mem[_573] = _586
                        mem[_573 + 32] = address(stor1[_572])
                        mem[mem[64] + 4] = arg1
                        require ext_code.size(address(stor1[_572]))
                        staticcall address(stor1[_572])._getRewardAmountOf(address arg1) with:
                                gas gas_remaining wei
                               args address(arg1)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _643 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if s > !mem[_643]:
                            revert with 0, 17
                        if s + mem[_643] < s:
                            revert with 0, 'SafeMath: addition overflow'
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + mem[_643]
                        continue 
                    if 31 >= stor[_572].field_1 % 128:
                        mem[_586 + 32] = 256 * Mask(248, 0, stor[_572].field_8)
                        mem[_573] = _586
                        mem[_573 + 32] = address(stor1[_572])
                        mem[mem[64] + 4] = arg1
                        require ext_code.size(address(stor1[_572]))
                        staticcall address(stor1[_572])._getRewardAmountOf(address arg1) with:
                                gas gas_remaining wei
                               args address(arg1)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _730 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if s > !mem[_730]:
                            revert with 0, 17
                        if s + mem[_730] < s:
                            revert with 0, 'SafeMath: addition overflow'
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + mem[_730]
                        continue 
                    mem[0] = _572
                    mem[_586 + 32] = uint256(stor[sha3(_572)].field_0)
                    t = _586 + 32
                    u = sha3(_572)
                    while _586 + stor[_572].field_1 % 128 > t:
                        mem[t + 32] = uint256(stor1[u])
                        t = t + 32
                        u = u + 1
                        continue 
                    mem[_573] = _586
                    mem[_573 + 32] = address(stor1[_572])
                    mem[mem[64] + 4] = arg1
                    require ext_code.size(address(stor1[_572]))
                    staticcall address(stor1[_572])._getRewardAmountOf(address arg1) with:
                            gas gas_remaining wei
                           args address(arg1)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1178 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if s > !mem[_1178]:
                        revert with 0, 17
                    if s + mem[_1178] < s:
                        revert with 0, 'SafeMath: addition overflow'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + mem[_1178]
                    continue 
                if bool(stor[_572].field_0) == stor[_572].field_1 % 128 < 32:
                    revert with 0, 34
                _590 = mem[64]
                mem[64] = mem[64] + ceil32(stor[_572].field_1 % 128) + 32
                mem[_590] = stor[_572].field_1 % 128
                if bool(stor[_572].field_0):
                    if bool(stor[_572].field_0) == uint255(uint256(stor[_572].field_0)) * 0.5 < 32:
                        revert with 0, 34
                    if not Mask(256, -1, uint256(stor[_572].field_0)):
                        mem[_573] = _590
                        mem[_573 + 32] = address(stor1[_572])
                        mem[mem[64] + 4] = arg1
                        require ext_code.size(address(stor1[_572]))
                        staticcall address(stor1[_572])._getRewardAmountOf(address arg1) with:
                                gas gas_remaining wei
                               args address(arg1)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _647 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if s > !mem[_647]:
                            revert with 0, 17
                        if s + mem[_647] < s:
                            revert with 0, 'SafeMath: addition overflow'
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + mem[_647]
                        continue 
                    if 31 >= uint255(uint256(stor[_572].field_0)) * 0.5:
                        mem[_590 + 32] = 256 * Mask(248, 0, stor[_572].field_8)
                        mem[_573] = _590
                        mem[_573 + 32] = address(stor1[_572])
                        mem[mem[64] + 4] = arg1
                        require ext_code.size(address(stor1[_572]))
                        staticcall address(stor1[_572])._getRewardAmountOf(address arg1) with:
                                gas gas_remaining wei
                               args address(arg1)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _735 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if s > !mem[_735]:
                            revert with 0, 17
                        if s + mem[_735] < s:
                            revert with 0, 'SafeMath: addition overflow'
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + mem[_735]
                        continue 
                    mem[0] = _572
                    mem[_590 + 32] = uint256(stor[sha3(_572)].field_0)
                    t = _590 + 32
                    u = sha3(_572)
                    while _590 + (uint255(uint256(stor[_572].field_0)) * 0.5) > t:
                        mem[t + 32] = uint256(stor1[u])
                        t = t + 32
                        u = u + 1
                        continue 
                    mem[_573] = _590
                    mem[_573 + 32] = address(stor1[_572])
                    mem[mem[64] + 4] = arg1
                    require ext_code.size(address(stor1[_572]))
                    staticcall address(stor1[_572])._getRewardAmountOf(address arg1) with:
                            gas gas_remaining wei
                           args address(arg1)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1179 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if s > !mem[_1179]:
                        revert with 0, 17
                    if s + mem[_1179] < s:
                        revert with 0, 'SafeMath: addition overflow'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + mem[_1179]
                    continue 
                if bool(stor[_572].field_0) == stor[_572].field_1 % 128 < 32:
                    revert with 0, 34
                if not stor[_572].field_1 % 128:
                    mem[_573] = _590
                    mem[_573 + 32] = address(stor1[_572])
                    mem[mem[64] + 4] = arg1
                    require ext_code.size(address(stor1[_572]))
                    staticcall address(stor1[_572])._getRewardAmountOf(address arg1) with:
                            gas gas_remaining wei
                           args address(arg1)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _685 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if s > !mem[_685]:
                        revert with 0, 17
                    if s + mem[_685] < s:
                        revert with 0, 'SafeMath: addition overflow'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + mem[_685]
                    continue 
                if 31 >= stor[_572].field_1 % 128:
                    mem[_590 + 32] = 256 * Mask(248, 0, stor[_572].field_8)
                    mem[_573] = _590
                    mem[_573 + 32] = address(stor1[_572])
                    mem[mem[64] + 4] = arg1
                    require ext_code.size(address(stor1[_572]))
                    staticcall address(stor1[_572])._getRewardAmountOf(address arg1) with:
                            gas gas_remaining wei
                           args address(arg1)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _785 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if s > !mem[_785]:
                        revert with 0, 17
                    if s + mem[_785] < s:
                        revert with 0, 'SafeMath: addition overflow'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + mem[_785]
                    continue 
                mem[0] = _572
                mem[_590 + 32] = uint256(stor[sha3(_572)].field_0)
                t = _590 + 32
                u = sha3(_572)
                while _590 + stor[_572].field_1 % 128 > t:
                    mem[t + 32] = uint256(stor1[u])
                    t = t + 32
                    u = u + 1
                    continue 
                mem[_573] = _590
                mem[_573 + 32] = address(stor1[_572])
                mem[mem[64] + 4] = arg1
                require ext_code.size(address(stor1[_572]))
                staticcall address(stor1[_572])._getRewardAmountOf(address arg1) with:
                        gas gas_remaining wei
                       args address(arg1)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1180 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if s > !mem[_1180]:
                    revert with 0, 17
                if s + mem[_1180] < s:
                    revert with 0, 'SafeMath: addition overflow'
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + mem[_1180]
                continue 
            if bool(stor25[idx].field_0) != 1:
                mem[0] = 24
                _575 = sha3(mem[mem[64] len -mem[64] + 32])
                _576 = mem[64]
                mem[64] = mem[64] + 64
                if bool(stor[_575].field_0):
                    if bool(stor[_575].field_0) == uint255(uint256(stor[_575].field_0)) * 0.5 < 32:
                        revert with 0, 34
                    _591 = mem[64]
                    mem[64] = mem[64] + ceil32(uint255(uint256(stor[_575].field_0)) * 0.5) + 32
                    mem[_591] = uint255(uint256(stor[_575].field_0)) * 0.5
                    if bool(stor[_575].field_0):
                        if bool(stor[_575].field_0) == uint255(uint256(stor[_575].field_0)) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, uint256(stor[_575].field_0)):
                            mem[_576] = _591
                            mem[_576 + 32] = address(stor1[_575])
                            mem[mem[64] + 4] = arg1
                            require ext_code.size(address(stor1[_575]))
                            staticcall address(stor1[_575])._getRewardAmountOf(address arg1) with:
                                    gas gas_remaining wei
                                   args address(arg1)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _655 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if s > !mem[_655]:
                                revert with 0, 17
                            if s + mem[_655] < s:
                                revert with 0, 'SafeMath: addition overflow'
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + mem[_655]
                            continue 
                        if 31 >= uint255(uint256(stor[_575].field_0)) * 0.5:
                            mem[_591 + 32] = 256 * Mask(248, 0, stor[_575].field_8)
                            mem[_576] = _591
                            mem[_576 + 32] = address(stor1[_575])
                            mem[mem[64] + 4] = arg1
                            require ext_code.size(address(stor1[_575]))
                            staticcall address(stor1[_575])._getRewardAmountOf(address arg1) with:
                                    gas gas_remaining wei
                                   args address(arg1)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _749 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if s > !mem[_749]:
                                revert with 0, 17
                            if s + mem[_749] < s:
                                revert with 0, 'SafeMath: addition overflow'
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + mem[_749]
                            continue 
                        mem[0] = _575
                        mem[_591 + 32] = uint256(stor[sha3(_575)].field_0)
                        t = _591 + 32
                        u = sha3(_575)
                        while _591 + (uint255(uint256(stor[_575].field_0)) * 0.5) > t:
                            mem[t + 32] = uint256(stor1[u])
                            t = t + 32
                            u = u + 1
                            continue 
                        mem[_576] = _591
                        mem[_576 + 32] = address(stor1[_575])
                        mem[mem[64] + 4] = arg1
                        require ext_code.size(address(stor1[_575]))
                        staticcall address(stor1[_575])._getRewardAmountOf(address arg1) with:
                                gas gas_remaining wei
                               args address(arg1)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1184 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if s > !mem[_1184]:
                            revert with 0, 17
                        if s + mem[_1184] < s:
                            revert with 0, 'SafeMath: addition overflow'
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + mem[_1184]
                        continue 
                    if bool(stor[_575].field_0) == stor[_575].field_1 % 128 < 32:
                        revert with 0, 34
                    if not stor[_575].field_1 % 128:
                        mem[_576] = _591
                        mem[_576 + 32] = address(stor1[_575])
                        mem[mem[64] + 4] = arg1
                        require ext_code.size(address(stor1[_575]))
                        staticcall address(stor1[_575])._getRewardAmountOf(address arg1) with:
                                gas gas_remaining wei
                               args address(arg1)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _696 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if s > !mem[_696]:
                            revert with 0, 17
                        if s + mem[_696] < s:
                            revert with 0, 'SafeMath: addition overflow'
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + mem[_696]
                        continue 
                    if 31 >= stor[_575].field_1 % 128:
                        mem[_591 + 32] = 256 * Mask(248, 0, stor[_575].field_8)
                        mem[_576] = _591
                        mem[_576 + 32] = address(stor1[_575])
                        mem[mem[64] + 4] = arg1
                        require ext_code.size(address(stor1[_575]))
                        staticcall address(stor1[_575])._getRewardAmountOf(address arg1) with:
                                gas gas_remaining wei
                               args address(arg1)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _799 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if s > !mem[_799]:
                            revert with 0, 17
                        if s + mem[_799] < s:
                            revert with 0, 'SafeMath: addition overflow'
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + mem[_799]
                        continue 
                    mem[0] = _575
                    mem[_591 + 32] = uint256(stor[sha3(_575)].field_0)
                    t = _591 + 32
                    u = sha3(_575)
                    while _591 + stor[_575].field_1 % 128 > t:
                        mem[t + 32] = uint256(stor1[u])
                        t = t + 32
                        u = u + 1
                        continue 
                    mem[_576] = _591
                    mem[_576 + 32] = address(stor1[_575])
                    mem[mem[64] + 4] = arg1
                    require ext_code.size(address(stor1[_575]))
                    staticcall address(stor1[_575])._getRewardAmountOf(address arg1) with:
                            gas gas_remaining wei
                           args address(arg1)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1185 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if s > !mem[_1185]:
                        revert with 0, 17
                    if s + mem[_1185] < s:
                        revert with 0, 'SafeMath: addition overflow'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + mem[_1185]
                    continue 
                if bool(stor[_575].field_0) == stor[_575].field_1 % 128 < 32:
                    revert with 0, 34
                _593 = mem[64]
                mem[64] = mem[64] + ceil32(stor[_575].field_1 % 128) + 32
                mem[_593] = stor[_575].field_1 % 128
                if bool(stor[_575].field_0):
                    if bool(stor[_575].field_0) == uint255(uint256(stor[_575].field_0)) * 0.5 < 32:
                        revert with 0, 34
                    if not Mask(256, -1, uint256(stor[_575].field_0)):
                        mem[_576] = _593
                        mem[_576 + 32] = address(stor1[_575])
                        mem[mem[64] + 4] = arg1
                        require ext_code.size(address(stor1[_575]))
                        staticcall address(stor1[_575])._getRewardAmountOf(address arg1) with:
                                gas gas_remaining wei
                               args address(arg1)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _700 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if s > !mem[_700]:
                            revert with 0, 17
                        if s + mem[_700] < s:
                            revert with 0, 'SafeMath: addition overflow'
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + mem[_700]
                        continue 
                    if 31 >= uint255(uint256(stor[_575].field_0)) * 0.5:
                        mem[_593 + 32] = 256 * Mask(248, 0, stor[_575].field_8)
                        mem[_576] = _593
                        mem[_576 + 32] = address(stor1[_575])
                        mem[mem[64] + 4] = arg1
                        require ext_code.size(address(stor1[_575]))
                        staticcall address(stor1[_575])._getRewardAmountOf(address arg1) with:
                                gas gas_remaining wei
                               args address(arg1)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _804 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if s > !mem[_804]:
                            revert with 0, 17
                        if s + mem[_804] < s:
                            revert with 0, 'SafeMath: addition overflow'
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + mem[_804]
                        continue 
                    mem[0] = _575
                    mem[_593 + 32] = uint256(stor[sha3(_575)].field_0)
                    t = _593 + 32
                    u = sha3(_575)
                    while _593 + (uint255(uint256(stor[_575].field_0)) * 0.5) > t:
                        mem[t + 32] = uint256(stor1[u])
                        t = t + 32
                        u = u + 1
                        continue 
                    mem[_576] = _593
                    mem[_576 + 32] = address(stor1[_575])
                    mem[mem[64] + 4] = arg1
                    require ext_code.size(address(stor1[_575]))
                    staticcall address(stor1[_575])._getRewardAmountOf(address arg1) with:
                            gas gas_remaining wei
                           args address(arg1)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1186 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if s > !mem[_1186]:
                        revert with 0, 17
                    if s + mem[_1186] < s:
                        revert with 0, 'SafeMath: addition overflow'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + mem[_1186]
                    continue 
                if bool(stor[_575].field_0) == stor[_575].field_1 % 128 < 32:
                    revert with 0, 34
                if not stor[_575].field_1 % 128:
                    mem[_576] = _593
                    mem[_576 + 32] = address(stor1[_575])
                    mem[mem[64] + 4] = arg1
                    require ext_code.size(address(stor1[_575]))
                    staticcall address(stor1[_575])._getRewardAmountOf(address arg1) with:
                            gas gas_remaining wei
                           args address(arg1)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _750 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if s > !mem[_750]:
                        revert with 0, 17
                    if s + mem[_750] < s:
                        revert with 0, 'SafeMath: addition overflow'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + mem[_750]
                    continue 
                if 31 >= stor[_575].field_1 % 128:
                    mem[_593 + 32] = 256 * Mask(248, 0, stor[_575].field_8)
                    mem[_576] = _593
                    mem[_576 + 32] = address(stor1[_575])
                    mem[mem[64] + 4] = arg1
                    require ext_code.size(address(stor1[_575]))
                    staticcall address(stor1[_575])._getRewardAmountOf(address arg1) with:
                            gas gas_remaining wei
                           args address(arg1)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _852 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if s > !mem[_852]:
                        revert with 0, 17
                    if s + mem[_852] < s:
                        revert with 0, 'SafeMath: addition overflow'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + mem[_852]
                    continue 
                mem[0] = _575
                mem[_593 + 32] = uint256(stor[sha3(_575)].field_0)
                t = _593 + 32
                u = sha3(_575)
                while _593 + stor[_575].field_1 % 128 > t:
                    mem[t + 32] = uint256(stor1[u])
                    t = t + 32
                    u = u + 1
                    continue 
                mem[_576] = _593
                mem[_576 + 32] = address(stor1[_575])
                mem[mem[64] + 4] = arg1
                require ext_code.size(address(stor1[_575]))
                staticcall address(stor1[_575])._getRewardAmountOf(address arg1) with:
                        gas gas_remaining wei
                       args address(arg1)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1187 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if s > !mem[_1187]:
                    revert with 0, 17
                if s + mem[_1187] < s:
                    revert with 0, 'SafeMath: addition overflow'
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + mem[_1187]
                continue 
            mem[0] = sha3(25) + idx
            t = 0
            u = sha3(mem[0])
            while t < uint255(uint256(stor25[idx].field_0)) * 0.5:
                mem[t + _567] = uint256(stor[u].field_0)
                t = t + 32
                u = u + 1
                continue 
            mem[_567 + (uint255(uint256(stor25[idx].field_0)) * 0.5)] = 24
            _1182 = sha3(mem[mem[64] len _567 + (uint255(uint256(stor25[idx].field_0)) * 0.5) + -mem[64] + 32])
            _1183 = mem[64]
            mem[64] = mem[64] + 64
            if bool(stor[_1182].field_0):
                if bool(stor[_1182].field_0) == uint255(uint256(stor[_1182].field_0)) * 0.5 < 32:
                    revert with 0, 34
                _1215 = mem[64]
                mem[64] = mem[64] + ceil32(uint255(uint256(stor[_1182].field_0)) * 0.5) + 32
                mem[_1215] = uint255(uint256(stor[_1182].field_0)) * 0.5
                if bool(stor[_1182].field_0):
                    if bool(stor[_1182].field_0) == uint255(uint256(stor[_1182].field_0)) * 0.5 < 32:
                        revert with 0, 34
                    if not Mask(256, -1, uint256(stor[_1182].field_0)):
                        mem[_1183] = _1215
                        mem[_1183 + 32] = address(stor1[_1182])
                        mem[mem[64] + 4] = arg1
                        require ext_code.size(address(stor1[_1182]))
                        staticcall address(stor1[_1182])._getRewardAmountOf(address arg1) with:
                                gas gas_remaining wei
                               args address(arg1)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1271 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if s > !mem[_1271]:
                            revert with 0, 17
                        if s + mem[_1271] < s:
                            revert with 0, 'SafeMath: addition overflow'
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + mem[_1271]
                        continue 
                    if 31 >= uint255(uint256(stor[_1182].field_0)) * 0.5:
                        mem[_1215 + 32] = 256 * Mask(248, 0, stor[_1182].field_8)
                        mem[_1183] = _1215
                        mem[_1183 + 32] = address(stor1[_1182])
                        mem[mem[64] + 4] = arg1
                        require ext_code.size(address(stor1[_1182]))
                        staticcall address(stor1[_1182])._getRewardAmountOf(address arg1) with:
                                gas gas_remaining wei
                               args address(arg1)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1311 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if s > !mem[_1311]:
                            revert with 0, 17
                        if s + mem[_1311] < s:
                            revert with 0, 'SafeMath: addition overflow'
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + mem[_1311]
                        continue 
                    mem[0] = _1182
                    mem[_1215 + 32] = uint256(stor[sha3(_1182)].field_0)
                    t = _1215 + 32
                    u = sha3(_1182)
                    while _1215 + (uint255(uint256(stor[_1182].field_0)) * 0.5) > t:
                        mem[t + 32] = uint256(stor1[u])
                        t = t + 32
                        u = u + 1
                        continue 
                    mem[_1183] = _1215
                    mem[_1183 + 32] = address(stor1[_1182])
                    mem[mem[64] + 4] = arg1
                    require ext_code.size(address(stor1[_1182]))
                    staticcall address(stor1[_1182])._getRewardAmountOf(address arg1) with:
                            gas gas_remaining wei
                           args address(arg1)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1451 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if s > !mem[_1451]:
                        revert with 0, 17
                    if s + mem[_1451] < s:
                        revert with 0, 'SafeMath: addition overflow'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + mem[_1451]
                    continue 
                if bool(stor[_1182].field_0) == stor[_1182].field_1 % 128 < 32:
                    revert with 0, 34
                if not stor[_1182].field_1 % 128:
                    mem[_1183] = _1215
                    mem[_1183 + 32] = address(stor1[_1182])
                    mem[mem[64] + 4] = arg1
                    require ext_code.size(address(stor1[_1182]))
                    staticcall address(stor1[_1182])._getRewardAmountOf(address arg1) with:
                            gas gas_remaining wei
                           args address(arg1)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1289 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if s > !mem[_1289]:
                        revert with 0, 17
                    if s + mem[_1289] < s:
                        revert with 0, 'SafeMath: addition overflow'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + mem[_1289]
                    continue 
                if 31 >= stor[_1182].field_1 % 128:
                    mem[_1215 + 32] = 256 * Mask(248, 0, stor[_1182].field_8)
                    mem[_1183] = _1215
                    mem[_1183 + 32] = address(stor1[_1182])
                    mem[mem[64] + 4] = arg1
                    require ext_code.size(address(stor1[_1182]))
                    staticcall address(stor1[_1182])._getRewardAmountOf(address arg1) with:
                            gas gas_remaining wei
                           args address(arg1)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1329 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if s > !mem[_1329]:
                        revert with 0, 17
                    if s + mem[_1329] < s:
                        revert with 0, 'SafeMath: addition overflow'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + mem[_1329]
                    continue 
                mem[0] = _1182
                mem[_1215 + 32] = uint256(stor[sha3(_1182)].field_0)
                t = _1215 + 32
                u = sha3(_1182)
                while _1215 + stor[_1182].field_1 % 128 > t:
                    mem[t + 32] = uint256(stor1[u])
                    t = t + 32
                    u = u + 1
                    continue 
                mem[_1183] = _1215
                mem[_1183 + 32] = address(stor1[_1182])
                mem[mem[64] + 4] = arg1
                require ext_code.size(address(stor1[_1182]))
                staticcall address(stor1[_1182])._getRewardAmountOf(address arg1) with:
                        gas gas_remaining wei
                       args address(arg1)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1452 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if s > !mem[_1452]:
                    revert with 0, 17
                if s + mem[_1452] < s:
                    revert with 0, 'SafeMath: addition overflow'
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + mem[_1452]
                continue 
            if bool(stor[_1182].field_0) == stor[_1182].field_1 % 128 < 32:
                revert with 0, 34
            _1217 = mem[64]
            mem[64] = mem[64] + ceil32(stor[_1182].field_1 % 128) + 32
            mem[_1217] = stor[_1182].field_1 % 128
            if bool(stor[_1182].field_0):
                if bool(stor[_1182].field_0) == uint255(uint256(stor[_1182].field_0)) * 0.5 < 32:
                    revert with 0, 34
                if not Mask(256, -1, uint256(stor[_1182].field_0)):
                    mem[_1183] = _1217
                    mem[_1183 + 32] = address(stor1[_1182])
                    mem[mem[64] + 4] = arg1
                    require ext_code.size(address(stor1[_1182]))
                    staticcall address(stor1[_1182])._getRewardAmountOf(address arg1) with:
                            gas gas_remaining wei
                           args address(arg1)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1293 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if s > !mem[_1293]:
                        revert with 0, 17
                    if s + mem[_1293] < s:
                        revert with 0, 'SafeMath: addition overflow'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + mem[_1293]
                    continue 
                if 31 >= uint255(uint256(stor[_1182].field_0)) * 0.5:
                    mem[_1217 + 32] = 256 * Mask(248, 0, stor[_1182].field_8)
                    mem[_1183] = _1217
                    mem[_1183 + 32] = address(stor1[_1182])
                    mem[mem[64] + 4] = arg1
                    require ext_code.size(address(stor1[_1182]))
                    staticcall address(stor1[_1182])._getRewardAmountOf(address arg1) with:
                            gas gas_remaining wei
                           args address(arg1)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1334 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if s > !mem[_1334]:
                        revert with 0, 17
                    if s + mem[_1334] < s:
                        revert with 0, 'SafeMath: addition overflow'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + mem[_1334]
                    continue 
                mem[0] = _1182
                mem[_1217 + 32] = uint256(stor[sha3(_1182)].field_0)
                t = _1217 + 32
                u = sha3(_1182)
                while _1217 + (uint255(uint256(stor[_1182].field_0)) * 0.5) > t:
                    mem[t + 32] = uint256(stor1[u])
                    t = t + 32
                    u = u + 1
                    continue 
                mem[_1183] = _1217
                mem[_1183 + 32] = address(stor1[_1182])
                mem[mem[64] + 4] = arg1
                require ext_code.size(address(stor1[_1182]))
                staticcall address(stor1[_1182])._getRewardAmountOf(address arg1) with:
                        gas gas_remaining wei
                       args address(arg1)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1453 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if s > !mem[_1453]:
                    revert with 0, 17
                if s + mem[_1453] < s:
                    revert with 0, 'SafeMath: addition overflow'
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + mem[_1453]
                continue 
            if bool(stor[_1182].field_0) == stor[_1182].field_1 % 128 < 32:
                revert with 0, 34
            if not stor[_1182].field_1 % 128:
                mem[_1183] = _1217
                mem[_1183 + 32] = address(stor1[_1182])
                mem[mem[64] + 4] = arg1
                require ext_code.size(address(stor1[_1182]))
                staticcall address(stor1[_1182])._getRewardAmountOf(address arg1) with:
                        gas gas_remaining wei
                       args address(arg1)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1312 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if s > !mem[_1312]:
                    revert with 0, 17
                if s + mem[_1312] < s:
                    revert with 0, 'SafeMath: addition overflow'
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + mem[_1312]
                continue 
            if 31 >= stor[_1182].field_1 % 128:
                mem[_1217 + 32] = 256 * Mask(248, 0, stor[_1182].field_8)
                mem[_1183] = _1217
                mem[_1183 + 32] = address(stor1[_1182])
                mem[mem[64] + 4] = arg1
                require ext_code.size(address(stor1[_1182]))
                staticcall address(stor1[_1182])._getRewardAmountOf(address arg1) with:
                        gas gas_remaining wei
                       args address(arg1)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1351 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if s > !mem[_1351]:
                    revert with 0, 17
                if s + mem[_1351] < s:
                    revert with 0, 'SafeMath: addition overflow'
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + mem[_1351]
                continue 
            mem[0] = _1182
            mem[_1217 + 32] = uint256(stor[sha3(_1182)].field_0)
            t = _1217 + 32
            u = sha3(_1182)
            while _1217 + stor[_1182].field_1 % 128 > t:
                mem[t + 32] = uint256(stor1[u])
                t = t + 32
                u = u + 1
                continue 
            mem[_1183] = _1217
            mem[_1183 + 32] = address(stor1[_1182])
            mem[mem[64] + 4] = arg1
            require ext_code.size(address(stor1[_1182]))
            staticcall address(stor1[_1182])._getRewardAmountOf(address arg1) with:
                    gas gas_remaining wei
                   args address(arg1)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1454 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            if s > !mem[_1454]:
                revert with 0, 17
            if s + mem[_1454] < s:
                revert with 0, 'SafeMath: addition overflow'
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s + mem[_1454]
            continue 
        if bool(stor25[idx].field_0) == stor25[idx].field_1 % 128 < 32:
            revert with 0, 34
        if not bool(stor25[idx].field_0):
            mem[mem[64]] = Mask(248, 8, uint256(stor25[idx].field_0))
            mem[mem[64] + stor25[idx].field_1 % 128] = 24
            _578 = sha3(Mask(248, 8, uint256(stor25[idx].field_0)), mem[mem[64] + 32 len stor25[idx].field_1 % 128])
            _579 = mem[64]
            mem[64] = mem[64] + 64
            if bool(stor[_578].field_0):
                if bool(stor[_578].field_0) == uint255(uint256(stor[_578].field_0)) * 0.5 < 32:
                    revert with 0, 34
                _592 = mem[64]
                mem[64] = mem[64] + ceil32(uint255(uint256(stor[_578].field_0)) * 0.5) + 32
                mem[_592] = uint255(uint256(stor[_578].field_0)) * 0.5
                if bool(stor[_578].field_0):
                    if bool(stor[_578].field_0) == uint255(uint256(stor[_578].field_0)) * 0.5 < 32:
                        revert with 0, 34
                    if not Mask(256, -1, uint256(stor[_578].field_0)):
                        mem[_579] = _592
                        mem[_579 + 32] = address(stor1[_578])
                        mem[mem[64] + 4] = arg1
                        require ext_code.size(address(stor1[_578]))
                        staticcall address(stor1[_578])._getRewardAmountOf(address arg1) with:
                                gas gas_remaining wei
                               args address(arg1)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _664 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if s > !mem[_664]:
                            revert with 0, 17
                        if s + mem[_664] < s:
                            revert with 0, 'SafeMath: addition overflow'
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + mem[_664]
                        continue 
                    if 31 >= uint255(uint256(stor[_578].field_0)) * 0.5:
                        mem[_592 + 32] = 256 * Mask(248, 0, stor[_578].field_8)
                        mem[_579] = _592
                        mem[_579 + 32] = address(stor1[_578])
                        mem[mem[64] + 4] = arg1
                        require ext_code.size(address(stor1[_578]))
                        staticcall address(stor1[_578])._getRewardAmountOf(address arg1) with:
                                gas gas_remaining wei
                               args address(arg1)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _758 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if s > !mem[_758]:
                            revert with 0, 17
                        if s + mem[_758] < s:
                            revert with 0, 'SafeMath: addition overflow'
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + mem[_758]
                        continue 
                    mem[0] = _578
                    mem[_592 + 32] = uint256(stor[sha3(_578)].field_0)
                    t = _592 + 32
                    u = sha3(_578)
                    while _592 + (uint255(uint256(stor[_578].field_0)) * 0.5) > t:
                        mem[t + 32] = uint256(stor1[u])
                        t = t + 32
                        u = u + 1
                        continue 
                    mem[_579] = _592
                    mem[_579 + 32] = address(stor1[_578])
                    mem[mem[64] + 4] = arg1
                    require ext_code.size(address(stor1[_578]))
                    staticcall address(stor1[_578])._getRewardAmountOf(address arg1) with:
                            gas gas_remaining wei
                           args address(arg1)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1188 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if s > !mem[_1188]:
                        revert with 0, 17
                    if s + mem[_1188] < s:
                        revert with 0, 'SafeMath: addition overflow'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + mem[_1188]
                    continue 
                if bool(stor[_578].field_0) == stor[_578].field_1 % 128 < 32:
                    revert with 0, 34
                if not stor[_578].field_1 % 128:
                    mem[_579] = _592
                    mem[_579 + 32] = address(stor1[_578])
                    mem[mem[64] + 4] = arg1
                    require ext_code.size(address(stor1[_578]))
                    staticcall address(stor1[_578])._getRewardAmountOf(address arg1) with:
                            gas gas_remaining wei
                           args address(arg1)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _705 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if s > !mem[_705]:
                        revert with 0, 17
                    if s + mem[_705] < s:
                        revert with 0, 'SafeMath: addition overflow'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + mem[_705]
                    continue 
                if 31 >= stor[_578].field_1 % 128:
                    mem[_592 + 32] = 256 * Mask(248, 0, stor[_578].field_8)
                    mem[_579] = _592
                    mem[_579 + 32] = address(stor1[_578])
                    mem[mem[64] + 4] = arg1
                    require ext_code.size(address(stor1[_578]))
                    staticcall address(stor1[_578])._getRewardAmountOf(address arg1) with:
                            gas gas_remaining wei
                           args address(arg1)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _809 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if s > !mem[_809]:
                        revert with 0, 17
                    if s + mem[_809] < s:
                        revert with 0, 'SafeMath: addition overflow'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + mem[_809]
                    continue 
                mem[0] = _578
                mem[_592 + 32] = uint256(stor[sha3(_578)].field_0)
                t = _592 + 32
                u = sha3(_578)
                while _592 + stor[_578].field_1 % 128 > t:
                    mem[t + 32] = uint256(stor1[u])
                    t = t + 32
                    u = u + 1
                    continue 
                mem[_579] = _592
                mem[_579 + 32] = address(stor1[_578])
                mem[mem[64] + 4] = arg1
                require ext_code.size(address(stor1[_578]))
                staticcall address(stor1[_578])._getRewardAmountOf(address arg1) with:
                        gas gas_remaining wei
                       args address(arg1)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1189 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if s > !mem[_1189]:
                    revert with 0, 17
                if s + mem[_1189] < s:
                    revert with 0, 'SafeMath: addition overflow'
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + mem[_1189]
                continue 
            if bool(stor[_578].field_0) == stor[_578].field_1 % 128 < 32:
                revert with 0, 34
            _594 = mem[64]
            mem[64] = mem[64] + ceil32(stor[_578].field_1 % 128) + 32
            mem[_594] = stor[_578].field_1 % 128
            if bool(stor[_578].field_0):
                if bool(stor[_578].field_0) == uint255(uint256(stor[_578].field_0)) * 0.5 < 32:
                    revert with 0, 34
                if not Mask(256, -1, uint256(stor[_578].field_0)):
                    mem[_579] = _594
                    mem[_579 + 32] = address(stor1[_578])
                    mem[mem[64] + 4] = arg1
                    require ext_code.size(address(stor1[_578]))
                    staticcall address(stor1[_578])._getRewardAmountOf(address arg1) with:
                            gas gas_remaining wei
                           args address(arg1)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _709 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if s > !mem[_709]:
                        revert with 0, 17
                    if s + mem[_709] < s:
                        revert with 0, 'SafeMath: addition overflow'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + mem[_709]
                    continue 
                if 31 >= uint255(uint256(stor[_578].field_0)) * 0.5:
                    mem[_594 + 32] = 256 * Mask(248, 0, stor[_578].field_8)
                    mem[_579] = _594
                    mem[_579 + 32] = address(stor1[_578])
                    mem[mem[64] + 4] = arg1
                    require ext_code.size(address(stor1[_578]))
                    staticcall address(stor1[_578])._getRewardAmountOf(address arg1) with:
                            gas gas_remaining wei
                           args address(arg1)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _814 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if s > !mem[_814]:
                        revert with 0, 17
                    if s + mem[_814] < s:
                        revert with 0, 'SafeMath: addition overflow'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + mem[_814]
                    continue 
                mem[0] = _578
                mem[_594 + 32] = uint256(stor[sha3(_578)].field_0)
                t = _594 + 32
                u = sha3(_578)
                while _594 + (uint255(uint256(stor[_578].field_0)) * 0.5) > t:
                    mem[t + 32] = uint256(stor1[u])
                    t = t + 32
                    u = u + 1
                    continue 
                mem[_579] = _594
                mem[_579 + 32] = address(stor1[_578])
                mem[mem[64] + 4] = arg1
                require ext_code.size(address(stor1[_578]))
                staticcall address(stor1[_578])._getRewardAmountOf(address arg1) with:
                        gas gas_remaining wei
                       args address(arg1)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1190 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if s > !mem[_1190]:
                    revert with 0, 17
                if s + mem[_1190] < s:
                    revert with 0, 'SafeMath: addition overflow'
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + mem[_1190]
                continue 
            if bool(stor[_578].field_0) == stor[_578].field_1 % 128 < 32:
                revert with 0, 34
            if not stor[_578].field_1 % 128:
                mem[_579] = _594
                mem[_579 + 32] = address(stor1[_578])
                mem[mem[64] + 4] = arg1
                require ext_code.size(address(stor1[_578]))
                staticcall address(stor1[_578])._getRewardAmountOf(address arg1) with:
                        gas gas_remaining wei
                       args address(arg1)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _759 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if s > !mem[_759]:
                    revert with 0, 17
                if s + mem[_759] < s:
                    revert with 0, 'SafeMath: addition overflow'
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + mem[_759]
                continue 
            if 31 >= stor[_578].field_1 % 128:
                mem[_594 + 32] = 256 * Mask(248, 0, stor[_578].field_8)
                mem[_579] = _594
                mem[_579 + 32] = address(stor1[_578])
                mem[mem[64] + 4] = arg1
                require ext_code.size(address(stor1[_578]))
                staticcall address(stor1[_578])._getRewardAmountOf(address arg1) with:
                        gas gas_remaining wei
                       args address(arg1)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _859 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if s > !mem[_859]:
                    revert with 0, 17
                if s + mem[_859] < s:
                    revert with 0, 'SafeMath: addition overflow'
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + mem[_859]
                continue 
            mem[0] = _578
            mem[_594 + 32] = uint256(stor[sha3(_578)].field_0)
            t = _594 + 32
            u = sha3(_578)
            while _594 + stor[_578].field_1 % 128 > t:
                mem[t + 32] = uint256(stor1[u])
                t = t + 32
                u = u + 1
                continue 
            mem[_579] = _594
            mem[_579 + 32] = address(stor1[_578])
            mem[mem[64] + 4] = arg1
            require ext_code.size(address(stor1[_578]))
            staticcall address(stor1[_578])._getRewardAmountOf(address arg1) with:
                    gas gas_remaining wei
                   args address(arg1)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1191 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            if s > !mem[_1191]:
                revert with 0, 17
            if s + mem[_1191] < s:
                revert with 0, 'SafeMath: addition overflow'
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s + mem[_1191]
            continue 
        if bool(stor25[idx].field_0) != 1:
            mem[0] = 24
            _581 = sha3(mem[mem[64] len -mem[64] + 32])
            _582 = mem[64]
            mem[64] = mem[64] + 64
            if bool(stor[_581].field_0):
                if bool(stor[_581].field_0) == uint255(uint256(stor[_581].field_0)) * 0.5 < 32:
                    revert with 0, 34
                _595 = mem[64]
                mem[64] = mem[64] + ceil32(uint255(uint256(stor[_581].field_0)) * 0.5) + 32
                mem[_595] = uint255(uint256(stor[_581].field_0)) * 0.5
                if bool(stor[_581].field_0):
                    if bool(stor[_581].field_0) == uint255(uint256(stor[_581].field_0)) * 0.5 < 32:
                        revert with 0, 34
                    if not Mask(256, -1, uint256(stor[_581].field_0)):
                        mem[_582] = _595
                        mem[_582 + 32] = address(stor1[_581])
                        mem[mem[64] + 4] = arg1
                        require ext_code.size(address(stor1[_581]))
                        staticcall address(stor1[_581])._getRewardAmountOf(address arg1) with:
                                gas gas_remaining wei
                               args address(arg1)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _717 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if s > !mem[_717]:
                            revert with 0, 17
                        if s + mem[_717] < s:
                            revert with 0, 'SafeMath: addition overflow'
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + mem[_717]
                        continue 
                    if 31 >= uint255(uint256(stor[_581].field_0)) * 0.5:
                        mem[_595 + 32] = 256 * Mask(248, 0, stor[_581].field_8)
                        mem[_582] = _595
                        mem[_582 + 32] = address(stor1[_581])
                        mem[mem[64] + 4] = arg1
                        require ext_code.size(address(stor1[_581]))
                        staticcall address(stor1[_581])._getRewardAmountOf(address arg1) with:
                                gas gas_remaining wei
                               args address(arg1)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _828 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if s > !mem[_828]:
                            revert with 0, 17
                        if s + mem[_828] < s:
                            revert with 0, 'SafeMath: addition overflow'
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + mem[_828]
                        continue 
                    mem[0] = _581
                    mem[_595 + 32] = uint256(stor[sha3(_581)].field_0)
                    t = _595 + 32
                    u = sha3(_581)
                    while _595 + (uint255(uint256(stor[_581].field_0)) * 0.5) > t:
                        mem[t + 32] = uint256(stor1[u])
                        t = t + 32
                        u = u + 1
                        continue 
                    mem[_582] = _595
                    mem[_582 + 32] = address(stor1[_581])
                    mem[mem[64] + 4] = arg1
                    require ext_code.size(address(stor1[_581]))
                    staticcall address(stor1[_581])._getRewardAmountOf(address arg1) with:
                            gas gas_remaining wei
                           args address(arg1)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1195 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if s > !mem[_1195]:
                        revert with 0, 17
                    if s + mem[_1195] < s:
                        revert with 0, 'SafeMath: addition overflow'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + mem[_1195]
                    continue 
                if bool(stor[_581].field_0) == stor[_581].field_1 % 128 < 32:
                    revert with 0, 34
                if not stor[_581].field_1 % 128:
                    mem[_582] = _595
                    mem[_582 + 32] = address(stor1[_581])
                    mem[mem[64] + 4] = arg1
                    require ext_code.size(address(stor1[_581]))
                    staticcall address(stor1[_581])._getRewardAmountOf(address arg1) with:
                            gas gas_remaining wei
                           args address(arg1)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _770 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if s > !mem[_770]:
                        revert with 0, 17
                    if s + mem[_770] < s:
                        revert with 0, 'SafeMath: addition overflow'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + mem[_770]
                    continue 
                if 31 >= stor[_581].field_1 % 128:
                    mem[_595 + 32] = 256 * Mask(248, 0, stor[_581].field_8)
                    mem[_582] = _595
                    mem[_582 + 32] = address(stor1[_581])
                    mem[mem[64] + 4] = arg1
                    require ext_code.size(address(stor1[_581]))
                    staticcall address(stor1[_581])._getRewardAmountOf(address arg1) with:
                            gas gas_remaining wei
                           args address(arg1)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _873 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if s > !mem[_873]:
                        revert with 0, 17
                    if s + mem[_873] < s:
                        revert with 0, 'SafeMath: addition overflow'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + mem[_873]
                    continue 
                mem[0] = _581
                mem[_595 + 32] = uint256(stor[sha3(_581)].field_0)
                t = _595 + 32
                u = sha3(_581)
                while _595 + stor[_581].field_1 % 128 > t:
                    mem[t + 32] = uint256(stor1[u])
                    t = t + 32
                    u = u + 1
                    continue 
                mem[_582] = _595
                mem[_582 + 32] = address(stor1[_581])
                mem[mem[64] + 4] = arg1
                require ext_code.size(address(stor1[_581]))
                staticcall address(stor1[_581])._getRewardAmountOf(address arg1) with:
                        gas gas_remaining wei
                       args address(arg1)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1196 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if s > !mem[_1196]:
                    revert with 0, 17
                if s + mem[_1196] < s:
                    revert with 0, 'SafeMath: addition overflow'
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + mem[_1196]
                continue 
            if bool(stor[_581].field_0) == stor[_581].field_1 % 128 < 32:
                revert with 0, 34
            _597 = mem[64]
            mem[64] = mem[64] + ceil32(stor[_581].field_1 % 128) + 32
            mem[_597] = stor[_581].field_1 % 128
            if bool(stor[_581].field_0):
                if bool(stor[_581].field_0) == uint255(uint256(stor[_581].field_0)) * 0.5 < 32:
                    revert with 0, 34
                if not Mask(256, -1, uint256(stor[_581].field_0)):
                    mem[_582] = _597
                    mem[_582 + 32] = address(stor1[_581])
                    mem[mem[64] + 4] = arg1
                    require ext_code.size(address(stor1[_581]))
                    staticcall address(stor1[_581])._getRewardAmountOf(address arg1) with:
                            gas gas_remaining wei
                           args address(arg1)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _774 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if s > !mem[_774]:
                        revert with 0, 17
                    if s + mem[_774] < s:
                        revert with 0, 'SafeMath: addition overflow'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + mem[_774]
                    continue 
                if 31 >= uint255(uint256(stor[_581].field_0)) * 0.5:
                    mem[_597 + 32] = 256 * Mask(248, 0, stor[_581].field_8)
                    mem[_582] = _597
                    mem[_582 + 32] = address(stor1[_581])
                    mem[mem[64] + 4] = arg1
                    require ext_code.size(address(stor1[_581]))
                    staticcall address(stor1[_581])._getRewardAmountOf(address arg1) with:
                            gas gas_remaining wei
                           args address(arg1)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _878 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if s > !mem[_878]:
                        revert with 0, 17
                    if s + mem[_878] < s:
                        revert with 0, 'SafeMath: addition overflow'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + mem[_878]
                    continue 
                mem[0] = _581
                mem[_597 + 32] = uint256(stor[sha3(_581)].field_0)
                t = _597 + 32
                u = sha3(_581)
                while _597 + (uint255(uint256(stor[_581].field_0)) * 0.5) > t:
                    mem[t + 32] = uint256(stor1[u])
                    t = t + 32
                    u = u + 1
                    continue 
                mem[_582] = _597
                mem[_582 + 32] = address(stor1[_581])
                mem[mem[64] + 4] = arg1
                require ext_code.size(address(stor1[_581]))
                staticcall address(stor1[_581])._getRewardAmountOf(address arg1) with:
                        gas gas_remaining wei
                       args address(arg1)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1197 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if s > !mem[_1197]:
                    revert with 0, 17
                if s + mem[_1197] < s:
                    revert with 0, 'SafeMath: addition overflow'
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + mem[_1197]
                continue 
            if bool(stor[_581].field_0) == stor[_581].field_1 % 128 < 32:
                revert with 0, 34
            if not stor[_581].field_1 % 128:
                mem[_582] = _597
                mem[_582 + 32] = address(stor1[_581])
                mem[mem[64] + 4] = arg1
                require ext_code.size(address(stor1[_581]))
                staticcall address(stor1[_581])._getRewardAmountOf(address arg1) with:
                        gas gas_remaining wei
                       args address(arg1)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _829 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if s > !mem[_829]:
                    revert with 0, 17
                if s + mem[_829] < s:
                    revert with 0, 'SafeMath: addition overflow'
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + mem[_829]
                continue 
            if 31 >= stor[_581].field_1 % 128:
                mem[_597 + 32] = 256 * Mask(248, 0, stor[_581].field_8)
                mem[_582] = _597
                mem[_582 + 32] = address(stor1[_581])
                mem[mem[64] + 4] = arg1
                require ext_code.size(address(stor1[_581]))
                staticcall address(stor1[_581])._getRewardAmountOf(address arg1) with:
                        gas gas_remaining wei
                       args address(arg1)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _915 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if s > !mem[_915]:
                    revert with 0, 17
                if s + mem[_915] < s:
                    revert with 0, 'SafeMath: addition overflow'
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + mem[_915]
                continue 
            mem[0] = _581
            mem[_597 + 32] = uint256(stor[sha3(_581)].field_0)
            t = _597 + 32
            u = sha3(_581)
            while _597 + stor[_581].field_1 % 128 > t:
                mem[t + 32] = uint256(stor1[u])
                t = t + 32
                u = u + 1
                continue 
            mem[_582] = _597
            mem[_582 + 32] = address(stor1[_581])
            mem[mem[64] + 4] = arg1
            require ext_code.size(address(stor1[_581]))
            staticcall address(stor1[_581])._getRewardAmountOf(address arg1) with:
                    gas gas_remaining wei
                   args address(arg1)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1198 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            if s > !mem[_1198]:
                revert with 0, 17
            if s + mem[_1198] < s:
                revert with 0, 'SafeMath: addition overflow'
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s + mem[_1198]
            continue 
        mem[0] = sha3(25) + idx
        t = 0
        u = sha3(mem[0])
        while t < stor25[idx].field_1 % 128:
            mem[t + _567] = uint256(stor[u].field_0)
            t = t + 32
            u = u + 1
            continue 
        mem[_567 + stor25[idx].field_1 % 128] = 24
        _1193 = sha3(mem[mem[64] len _567 + stor25[idx].field_1 % 128 + -mem[64] + 32])
        _1194 = mem[64]
        mem[64] = mem[64] + 64
        if bool(stor[_1193].field_0):
            if bool(stor[_1193].field_0) == uint255(uint256(stor[_1193].field_0)) * 0.5 < 32:
                revert with 0, 34
            _1216 = mem[64]
            mem[64] = mem[64] + ceil32(uint255(uint256(stor[_1193].field_0)) * 0.5) + 32
            mem[_1216] = uint255(uint256(stor[_1193].field_0)) * 0.5
            if bool(stor[_1193].field_0):
                if bool(stor[_1193].field_0) == uint255(uint256(stor[_1193].field_0)) * 0.5 < 32:
                    revert with 0, 34
                if not Mask(256, -1, uint256(stor[_1193].field_0)):
                    mem[_1194] = _1216
                    mem[_1194 + 32] = address(stor1[_1193])
                    mem[mem[64] + 4] = arg1
                    require ext_code.size(address(stor1[_1193]))
                    staticcall address(stor1[_1193])._getRewardAmountOf(address arg1) with:
                            gas gas_remaining wei
                           args address(arg1)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1280 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if s > !mem[_1280]:
                        revert with 0, 17
                    if s + mem[_1280] < s:
                        revert with 0, 'SafeMath: addition overflow'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + mem[_1280]
                    continue 
                if 31 >= uint255(uint256(stor[_1193].field_0)) * 0.5:
                    mem[_1216 + 32] = 256 * Mask(248, 0, stor[_1193].field_8)
                    mem[_1194] = _1216
                    mem[_1194 + 32] = address(stor1[_1193])
                    mem[mem[64] + 4] = arg1
                    require ext_code.size(address(stor1[_1193]))
                    staticcall address(stor1[_1193])._getRewardAmountOf(address arg1) with:
                            gas gas_remaining wei
                           args address(arg1)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1320 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if s > !mem[_1320]:
                        revert with 0, 17
                    if s + mem[_1320] < s:
                        revert with 0, 'SafeMath: addition overflow'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + mem[_1320]
                    continue 
                mem[0] = _1193
                mem[_1216 + 32] = uint256(stor[sha3(_1193)].field_0)
                t = _1216 + 32
                u = sha3(_1193)
                while _1216 + (uint255(uint256(stor[_1193].field_0)) * 0.5) > t:
                    mem[t + 32] = uint256(stor1[u])
                    t = t + 32
                    u = u + 1
                    continue 
                mem[_1194] = _1216
                mem[_1194 + 32] = address(stor1[_1193])
                mem[mem[64] + 4] = arg1
                require ext_code.size(address(stor1[_1193]))
                staticcall address(stor1[_1193])._getRewardAmountOf(address arg1) with:
                        gas gas_remaining wei
                       args address(arg1)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1455 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if s > !mem[_1455]:
                    revert with 0, 17
                if s + mem[_1455] < s:
                    revert with 0, 'SafeMath: addition overflow'
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + mem[_1455]
                continue 
            if bool(stor[_1193].field_0) == stor[_1193].field_1 % 128 < 32:
                revert with 0, 34
            if not stor[_1193].field_1 % 128:
                mem[_1194] = _1216
                mem[_1194 + 32] = address(stor1[_1193])
                mem[mem[64] + 4] = arg1
                require ext_code.size(address(stor1[_1193]))
                staticcall address(stor1[_1193])._getRewardAmountOf(address arg1) with:
                        gas gas_remaining wei
                       args address(arg1)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1298 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if s > !mem[_1298]:
                    revert with 0, 17
                if s + mem[_1298] < s:
                    revert with 0, 'SafeMath: addition overflow'
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + mem[_1298]
                continue 
            if 31 >= stor[_1193].field_1 % 128:
                mem[_1216 + 32] = 256 * Mask(248, 0, stor[_1193].field_8)
                mem[_1194] = _1216
                mem[_1194 + 32] = address(stor1[_1193])
                mem[mem[64] + 4] = arg1
                require ext_code.size(address(stor1[_1193]))
                staticcall address(stor1[_1193])._getRewardAmountOf(address arg1) with:
                        gas gas_remaining wei
                       args address(arg1)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1339 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if s > !mem[_1339]:
                    revert with 0, 17
                if s + mem[_1339] < s:
                    revert with 0, 'SafeMath: addition overflow'
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + mem[_1339]
                continue 
            mem[0] = _1193
            mem[_1216 + 32] = uint256(stor[sha3(_1193)].field_0)
            t = _1216 + 32
            u = sha3(_1193)
            while _1216 + stor[_1193].field_1 % 128 > t:
                mem[t + 32] = uint256(stor1[u])
                t = t + 32
                u = u + 1
                continue 
            mem[_1194] = _1216
            mem[_1194 + 32] = address(stor1[_1193])
            mem[mem[64] + 4] = arg1
            require ext_code.size(address(stor1[_1193]))
            staticcall address(stor1[_1193])._getRewardAmountOf(address arg1) with:
                    gas gas_remaining wei
                   args address(arg1)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1456 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            if s > !mem[_1456]:
                revert with 0, 17
            if s + mem[_1456] < s:
                revert with 0, 'SafeMath: addition overflow'
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s + mem[_1456]
            continue 
        if bool(stor[_1193].field_0) == stor[_1193].field_1 % 128 < 32:
            revert with 0, 34
        _1218 = mem[64]
        mem[64] = mem[64] + ceil32(stor[_1193].field_1 % 128) + 32
        mem[_1218] = stor[_1193].field_1 % 128
        if bool(stor[_1193].field_0):
            if bool(stor[_1193].field_0) == uint255(uint256(stor[_1193].field_0)) * 0.5 < 32:
                revert with 0, 34
            if not Mask(256, -1, uint256(stor[_1193].field_0)):
                mem[_1194] = _1218
                mem[_1194 + 32] = address(stor1[_1193])
                mem[mem[64] + 4] = arg1
                require ext_code.size(address(stor1[_1193]))
                staticcall address(stor1[_1193])._getRewardAmountOf(address arg1) with:
                        gas gas_remaining wei
                       args address(arg1)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1302 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if s > !mem[_1302]:
                    revert with 0, 17
                if s + mem[_1302] < s:
                    revert with 0, 'SafeMath: addition overflow'
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + mem[_1302]
                continue 
            if 31 >= uint255(uint256(stor[_1193].field_0)) * 0.5:
                mem[_1218 + 32] = 256 * Mask(248, 0, stor[_1193].field_8)
                mem[_1194] = _1218
                mem[_1194 + 32] = address(stor1[_1193])
                mem[mem[64] + 4] = arg1
                require ext_code.size(address(stor1[_1193]))
                staticcall address(stor1[_1193])._getRewardAmountOf(address arg1) with:
                        gas gas_remaining wei
                       args address(arg1)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1344 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if s > !mem[_1344]:
                    revert with 0, 17
                if s + mem[_1344] < s:
                    revert with 0, 'SafeMath: addition overflow'
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + mem[_1344]
                continue 
            mem[0] = _1193
            mem[_1218 + 32] = uint256(stor[sha3(_1193)].field_0)
            t = _1218 + 32
            u = sha3(_1193)
            while _1218 + (uint255(uint256(stor[_1193].field_0)) * 0.5) > t:
                mem[t + 32] = uint256(stor1[u])
                t = t + 32
                u = u + 1
                continue 
            mem[_1194] = _1218
            mem[_1194 + 32] = address(stor1[_1193])
            mem[mem[64] + 4] = arg1
            require ext_code.size(address(stor1[_1193]))
            staticcall address(stor1[_1193])._getRewardAmountOf(address arg1) with:
                    gas gas_remaining wei
                   args address(arg1)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1457 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            if s > !mem[_1457]:
                revert with 0, 17
            if s + mem[_1457] < s:
                revert with 0, 'SafeMath: addition overflow'
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s + mem[_1457]
            continue 
        if bool(stor[_1193].field_0) == stor[_1193].field_1 % 128 < 32:
            revert with 0, 34
        if not stor[_1193].field_1 % 128:
            mem[_1194] = _1218
            mem[_1194 + 32] = address(stor1[_1193])
            mem[mem[64] + 4] = arg1
            require ext_code.size(address(stor1[_1193]))
            staticcall address(stor1[_1193])._getRewardAmountOf(address arg1) with:
                    gas gas_remaining wei
                   args address(arg1)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1321 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            if s > !mem[_1321]:
                revert with 0, 17
            if s + mem[_1321] < s:
                revert with 0, 'SafeMath: addition overflow'
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s + mem[_1321]
            continue 
        if 31 >= stor[_1193].field_1 % 128:
            mem[_1218 + 32] = 256 * Mask(248, 0, stor[_1193].field_8)
            mem[_1194] = _1218
            mem[_1194 + 32] = address(stor1[_1193])
            mem[mem[64] + 4] = arg1
            require ext_code.size(address(stor1[_1193]))
            staticcall address(stor1[_1193])._getRewardAmountOf(address arg1) with:
                    gas gas_remaining wei
                   args address(arg1)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1358 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            if s > !mem[_1358]:
                revert with 0, 17
            if s + mem[_1358] < s:
                revert with 0, 'SafeMath: addition overflow'
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s + mem[_1358]
            continue 
        mem[0] = _1193
        mem[_1218 + 32] = uint256(stor[sha3(_1193)].field_0)
        t = _1218 + 32
        u = sha3(_1193)
        while _1218 + stor[_1193].field_1 % 128 > t:
            mem[t + 32] = uint256(stor1[u])
            t = t + 32
            u = u + 1
            continue 
        mem[_1194] = _1218
        mem[_1194 + 32] = address(stor1[_1193])
        mem[mem[64] + 4] = arg1
        require ext_code.size(address(stor1[_1193]))
        staticcall address(stor1[_1193])._getRewardAmountOf(address arg1) with:
                gas gas_remaining wei
               args address(arg1)
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _1458 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        if s > !mem[_1458]:
            revert with 0, 17
        if s + mem[_1458] < s:
            revert with 0, 'SafeMath: addition overflow'
        if idx == -1:
            revert with 0, 17
        idx = idx + 1
        s = s + mem[_1458]
        continue 
    return s
}

function sub_568253f3(?) payable {
    mem[64] = 96
    require not msg.value
    idx = 0
    s = 0
    while idx < stor25.length:
        mem[0] = 25
        _600 = mem[64]
        if bool(stor25[idx].field_0):
            if bool(stor25[idx].field_0) == uint255(uint256(stor25[idx].field_0)) * 0.5 < 32:
                revert with 0, 34
            if not bool(stor25[idx].field_0):
                mem[mem[64]] = Mask(248, 8, uint256(stor25[idx].field_0))
                mem[mem[64] + (uint255(uint256(stor25[idx].field_0)) * 0.5)] = 24
                _610 = sha3(Mask(248, 8, uint256(stor25[idx].field_0)), mem[mem[64] + 32 len uint255(uint256(stor25[idx].field_0)) * 0.5])
                _611 = mem[64]
                mem[64] = mem[64] + 64
                if bool(stor[_610].field_0):
                    if bool(stor[_610].field_0) == uint255(uint256(stor[_610].field_0)) * 0.5 < 32:
                        revert with 0, 34
                    _629 = mem[64]
                    mem[64] = mem[64] + ceil32(uint255(uint256(stor[_610].field_0)) * 0.5) + 32
                    mem[_629] = uint255(uint256(stor[_610].field_0)) * 0.5
                    if bool(stor[_610].field_0):
                        if bool(stor[_610].field_0) == uint255(uint256(stor[_610].field_0)) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, uint256(stor[_610].field_0)):
                            mem[_611] = _629
                            mem[_611 + 32] = address(stor1[_610])
                            mem[mem[64] + 4] = msg.sender
                            require ext_code.size(address(stor1[_610]))
                            call address(stor1[_610])._cashoutAllNodesReward(address arg1) with:
                                 gas gas_remaining wei
                                args msg.sender
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _665 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if s > !mem[_665]:
                                revert with 0, 17
                            if s + mem[_665] < s:
                                revert with 0, 'SafeMath: addition overflow'
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + mem[_665]
                            continue 
                        if 31 >= uint255(uint256(stor[_610].field_0)) * 0.5:
                            mem[_629 + 32] = 256 * Mask(248, 0, stor[_610].field_8)
                            mem[_611] = _629
                            mem[_611 + 32] = address(stor1[_610])
                            mem[mem[64] + 4] = msg.sender
                            require ext_code.size(address(stor1[_610]))
                            call address(stor1[_610])._cashoutAllNodesReward(address arg1) with:
                                 gas gas_remaining wei
                                args msg.sender
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _735 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if s > !mem[_735]:
                                revert with 0, 17
                            if s + mem[_735] < s:
                                revert with 0, 'SafeMath: addition overflow'
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + mem[_735]
                            continue 
                        mem[0] = _610
                        mem[_629 + 32] = uint256(stor[sha3(_610)].field_0)
                        t = _629 + 32
                        u = sha3(_610)
                        while _629 + (uint255(uint256(stor[_610].field_0)) * 0.5) > t:
                            mem[t + 32] = uint256(stor1[u])
                            t = t + 32
                            u = u + 1
                            continue 
                        mem[_611] = _629
                        mem[_611 + 32] = address(stor1[_610])
                        mem[mem[64] + 4] = msg.sender
                        require ext_code.size(address(stor1[_610]))
                        call address(stor1[_610])._cashoutAllNodesReward(address arg1) with:
                             gas gas_remaining wei
                            args msg.sender
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1276 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if s > !mem[_1276]:
                            revert with 0, 17
                        if s + mem[_1276] < s:
                            revert with 0, 'SafeMath: addition overflow'
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + mem[_1276]
                        continue 
                    if bool(stor[_610].field_0) == stor[_610].field_1 % 128 < 32:
                        revert with 0, 34
                    if not stor[_610].field_1 % 128:
                        mem[_611] = _629
                        mem[_611 + 32] = address(stor1[_610])
                        mem[mem[64] + 4] = msg.sender
                        require ext_code.size(address(stor1[_610]))
                        call address(stor1[_610])._cashoutAllNodesReward(address arg1) with:
                             gas gas_remaining wei
                            args msg.sender
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _692 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if s > !mem[_692]:
                            revert with 0, 17
                        if s + mem[_692] < s:
                            revert with 0, 'SafeMath: addition overflow'
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + mem[_692]
                        continue 
                    if 31 >= stor[_610].field_1 % 128:
                        mem[_629 + 32] = 256 * Mask(248, 0, stor[_610].field_8)
                        mem[_611] = _629
                        mem[_611 + 32] = address(stor1[_610])
                        mem[mem[64] + 4] = msg.sender
                        require ext_code.size(address(stor1[_610]))
                        call address(stor1[_610])._cashoutAllNodesReward(address arg1) with:
                             gas gas_remaining wei
                            args msg.sender
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _783 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if s > !mem[_783]:
                            revert with 0, 17
                        if s + mem[_783] < s:
                            revert with 0, 'SafeMath: addition overflow'
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + mem[_783]
                        continue 
                    mem[0] = _610
                    mem[_629 + 32] = uint256(stor[sha3(_610)].field_0)
                    t = _629 + 32
                    u = sha3(_610)
                    while _629 + stor[_610].field_1 % 128 > t:
                        mem[t + 32] = uint256(stor1[u])
                        t = t + 32
                        u = u + 1
                        continue 
                    mem[_611] = _629
                    mem[_611 + 32] = address(stor1[_610])
                    mem[mem[64] + 4] = msg.sender
                    require ext_code.size(address(stor1[_610]))
                    call address(stor1[_610])._cashoutAllNodesReward(address arg1) with:
                         gas gas_remaining wei
                        args msg.sender
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1277 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if s > !mem[_1277]:
                        revert with 0, 17
                    if s + mem[_1277] < s:
                        revert with 0, 'SafeMath: addition overflow'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + mem[_1277]
                    continue 
                if bool(stor[_610].field_0) == stor[_610].field_1 % 128 < 32:
                    revert with 0, 34
                _633 = mem[64]
                mem[64] = mem[64] + ceil32(stor[_610].field_1 % 128) + 32
                mem[_633] = stor[_610].field_1 % 128
                if bool(stor[_610].field_0):
                    if bool(stor[_610].field_0) == uint255(uint256(stor[_610].field_0)) * 0.5 < 32:
                        revert with 0, 34
                    if not Mask(256, -1, uint256(stor[_610].field_0)):
                        mem[_611] = _633
                        mem[_611 + 32] = address(stor1[_610])
                        mem[mem[64] + 4] = msg.sender
                        require ext_code.size(address(stor1[_610]))
                        call address(stor1[_610])._cashoutAllNodesReward(address arg1) with:
                             gas gas_remaining wei
                            args msg.sender
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _696 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if s > !mem[_696]:
                            revert with 0, 17
                        if s + mem[_696] < s:
                            revert with 0, 'SafeMath: addition overflow'
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + mem[_696]
                        continue 
                    if 31 >= uint255(uint256(stor[_610].field_0)) * 0.5:
                        mem[_633 + 32] = 256 * Mask(248, 0, stor[_610].field_8)
                        mem[_611] = _633
                        mem[_611 + 32] = address(stor1[_610])
                        mem[mem[64] + 4] = msg.sender
                        require ext_code.size(address(stor1[_610]))
                        call address(stor1[_610])._cashoutAllNodesReward(address arg1) with:
                             gas gas_remaining wei
                            args msg.sender
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _788 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if s > !mem[_788]:
                            revert with 0, 17
                        if s + mem[_788] < s:
                            revert with 0, 'SafeMath: addition overflow'
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + mem[_788]
                        continue 
                    mem[0] = _610
                    mem[_633 + 32] = uint256(stor[sha3(_610)].field_0)
                    t = _633 + 32
                    u = sha3(_610)
                    while _633 + (uint255(uint256(stor[_610].field_0)) * 0.5) > t:
                        mem[t + 32] = uint256(stor1[u])
                        t = t + 32
                        u = u + 1
                        continue 
                    mem[_611] = _633
                    mem[_611 + 32] = address(stor1[_610])
                    mem[mem[64] + 4] = msg.sender
                    require ext_code.size(address(stor1[_610]))
                    call address(stor1[_610])._cashoutAllNodesReward(address arg1) with:
                         gas gas_remaining wei
                        args msg.sender
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1278 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if s > !mem[_1278]:
                        revert with 0, 17
                    if s + mem[_1278] < s:
                        revert with 0, 'SafeMath: addition overflow'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + mem[_1278]
                    continue 
                if bool(stor[_610].field_0) == stor[_610].field_1 % 128 < 32:
                    revert with 0, 34
                if not stor[_610].field_1 % 128:
                    mem[_611] = _633
                    mem[_611 + 32] = address(stor1[_610])
                    mem[mem[64] + 4] = msg.sender
                    require ext_code.size(address(stor1[_610]))
                    call address(stor1[_610])._cashoutAllNodesReward(address arg1) with:
                         gas gas_remaining wei
                        args msg.sender
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _736 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if s > !mem[_736]:
                        revert with 0, 17
                    if s + mem[_736] < s:
                        revert with 0, 'SafeMath: addition overflow'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + mem[_736]
                    continue 
                if 31 >= stor[_610].field_1 % 128:
                    mem[_633 + 32] = 256 * Mask(248, 0, stor[_610].field_8)
                    mem[_611] = _633
                    mem[_611 + 32] = address(stor1[_610])
                    mem[mem[64] + 4] = msg.sender
                    require ext_code.size(address(stor1[_610]))
                    call address(stor1[_610])._cashoutAllNodesReward(address arg1) with:
                         gas gas_remaining wei
                        args msg.sender
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _838 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if s > !mem[_838]:
                        revert with 0, 17
                    if s + mem[_838] < s:
                        revert with 0, 'SafeMath: addition overflow'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + mem[_838]
                    continue 
                mem[0] = _610
                mem[_633 + 32] = uint256(stor[sha3(_610)].field_0)
                t = _633 + 32
                u = sha3(_610)
                while _633 + stor[_610].field_1 % 128 > t:
                    mem[t + 32] = uint256(stor1[u])
                    t = t + 32
                    u = u + 1
                    continue 
                mem[_611] = _633
                mem[_611 + 32] = address(stor1[_610])
                mem[mem[64] + 4] = msg.sender
                require ext_code.size(address(stor1[_610]))
                call address(stor1[_610])._cashoutAllNodesReward(address arg1) with:
                     gas gas_remaining wei
                    args msg.sender
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1279 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if s > !mem[_1279]:
                    revert with 0, 17
                if s + mem[_1279] < s:
                    revert with 0, 'SafeMath: addition overflow'
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + mem[_1279]
                continue 
            if bool(stor25[idx].field_0) != 1:
                mem[0] = 24
                _614 = sha3(mem[mem[64] len -mem[64] + 32])
                _615 = mem[64]
                mem[64] = mem[64] + 64
                if bool(stor[_614].field_0):
                    if bool(stor[_614].field_0) == uint255(uint256(stor[_614].field_0)) * 0.5 < 32:
                        revert with 0, 34
                    _634 = mem[64]
                    mem[64] = mem[64] + ceil32(uint255(uint256(stor[_614].field_0)) * 0.5) + 32
                    mem[_634] = uint255(uint256(stor[_614].field_0)) * 0.5
                    if bool(stor[_614].field_0):
                        if bool(stor[_614].field_0) == uint255(uint256(stor[_614].field_0)) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, uint256(stor[_614].field_0)):
                            mem[_615] = _634
                            mem[_615 + 32] = address(stor1[_614])
                            mem[mem[64] + 4] = msg.sender
                            require ext_code.size(address(stor1[_614]))
                            call address(stor1[_614])._cashoutAllNodesReward(address arg1) with:
                                 gas gas_remaining wei
                                args msg.sender
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _704 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if s > !mem[_704]:
                                revert with 0, 17
                            if s + mem[_704] < s:
                                revert with 0, 'SafeMath: addition overflow'
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + mem[_704]
                            continue 
                        if 31 >= uint255(uint256(stor[_614].field_0)) * 0.5:
                            mem[_634 + 32] = 256 * Mask(248, 0, stor[_614].field_8)
                            mem[_615] = _634
                            mem[_615 + 32] = address(stor1[_614])
                            mem[mem[64] + 4] = msg.sender
                            require ext_code.size(address(stor1[_614]))
                            call address(stor1[_614])._cashoutAllNodesReward(address arg1) with:
                                 gas gas_remaining wei
                                args msg.sender
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _802 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if s > !mem[_802]:
                                revert with 0, 17
                            if s + mem[_802] < s:
                                revert with 0, 'SafeMath: addition overflow'
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + mem[_802]
                            continue 
                        mem[0] = _614
                        mem[_634 + 32] = uint256(stor[sha3(_614)].field_0)
                        t = _634 + 32
                        u = sha3(_614)
                        while _634 + (uint255(uint256(stor[_614].field_0)) * 0.5) > t:
                            mem[t + 32] = uint256(stor1[u])
                            t = t + 32
                            u = u + 1
                            continue 
                        mem[_615] = _634
                        mem[_615 + 32] = address(stor1[_614])
                        mem[mem[64] + 4] = msg.sender
                        require ext_code.size(address(stor1[_614]))
                        call address(stor1[_614])._cashoutAllNodesReward(address arg1) with:
                             gas gas_remaining wei
                            args msg.sender
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1283 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if s > !mem[_1283]:
                            revert with 0, 17
                        if s + mem[_1283] < s:
                            revert with 0, 'SafeMath: addition overflow'
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + mem[_1283]
                        continue 
                    if bool(stor[_614].field_0) == stor[_614].field_1 % 128 < 32:
                        revert with 0, 34
                    if not stor[_614].field_1 % 128:
                        mem[_615] = _634
                        mem[_615 + 32] = address(stor1[_614])
                        mem[mem[64] + 4] = msg.sender
                        require ext_code.size(address(stor1[_614]))
                        call address(stor1[_614])._cashoutAllNodesReward(address arg1) with:
                             gas gas_remaining wei
                            args msg.sender
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _747 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if s > !mem[_747]:
                            revert with 0, 17
                        if s + mem[_747] < s:
                            revert with 0, 'SafeMath: addition overflow'
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + mem[_747]
                        continue 
                    if 31 >= stor[_614].field_1 % 128:
                        mem[_634 + 32] = 256 * Mask(248, 0, stor[_614].field_8)
                        mem[_615] = _634
                        mem[_615 + 32] = address(stor1[_614])
                        mem[mem[64] + 4] = msg.sender
                        require ext_code.size(address(stor1[_614]))
                        call address(stor1[_614])._cashoutAllNodesReward(address arg1) with:
                             gas gas_remaining wei
                            args msg.sender
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _852 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if s > !mem[_852]:
                            revert with 0, 17
                        if s + mem[_852] < s:
                            revert with 0, 'SafeMath: addition overflow'
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + mem[_852]
                        continue 
                    mem[0] = _614
                    mem[_634 + 32] = uint256(stor[sha3(_614)].field_0)
                    t = _634 + 32
                    u = sha3(_614)
                    while _634 + stor[_614].field_1 % 128 > t:
                        mem[t + 32] = uint256(stor1[u])
                        t = t + 32
                        u = u + 1
                        continue 
                    mem[_615] = _634
                    mem[_615 + 32] = address(stor1[_614])
                    mem[mem[64] + 4] = msg.sender
                    require ext_code.size(address(stor1[_614]))
                    call address(stor1[_614])._cashoutAllNodesReward(address arg1) with:
                         gas gas_remaining wei
                        args msg.sender
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1284 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if s > !mem[_1284]:
                        revert with 0, 17
                    if s + mem[_1284] < s:
                        revert with 0, 'SafeMath: addition overflow'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + mem[_1284]
                    continue 
                if bool(stor[_614].field_0) == stor[_614].field_1 % 128 < 32:
                    revert with 0, 34
                _636 = mem[64]
                mem[64] = mem[64] + ceil32(stor[_614].field_1 % 128) + 32
                mem[_636] = stor[_614].field_1 % 128
                if bool(stor[_614].field_0):
                    if bool(stor[_614].field_0) == uint255(uint256(stor[_614].field_0)) * 0.5 < 32:
                        revert with 0, 34
                    if not Mask(256, -1, uint256(stor[_614].field_0)):
                        mem[_615] = _636
                        mem[_615 + 32] = address(stor1[_614])
                        mem[mem[64] + 4] = msg.sender
                        require ext_code.size(address(stor1[_614]))
                        call address(stor1[_614])._cashoutAllNodesReward(address arg1) with:
                             gas gas_remaining wei
                            args msg.sender
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _751 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if s > !mem[_751]:
                            revert with 0, 17
                        if s + mem[_751] < s:
                            revert with 0, 'SafeMath: addition overflow'
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + mem[_751]
                        continue 
                    if 31 >= uint255(uint256(stor[_614].field_0)) * 0.5:
                        mem[_636 + 32] = 256 * Mask(248, 0, stor[_614].field_8)
                        mem[_615] = _636
                        mem[_615 + 32] = address(stor1[_614])
                        mem[mem[64] + 4] = msg.sender
                        require ext_code.size(address(stor1[_614]))
                        call address(stor1[_614])._cashoutAllNodesReward(address arg1) with:
                             gas gas_remaining wei
                            args msg.sender
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _857 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if s > !mem[_857]:
                            revert with 0, 17
                        if s + mem[_857] < s:
                            revert with 0, 'SafeMath: addition overflow'
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + mem[_857]
                        continue 
                    mem[0] = _614
                    mem[_636 + 32] = uint256(stor[sha3(_614)].field_0)
                    t = _636 + 32
                    u = sha3(_614)
                    while _636 + (uint255(uint256(stor[_614].field_0)) * 0.5) > t:
                        mem[t + 32] = uint256(stor1[u])
                        t = t + 32
                        u = u + 1
                        continue 
                    mem[_615] = _636
                    mem[_615 + 32] = address(stor1[_614])
                    mem[mem[64] + 4] = msg.sender
                    require ext_code.size(address(stor1[_614]))
                    call address(stor1[_614])._cashoutAllNodesReward(address arg1) with:
                         gas gas_remaining wei
                        args msg.sender
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1285 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if s > !mem[_1285]:
                        revert with 0, 17
                    if s + mem[_1285] < s:
                        revert with 0, 'SafeMath: addition overflow'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + mem[_1285]
                    continue 
                if bool(stor[_614].field_0) == stor[_614].field_1 % 128 < 32:
                    revert with 0, 34
                if not stor[_614].field_1 % 128:
                    mem[_615] = _636
                    mem[_615 + 32] = address(stor1[_614])
                    mem[mem[64] + 4] = msg.sender
                    require ext_code.size(address(stor1[_614]))
                    call address(stor1[_614])._cashoutAllNodesReward(address arg1) with:
                         gas gas_remaining wei
                        args msg.sender
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _803 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if s > !mem[_803]:
                        revert with 0, 17
                    if s + mem[_803] < s:
                        revert with 0, 'SafeMath: addition overflow'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + mem[_803]
                    continue 
                if 31 >= stor[_614].field_1 % 128:
                    mem[_636 + 32] = 256 * Mask(248, 0, stor[_614].field_8)
                    mem[_615] = _636
                    mem[_615 + 32] = address(stor1[_614])
                    mem[mem[64] + 4] = msg.sender
                    require ext_code.size(address(stor1[_614]))
                    call address(stor1[_614])._cashoutAllNodesReward(address arg1) with:
                         gas gas_remaining wei
                        args msg.sender
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _907 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if s > !mem[_907]:
                        revert with 0, 17
                    if s + mem[_907] < s:
                        revert with 0, 'SafeMath: addition overflow'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + mem[_907]
                    continue 
                mem[0] = _614
                mem[_636 + 32] = uint256(stor[sha3(_614)].field_0)
                t = _636 + 32
                u = sha3(_614)
                while _636 + stor[_614].field_1 % 128 > t:
                    mem[t + 32] = uint256(stor1[u])
                    t = t + 32
                    u = u + 1
                    continue 
                mem[_615] = _636
                mem[_615 + 32] = address(stor1[_614])
                mem[mem[64] + 4] = msg.sender
                require ext_code.size(address(stor1[_614]))
                call address(stor1[_614])._cashoutAllNodesReward(address arg1) with:
                     gas gas_remaining wei
                    args msg.sender
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1286 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if s > !mem[_1286]:
                    revert with 0, 17
                if s + mem[_1286] < s:
                    revert with 0, 'SafeMath: addition overflow'
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + mem[_1286]
                continue 
            mem[0] = sha3(25) + idx
            t = 0
            u = sha3(mem[0])
            while t < uint255(uint256(stor25[idx].field_0)) * 0.5:
                mem[t + _600] = uint256(stor[u].field_0)
                t = t + 32
                u = u + 1
                continue 
            mem[_600 + (uint255(uint256(stor25[idx].field_0)) * 0.5)] = 24
            _1281 = sha3(mem[mem[64] len _600 + (uint255(uint256(stor25[idx].field_0)) * 0.5) + -mem[64] + 32])
            _1282 = mem[64]
            mem[64] = mem[64] + 64
            if bool(stor[_1281].field_0):
                if bool(stor[_1281].field_0) == uint255(uint256(stor[_1281].field_0)) * 0.5 < 32:
                    revert with 0, 34
                _1318 = mem[64]
                mem[64] = mem[64] + ceil32(uint255(uint256(stor[_1281].field_0)) * 0.5) + 32
                mem[_1318] = uint255(uint256(stor[_1281].field_0)) * 0.5
                if bool(stor[_1281].field_0):
                    if bool(stor[_1281].field_0) == uint255(uint256(stor[_1281].field_0)) * 0.5 < 32:
                        revert with 0, 34
                    if not Mask(256, -1, uint256(stor[_1281].field_0)):
                        mem[_1282] = _1318
                        mem[_1282 + 32] = address(stor1[_1281])
                        mem[mem[64] + 4] = msg.sender
                        require ext_code.size(address(stor1[_1281]))
                        call address(stor1[_1281])._cashoutAllNodesReward(address arg1) with:
                             gas gas_remaining wei
                            args msg.sender
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1380 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if s > !mem[_1380]:
                            revert with 0, 17
                        if s + mem[_1380] < s:
                            revert with 0, 'SafeMath: addition overflow'
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + mem[_1380]
                        continue 
                    if 31 >= uint255(uint256(stor[_1281].field_0)) * 0.5:
                        mem[_1318 + 32] = 256 * Mask(248, 0, stor[_1281].field_8)
                        mem[_1282] = _1318
                        mem[_1282 + 32] = address(stor1[_1281])
                        mem[mem[64] + 4] = msg.sender
                        require ext_code.size(address(stor1[_1281]))
                        call address(stor1[_1281])._cashoutAllNodesReward(address arg1) with:
                             gas gas_remaining wei
                            args msg.sender
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1422 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if s > !mem[_1422]:
                            revert with 0, 17
                        if s + mem[_1422] < s:
                            revert with 0, 'SafeMath: addition overflow'
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + mem[_1422]
                        continue 
                    mem[0] = _1281
                    mem[_1318 + 32] = uint256(stor[sha3(_1281)].field_0)
                    t = _1318 + 32
                    u = sha3(_1281)
                    while _1318 + (uint255(uint256(stor[_1281].field_0)) * 0.5) > t:
                        mem[t + 32] = uint256(stor1[u])
                        t = t + 32
                        u = u + 1
                        continue 
                    mem[_1282] = _1318
                    mem[_1282 + 32] = address(stor1[_1281])
                    mem[mem[64] + 4] = msg.sender
                    require ext_code.size(address(stor1[_1281]))
                    call address(stor1[_1281])._cashoutAllNodesReward(address arg1) with:
                         gas gas_remaining wei
                        args msg.sender
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1574 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if s > !mem[_1574]:
                        revert with 0, 17
                    if s + mem[_1574] < s:
                        revert with 0, 'SafeMath: addition overflow'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + mem[_1574]
                    continue 
                if bool(stor[_1281].field_0) == stor[_1281].field_1 % 128 < 32:
                    revert with 0, 34
                if not stor[_1281].field_1 % 128:
                    mem[_1282] = _1318
                    mem[_1282 + 32] = address(stor1[_1281])
                    mem[mem[64] + 4] = msg.sender
                    require ext_code.size(address(stor1[_1281]))
                    call address(stor1[_1281])._cashoutAllNodesReward(address arg1) with:
                         gas gas_remaining wei
                        args msg.sender
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1398 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if s > !mem[_1398]:
                        revert with 0, 17
                    if s + mem[_1398] < s:
                        revert with 0, 'SafeMath: addition overflow'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + mem[_1398]
                    continue 
                if 31 >= stor[_1281].field_1 % 128:
                    mem[_1318 + 32] = 256 * Mask(248, 0, stor[_1281].field_8)
                    mem[_1282] = _1318
                    mem[_1282 + 32] = address(stor1[_1281])
                    mem[mem[64] + 4] = msg.sender
                    require ext_code.size(address(stor1[_1281]))
                    call address(stor1[_1281])._cashoutAllNodesReward(address arg1) with:
                         gas gas_remaining wei
                        args msg.sender
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1442 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if s > !mem[_1442]:
                        revert with 0, 17
                    if s + mem[_1442] < s:
                        revert with 0, 'SafeMath: addition overflow'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + mem[_1442]
                    continue 
                mem[0] = _1281
                mem[_1318 + 32] = uint256(stor[sha3(_1281)].field_0)
                t = _1318 + 32
                u = sha3(_1281)
                while _1318 + stor[_1281].field_1 % 128 > t:
                    mem[t + 32] = uint256(stor1[u])
                    t = t + 32
                    u = u + 1
                    continue 
                mem[_1282] = _1318
                mem[_1282 + 32] = address(stor1[_1281])
                mem[mem[64] + 4] = msg.sender
                require ext_code.size(address(stor1[_1281]))
                call address(stor1[_1281])._cashoutAllNodesReward(address arg1) with:
                     gas gas_remaining wei
                    args msg.sender
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1575 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if s > !mem[_1575]:
                    revert with 0, 17
                if s + mem[_1575] < s:
                    revert with 0, 'SafeMath: addition overflow'
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + mem[_1575]
                continue 
            if bool(stor[_1281].field_0) == stor[_1281].field_1 % 128 < 32:
                revert with 0, 34
            _1320 = mem[64]
            mem[64] = mem[64] + ceil32(stor[_1281].field_1 % 128) + 32
            mem[_1320] = stor[_1281].field_1 % 128
            if bool(stor[_1281].field_0):
                if bool(stor[_1281].field_0) == uint255(uint256(stor[_1281].field_0)) * 0.5 < 32:
                    revert with 0, 34
                if not Mask(256, -1, uint256(stor[_1281].field_0)):
                    mem[_1282] = _1320
                    mem[_1282 + 32] = address(stor1[_1281])
                    mem[mem[64] + 4] = msg.sender
                    require ext_code.size(address(stor1[_1281]))
                    call address(stor1[_1281])._cashoutAllNodesReward(address arg1) with:
                         gas gas_remaining wei
                        args msg.sender
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1402 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if s > !mem[_1402]:
                        revert with 0, 17
                    if s + mem[_1402] < s:
                        revert with 0, 'SafeMath: addition overflow'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + mem[_1402]
                    continue 
                if 31 >= uint255(uint256(stor[_1281].field_0)) * 0.5:
                    mem[_1320 + 32] = 256 * Mask(248, 0, stor[_1281].field_8)
                    mem[_1282] = _1320
                    mem[_1282 + 32] = address(stor1[_1281])
                    mem[mem[64] + 4] = msg.sender
                    require ext_code.size(address(stor1[_1281]))
                    call address(stor1[_1281])._cashoutAllNodesReward(address arg1) with:
                         gas gas_remaining wei
                        args msg.sender
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1447 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if s > !mem[_1447]:
                        revert with 0, 17
                    if s + mem[_1447] < s:
                        revert with 0, 'SafeMath: addition overflow'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + mem[_1447]
                    continue 
                mem[0] = _1281
                mem[_1320 + 32] = uint256(stor[sha3(_1281)].field_0)
                t = _1320 + 32
                u = sha3(_1281)
                while _1320 + (uint255(uint256(stor[_1281].field_0)) * 0.5) > t:
                    mem[t + 32] = uint256(stor1[u])
                    t = t + 32
                    u = u + 1
                    continue 
                mem[_1282] = _1320
                mem[_1282 + 32] = address(stor1[_1281])
                mem[mem[64] + 4] = msg.sender
                require ext_code.size(address(stor1[_1281]))
                call address(stor1[_1281])._cashoutAllNodesReward(address arg1) with:
                     gas gas_remaining wei
                    args msg.sender
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1576 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if s > !mem[_1576]:
                    revert with 0, 17
                if s + mem[_1576] < s:
                    revert with 0, 'SafeMath: addition overflow'
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + mem[_1576]
                continue 
            if bool(stor[_1281].field_0) == stor[_1281].field_1 % 128 < 32:
                revert with 0, 34
            if not stor[_1281].field_1 % 128:
                mem[_1282] = _1320
                mem[_1282 + 32] = address(stor1[_1281])
                mem[mem[64] + 4] = msg.sender
                require ext_code.size(address(stor1[_1281]))
                call address(stor1[_1281])._cashoutAllNodesReward(address arg1) with:
                     gas gas_remaining wei
                    args msg.sender
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1423 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if s > !mem[_1423]:
                    revert with 0, 17
                if s + mem[_1423] < s:
                    revert with 0, 'SafeMath: addition overflow'
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + mem[_1423]
                continue 
            if 31 >= stor[_1281].field_1 % 128:
                mem[_1320 + 32] = 256 * Mask(248, 0, stor[_1281].field_8)
                mem[_1282] = _1320
                mem[_1282 + 32] = address(stor1[_1281])
                mem[mem[64] + 4] = msg.sender
                require ext_code.size(address(stor1[_1281]))
                call address(stor1[_1281])._cashoutAllNodesReward(address arg1) with:
                     gas gas_remaining wei
                    args msg.sender
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1466 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if s > !mem[_1466]:
                    revert with 0, 17
                if s + mem[_1466] < s:
                    revert with 0, 'SafeMath: addition overflow'
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + mem[_1466]
                continue 
            mem[0] = _1281
            mem[_1320 + 32] = uint256(stor[sha3(_1281)].field_0)
            t = _1320 + 32
            u = sha3(_1281)
            while _1320 + stor[_1281].field_1 % 128 > t:
                mem[t + 32] = uint256(stor1[u])
                t = t + 32
                u = u + 1
                continue 
            mem[_1282] = _1320
            mem[_1282 + 32] = address(stor1[_1281])
            mem[mem[64] + 4] = msg.sender
            require ext_code.size(address(stor1[_1281]))
            call address(stor1[_1281])._cashoutAllNodesReward(address arg1) with:
                 gas gas_remaining wei
                args msg.sender
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1577 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            if s > !mem[_1577]:
                revert with 0, 17
            if s + mem[_1577] < s:
                revert with 0, 'SafeMath: addition overflow'
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s + mem[_1577]
            continue 
        if bool(stor25[idx].field_0) == stor25[idx].field_1 % 128 < 32:
            revert with 0, 34
        if not bool(stor25[idx].field_0):
            mem[mem[64]] = Mask(248, 8, uint256(stor25[idx].field_0))
            mem[mem[64] + stor25[idx].field_1 % 128] = 24
            _617 = sha3(Mask(248, 8, uint256(stor25[idx].field_0)), mem[mem[64] + 32 len stor25[idx].field_1 % 128])
            _618 = mem[64]
            mem[64] = mem[64] + 64
            if bool(stor[_617].field_0):
                if bool(stor[_617].field_0) == uint255(uint256(stor[_617].field_0)) * 0.5 < 32:
                    revert with 0, 34
                _635 = mem[64]
                mem[64] = mem[64] + ceil32(uint255(uint256(stor[_617].field_0)) * 0.5) + 32
                mem[_635] = uint255(uint256(stor[_617].field_0)) * 0.5
                if bool(stor[_617].field_0):
                    if bool(stor[_617].field_0) == uint255(uint256(stor[_617].field_0)) * 0.5 < 32:
                        revert with 0, 34
                    if not Mask(256, -1, uint256(stor[_617].field_0)):
                        mem[_618] = _635
                        mem[_618 + 32] = address(stor1[_617])
                        mem[mem[64] + 4] = msg.sender
                        require ext_code.size(address(stor1[_617]))
                        call address(stor1[_617])._cashoutAllNodesReward(address arg1) with:
                             gas gas_remaining wei
                            args msg.sender
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _713 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if s > !mem[_713]:
                            revert with 0, 17
                        if s + mem[_713] < s:
                            revert with 0, 'SafeMath: addition overflow'
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + mem[_713]
                        continue 
                    if 31 >= uint255(uint256(stor[_617].field_0)) * 0.5:
                        mem[_635 + 32] = 256 * Mask(248, 0, stor[_617].field_8)
                        mem[_618] = _635
                        mem[_618 + 32] = address(stor1[_617])
                        mem[mem[64] + 4] = msg.sender
                        require ext_code.size(address(stor1[_617]))
                        call address(stor1[_617])._cashoutAllNodesReward(address arg1) with:
                             gas gas_remaining wei
                            args msg.sender
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _811 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if s > !mem[_811]:
                            revert with 0, 17
                        if s + mem[_811] < s:
                            revert with 0, 'SafeMath: addition overflow'
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + mem[_811]
                        continue 
                    mem[0] = _617
                    mem[_635 + 32] = uint256(stor[sha3(_617)].field_0)
                    t = _635 + 32
                    u = sha3(_617)
                    while _635 + (uint255(uint256(stor[_617].field_0)) * 0.5) > t:
                        mem[t + 32] = uint256(stor1[u])
                        t = t + 32
                        u = u + 1
                        continue 
                    mem[_618] = _635
                    mem[_618 + 32] = address(stor1[_617])
                    mem[mem[64] + 4] = msg.sender
                    require ext_code.size(address(stor1[_617]))
                    call address(stor1[_617])._cashoutAllNodesReward(address arg1) with:
                         gas gas_remaining wei
                        args msg.sender
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1287 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if s > !mem[_1287]:
                        revert with 0, 17
                    if s + mem[_1287] < s:
                        revert with 0, 'SafeMath: addition overflow'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + mem[_1287]
                    continue 
                if bool(stor[_617].field_0) == stor[_617].field_1 % 128 < 32:
                    revert with 0, 34
                if not stor[_617].field_1 % 128:
                    mem[_618] = _635
                    mem[_618 + 32] = address(stor1[_617])
                    mem[mem[64] + 4] = msg.sender
                    require ext_code.size(address(stor1[_617]))
                    call address(stor1[_617])._cashoutAllNodesReward(address arg1) with:
                         gas gas_remaining wei
                        args msg.sender
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _756 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if s > !mem[_756]:
                        revert with 0, 17
                    if s + mem[_756] < s:
                        revert with 0, 'SafeMath: addition overflow'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + mem[_756]
                    continue 
                if 31 >= stor[_617].field_1 % 128:
                    mem[_635 + 32] = 256 * Mask(248, 0, stor[_617].field_8)
                    mem[_618] = _635
                    mem[_618 + 32] = address(stor1[_617])
                    mem[mem[64] + 4] = msg.sender
                    require ext_code.size(address(stor1[_617]))
                    call address(stor1[_617])._cashoutAllNodesReward(address arg1) with:
                         gas gas_remaining wei
                        args msg.sender
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _862 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if s > !mem[_862]:
                        revert with 0, 17
                    if s + mem[_862] < s:
                        revert with 0, 'SafeMath: addition overflow'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + mem[_862]
                    continue 
                mem[0] = _617
                mem[_635 + 32] = uint256(stor[sha3(_617)].field_0)
                t = _635 + 32
                u = sha3(_617)
                while _635 + stor[_617].field_1 % 128 > t:
                    mem[t + 32] = uint256(stor1[u])
                    t = t + 32
                    u = u + 1
                    continue 
                mem[_618] = _635
                mem[_618 + 32] = address(stor1[_617])
                mem[mem[64] + 4] = msg.sender
                require ext_code.size(address(stor1[_617]))
                call address(stor1[_617])._cashoutAllNodesReward(address arg1) with:
                     gas gas_remaining wei
                    args msg.sender
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1288 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if s > !mem[_1288]:
                    revert with 0, 17
                if s + mem[_1288] < s:
                    revert with 0, 'SafeMath: addition overflow'
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + mem[_1288]
                continue 
            if bool(stor[_617].field_0) == stor[_617].field_1 % 128 < 32:
                revert with 0, 34
            _637 = mem[64]
            mem[64] = mem[64] + ceil32(stor[_617].field_1 % 128) + 32
            mem[_637] = stor[_617].field_1 % 128
            if bool(stor[_617].field_0):
                if bool(stor[_617].field_0) == uint255(uint256(stor[_617].field_0)) * 0.5 < 32:
                    revert with 0, 34
                if not Mask(256, -1, uint256(stor[_617].field_0)):
                    mem[_618] = _637
                    mem[_618 + 32] = address(stor1[_617])
                    mem[mem[64] + 4] = msg.sender
                    require ext_code.size(address(stor1[_617]))
                    call address(stor1[_617])._cashoutAllNodesReward(address arg1) with:
                         gas gas_remaining wei
                        args msg.sender
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _760 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if s > !mem[_760]:
                        revert with 0, 17
                    if s + mem[_760] < s:
                        revert with 0, 'SafeMath: addition overflow'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + mem[_760]
                    continue 
                if 31 >= uint255(uint256(stor[_617].field_0)) * 0.5:
                    mem[_637 + 32] = 256 * Mask(248, 0, stor[_617].field_8)
                    mem[_618] = _637
                    mem[_618 + 32] = address(stor1[_617])
                    mem[mem[64] + 4] = msg.sender
                    require ext_code.size(address(stor1[_617]))
                    call address(stor1[_617])._cashoutAllNodesReward(address arg1) with:
                         gas gas_remaining wei
                        args msg.sender
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _867 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if s > !mem[_867]:
                        revert with 0, 17
                    if s + mem[_867] < s:
                        revert with 0, 'SafeMath: addition overflow'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + mem[_867]
                    continue 
                mem[0] = _617
                mem[_637 + 32] = uint256(stor[sha3(_617)].field_0)
                t = _637 + 32
                u = sha3(_617)
                while _637 + (uint255(uint256(stor[_617].field_0)) * 0.5) > t:
                    mem[t + 32] = uint256(stor1[u])
                    t = t + 32
                    u = u + 1
                    continue 
                mem[_618] = _637
                mem[_618 + 32] = address(stor1[_617])
                mem[mem[64] + 4] = msg.sender
                require ext_code.size(address(stor1[_617]))
                call address(stor1[_617])._cashoutAllNodesReward(address arg1) with:
                     gas gas_remaining wei
                    args msg.sender
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1289 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if s > !mem[_1289]:
                    revert with 0, 17
                if s + mem[_1289] < s:
                    revert with 0, 'SafeMath: addition overflow'
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + mem[_1289]
                continue 
            if bool(stor[_617].field_0) == stor[_617].field_1 % 128 < 32:
                revert with 0, 34
            if not stor[_617].field_1 % 128:
                mem[_618] = _637
                mem[_618 + 32] = address(stor1[_617])
                mem[mem[64] + 4] = msg.sender
                require ext_code.size(address(stor1[_617]))
                call address(stor1[_617])._cashoutAllNodesReward(address arg1) with:
                     gas gas_remaining wei
                    args msg.sender
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _812 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if s > !mem[_812]:
                    revert with 0, 17
                if s + mem[_812] < s:
                    revert with 0, 'SafeMath: addition overflow'
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + mem[_812]
                continue 
            if 31 >= stor[_617].field_1 % 128:
                mem[_637 + 32] = 256 * Mask(248, 0, stor[_617].field_8)
                mem[_618] = _637
                mem[_618 + 32] = address(stor1[_617])
                mem[mem[64] + 4] = msg.sender
                require ext_code.size(address(stor1[_617]))
                call address(stor1[_617])._cashoutAllNodesReward(address arg1) with:
                     gas gas_remaining wei
                    args msg.sender
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _914 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if s > !mem[_914]:
                    revert with 0, 17
                if s + mem[_914] < s:
                    revert with 0, 'SafeMath: addition overflow'
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + mem[_914]
                continue 
            mem[0] = _617
            mem[_637 + 32] = uint256(stor[sha3(_617)].field_0)
            t = _637 + 32
            u = sha3(_617)
            while _637 + stor[_617].field_1 % 128 > t:
                mem[t + 32] = uint256(stor1[u])
                t = t + 32
                u = u + 1
                continue 
            mem[_618] = _637
            mem[_618 + 32] = address(stor1[_617])
            mem[mem[64] + 4] = msg.sender
            require ext_code.size(address(stor1[_617]))
            call address(stor1[_617])._cashoutAllNodesReward(address arg1) with:
                 gas gas_remaining wei
                args msg.sender
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1290 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            if s > !mem[_1290]:
                revert with 0, 17
            if s + mem[_1290] < s:
                revert with 0, 'SafeMath: addition overflow'
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s + mem[_1290]
            continue 
        if bool(stor25[idx].field_0) != 1:
            mem[0] = 24
            _621 = sha3(mem[mem[64] len -mem[64] + 32])
            _622 = mem[64]
            mem[64] = mem[64] + 64
            if bool(stor[_621].field_0):
                if bool(stor[_621].field_0) == uint255(uint256(stor[_621].field_0)) * 0.5 < 32:
                    revert with 0, 34
                _638 = mem[64]
                mem[64] = mem[64] + ceil32(uint255(uint256(stor[_621].field_0)) * 0.5) + 32
                mem[_638] = uint255(uint256(stor[_621].field_0)) * 0.5
                if bool(stor[_621].field_0):
                    if bool(stor[_621].field_0) == uint255(uint256(stor[_621].field_0)) * 0.5 < 32:
                        revert with 0, 34
                    if not Mask(256, -1, uint256(stor[_621].field_0)):
                        mem[_622] = _638
                        mem[_622 + 32] = address(stor1[_621])
                        mem[mem[64] + 4] = msg.sender
                        require ext_code.size(address(stor1[_621]))
                        call address(stor1[_621])._cashoutAllNodesReward(address arg1) with:
                             gas gas_remaining wei
                            args msg.sender
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _768 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if s > !mem[_768]:
                            revert with 0, 17
                        if s + mem[_768] < s:
                            revert with 0, 'SafeMath: addition overflow'
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + mem[_768]
                        continue 
                    if 31 >= uint255(uint256(stor[_621].field_0)) * 0.5:
                        mem[_638 + 32] = 256 * Mask(248, 0, stor[_621].field_8)
                        mem[_622] = _638
                        mem[_622 + 32] = address(stor1[_621])
                        mem[mem[64] + 4] = msg.sender
                        require ext_code.size(address(stor1[_621]))
                        call address(stor1[_621])._cashoutAllNodesReward(address arg1) with:
                             gas gas_remaining wei
                            args msg.sender
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _881 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if s > !mem[_881]:
                            revert with 0, 17
                        if s + mem[_881] < s:
                            revert with 0, 'SafeMath: addition overflow'
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + mem[_881]
                        continue 
                    mem[0] = _621
                    mem[_638 + 32] = uint256(stor[sha3(_621)].field_0)
                    t = _638 + 32
                    u = sha3(_621)
                    while _638 + (uint255(uint256(stor[_621].field_0)) * 0.5) > t:
                        mem[t + 32] = uint256(stor1[u])
                        t = t + 32
                        u = u + 1
                        continue 
                    mem[_622] = _638
                    mem[_622 + 32] = address(stor1[_621])
                    mem[mem[64] + 4] = msg.sender
                    require ext_code.size(address(stor1[_621]))
                    call address(stor1[_621])._cashoutAllNodesReward(address arg1) with:
                         gas gas_remaining wei
                        args msg.sender
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1294 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if s > !mem[_1294]:
                        revert with 0, 17
                    if s + mem[_1294] < s:
                        revert with 0, 'SafeMath: addition overflow'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + mem[_1294]
                    continue 
                if bool(stor[_621].field_0) == stor[_621].field_1 % 128 < 32:
                    revert with 0, 34
                if not stor[_621].field_1 % 128:
                    mem[_622] = _638
                    mem[_622 + 32] = address(stor1[_621])
                    mem[mem[64] + 4] = msg.sender
                    require ext_code.size(address(stor1[_621]))
                    call address(stor1[_621])._cashoutAllNodesReward(address arg1) with:
                         gas gas_remaining wei
                        args msg.sender
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _823 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if s > !mem[_823]:
                        revert with 0, 17
                    if s + mem[_823] < s:
                        revert with 0, 'SafeMath: addition overflow'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + mem[_823]
                    continue 
                if 31 >= stor[_621].field_1 % 128:
                    mem[_638 + 32] = 256 * Mask(248, 0, stor[_621].field_8)
                    mem[_622] = _638
                    mem[_622 + 32] = address(stor1[_621])
                    mem[mem[64] + 4] = msg.sender
                    require ext_code.size(address(stor1[_621]))
                    call address(stor1[_621])._cashoutAllNodesReward(address arg1) with:
                         gas gas_remaining wei
                        args msg.sender
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _928 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if s > !mem[_928]:
                        revert with 0, 17
                    if s + mem[_928] < s:
                        revert with 0, 'SafeMath: addition overflow'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + mem[_928]
                    continue 
                mem[0] = _621
                mem[_638 + 32] = uint256(stor[sha3(_621)].field_0)
                t = _638 + 32
                u = sha3(_621)
                while _638 + stor[_621].field_1 % 128 > t:
                    mem[t + 32] = uint256(stor1[u])
                    t = t + 32
                    u = u + 1
                    continue 
                mem[_622] = _638
                mem[_622 + 32] = address(stor1[_621])
                mem[mem[64] + 4] = msg.sender
                require ext_code.size(address(stor1[_621]))
                call address(stor1[_621])._cashoutAllNodesReward(address arg1) with:
                     gas gas_remaining wei
                    args msg.sender
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1295 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if s > !mem[_1295]:
                    revert with 0, 17
                if s + mem[_1295] < s:
                    revert with 0, 'SafeMath: addition overflow'
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + mem[_1295]
                continue 
            if bool(stor[_621].field_0) == stor[_621].field_1 % 128 < 32:
                revert with 0, 34
            _642 = mem[64]
            mem[64] = mem[64] + ceil32(stor[_621].field_1 % 128) + 32
            mem[_642] = stor[_621].field_1 % 128
            if bool(stor[_621].field_0):
                if bool(stor[_621].field_0) == uint255(uint256(stor[_621].field_0)) * 0.5 < 32:
                    revert with 0, 34
                if not Mask(256, -1, uint256(stor[_621].field_0)):
                    mem[_622] = _642
                    mem[_622 + 32] = address(stor1[_621])
                    mem[mem[64] + 4] = msg.sender
                    require ext_code.size(address(stor1[_621]))
                    call address(stor1[_621])._cashoutAllNodesReward(address arg1) with:
                         gas gas_remaining wei
                        args msg.sender
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _827 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if s > !mem[_827]:
                        revert with 0, 17
                    if s + mem[_827] < s:
                        revert with 0, 'SafeMath: addition overflow'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + mem[_827]
                    continue 
                if 31 >= uint255(uint256(stor[_621].field_0)) * 0.5:
                    mem[_642 + 32] = 256 * Mask(248, 0, stor[_621].field_8)
                    mem[_622] = _642
                    mem[_622 + 32] = address(stor1[_621])
                    mem[mem[64] + 4] = msg.sender
                    require ext_code.size(address(stor1[_621]))
                    call address(stor1[_621])._cashoutAllNodesReward(address arg1) with:
                         gas gas_remaining wei
                        args msg.sender
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _933 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if s > !mem[_933]:
                        revert with 0, 17
                    if s + mem[_933] < s:
                        revert with 0, 'SafeMath: addition overflow'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + mem[_933]
                    continue 
                mem[0] = _621
                mem[_642 + 32] = uint256(stor[sha3(_621)].field_0)
                t = _642 + 32
                u = sha3(_621)
                while _642 + (uint255(uint256(stor[_621].field_0)) * 0.5) > t:
                    mem[t + 32] = uint256(stor1[u])
                    t = t + 32
                    u = u + 1
                    continue 
                mem[_622] = _642
                mem[_622 + 32] = address(stor1[_621])
                mem[mem[64] + 4] = msg.sender
                require ext_code.size(address(stor1[_621]))
                call address(stor1[_621])._cashoutAllNodesReward(address arg1) with:
                     gas gas_remaining wei
                    args msg.sender
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1296 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if s > !mem[_1296]:
                    revert with 0, 17
                if s + mem[_1296] < s:
                    revert with 0, 'SafeMath: addition overflow'
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + mem[_1296]
                continue 
            if bool(stor[_621].field_0) == stor[_621].field_1 % 128 < 32:
                revert with 0, 34
            if not stor[_621].field_1 % 128:
                mem[_622] = _642
                mem[_622 + 32] = address(stor1[_621])
                mem[mem[64] + 4] = msg.sender
                require ext_code.size(address(stor1[_621]))
                call address(stor1[_621])._cashoutAllNodesReward(address arg1) with:
                     gas gas_remaining wei
                    args msg.sender
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _882 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if s > !mem[_882]:
                    revert with 0, 17
                if s + mem[_882] < s:
                    revert with 0, 'SafeMath: addition overflow'
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + mem[_882]
                continue 
            if 31 >= stor[_621].field_1 % 128:
                mem[_642 + 32] = 256 * Mask(248, 0, stor[_621].field_8)
                mem[_622] = _642
                mem[_622 + 32] = address(stor1[_621])
                mem[mem[64] + 4] = msg.sender
                require ext_code.size(address(stor1[_621]))
                call address(stor1[_621])._cashoutAllNodesReward(address arg1) with:
                     gas gas_remaining wei
                    args msg.sender
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _972 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if s > !mem[_972]:
                    revert with 0, 17
                if s + mem[_972] < s:
                    revert with 0, 'SafeMath: addition overflow'
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + mem[_972]
                continue 
            mem[0] = _621
            mem[_642 + 32] = uint256(stor[sha3(_621)].field_0)
            t = _642 + 32
            u = sha3(_621)
            while _642 + stor[_621].field_1 % 128 > t:
                mem[t + 32] = uint256(stor1[u])
                t = t + 32
                u = u + 1
                continue 
            mem[_622] = _642
            mem[_622 + 32] = address(stor1[_621])
            mem[mem[64] + 4] = msg.sender
            require ext_code.size(address(stor1[_621]))
            call address(stor1[_621])._cashoutAllNodesReward(address arg1) with:
                 gas gas_remaining wei
                args msg.sender
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1297 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            if s > !mem[_1297]:
                revert with 0, 17
            if s + mem[_1297] < s:
                revert with 0, 'SafeMath: addition overflow'
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s + mem[_1297]
            continue 
        mem[0] = sha3(25) + idx
        t = 0
        u = sha3(mem[0])
        while t < stor25[idx].field_1 % 128:
            mem[t + _600] = uint256(stor[u].field_0)
            t = t + 32
            u = u + 1
            continue 
        mem[_600 + stor25[idx].field_1 % 128] = 24
        _1292 = sha3(mem[mem[64] len _600 + stor25[idx].field_1 % 128 + -mem[64] + 32])
        _1293 = mem[64]
        mem[64] = mem[64] + 64
        if bool(stor[_1292].field_0):
            if bool(stor[_1292].field_0) == uint255(uint256(stor[_1292].field_0)) * 0.5 < 32:
                revert with 0, 34
            _1319 = mem[64]
            mem[64] = mem[64] + ceil32(uint255(uint256(stor[_1292].field_0)) * 0.5) + 32
            mem[_1319] = uint255(uint256(stor[_1292].field_0)) * 0.5
            if bool(stor[_1292].field_0):
                if bool(stor[_1292].field_0) == uint255(uint256(stor[_1292].field_0)) * 0.5 < 32:
                    revert with 0, 34
                if not Mask(256, -1, uint256(stor[_1292].field_0)):
                    mem[_1293] = _1319
                    mem[_1293 + 32] = address(stor1[_1292])
                    mem[mem[64] + 4] = msg.sender
                    require ext_code.size(address(stor1[_1292]))
                    call address(stor1[_1292])._cashoutAllNodesReward(address arg1) with:
                         gas gas_remaining wei
                        args msg.sender
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1389 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if s > !mem[_1389]:
                        revert with 0, 17
                    if s + mem[_1389] < s:
                        revert with 0, 'SafeMath: addition overflow'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + mem[_1389]
                    continue 
                if 31 >= uint255(uint256(stor[_1292].field_0)) * 0.5:
                    mem[_1319 + 32] = 256 * Mask(248, 0, stor[_1292].field_8)
                    mem[_1293] = _1319
                    mem[_1293 + 32] = address(stor1[_1292])
                    mem[mem[64] + 4] = msg.sender
                    require ext_code.size(address(stor1[_1292]))
                    call address(stor1[_1292])._cashoutAllNodesReward(address arg1) with:
                         gas gas_remaining wei
                        args msg.sender
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1431 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if s > !mem[_1431]:
                        revert with 0, 17
                    if s + mem[_1431] < s:
                        revert with 0, 'SafeMath: addition overflow'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + mem[_1431]
                    continue 
                mem[0] = _1292
                mem[_1319 + 32] = uint256(stor[sha3(_1292)].field_0)
                t = _1319 + 32
                u = sha3(_1292)
                while _1319 + (uint255(uint256(stor[_1292].field_0)) * 0.5) > t:
                    mem[t + 32] = uint256(stor1[u])
                    t = t + 32
                    u = u + 1
                    continue 
                mem[_1293] = _1319
                mem[_1293 + 32] = address(stor1[_1292])
                mem[mem[64] + 4] = msg.sender
                require ext_code.size(address(stor1[_1292]))
                call address(stor1[_1292])._cashoutAllNodesReward(address arg1) with:
                     gas gas_remaining wei
                    args msg.sender
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1578 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if s > !mem[_1578]:
                    revert with 0, 17
                if s + mem[_1578] < s:
                    revert with 0, 'SafeMath: addition overflow'
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + mem[_1578]
                continue 
            if bool(stor[_1292].field_0) == stor[_1292].field_1 % 128 < 32:
                revert with 0, 34
            if not stor[_1292].field_1 % 128:
                mem[_1293] = _1319
                mem[_1293 + 32] = address(stor1[_1292])
                mem[mem[64] + 4] = msg.sender
                require ext_code.size(address(stor1[_1292]))
                call address(stor1[_1292])._cashoutAllNodesReward(address arg1) with:
                     gas gas_remaining wei
                    args msg.sender
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1407 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if s > !mem[_1407]:
                    revert with 0, 17
                if s + mem[_1407] < s:
                    revert with 0, 'SafeMath: addition overflow'
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + mem[_1407]
                continue 
            if 31 >= stor[_1292].field_1 % 128:
                mem[_1319 + 32] = 256 * Mask(248, 0, stor[_1292].field_8)
                mem[_1293] = _1319
                mem[_1293 + 32] = address(stor1[_1292])
                mem[mem[64] + 4] = msg.sender
                require ext_code.size(address(stor1[_1292]))
                call address(stor1[_1292])._cashoutAllNodesReward(address arg1) with:
                     gas gas_remaining wei
                    args msg.sender
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1452 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if s > !mem[_1452]:
                    revert with 0, 17
                if s + mem[_1452] < s:
                    revert with 0, 'SafeMath: addition overflow'
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + mem[_1452]
                continue 
            mem[0] = _1292
            mem[_1319 + 32] = uint256(stor[sha3(_1292)].field_0)
            t = _1319 + 32
            u = sha3(_1292)
            while _1319 + stor[_1292].field_1 % 128 > t:
                mem[t + 32] = uint256(stor1[u])
                t = t + 32
                u = u + 1
                continue 
            mem[_1293] = _1319
            mem[_1293 + 32] = address(stor1[_1292])
            mem[mem[64] + 4] = msg.sender
            require ext_code.size(address(stor1[_1292]))
            call address(stor1[_1292])._cashoutAllNodesReward(address arg1) with:
                 gas gas_remaining wei
                args msg.sender
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1579 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            if s > !mem[_1579]:
                revert with 0, 17
            if s + mem[_1579] < s:
                revert with 0, 'SafeMath: addition overflow'
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s + mem[_1579]
            continue 
        if bool(stor[_1292].field_0) == stor[_1292].field_1 % 128 < 32:
            revert with 0, 34
        _1321 = mem[64]
        mem[64] = mem[64] + ceil32(stor[_1292].field_1 % 128) + 32
        mem[_1321] = stor[_1292].field_1 % 128
        if bool(stor[_1292].field_0):
            if bool(stor[_1292].field_0) == uint255(uint256(stor[_1292].field_0)) * 0.5 < 32:
                revert with 0, 34
            if not Mask(256, -1, uint256(stor[_1292].field_0)):
                mem[_1293] = _1321
                mem[_1293 + 32] = address(stor1[_1292])
                mem[mem[64] + 4] = msg.sender
                require ext_code.size(address(stor1[_1292]))
                call address(stor1[_1292])._cashoutAllNodesReward(address arg1) with:
                     gas gas_remaining wei
                    args msg.sender
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1411 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if s > !mem[_1411]:
                    revert with 0, 17
                if s + mem[_1411] < s:
                    revert with 0, 'SafeMath: addition overflow'
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + mem[_1411]
                continue 
            if 31 >= uint255(uint256(stor[_1292].field_0)) * 0.5:
                mem[_1321 + 32] = 256 * Mask(248, 0, stor[_1292].field_8)
                mem[_1293] = _1321
                mem[_1293 + 32] = address(stor1[_1292])
                mem[mem[64] + 4] = msg.sender
                require ext_code.size(address(stor1[_1292]))
                call address(stor1[_1292])._cashoutAllNodesReward(address arg1) with:
                     gas gas_remaining wei
                    args msg.sender
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1457 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if s > !mem[_1457]:
                    revert with 0, 17
                if s + mem[_1457] < s:
                    revert with 0, 'SafeMath: addition overflow'
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + mem[_1457]
                continue 
            mem[0] = _1292
            mem[_1321 + 32] = uint256(stor[sha3(_1292)].field_0)
            t = _1321 + 32
            u = sha3(_1292)
            while _1321 + (uint255(uint256(stor[_1292].field_0)) * 0.5) > t:
                mem[t + 32] = uint256(stor1[u])
                t = t + 32
                u = u + 1
                continue 
            mem[_1293] = _1321
            mem[_1293 + 32] = address(stor1[_1292])
            mem[mem[64] + 4] = msg.sender
            require ext_code.size(address(stor1[_1292]))
            call address(stor1[_1292])._cashoutAllNodesReward(address arg1) with:
                 gas gas_remaining wei
                args msg.sender
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1580 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            if s > !mem[_1580]:
                revert with 0, 17
            if s + mem[_1580] < s:
                revert with 0, 'SafeMath: addition overflow'
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s + mem[_1580]
            continue 
        if bool(stor[_1292].field_0) == stor[_1292].field_1 % 128 < 32:
            revert with 0, 34
        if not stor[_1292].field_1 % 128:
            mem[_1293] = _1321
            mem[_1293 + 32] = address(stor1[_1292])
            mem[mem[64] + 4] = msg.sender
            require ext_code.size(address(stor1[_1292]))
            call address(stor1[_1292])._cashoutAllNodesReward(address arg1) with:
                 gas gas_remaining wei
                args msg.sender
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1432 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            if s > !mem[_1432]:
                revert with 0, 17
            if s + mem[_1432] < s:
                revert with 0, 'SafeMath: addition overflow'
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s + mem[_1432]
            continue 
        if 31 >= stor[_1292].field_1 % 128:
            mem[_1321 + 32] = 256 * Mask(248, 0, stor[_1292].field_8)
            mem[_1293] = _1321
            mem[_1293 + 32] = address(stor1[_1292])
            mem[mem[64] + 4] = msg.sender
            require ext_code.size(address(stor1[_1292]))
            call address(stor1[_1292])._cashoutAllNodesReward(address arg1) with:
                 gas gas_remaining wei
                args msg.sender
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1473 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            if s > !mem[_1473]:
                revert with 0, 17
            if s + mem[_1473] < s:
                revert with 0, 'SafeMath: addition overflow'
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s + mem[_1473]
            continue 
        mem[0] = _1292
        mem[_1321 + 32] = uint256(stor[sha3(_1292)].field_0)
        t = _1321 + 32
        u = sha3(_1292)
        while _1321 + stor[_1292].field_1 % 128 > t:
            mem[t + 32] = uint256(stor1[u])
            t = t + 32
            u = u + 1
            continue 
        mem[_1293] = _1321
        mem[_1293 + 32] = address(stor1[_1292])
        mem[mem[64] + 4] = msg.sender
        require ext_code.size(address(stor1[_1292]))
        call address(stor1[_1292])._cashoutAllNodesReward(address arg1) with:
             gas gas_remaining wei
            args msg.sender
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _1581 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        if s > !mem[_1581]:
            revert with 0, 17
        if s + mem[_1581] < s:
            revert with 0, 'SafeMath: addition overflow'
        if idx == -1:
            revert with 0, 17
        idx = idx + 1
        s = s + mem[_1581]
        continue 
    if not uint8(stor20):
        mem[mem[64] + 4] = distributionPoolAddress
        mem[mem[64] + 36] = msg.sender
        mem[mem[64] + 68] = s
        require ext_code.size(stor9)
        call stor9.0x23b872dd with:
             gas gas_remaining wei
            args distributionPoolAddress, msg.sender, s
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _602 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        require mem[_602] == bool(mem[_602])
    else:
        if not cashoutFee:
            if s < 0:
                revert with 0, 17
            mem[mem[64] + 4] = distributionPoolAddress
            mem[mem[64] + 36] = msg.sender
            mem[mem[64] + 68] = s
            require ext_code.size(stor9)
            call stor9.0x23b872dd with:
                 gas gas_remaining wei
                args distributionPoolAddress, msg.sender, s
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _612 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_612] == bool(mem[_612])
        else:
            if s:
                if s and cashoutFee > -1 / s:
                    revert with 0, 17
                if not s:
                    revert with 0, 18
                if s * cashoutFee / s != cashoutFee:
                    revert with 0, 'SafeMath: multiplication overflow'
                _628 = mem[64]
                mem[64] = mem[64] + 64
                mem[_628] = 26
                mem[_628 + 32] = 'SafeMath: division by zero'
                _729 = mem[64]
                mem[mem[64]] = 2
                mem[64] = mem[64] + 96
                mem[_729 + 32 len 64] = call.data[calldata.size len 64]
                if not mem[_729]:
                    revert with 0, 50
                mem[_729 + 32] = stor9
                require ext_code.size(uniswapV2RouterAddress)
                staticcall uniswapV2RouterAddress.0x73b295c2 with:
                        gas gas_remaining wei
                mem[_729 + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[64] = _729 + ceil32(return_data.size) + 96
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                if 1 >= mem[_729]:
                    revert with 0, 50
                mem[_729 + 64] = ext_call.return_data[12 len 20]
                mem[_729 + ceil32(return_data.size) + 100] = uniswapV2RouterAddress
                mem[_729 + ceil32(return_data.size) + 132] = s * cashoutFee / 100
                require ext_code.size(stor9)
                call stor9.approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args uniswapV2RouterAddress, s * cashoutFee / 100
                mem[_729 + ceil32(return_data.size) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[64] = _729 + (2 * ceil32(return_data.size)) + 96
                require return_data.size >= 32
                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                mem[_729 + (2 * ceil32(return_data.size)) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                mem[_729 + (2 * ceil32(return_data.size)) + 100] = s * cashoutFee / 100
                mem[_729 + (2 * ceil32(return_data.size)) + 132] = 0
                mem[_729 + (2 * ceil32(return_data.size)) + 164] = 160
                mem[_729 + (2 * ceil32(return_data.size)) + 260] = mem[_729]
                idx = 0
                t = _729 + (2 * ceil32(return_data.size)) + 292
                u = _729 + 32
                while idx < mem[_729]:
                    mem[t] = mem[u + 12 len 20]
                    idx = idx + 1
                    t = t + 32
                    u = u + 32
                    continue 
                require ext_code.size(uniswapV2RouterAddress)
                call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                     gas gas_remaining wei
                    args s * cashoutFee / 100, 0, 160, address(this.address), block.timestamp, mem[_729 + (2 * ceil32(return_data.size)) + 260 len (32 * mem[_729]) + 32]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if eth.balance(this.address) > eth.balance(this.address):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if eth.balance(this.address) < eth.balance(this.address):
                    revert with 0, 17
                call futurUsePoolAddress with:
                     gas 2300 wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if s < s * cashoutFee / 100:
                    revert with 0, 17
                require ext_code.size(stor9)
                call stor9.0x23b872dd with:
                     gas gas_remaining wei
                    args distributionPoolAddress, msg.sender, s - (s * cashoutFee / 100)
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == bool(ext_call.return_data[0])
            else:
                _605 = mem[64]
                mem[64] = mem[64] + 64
                mem[_605] = 26
                mem[_605 + 32] = 'SafeMath: division by zero'
                _639 = mem[64]
                mem[mem[64]] = 2
                mem[64] = mem[64] + 96
                mem[_639 + 32 len 64] = call.data[calldata.size len 64]
                if not mem[_639]:
                    revert with 0, 50
                mem[_639 + 32] = stor9
                require ext_code.size(uniswapV2RouterAddress)
                staticcall uniswapV2RouterAddress.0x73b295c2 with:
                        gas gas_remaining wei
                mem[_639 + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[64] = _639 + ceil32(return_data.size) + 96
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                if 1 >= mem[_639]:
                    revert with 0, 50
                mem[_639 + 64] = ext_call.return_data[12 len 20]
                mem[_639 + ceil32(return_data.size) + 100] = uniswapV2RouterAddress
                mem[_639 + ceil32(return_data.size) + 132] = 0
                require ext_code.size(stor9)
                call stor9.approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args uniswapV2RouterAddress, 0
                mem[_639 + ceil32(return_data.size) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[64] = _639 + (2 * ceil32(return_data.size)) + 96
                require return_data.size >= 32
                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                mem[_639 + (2 * ceil32(return_data.size)) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                mem[_639 + (2 * ceil32(return_data.size)) + 100] = 0
                mem[_639 + (2 * ceil32(return_data.size)) + 132] = 0
                mem[_639 + (2 * ceil32(return_data.size)) + 164] = 160
                mem[_639 + (2 * ceil32(return_data.size)) + 260] = mem[_639]
                t = 0
                u = _639 + (2 * ceil32(return_data.size)) + 292
                v = _639 + 32
                while t < mem[_639]:
                    mem[u] = mem[v + 12 len 20]
                    t = t + 1
                    u = u + 32
                    v = v + 32
                    continue 
                mem[_639 + (2 * ceil32(return_data.size)) + 196] = this.address
                mem[_639 + (2 * ceil32(return_data.size)) + 228] = block.timestamp
                require ext_code.size(uniswapV2RouterAddress)
                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len _639 + (2 * ceil32(return_data.size)) + (32 * mem[_639]) + -mem[64] + 288]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1299 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1299] = 30
                mem[_1299 + 32] = 'SafeMath: subtraction overflow'
                if eth.balance(this.address) > eth.balance(this.address):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if eth.balance(this.address) < eth.balance(this.address):
                    revert with 0, 17
                call futurUsePoolAddress with:
                     gas 2300 wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if s < 0:
                    revert with 0, 17
                mem[mem[64] + 4] = distributionPoolAddress
                mem[mem[64] + 36] = msg.sender
                mem[mem[64] + 68] = s
                require ext_code.size(stor9)
                call stor9.0x23b872dd with:
                     gas gas_remaining wei
                    args distributionPoolAddress, msg.sender, s
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1495 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_1495] == bool(mem[_1495])
}

function sub_4639670c(?) {
    require calldata.size - 4 >= 32
    require arg1 <= test266151307()
    require arg1 + 35 < calldata.size
    if arg1.length > test266151307():
        revert with 0, 65
    if ceil32(ceil32(arg1.length)) + 97 < 96 or ceil32(ceil32(arg1.length)) + 97 > test266151307():
        revert with 0, 65
    mem[96] = arg1.length
    require arg1 + arg1.length + 36 <= calldata.size
    mem[128 len arg1.length] = arg1[all]
    mem[arg1.length + 128] = 0
    if not msg.sender:
        revert with 0, 'SENDER CAN'T BE ZERO'
    mem[ceil32(ceil32(arg1.length)) + 97 len ceil32(arg1.length)] = arg1[all], mem[arg1.length + 128 len ceil32(arg1.length) - arg1.length]
    mem[arg1.length + ceil32(ceil32(arg1.length)) + 97] = 24
    if ceil32(arg1.length) <= arg1.length:
        _603 = sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])
        if bool(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0):
            if bool(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0) == uint255(uint256(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0)) * 0.5 < 32:
                revert with 0, 34
            mem[64] = ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0)) * 0.5) + 193
            mem[ceil32(ceil32(arg1.length)) + 161] = uint255(uint256(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0)) * 0.5
            if bool(stor[_603].field_0):
                if bool(stor[_603].field_0) == uint255(uint256(stor[_603].field_0)) * 0.5 < 32:
                    revert with 0, 34
                if not Mask(256, -1, uint256(stor[_603].field_0)):
                    mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
                    mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_603])
                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + 197] = msg.sender
                    require ext_code.size(address(stor1[_603]))
                    staticcall address(stor1[_603])._isNodeOwner(address arg1) with:
                            gas gas_remaining wei
                           args msg.sender
                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + 193] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                    if not ext_call.return_data[0]:
                        revert with 0, 'NO NODE OWNER'
                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193] = 0x334de3a200000000000000000000000000000000000000000000000000000000
                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 197] = msg.sender
                    require ext_code.size(address(stor1[_603]))
                    staticcall address(stor1[_603])._getNodesNames(address arg1) with:
                            gas gas_remaining wei
                           args msg.sender
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 193
                    require return_data.size >= 32
                    _792 = mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32
                    require mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 <= test266151307()
                    require ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + return_data.size + 193 > ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 224
                    _835 = mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193]
                    if mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193] > test266151307():
                        revert with 0, 65
                    if ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 1 < 0 or ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 194 > test266151307():
                        revert with 0, 65
                    mem[64] = ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 194
                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 193] = _835
                    require _792 + _835 + 32 <= return_data.size
                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 225 len ceil32(_835)] = mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + _792 + 225 len ceil32(_835)]
                    if ceil32(_835) <= _835:
                        _1244 = mem[64]
                        mem[mem[64]] = 32
                        mem[mem[64] + 32] = _835
                        mem[mem[64] + 64 len ceil32(_835)] = mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 225 len ceil32(_835)]
                        if ceil32(_835) <= _835:
                            return Array(len=_835, data=mem[mem[64] + 64 len ceil32(_835)])
                        mem[mem[64] + _835 + 64] = 0
                        return memory
                          from mem[64]
                           len ceil32(_835) + _1244 + -mem[64] + 64
                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + _835 + 225] = 0
                    _1260 = mem[64]
                    mem[mem[64]] = 32
                    mem[mem[64] + 32] = _835
                    mem[mem[64] + 64 len ceil32(_835)] = mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 225 len ceil32(_835)]
                    if ceil32(_835) <= _835:
                        return Array(len=_835, data=mem[mem[64] + 64 len ceil32(_835)])
                    mem[mem[64] + _835 + 64] = 0
                    return memory
                      from mem[64]
                       len ceil32(_835) + _1260 + -mem[64] + 64
                if 31 >= uint255(uint256(stor[_603].field_0)) * 0.5:
                    mem[ceil32(ceil32(arg1.length)) + 193] = 256 * Mask(248, 0, stor[_603].field_8)
                    mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
                    mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_603])
                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + 197] = msg.sender
                    require ext_code.size(address(stor1[_603]))
                    staticcall address(stor1[_603])._isNodeOwner(address arg1) with:
                            gas gas_remaining wei
                           args msg.sender
                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + 193] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                    if not ext_call.return_data[0]:
                        revert with 0, 'NO NODE OWNER'
                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193] = 0x334de3a200000000000000000000000000000000000000000000000000000000
                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 197] = msg.sender
                    require ext_code.size(address(stor1[_603]))
                    staticcall address(stor1[_603])._getNodesNames(address arg1) with:
                            gas gas_remaining wei
                           args msg.sender
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 193
                    require return_data.size >= 32
                    _837 = mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32
                    require mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 <= test266151307()
                    require ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + return_data.size + 193 > ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 224
                    _872 = mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193]
                    if mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193] > test266151307():
                        revert with 0, 65
                    if ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 1 < 0 or ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 194 > test266151307():
                        revert with 0, 65
                    mem[64] = ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 194
                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 193] = _872
                    require _837 + _872 + 32 <= return_data.size
                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 225 len ceil32(_872)] = mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + _837 + 225 len ceil32(_872)]
                    if ceil32(_872) > _872:
                        mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + _872 + 225] = 0
                    mem[mem[64]] = 32
                    mem[mem[64] + 32] = _872
                    mem[mem[64] + 64 len ceil32(_872)] = mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 225 len ceil32(_872)]
                    if ceil32(_872) > _872:
                        mem[mem[64] + _872 + 64] = 0
                    return Array(len=_872, data=mem[mem[64] + 64 len ceil32(_872)])
                mem[0] = _603
                mem[ceil32(ceil32(arg1.length)) + 193] = uint256(stor[sha3(_603)].field_0)
                idx = ceil32(ceil32(arg1.length)) + 193
                s = 0
                while ceil32(ceil32(arg1.length)) + (uint255(uint256(stor[_603].field_0)) * 0.5) + 161 > idx:
                    mem[idx + 32] = uint256(stor[s + sha3(_603) + 1].field_0)
                    idx = idx + 32
                    s = s + 1
                    continue 
                mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
                mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_603])
                mem[mem[64] + 4] = msg.sender
                require ext_code.size(address(stor1[_603]))
                staticcall address(stor1[_603])._isNodeOwner(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1236 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_1236] == bool(mem[_1236])
                if not mem[_1236]:
                    revert with 0, 'NO NODE OWNER'
                mem[mem[64]] = 0x334de3a200000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = msg.sender
                require ext_code.size(address(stor1[_603]))
                staticcall address(stor1[_603])._getNodesNames(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1381 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _1437 = mem[_1381]
                require mem[_1381] <= test266151307()
                require _1381 + return_data.size > _1381 + mem[_1381] + 31
                _1460 = mem[_1381 + mem[_1381]]
                if mem[_1381 + mem[_1381]] > test266151307():
                    revert with 0, 65
                if ceil32(ceil32(mem[_1381 + mem[_1381]])) + 1 < 0 or _1381 + ceil32(return_data.size) + ceil32(ceil32(mem[_1381 + mem[_1381]])) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _1381 + ceil32(return_data.size) + ceil32(ceil32(mem[_1381 + mem[_1381]])) + 1
                mem[_1381 + ceil32(return_data.size)] = _1460
                require _1437 + _1460 + 32 <= return_data.size
                mem[_1381 + ceil32(return_data.size) + 32 len ceil32(_1460)] = mem[_1381 + _1437 + 32 len ceil32(_1460)]
                if ceil32(_1460) > _1460:
                    mem[_1381 + ceil32(return_data.size) + _1460 + 32] = 0
                mem[mem[64]] = 32
                mem[mem[64] + 32] = _1460
                mem[mem[64] + 64 len ceil32(_1460)] = mem[_1381 + ceil32(return_data.size) + 32 len ceil32(_1460)]
                if ceil32(_1460) > _1460:
                    mem[mem[64] + _1460 + 64] = 0
                return Array(len=_1460, data=mem[mem[64] + 64 len ceil32(_1460)])
            if bool(stor[_603].field_0) == stor[_603].field_1 % 128 < 32:
                revert with 0, 34
            if not stor[_603].field_1 % 128:
                mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
                mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_603])
                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + 197] = msg.sender
                require ext_code.size(address(stor1[_603]))
                staticcall address(stor1[_603])._isNodeOwner(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + 193] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                if not ext_call.return_data[0]:
                    revert with 0, 'NO NODE OWNER'
                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193] = 0x334de3a200000000000000000000000000000000000000000000000000000000
                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 197] = msg.sender
                require ext_code.size(address(stor1[_603]))
                staticcall address(stor1[_603])._getNodesNames(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 193
                require return_data.size >= 32
                _814 = mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32
                require mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 <= test266151307()
                require ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + return_data.size + 193 > ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 224
                _855 = mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193]
                if mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193] > test266151307():
                    revert with 0, 65
                if ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 1 < 0 or ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 194 > test266151307():
                    revert with 0, 65
                mem[64] = ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 194
                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 193] = _855
                require _814 + _855 + 32 <= return_data.size
                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 225 len ceil32(_855)] = mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + _814 + 225 len ceil32(_855)]
                if ceil32(_855) > _855:
                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + _855 + 225] = 0
                mem[mem[64]] = 32
                mem[mem[64] + 32] = _855
                mem[mem[64] + 64 len ceil32(_855)] = mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 225 len ceil32(_855)]
                if ceil32(_855) > _855:
                    mem[mem[64] + _855 + 64] = 0
                return Array(len=_855, data=mem[mem[64] + 64 len ceil32(_855)])
            if 31 >= stor[_603].field_1 % 128:
                mem[ceil32(ceil32(arg1.length)) + 193] = 256 * Mask(248, 0, stor[_603].field_8)
                mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
                mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_603])
                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + 197] = msg.sender
                require ext_code.size(address(stor1[_603]))
                staticcall address(stor1[_603])._isNodeOwner(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + 193] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                if not ext_call.return_data[0]:
                    revert with 0, 'NO NODE OWNER'
                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193] = 0x334de3a200000000000000000000000000000000000000000000000000000000
                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 197] = msg.sender
                require ext_code.size(address(stor1[_603]))
                staticcall address(stor1[_603])._getNodesNames(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 193
                require return_data.size >= 32
                _857 = mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32
                require mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 <= test266151307()
                require ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + return_data.size + 193 > ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 224
                _884 = mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193]
                if mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193] > test266151307():
                    revert with 0, 65
                if ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 1 < 0 or ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 194 > test266151307():
                    revert with 0, 65
                mem[64] = ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 194
                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 193] = _884
                require _857 + _884 + 32 <= return_data.size
                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 225 len ceil32(_884)] = mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + _857 + 225 len ceil32(_884)]
                if ceil32(_884) <= _884:
                    _1247 = mem[64]
                    mem[mem[64]] = 32
                    mem[mem[64] + 32] = _884
                    mem[mem[64] + 64 len ceil32(_884)] = mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 225 len ceil32(_884)]
                    if ceil32(_884) <= _884:
                        return Array(len=_884, data=mem[mem[64] + 64 len ceil32(_884)])
                    mem[mem[64] + _884 + 64] = 0
                    return memory
                      from mem[64]
                       len ceil32(_884) + _1247 + -mem[64] + 64
                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + _884 + 225] = 0
                _1265 = mem[64]
                mem[mem[64]] = 32
                mem[mem[64] + 32] = _884
                mem[mem[64] + 64 len ceil32(_884)] = mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 225 len ceil32(_884)]
                if ceil32(_884) <= _884:
                    return Array(len=_884, data=mem[mem[64] + 64 len ceil32(_884)])
                mem[mem[64] + _884 + 64] = 0
                return memory
                  from mem[64]
                   len ceil32(_884) + _1265 + -mem[64] + 64
            mem[0] = _603
            mem[ceil32(ceil32(arg1.length)) + 193] = uint256(stor[sha3(_603)].field_0)
            idx = ceil32(ceil32(arg1.length)) + 193
            s = 0
            while ceil32(ceil32(arg1.length)) + stor[_603].field_1 % 128 + 161 > idx:
                mem[idx + 32] = uint256(stor[s + sha3(_603) + 1].field_0)
                idx = idx + 32
                s = s + 1
                continue 
            mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
            mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_603])
            mem[mem[64] + 4] = msg.sender
            require ext_code.size(address(stor1[_603]))
            staticcall address(stor1[_603])._isNodeOwner(address arg1) with:
                    gas gas_remaining wei
                   args msg.sender
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1237 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_1237] == bool(mem[_1237])
            if not mem[_1237]:
                revert with 0, 'NO NODE OWNER'
            mem[mem[64]] = 0x334de3a200000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = msg.sender
            require ext_code.size(address(stor1[_603]))
            staticcall address(stor1[_603])._getNodesNames(address arg1) with:
                    gas gas_remaining wei
                   args msg.sender
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1384 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _1440 = mem[_1384]
            require mem[_1384] <= test266151307()
            require _1384 + return_data.size > _1384 + mem[_1384] + 31
            _1461 = mem[_1384 + mem[_1384]]
            if mem[_1384 + mem[_1384]] > test266151307():
                revert with 0, 65
            if ceil32(ceil32(mem[_1384 + mem[_1384]])) + 1 < 0 or _1384 + ceil32(return_data.size) + ceil32(ceil32(mem[_1384 + mem[_1384]])) + 1 > test266151307():
                revert with 0, 65
            mem[64] = _1384 + ceil32(return_data.size) + ceil32(ceil32(mem[_1384 + mem[_1384]])) + 1
            mem[_1384 + ceil32(return_data.size)] = _1461
            require _1440 + _1461 + 32 <= return_data.size
            mem[_1384 + ceil32(return_data.size) + 32 len ceil32(_1461)] = mem[_1384 + _1440 + 32 len ceil32(_1461)]
            if ceil32(_1461) > _1461:
                mem[_1384 + ceil32(return_data.size) + _1461 + 32] = 0
            mem[mem[64]] = 32
            mem[mem[64] + 32] = _1461
            mem[mem[64] + 64 len ceil32(_1461)] = mem[_1384 + ceil32(return_data.size) + 32 len ceil32(_1461)]
            if ceil32(_1461) > _1461:
                mem[mem[64] + _1461 + 64] = 0
            return Array(len=_1461, data=mem[mem[64] + 64 len ceil32(_1461)])
        if bool(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0) == stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_1 % 128 < 32:
            revert with 0, 34
        mem[64] = ceil32(ceil32(arg1.length)) + ceil32(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_1 % 128) + 193
        mem[ceil32(ceil32(arg1.length)) + 161] = stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_1 % 128
        if bool(stor[_603].field_0):
            if bool(stor[_603].field_0) == uint255(uint256(stor[_603].field_0)) * 0.5 < 32:
                revert with 0, 34
            if not Mask(256, -1, uint256(stor[_603].field_0)):
                mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
                mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_603])
                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + 197] = msg.sender
                require ext_code.size(address(stor1[_603]))
                staticcall address(stor1[_603])._isNodeOwner(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + 193] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                if not ext_call.return_data[0]:
                    revert with 0, 'NO NODE OWNER'
                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193] = 0x334de3a200000000000000000000000000000000000000000000000000000000
                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 197] = msg.sender
                require ext_code.size(address(stor1[_603]))
                staticcall address(stor1[_603])._getNodesNames(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + (2 * ceil32(return_data.size)) + 193
                require return_data.size >= 32
                _818 = mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32
                require mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 <= test266151307()
                require ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + return_data.size + 193 > ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 224
                _858 = mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193]
                if mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193] > test266151307():
                    revert with 0, 65
                if ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 1 < 0 or ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + (2 * ceil32(return_data.size)) + ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 194 > test266151307():
                    revert with 0, 65
                mem[64] = ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + (2 * ceil32(return_data.size)) + ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 194
                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + (2 * ceil32(return_data.size)) + 193] = _858
                require _818 + _858 + 32 <= return_data.size
                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + (2 * ceil32(return_data.size)) + 225 len ceil32(_858)] = mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + _818 + 225 len ceil32(_858)]
                if ceil32(_858) > _858:
                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + (2 * ceil32(return_data.size)) + _858 + 225] = 0
                mem[mem[64]] = 32
                mem[mem[64] + 32] = _858
                mem[mem[64] + 64 len ceil32(_858)] = mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + (2 * ceil32(return_data.size)) + 225 len ceil32(_858)]
                if ceil32(_858) > _858:
                    mem[mem[64] + _858 + 64] = 0
                return Array(len=_858, data=mem[mem[64] + 64 len ceil32(_858)])
            if 31 >= uint255(uint256(stor[_603].field_0)) * 0.5:
                mem[ceil32(ceil32(arg1.length)) + 193] = 256 * Mask(248, 0, stor[_603].field_8)
                mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
                mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_603])
                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + 197] = msg.sender
                require ext_code.size(address(stor1[_603]))
                staticcall address(stor1[_603])._isNodeOwner(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + 193] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                if not ext_call.return_data[0]:
                    revert with 0, 'NO NODE OWNER'
                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193] = 0x334de3a200000000000000000000000000000000000000000000000000000000
                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 197] = msg.sender
                require ext_code.size(address(stor1[_603]))
                staticcall address(stor1[_603])._getNodesNames(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + (2 * ceil32(return_data.size)) + 193
                require return_data.size >= 32
                _860 = mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32
                require mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 <= test266151307()
                require ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + return_data.size + 193 > ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 224
                _886 = mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193]
                if mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193] > test266151307():
                    revert with 0, 65
                if ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 1 < 0 or ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + (2 * ceil32(return_data.size)) + ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 194 > test266151307():
                    revert with 0, 65
                mem[64] = ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + (2 * ceil32(return_data.size)) + ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 194
                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + (2 * ceil32(return_data.size)) + 193] = _886
                require _860 + _886 + 32 <= return_data.size
                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + (2 * ceil32(return_data.size)) + 225 len ceil32(_886)] = mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + _860 + 225 len ceil32(_886)]
                if ceil32(_886) > _886:
                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + (2 * ceil32(return_data.size)) + _886 + 225] = 0
                mem[mem[64]] = 32
                mem[mem[64] + 32] = _886
                mem[mem[64] + 64 len ceil32(_886)] = mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + (2 * ceil32(return_data.size)) + 225 len ceil32(_886)]
                if ceil32(_886) > _886:
                    mem[mem[64] + _886 + 64] = 0
                return Array(len=_886, data=mem[mem[64] + 64 len ceil32(_886)])
            mem[0] = _603
            mem[ceil32(ceil32(arg1.length)) + 193] = uint256(stor[sha3(_603)].field_0)
            idx = ceil32(ceil32(arg1.length)) + 193
            s = 0
            while ceil32(ceil32(arg1.length)) + (uint255(uint256(stor[_603].field_0)) * 0.5) + 161 > idx:
                mem[idx + 32] = uint256(stor[s + sha3(_603) + 1].field_0)
                idx = idx + 32
                s = s + 1
                continue 
            mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
            mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_603])
            mem[mem[64] + 4] = msg.sender
            require ext_code.size(address(stor1[_603]))
            staticcall address(stor1[_603])._isNodeOwner(address arg1) with:
                    gas gas_remaining wei
                   args msg.sender
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1238 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_1238] == bool(mem[_1238])
            if not mem[_1238]:
                revert with 0, 'NO NODE OWNER'
            mem[mem[64]] = 0x334de3a200000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = msg.sender
            require ext_code.size(address(stor1[_603]))
            staticcall address(stor1[_603])._getNodesNames(address arg1) with:
                    gas gas_remaining wei
                   args msg.sender
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1387 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _1443 = mem[_1387]
            require mem[_1387] <= test266151307()
            require _1387 + return_data.size > _1387 + mem[_1387] + 31
            _1462 = mem[_1387 + mem[_1387]]
            if mem[_1387 + mem[_1387]] > test266151307():
                revert with 0, 65
            if ceil32(ceil32(mem[_1387 + mem[_1387]])) + 1 < 0 or _1387 + ceil32(return_data.size) + ceil32(ceil32(mem[_1387 + mem[_1387]])) + 1 > test266151307():
                revert with 0, 65
            mem[64] = _1387 + ceil32(return_data.size) + ceil32(ceil32(mem[_1387 + mem[_1387]])) + 1
            mem[_1387 + ceil32(return_data.size)] = _1462
            require _1443 + _1462 + 32 <= return_data.size
            mem[_1387 + ceil32(return_data.size) + 32 len ceil32(_1462)] = mem[_1387 + _1443 + 32 len ceil32(_1462)]
            if ceil32(_1462) > _1462:
                mem[_1387 + ceil32(return_data.size) + _1462 + 32] = 0
            mem[mem[64]] = 32
            mem[mem[64] + 32] = _1462
            mem[mem[64] + 64 len ceil32(_1462)] = mem[_1387 + ceil32(return_data.size) + 32 len ceil32(_1462)]
            if ceil32(_1462) > _1462:
                mem[mem[64] + _1462 + 64] = 0
            return Array(len=_1462, data=mem[mem[64] + 64 len ceil32(_1462)])
        if bool(stor[_603].field_0) == stor[_603].field_1 % 128 < 32:
            revert with 0, 34
        if not stor[_603].field_1 % 128:
            mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
            mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_603])
            mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + 197] = msg.sender
            require ext_code.size(address(stor1[_603]))
            staticcall address(stor1[_603])._isNodeOwner(address arg1) with:
                    gas gas_remaining wei
                   args msg.sender
            mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + 193] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == bool(ext_call.return_data[0])
            if not ext_call.return_data[0]:
                revert with 0, 'NO NODE OWNER'
            mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193] = 0x334de3a200000000000000000000000000000000000000000000000000000000
            mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 197] = msg.sender
            require ext_code.size(address(stor1[_603]))
            staticcall address(stor1[_603])._getNodesNames(address arg1) with:
                    gas gas_remaining wei
                   args msg.sender
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + (2 * ceil32(return_data.size)) + 193
            require return_data.size >= 32
            _840 = mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32
            require mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 <= test266151307()
            require ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + return_data.size + 193 > ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 224
            _873 = mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193]
            if mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193] > test266151307():
                revert with 0, 65
            if ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 1 < 0 or ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + (2 * ceil32(return_data.size)) + ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 194 > test266151307():
                revert with 0, 65
            mem[64] = ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + (2 * ceil32(return_data.size)) + ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 194
            mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + (2 * ceil32(return_data.size)) + 193] = _873
            require _840 + _873 + 32 <= return_data.size
            mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + (2 * ceil32(return_data.size)) + 225 len ceil32(_873)] = mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + _840 + 225 len ceil32(_873)]
            if ceil32(_873) > _873:
                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + (2 * ceil32(return_data.size)) + _873 + 225] = 0
            mem[mem[64]] = 32
            mem[mem[64] + 32] = _873
            mem[mem[64] + 64 len ceil32(_873)] = mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + (2 * ceil32(return_data.size)) + 225 len ceil32(_873)]
            if ceil32(_873) > _873:
                mem[mem[64] + _873 + 64] = 0
            return Array(len=_873, data=mem[mem[64] + 64 len ceil32(_873)])
        if 31 >= stor[_603].field_1 % 128:
            mem[ceil32(ceil32(arg1.length)) + 193] = 256 * Mask(248, 0, stor[_603].field_8)
            mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
            mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_603])
            mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + 197] = msg.sender
            require ext_code.size(address(stor1[_603]))
            staticcall address(stor1[_603])._isNodeOwner(address arg1) with:
                    gas gas_remaining wei
                   args msg.sender
            mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + 193] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == bool(ext_call.return_data[0])
            if not ext_call.return_data[0]:
                revert with 0, 'NO NODE OWNER'
            mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193] = 0x334de3a200000000000000000000000000000000000000000000000000000000
            mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 197] = msg.sender
            require ext_code.size(address(stor1[_603]))
            staticcall address(stor1[_603])._getNodesNames(address arg1) with:
                    gas gas_remaining wei
                   args msg.sender
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + (2 * ceil32(return_data.size)) + 193
            require return_data.size >= 32
            _875 = mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32
            require mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 <= test266151307()
            require ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + return_data.size + 193 > ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 224
            _895 = mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193]
            if mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193] > test266151307():
                revert with 0, 65
            if ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 1 < 0 or ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + (2 * ceil32(return_data.size)) + ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 194 > test266151307():
                revert with 0, 65
            mem[64] = ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + (2 * ceil32(return_data.size)) + ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 194
            mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + (2 * ceil32(return_data.size)) + 193] = _895
            require _875 + _895 + 32 <= return_data.size
            mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + (2 * ceil32(return_data.size)) + 225 len ceil32(_895)] = mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + _875 + 225 len ceil32(_895)]
            if ceil32(_895) > _895:
                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + (2 * ceil32(return_data.size)) + _895 + 225] = 0
            mem[mem[64]] = 32
            mem[mem[64] + 32] = _895
            mem[mem[64] + 64 len ceil32(_895)] = mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + (2 * ceil32(return_data.size)) + 225 len ceil32(_895)]
            if ceil32(_895) > _895:
                mem[mem[64] + _895 + 64] = 0
            return Array(len=_895, data=mem[mem[64] + 64 len ceil32(_895)])
        mem[0] = _603
        mem[ceil32(ceil32(arg1.length)) + 193] = uint256(stor[sha3(_603)].field_0)
        idx = ceil32(ceil32(arg1.length)) + 193
        s = 0
        while ceil32(ceil32(arg1.length)) + stor[_603].field_1 % 128 + 161 > idx:
            mem[idx + 32] = uint256(stor[s + sha3(_603) + 1].field_0)
            idx = idx + 32
            s = s + 1
            continue 
        mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
        mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_603])
        mem[mem[64] + 4] = msg.sender
        require ext_code.size(address(stor1[_603]))
        staticcall address(stor1[_603])._isNodeOwner(address arg1) with:
                gas gas_remaining wei
               args msg.sender
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _1239 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        require mem[_1239] == bool(mem[_1239])
        if not mem[_1239]:
            revert with 0, 'NO NODE OWNER'
        mem[mem[64]] = 0x334de3a200000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = msg.sender
        require ext_code.size(address(stor1[_603]))
        staticcall address(stor1[_603])._getNodesNames(address arg1) with:
                gas gas_remaining wei
               args msg.sender
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _1390 = mem[64]
        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _1446 = mem[_1390]
        require mem[_1390] <= test266151307()
        require _1390 + return_data.size > _1390 + mem[_1390] + 31
        _1463 = mem[_1390 + mem[_1390]]
        if mem[_1390 + mem[_1390]] > test266151307():
            revert with 0, 65
        if ceil32(ceil32(mem[_1390 + mem[_1390]])) + 1 < 0 or _1390 + ceil32(return_data.size) + ceil32(ceil32(mem[_1390 + mem[_1390]])) + 1 > test266151307():
            revert with 0, 65
        mem[64] = _1390 + ceil32(return_data.size) + ceil32(ceil32(mem[_1390 + mem[_1390]])) + 1
        mem[_1390 + ceil32(return_data.size)] = _1463
        require _1446 + _1463 + 32 <= return_data.size
        mem[_1390 + ceil32(return_data.size) + 32 len ceil32(_1463)] = mem[_1390 + _1446 + 32 len ceil32(_1463)]
        if ceil32(_1463) <= _1463:
            _1621 = mem[64]
            mem[mem[64]] = 32
            mem[mem[64] + 32] = _1463
            mem[mem[64] + 64 len ceil32(_1463)] = mem[_1390 + ceil32(return_data.size) + 32 len ceil32(_1463)]
            if ceil32(_1463) <= _1463:
                return Array(len=_1463, data=mem[mem[64] + 64 len ceil32(_1463)])
            mem[mem[64] + _1463 + 64] = 0
            return memory
              from mem[64]
               len ceil32(_1463) + _1621 + -mem[64] + 64
        mem[_1390 + ceil32(return_data.size) + _1463 + 32] = 0
        _1661 = mem[64]
        mem[mem[64]] = 32
        mem[mem[64] + 32] = _1463
        mem[mem[64] + 64 len ceil32(_1463)] = mem[_1390 + ceil32(return_data.size) + 32 len ceil32(_1463)]
        if ceil32(_1463) <= _1463:
            return Array(len=_1463, data=mem[mem[64] + 64 len ceil32(_1463)])
        mem[mem[64] + _1463 + 64] = 0
        return memory
          from mem[64]
           len ceil32(_1463) + _1661 + -mem[64] + 64
    _606 = sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])
    if bool(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0):
        if bool(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0) == uint255(uint256(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0)) * 0.5 < 32:
            revert with 0, 34
        mem[64] = ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0)) * 0.5) + 193
        mem[ceil32(ceil32(arg1.length)) + 161] = uint255(uint256(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0)) * 0.5
        if bool(stor[_606].field_0):
            if bool(stor[_606].field_0) == uint255(uint256(stor[_606].field_0)) * 0.5 < 32:
                revert with 0, 34
            if not Mask(256, -1, uint256(stor[_606].field_0)):
                mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
                mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_606])
                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + 197] = msg.sender
                require ext_code.size(address(stor1[_606]))
                staticcall address(stor1[_606])._isNodeOwner(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + 193] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                if not ext_call.return_data[0]:
                    revert with 0, 'NO NODE OWNER'
                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193] = 0x334de3a200000000000000000000000000000000000000000000000000000000
                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 197] = msg.sender
                require ext_code.size(address(stor1[_606]))
                staticcall address(stor1[_606])._getNodesNames(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 193
                require return_data.size >= 32
                _824 = mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32
                require mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 <= test266151307()
                require ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + return_data.size + 193 > ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 224
                _862 = mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193]
                if mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193] > test266151307():
                    revert with 0, 65
                if ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 1 < 0 or ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 194 > test266151307():
                    revert with 0, 65
                mem[64] = ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 194
                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 193] = _862
                require _824 + _862 + 32 <= return_data.size
                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 225 len ceil32(_862)] = mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + _824 + 225 len ceil32(_862)]
                if ceil32(_862) > _862:
                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + _862 + 225] = 0
                mem[mem[64]] = 32
                mem[mem[64] + 32] = _862
                mem[mem[64] + 64 len ceil32(_862)] = mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 225 len ceil32(_862)]
                if ceil32(_862) > _862:
                    mem[mem[64] + _862 + 64] = 0
                return Array(len=_862, data=mem[mem[64] + 64 len ceil32(_862)])
            if 31 >= uint255(uint256(stor[_606].field_0)) * 0.5:
                mem[ceil32(ceil32(arg1.length)) + 193] = 256 * Mask(248, 0, stor[_606].field_8)
                mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
                mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_606])
                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + 197] = msg.sender
                require ext_code.size(address(stor1[_606]))
                staticcall address(stor1[_606])._isNodeOwner(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + 193] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                if not ext_call.return_data[0]:
                    revert with 0, 'NO NODE OWNER'
                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193] = 0x334de3a200000000000000000000000000000000000000000000000000000000
                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 197] = msg.sender
                require ext_code.size(address(stor1[_606]))
                staticcall address(stor1[_606])._getNodesNames(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 193
                require return_data.size >= 32
                _864 = mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32
                require mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 <= test266151307()
                require ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + return_data.size + 193 > ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 224
                _888 = mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193]
                if mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193] > test266151307():
                    revert with 0, 65
                if ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 1 < 0 or ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 194 > test266151307():
                    revert with 0, 65
                mem[64] = ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 194
                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 193] = _888
                require _864 + _888 + 32 <= return_data.size
                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 225 len ceil32(_888)] = mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + _864 + 225 len ceil32(_888)]
                if ceil32(_888) > _888:
                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + _888 + 225] = 0
                mem[mem[64]] = 32
                mem[mem[64] + 32] = _888
                mem[mem[64] + 64 len ceil32(_888)] = mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 225 len ceil32(_888)]
                if ceil32(_888) > _888:
                    mem[mem[64] + _888 + 64] = 0
                return Array(len=_888, data=mem[mem[64] + 64 len ceil32(_888)])
            mem[0] = _606
            mem[ceil32(ceil32(arg1.length)) + 193] = uint256(stor[sha3(_606)].field_0)
            idx = ceil32(ceil32(arg1.length)) + 193
            s = 0
            while ceil32(ceil32(arg1.length)) + (uint255(uint256(stor[_606].field_0)) * 0.5) + 161 > idx:
                mem[idx + 32] = uint256(stor[s + sha3(_606) + 1].field_0)
                idx = idx + 32
                s = s + 1
                continue 
            mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
            mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_606])
            mem[mem[64] + 4] = msg.sender
            require ext_code.size(address(stor1[_606]))
            staticcall address(stor1[_606])._isNodeOwner(address arg1) with:
                    gas gas_remaining wei
                   args msg.sender
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1240 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_1240] == bool(mem[_1240])
            if not mem[_1240]:
                revert with 0, 'NO NODE OWNER'
            mem[mem[64]] = 0x334de3a200000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = msg.sender
            require ext_code.size(address(stor1[_606]))
            staticcall address(stor1[_606])._getNodesNames(address arg1) with:
                    gas gas_remaining wei
                   args msg.sender
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1393 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _1449 = mem[_1393]
            require mem[_1393] <= test266151307()
            require _1393 + return_data.size > _1393 + mem[_1393] + 31
            _1464 = mem[_1393 + mem[_1393]]
            if mem[_1393 + mem[_1393]] > test266151307():
                revert with 0, 65
            if ceil32(ceil32(mem[_1393 + mem[_1393]])) + 1 < 0 or _1393 + ceil32(return_data.size) + ceil32(ceil32(mem[_1393 + mem[_1393]])) + 1 > test266151307():
                revert with 0, 65
            mem[64] = _1393 + ceil32(return_data.size) + ceil32(ceil32(mem[_1393 + mem[_1393]])) + 1
            mem[_1393 + ceil32(return_data.size)] = _1464
            require _1449 + _1464 + 32 <= return_data.size
            mem[_1393 + ceil32(return_data.size) + 32 len ceil32(_1464)] = mem[_1393 + _1449 + 32 len ceil32(_1464)]
            if ceil32(_1464) > _1464:
                mem[_1393 + ceil32(return_data.size) + _1464 + 32] = 0
            mem[mem[64]] = 32
            mem[mem[64] + 32] = _1464
            mem[mem[64] + 64 len ceil32(_1464)] = mem[_1393 + ceil32(return_data.size) + 32 len ceil32(_1464)]
            if ceil32(_1464) > _1464:
                mem[mem[64] + _1464 + 64] = 0
            return Array(len=_1464, data=mem[mem[64] + 64 len ceil32(_1464)])
        if bool(stor[_606].field_0) == stor[_606].field_1 % 128 < 32:
            revert with 0, 34
        if not stor[_606].field_1 % 128:
            mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
            mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_606])
            mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + 197] = msg.sender
            require ext_code.size(address(stor1[_606]))
            staticcall address(stor1[_606])._isNodeOwner(address arg1) with:
                    gas gas_remaining wei
                   args msg.sender
            mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + 193] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == bool(ext_call.return_data[0])
            if not ext_call.return_data[0]:
                revert with 0, 'NO NODE OWNER'
            mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193] = 0x334de3a200000000000000000000000000000000000000000000000000000000
            mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 197] = msg.sender
            require ext_code.size(address(stor1[_606]))
            staticcall address(stor1[_606])._getNodesNames(address arg1) with:
                    gas gas_remaining wei
                   args msg.sender
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 193
            require return_data.size >= 32
            _845 = mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32
            require mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 <= test266151307()
            require ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + return_data.size + 193 > ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 224
            _876 = mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193]
            if mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193] > test266151307():
                revert with 0, 65
            if ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 1 < 0 or ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 194 > test266151307():
                revert with 0, 65
            mem[64] = ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 194
            mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 193] = _876
            require _845 + _876 + 32 <= return_data.size
            mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 225 len ceil32(_876)] = mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + _845 + 225 len ceil32(_876)]
            if ceil32(_876) > _876:
                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + _876 + 225] = 0
            mem[mem[64]] = 32
            mem[mem[64] + 32] = _876
            mem[mem[64] + 64 len ceil32(_876)] = mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 225 len ceil32(_876)]
            if ceil32(_876) > _876:
                mem[mem[64] + _876 + 64] = 0
            return Array(len=_876, data=mem[mem[64] + 64 len ceil32(_876)])
        if 31 >= stor[_606].field_1 % 128:
            mem[ceil32(ceil32(arg1.length)) + 193] = 256 * Mask(248, 0, stor[_606].field_8)
            mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
            mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_606])
            mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + 197] = msg.sender
            require ext_code.size(address(stor1[_606]))
            staticcall address(stor1[_606])._isNodeOwner(address arg1) with:
                    gas gas_remaining wei
                   args msg.sender
            mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + 193] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == bool(ext_call.return_data[0])
            if not ext_call.return_data[0]:
                revert with 0, 'NO NODE OWNER'
            mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193] = 0x334de3a200000000000000000000000000000000000000000000000000000000
            mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 197] = msg.sender
            require ext_code.size(address(stor1[_606]))
            staticcall address(stor1[_606])._getNodesNames(address arg1) with:
                    gas gas_remaining wei
                   args msg.sender
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 193
            require return_data.size >= 32
            _878 = mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32
            require mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 <= test266151307()
            require ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + return_data.size + 193 > ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 224
            _897 = mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193]
            if mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193] > test266151307():
                revert with 0, 65
            if ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 1 < 0 or ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 194 > test266151307():
                revert with 0, 65
            mem[64] = ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 194
            mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 193] = _897
            require _878 + _897 + 32 <= return_data.size
            mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 225 len ceil32(_897)] = mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + _878 + 225 len ceil32(_897)]
            if ceil32(_897) > _897:
                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + _897 + 225] = 0
            mem[mem[64]] = 32
            mem[mem[64] + 32] = _897
            mem[mem[64] + 64 len ceil32(_897)] = mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 225 len ceil32(_897)]
            if ceil32(_897) > _897:
                mem[mem[64] + _897 + 64] = 0
            return Array(len=_897, data=mem[mem[64] + 64 len ceil32(_897)])
        mem[0] = _606
        mem[ceil32(ceil32(arg1.length)) + 193] = uint256(stor[sha3(_606)].field_0)
        idx = ceil32(ceil32(arg1.length)) + 193
        s = 0
        while ceil32(ceil32(arg1.length)) + stor[_606].field_1 % 128 + 161 > idx:
            mem[idx + 32] = uint256(stor[s + sha3(_606) + 1].field_0)
            idx = idx + 32
            s = s + 1
            continue 
        mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
        mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_606])
        mem[mem[64] + 4] = msg.sender
        require ext_code.size(address(stor1[_606]))
        staticcall address(stor1[_606])._isNodeOwner(address arg1) with:
                gas gas_remaining wei
               args msg.sender
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _1241 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        require mem[_1241] == bool(mem[_1241])
        if not mem[_1241]:
            revert with 0, 'NO NODE OWNER'
        mem[mem[64]] = 0x334de3a200000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = msg.sender
        require ext_code.size(address(stor1[_606]))
        staticcall address(stor1[_606])._getNodesNames(address arg1) with:
                gas gas_remaining wei
               args msg.sender
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _1396 = mem[64]
        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _1452 = mem[_1396]
        require mem[_1396] <= test266151307()
        require _1396 + return_data.size > _1396 + mem[_1396] + 31
        _1465 = mem[_1396 + mem[_1396]]
        if mem[_1396 + mem[_1396]] > test266151307():
            revert with 0, 65
        if ceil32(ceil32(mem[_1396 + mem[_1396]])) + 1 < 0 or _1396 + ceil32(return_data.size) + ceil32(ceil32(mem[_1396 + mem[_1396]])) + 1 > test266151307():
            revert with 0, 65
        mem[64] = _1396 + ceil32(return_data.size) + ceil32(ceil32(mem[_1396 + mem[_1396]])) + 1
        mem[_1396 + ceil32(return_data.size)] = _1465
        require _1452 + _1465 + 32 <= return_data.size
        mem[_1396 + ceil32(return_data.size) + 32 len ceil32(_1465)] = mem[_1396 + _1452 + 32 len ceil32(_1465)]
        if ceil32(_1465) > _1465:
            mem[_1396 + ceil32(return_data.size) + _1465 + 32] = 0
        mem[mem[64]] = 32
        mem[mem[64] + 32] = _1465
        mem[mem[64] + 64 len ceil32(_1465)] = mem[_1396 + ceil32(return_data.size) + 32 len ceil32(_1465)]
        if ceil32(_1465) > _1465:
            mem[mem[64] + _1465 + 64] = 0
        return Array(len=_1465, data=mem[mem[64] + 64 len ceil32(_1465)])
    if bool(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0) == stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_1 % 128 < 32:
        revert with 0, 34
    mem[64] = ceil32(ceil32(arg1.length)) + ceil32(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_1 % 128) + 193
    mem[ceil32(ceil32(arg1.length)) + 161] = stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_1 % 128
    if bool(stor[_606].field_0):
        if bool(stor[_606].field_0) == uint255(uint256(stor[_606].field_0)) * 0.5 < 32:
            revert with 0, 34
        if not Mask(256, -1, uint256(stor[_606].field_0)):
            mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
            mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_606])
            mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + 197] = msg.sender
            require ext_code.size(address(stor1[_606]))
            staticcall address(stor1[_606])._isNodeOwner(address arg1) with:
                    gas gas_remaining wei
                   args msg.sender
            mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + 193] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == bool(ext_call.return_data[0])
            if not ext_call.return_data[0]:
                revert with 0, 'NO NODE OWNER'
            mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193] = 0x334de3a200000000000000000000000000000000000000000000000000000000
            mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 197] = msg.sender
            require ext_code.size(address(stor1[_606]))
            staticcall address(stor1[_606])._getNodesNames(address arg1) with:
                    gas gas_remaining wei
                   args msg.sender
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + (2 * ceil32(return_data.size)) + 193
            require return_data.size >= 32
            _849 = mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32
            require mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 <= test266151307()
            require ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + return_data.size + 193 > ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 224
            _879 = mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193]
            if mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193] > test266151307():
                revert with 0, 65
            if ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 1 < 0 or ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + (2 * ceil32(return_data.size)) + ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 194 > test266151307():
                revert with 0, 65
            mem[64] = ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + (2 * ceil32(return_data.size)) + ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 194
            mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + (2 * ceil32(return_data.size)) + 193] = _879
            require _849 + _879 + 32 <= return_data.size
            mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + (2 * ceil32(return_data.size)) + 225 len ceil32(_879)] = mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + _849 + 225 len ceil32(_879)]
            if ceil32(_879) <= _879:
                _1256 = mem[64]
                mem[mem[64]] = 32
                mem[mem[64] + 32] = _879
                mem[mem[64] + 64 len ceil32(_879)] = mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + (2 * ceil32(return_data.size)) + 225 len ceil32(_879)]
                if ceil32(_879) <= _879:
                    return Array(len=_879, data=mem[mem[64] + 64 len ceil32(_879)])
                mem[mem[64] + _879 + 64] = 0
                return memory
                  from mem[64]
                   len ceil32(_879) + _1256 + -mem[64] + 64
            mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + (2 * ceil32(return_data.size)) + _879 + 225] = 0
            _1278 = mem[64]
            mem[mem[64]] = 32
            mem[mem[64] + 32] = _879
            mem[mem[64] + 64 len ceil32(_879)] = mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + (2 * ceil32(return_data.size)) + 225 len ceil32(_879)]
            if ceil32(_879) <= _879:
                return Array(len=_879, data=mem[mem[64] + 64 len ceil32(_879)])
            mem[mem[64] + _879 + 64] = 0
            return memory
              from mem[64]
               len ceil32(_879) + _1278 + -mem[64] + 64
        if 31 >= uint255(uint256(stor[_606].field_0)) * 0.5:
            mem[ceil32(ceil32(arg1.length)) + 193] = 256 * Mask(248, 0, stor[_606].field_8)
            mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
            mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_606])
            mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + 197] = msg.sender
            require ext_code.size(address(stor1[_606]))
            staticcall address(stor1[_606])._isNodeOwner(address arg1) with:
                    gas gas_remaining wei
                   args msg.sender
            mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + 193] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == bool(ext_call.return_data[0])
            if not ext_call.return_data[0]:
                revert with 0, 'NO NODE OWNER'
            mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193] = 0x334de3a200000000000000000000000000000000000000000000000000000000
            mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 197] = msg.sender
            require ext_code.size(address(stor1[_606]))
            staticcall address(stor1[_606])._getNodesNames(address arg1) with:
                    gas gas_remaining wei
                   args msg.sender
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + (2 * ceil32(return_data.size)) + 193
            require return_data.size >= 32
            _881 = mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32
            require mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 <= test266151307()
            require ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + return_data.size + 193 > ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 224
            _899 = mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193]
            if mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193] > test266151307():
                revert with 0, 65
            if ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 1 < 0 or ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + (2 * ceil32(return_data.size)) + ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 194 > test266151307():
                revert with 0, 65
            mem[64] = ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + (2 * ceil32(return_data.size)) + ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 194
            mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + (2 * ceil32(return_data.size)) + 193] = _899
            require _881 + _899 + 32 <= return_data.size
            mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + (2 * ceil32(return_data.size)) + 225 len ceil32(_899)] = mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + _881 + 225 len ceil32(_899)]
            if ceil32(_899) > _899:
                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + (2 * ceil32(return_data.size)) + _899 + 225] = 0
            mem[mem[64]] = 32
            mem[mem[64] + 32] = _899
            mem[mem[64] + 64 len ceil32(_899)] = mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + (2 * ceil32(return_data.size)) + 225 len ceil32(_899)]
            if ceil32(_899) > _899:
                mem[mem[64] + _899 + 64] = 0
            return Array(len=_899, data=mem[mem[64] + 64 len ceil32(_899)])
        mem[0] = _606
        mem[ceil32(ceil32(arg1.length)) + 193] = uint256(stor[sha3(_606)].field_0)
        idx = ceil32(ceil32(arg1.length)) + 193
        s = 0
        while ceil32(ceil32(arg1.length)) + (uint255(uint256(stor[_606].field_0)) * 0.5) + 161 > idx:
            mem[idx + 32] = uint256(stor[s + sha3(_606) + 1].field_0)
            idx = idx + 32
            s = s + 1
            continue 
        mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
        mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_606])
        mem[mem[64] + 4] = msg.sender
        require ext_code.size(address(stor1[_606]))
        staticcall address(stor1[_606])._isNodeOwner(address arg1) with:
                gas gas_remaining wei
               args msg.sender
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _1242 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        require mem[_1242] == bool(mem[_1242])
        if not mem[_1242]:
            revert with 0, 'NO NODE OWNER'
        mem[mem[64]] = 0x334de3a200000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = msg.sender
        require ext_code.size(address(stor1[_606]))
        staticcall address(stor1[_606])._getNodesNames(address arg1) with:
                gas gas_remaining wei
               args msg.sender
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _1399 = mem[64]
        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _1455 = mem[_1399]
        require mem[_1399] <= test266151307()
        require _1399 + return_data.size > _1399 + mem[_1399] + 31
        _1466 = mem[_1399 + mem[_1399]]
        if mem[_1399 + mem[_1399]] > test266151307():
            revert with 0, 65
        if ceil32(ceil32(mem[_1399 + mem[_1399]])) + 1 < 0 or _1399 + ceil32(return_data.size) + ceil32(ceil32(mem[_1399 + mem[_1399]])) + 1 > test266151307():
            revert with 0, 65
        mem[64] = _1399 + ceil32(return_data.size) + ceil32(ceil32(mem[_1399 + mem[_1399]])) + 1
        mem[_1399 + ceil32(return_data.size)] = _1466
        require _1455 + _1466 + 32 <= return_data.size
        mem[_1399 + ceil32(return_data.size) + 32 len ceil32(_1466)] = mem[_1399 + _1455 + 32 len ceil32(_1466)]
        if ceil32(_1466) > _1466:
            mem[_1399 + ceil32(return_data.size) + _1466 + 32] = 0
        mem[mem[64]] = 32
        mem[mem[64] + 32] = _1466
        mem[mem[64] + 64 len ceil32(_1466)] = mem[_1399 + ceil32(return_data.size) + 32 len ceil32(_1466)]
        if ceil32(_1466) > _1466:
            mem[mem[64] + _1466 + 64] = 0
        return Array(len=_1466, data=mem[mem[64] + 64 len ceil32(_1466)])
    if bool(stor[_606].field_0) == stor[_606].field_1 % 128 < 32:
        revert with 0, 34
    if not stor[_606].field_1 % 128:
        mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
        mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_606])
        mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + 197] = msg.sender
        require ext_code.size(address(stor1[_606]))
        staticcall address(stor1[_606])._isNodeOwner(address arg1) with:
                gas gas_remaining wei
               args msg.sender
        mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + 193] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == bool(ext_call.return_data[0])
        if not ext_call.return_data[0]:
            revert with 0, 'NO NODE OWNER'
        mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193] = 0x334de3a200000000000000000000000000000000000000000000000000000000
        mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 197] = msg.sender
        require ext_code.size(address(stor1[_606]))
        staticcall address(stor1[_606])._getNodesNames(address arg1) with:
                gas gas_remaining wei
               args msg.sender
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193 len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + (2 * ceil32(return_data.size)) + 193
        require return_data.size >= 32
        _867 = mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32
        require mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 <= test266151307()
        require ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + return_data.size + 193 > ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 224
        _889 = mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193]
        if mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193] > test266151307():
            revert with 0, 65
        if ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 1 < 0 or ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + (2 * ceil32(return_data.size)) + ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 194 > test266151307():
            revert with 0, 65
        mem[64] = ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + (2 * ceil32(return_data.size)) + ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 194
        mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + (2 * ceil32(return_data.size)) + 193] = _889
        require _867 + _889 + 32 <= return_data.size
        mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + (2 * ceil32(return_data.size)) + 225 len ceil32(_889)] = mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + _867 + 225 len ceil32(_889)]
        if ceil32(_889) > _889:
            mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + (2 * ceil32(return_data.size)) + _889 + 225] = 0
        mem[mem[64]] = 32
        mem[mem[64] + 32] = _889
        mem[mem[64] + 64 len ceil32(_889)] = mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + (2 * ceil32(return_data.size)) + 225 len ceil32(_889)]
        if ceil32(_889) > _889:
            mem[mem[64] + _889 + 64] = 0
        return Array(len=_889, data=mem[mem[64] + 64 len ceil32(_889)])
    if 31 >= stor[_606].field_1 % 128:
        mem[ceil32(ceil32(arg1.length)) + 193] = 256 * Mask(248, 0, stor[_606].field_8)
        mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
        mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_606])
        mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + 197] = msg.sender
        require ext_code.size(address(stor1[_606]))
        staticcall address(stor1[_606])._isNodeOwner(address arg1) with:
                gas gas_remaining wei
               args msg.sender
        mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + 193] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == bool(ext_call.return_data[0])
        if not ext_call.return_data[0]:
            revert with 0, 'NO NODE OWNER'
        mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193] = 0x334de3a200000000000000000000000000000000000000000000000000000000
        mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 197] = msg.sender
        require ext_code.size(address(stor1[_606]))
        staticcall address(stor1[_606])._getNodesNames(address arg1) with:
                gas gas_remaining wei
               args msg.sender
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193 len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + (2 * ceil32(return_data.size)) + 193
        require return_data.size >= 32
        _891 = mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32
        require mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 <= test266151307()
        require ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + return_data.size + 193 > ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 224
        _907 = mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193]
        if mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193] > test266151307():
            revert with 0, 65
        if ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 1 < 0 or ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + (2 * ceil32(return_data.size)) + ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 194 > test266151307():
            revert with 0, 65
        mem[64] = ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + (2 * ceil32(return_data.size)) + ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 194
        mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + (2 * ceil32(return_data.size)) + 193] = _907
        require _891 + _907 + 32 <= return_data.size
        mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + (2 * ceil32(return_data.size)) + 225 len ceil32(_907)] = mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + _891 + 225 len ceil32(_907)]
        if ceil32(_907) > _907:
            mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + (2 * ceil32(return_data.size)) + _907 + 225] = 0
        mem[mem[64]] = 32
        mem[mem[64] + 32] = _907
        mem[mem[64] + 64 len ceil32(_907)] = mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + (2 * ceil32(return_data.size)) + 225 len ceil32(_907)]
        if ceil32(_907) > _907:
            mem[mem[64] + _907 + 64] = 0
        return Array(len=_907, data=mem[mem[64] + 64 len ceil32(_907)])
    mem[0] = _606
    mem[ceil32(ceil32(arg1.length)) + 193] = uint256(stor[sha3(_606)].field_0)
    idx = ceil32(ceil32(arg1.length)) + 193
    s = 0
    while ceil32(ceil32(arg1.length)) + stor[_606].field_1 % 128 + 161 > idx:
        mem[idx + 32] = uint256(stor[s + sha3(_606) + 1].field_0)
        idx = idx + 32
        s = s + 1
        continue 
    mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
    mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_606])
    mem[mem[64] + 4] = msg.sender
    require ext_code.size(address(stor1[_606]))
    staticcall address(stor1[_606])._isNodeOwner(address arg1) with:
            gas gas_remaining wei
           args msg.sender
    mem[mem[64]] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _1243 = mem[64]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    require mem[_1243] == bool(mem[_1243])
    if not mem[_1243]:
        revert with 0, 'NO NODE OWNER'
    mem[mem[64]] = 0x334de3a200000000000000000000000000000000000000000000000000000000
    mem[mem[64] + 4] = msg.sender
    require ext_code.size(address(stor1[_606]))
    staticcall address(stor1[_606])._getNodesNames(address arg1) with:
            gas gas_remaining wei
           args msg.sender
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _1402 = mem[64]
    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    _1458 = mem[_1402]
    require mem[_1402] <= test266151307()
    require _1402 + return_data.size > _1402 + mem[_1402] + 31
    _1467 = mem[_1402 + mem[_1402]]
    if mem[_1402 + mem[_1402]] > test266151307():
        revert with 0, 65
    if ceil32(ceil32(mem[_1402 + mem[_1402]])) + 1 < 0 or _1402 + ceil32(return_data.size) + ceil32(ceil32(mem[_1402 + mem[_1402]])) + 1 > test266151307():
        revert with 0, 65
    mem[64] = _1402 + ceil32(return_data.size) + ceil32(ceil32(mem[_1402 + mem[_1402]])) + 1
    mem[_1402 + ceil32(return_data.size)] = _1467
    require _1458 + _1467 + 32 <= return_data.size
    mem[_1402 + ceil32(return_data.size) + 32 len ceil32(_1467)] = mem[_1402 + _1458 + 32 len ceil32(_1467)]
    if ceil32(_1467) <= _1467:
        _1641 = mem[64]
        mem[mem[64]] = 32
        mem[mem[64] + 32] = _1467
        mem[mem[64] + 64 len ceil32(_1467)] = mem[_1402 + ceil32(return_data.size) + 32 len ceil32(_1467)]
        if ceil32(_1467) <= _1467:
            return Array(len=_1467, data=mem[mem[64] + 64 len ceil32(_1467)])
        mem[mem[64] + _1467 + 64] = 0
        return memory
          from mem[64]
           len ceil32(_1467) + _1641 + -mem[64] + 64
    mem[_1402 + ceil32(return_data.size) + _1467 + 32] = 0
    _1681 = mem[64]
    mem[mem[64]] = 32
    mem[mem[64] + 32] = _1467
    mem[mem[64] + 64 len ceil32(_1467)] = mem[_1402 + ceil32(return_data.size) + 32 len ceil32(_1467)]
    if ceil32(_1467) <= _1467:
        return Array(len=_1467, data=mem[mem[64] + 64 len ceil32(_1467)])
    mem[mem[64] + _1467 + 64] = 0
    return memory
      from mem[64]
       len ceil32(_1467) + _1681 + -mem[64] + 64
}

function sub_bd3f85d2(?) {
    require calldata.size - 4 >= 32
    require arg1 <= test266151307()
    require arg1 + 35 < calldata.size
    if arg1.length > test266151307():
        revert with 0, 65
    if ceil32(ceil32(arg1.length)) + 97 < 96 or ceil32(ceil32(arg1.length)) + 97 > test266151307():
        revert with 0, 65
    mem[96] = arg1.length
    require arg1 + arg1.length + 36 <= calldata.size
    mem[128 len arg1.length] = arg1[all]
    mem[arg1.length + 128] = 0
    if not msg.sender:
        revert with 0, 'SENDER CAN'T BE ZERO'
    mem[ceil32(ceil32(arg1.length)) + 97 len ceil32(arg1.length)] = arg1[all], mem[arg1.length + 128 len ceil32(arg1.length) - arg1.length]
    mem[arg1.length + ceil32(ceil32(arg1.length)) + 97] = 24
    if ceil32(arg1.length) <= arg1.length:
        _603 = sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])
        if bool(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0):
            if bool(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0) == uint255(uint256(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0)) * 0.5 < 32:
                revert with 0, 34
            mem[64] = ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0)) * 0.5) + 193
            mem[ceil32(ceil32(arg1.length)) + 161] = uint255(uint256(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0)) * 0.5
            if bool(stor[_603].field_0):
                if bool(stor[_603].field_0) == uint255(uint256(stor[_603].field_0)) * 0.5 < 32:
                    revert with 0, 34
                if not Mask(256, -1, uint256(stor[_603].field_0)):
                    mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
                    mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_603])
                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + 197] = msg.sender
                    require ext_code.size(address(stor1[_603]))
                    staticcall address(stor1[_603])._isNodeOwner(address arg1) with:
                            gas gas_remaining wei
                           args msg.sender
                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + 193] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                    if not ext_call.return_data[0]:
                        revert with 0, 'NO NODE OWNER'
                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193] = 0xc92819ce00000000000000000000000000000000000000000000000000000000
                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 197] = msg.sender
                    require ext_code.size(address(stor1[_603]))
                    staticcall address(stor1[_603])._getNodesCreationTime(address arg1) with:
                            gas gas_remaining wei
                           args msg.sender
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 193
                    require return_data.size >= 32
                    _792 = mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32
                    require mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 <= test266151307()
                    require ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + return_data.size + 193 > ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 224
                    _835 = mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193]
                    if mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193] > test266151307():
                        revert with 0, 65
                    if ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 1 < 0 or ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 194 > test266151307():
                        revert with 0, 65
                    mem[64] = ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 194
                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 193] = _835
                    require _792 + _835 + 32 <= return_data.size
                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 225 len ceil32(_835)] = mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + _792 + 225 len ceil32(_835)]
                    if ceil32(_835) <= _835:
                        _1244 = mem[64]
                        mem[mem[64]] = 32
                        mem[mem[64] + 32] = _835
                        mem[mem[64] + 64 len ceil32(_835)] = mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 225 len ceil32(_835)]
                        if ceil32(_835) <= _835:
                            return Array(len=_835, data=mem[mem[64] + 64 len ceil32(_835)])
                        mem[mem[64] + _835 + 64] = 0
                        return memory
                          from mem[64]
                           len ceil32(_835) + _1244 + -mem[64] + 64
                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + _835 + 225] = 0
                    _1260 = mem[64]
                    mem[mem[64]] = 32
                    mem[mem[64] + 32] = _835
                    mem[mem[64] + 64 len ceil32(_835)] = mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 225 len ceil32(_835)]
                    if ceil32(_835) <= _835:
                        return Array(len=_835, data=mem[mem[64] + 64 len ceil32(_835)])
                    mem[mem[64] + _835 + 64] = 0
                    return memory
                      from mem[64]
                       len ceil32(_835) + _1260 + -mem[64] + 64
                if 31 >= uint255(uint256(stor[_603].field_0)) * 0.5:
                    mem[ceil32(ceil32(arg1.length)) + 193] = 256 * Mask(248, 0, stor[_603].field_8)
                    mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
                    mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_603])
                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + 197] = msg.sender
                    require ext_code.size(address(stor1[_603]))
                    staticcall address(stor1[_603])._isNodeOwner(address arg1) with:
                            gas gas_remaining wei
                           args msg.sender
                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + 193] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                    if not ext_call.return_data[0]:
                        revert with 0, 'NO NODE OWNER'
                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193] = 0xc92819ce00000000000000000000000000000000000000000000000000000000
                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 197] = msg.sender
                    require ext_code.size(address(stor1[_603]))
                    staticcall address(stor1[_603])._getNodesCreationTime(address arg1) with:
                            gas gas_remaining wei
                           args msg.sender
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 193
                    require return_data.size >= 32
                    _837 = mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32
                    require mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 <= test266151307()
                    require ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + return_data.size + 193 > ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 224
                    _872 = mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193]
                    if mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193] > test266151307():
                        revert with 0, 65
                    if ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 1 < 0 or ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 194 > test266151307():
                        revert with 0, 65
                    mem[64] = ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 194
                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 193] = _872
                    require _837 + _872 + 32 <= return_data.size
                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 225 len ceil32(_872)] = mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + _837 + 225 len ceil32(_872)]
                    if ceil32(_872) > _872:
                        mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + _872 + 225] = 0
                    mem[mem[64]] = 32
                    mem[mem[64] + 32] = _872
                    mem[mem[64] + 64 len ceil32(_872)] = mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 225 len ceil32(_872)]
                    if ceil32(_872) > _872:
                        mem[mem[64] + _872 + 64] = 0
                    return Array(len=_872, data=mem[mem[64] + 64 len ceil32(_872)])
                mem[0] = _603
                mem[ceil32(ceil32(arg1.length)) + 193] = uint256(stor[sha3(_603)].field_0)
                idx = ceil32(ceil32(arg1.length)) + 193
                s = 0
                while ceil32(ceil32(arg1.length)) + (uint255(uint256(stor[_603].field_0)) * 0.5) + 161 > idx:
                    mem[idx + 32] = uint256(stor[s + sha3(_603) + 1].field_0)
                    idx = idx + 32
                    s = s + 1
                    continue 
                mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
                mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_603])
                mem[mem[64] + 4] = msg.sender
                require ext_code.size(address(stor1[_603]))
                staticcall address(stor1[_603])._isNodeOwner(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1236 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_1236] == bool(mem[_1236])
                if not mem[_1236]:
                    revert with 0, 'NO NODE OWNER'
                mem[mem[64]] = 0xc92819ce00000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = msg.sender
                require ext_code.size(address(stor1[_603]))
                staticcall address(stor1[_603])._getNodesCreationTime(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1381 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _1437 = mem[_1381]
                require mem[_1381] <= test266151307()
                require _1381 + return_data.size > _1381 + mem[_1381] + 31
                _1460 = mem[_1381 + mem[_1381]]
                if mem[_1381 + mem[_1381]] > test266151307():
                    revert with 0, 65
                if ceil32(ceil32(mem[_1381 + mem[_1381]])) + 1 < 0 or _1381 + ceil32(return_data.size) + ceil32(ceil32(mem[_1381 + mem[_1381]])) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _1381 + ceil32(return_data.size) + ceil32(ceil32(mem[_1381 + mem[_1381]])) + 1
                mem[_1381 + ceil32(return_data.size)] = _1460
                require _1437 + _1460 + 32 <= return_data.size
                mem[_1381 + ceil32(return_data.size) + 32 len ceil32(_1460)] = mem[_1381 + _1437 + 32 len ceil32(_1460)]
                if ceil32(_1460) > _1460:
                    mem[_1381 + ceil32(return_data.size) + _1460 + 32] = 0
                mem[mem[64]] = 32
                mem[mem[64] + 32] = _1460
                mem[mem[64] + 64 len ceil32(_1460)] = mem[_1381 + ceil32(return_data.size) + 32 len ceil32(_1460)]
                if ceil32(_1460) > _1460:
                    mem[mem[64] + _1460 + 64] = 0
                return Array(len=_1460, data=mem[mem[64] + 64 len ceil32(_1460)])
            if bool(stor[_603].field_0) == stor[_603].field_1 % 128 < 32:
                revert with 0, 34
            if not stor[_603].field_1 % 128:
                mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
                mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_603])
                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + 197] = msg.sender
                require ext_code.size(address(stor1[_603]))
                staticcall address(stor1[_603])._isNodeOwner(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + 193] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                if not ext_call.return_data[0]:
                    revert with 0, 'NO NODE OWNER'
                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193] = 0xc92819ce00000000000000000000000000000000000000000000000000000000
                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 197] = msg.sender
                require ext_code.size(address(stor1[_603]))
                staticcall address(stor1[_603])._getNodesCreationTime(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 193
                require return_data.size >= 32
                _814 = mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32
                require mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 <= test266151307()
                require ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + return_data.size + 193 > ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 224
                _855 = mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193]
                if mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193] > test266151307():
                    revert with 0, 65
                if ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 1 < 0 or ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 194 > test266151307():
                    revert with 0, 65
                mem[64] = ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 194
                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 193] = _855
                require _814 + _855 + 32 <= return_data.size
                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 225 len ceil32(_855)] = mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + _814 + 225 len ceil32(_855)]
                if ceil32(_855) > _855:
                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + _855 + 225] = 0
                mem[mem[64]] = 32
                mem[mem[64] + 32] = _855
                mem[mem[64] + 64 len ceil32(_855)] = mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 225 len ceil32(_855)]
                if ceil32(_855) > _855:
                    mem[mem[64] + _855 + 64] = 0
                return Array(len=_855, data=mem[mem[64] + 64 len ceil32(_855)])
            if 31 >= stor[_603].field_1 % 128:
                mem[ceil32(ceil32(arg1.length)) + 193] = 256 * Mask(248, 0, stor[_603].field_8)
                mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
                mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_603])
                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + 197] = msg.sender
                require ext_code.size(address(stor1[_603]))
                staticcall address(stor1[_603])._isNodeOwner(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + 193] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                if not ext_call.return_data[0]:
                    revert with 0, 'NO NODE OWNER'
                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193] = 0xc92819ce00000000000000000000000000000000000000000000000000000000
                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 197] = msg.sender
                require ext_code.size(address(stor1[_603]))
                staticcall address(stor1[_603])._getNodesCreationTime(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 193
                require return_data.size >= 32
                _857 = mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32
                require mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 <= test266151307()
                require ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + return_data.size + 193 > ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 224
                _884 = mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193]
                if mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193] > test266151307():
                    revert with 0, 65
                if ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 1 < 0 or ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 194 > test266151307():
                    revert with 0, 65
                mem[64] = ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 194
                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 193] = _884
                require _857 + _884 + 32 <= return_data.size
                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 225 len ceil32(_884)] = mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + _857 + 225 len ceil32(_884)]
                if ceil32(_884) <= _884:
                    _1247 = mem[64]
                    mem[mem[64]] = 32
                    mem[mem[64] + 32] = _884
                    mem[mem[64] + 64 len ceil32(_884)] = mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 225 len ceil32(_884)]
                    if ceil32(_884) <= _884:
                        return Array(len=_884, data=mem[mem[64] + 64 len ceil32(_884)])
                    mem[mem[64] + _884 + 64] = 0
                    return memory
                      from mem[64]
                       len ceil32(_884) + _1247 + -mem[64] + 64
                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + _884 + 225] = 0
                _1265 = mem[64]
                mem[mem[64]] = 32
                mem[mem[64] + 32] = _884
                mem[mem[64] + 64 len ceil32(_884)] = mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 225 len ceil32(_884)]
                if ceil32(_884) <= _884:
                    return Array(len=_884, data=mem[mem[64] + 64 len ceil32(_884)])
                mem[mem[64] + _884 + 64] = 0
                return memory
                  from mem[64]
                   len ceil32(_884) + _1265 + -mem[64] + 64
            mem[0] = _603
            mem[ceil32(ceil32(arg1.length)) + 193] = uint256(stor[sha3(_603)].field_0)
            idx = ceil32(ceil32(arg1.length)) + 193
            s = 0
            while ceil32(ceil32(arg1.length)) + stor[_603].field_1 % 128 + 161 > idx:
                mem[idx + 32] = uint256(stor[s + sha3(_603) + 1].field_0)
                idx = idx + 32
                s = s + 1
                continue 
            mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
            mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_603])
            mem[mem[64] + 4] = msg.sender
            require ext_code.size(address(stor1[_603]))
            staticcall address(stor1[_603])._isNodeOwner(address arg1) with:
                    gas gas_remaining wei
                   args msg.sender
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1237 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_1237] == bool(mem[_1237])
            if not mem[_1237]:
                revert with 0, 'NO NODE OWNER'
            mem[mem[64]] = 0xc92819ce00000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = msg.sender
            require ext_code.size(address(stor1[_603]))
            staticcall address(stor1[_603])._getNodesCreationTime(address arg1) with:
                    gas gas_remaining wei
                   args msg.sender
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1384 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _1440 = mem[_1384]
            require mem[_1384] <= test266151307()
            require _1384 + return_data.size > _1384 + mem[_1384] + 31
            _1461 = mem[_1384 + mem[_1384]]
            if mem[_1384 + mem[_1384]] > test266151307():
                revert with 0, 65
            if ceil32(ceil32(mem[_1384 + mem[_1384]])) + 1 < 0 or _1384 + ceil32(return_data.size) + ceil32(ceil32(mem[_1384 + mem[_1384]])) + 1 > test266151307():
                revert with 0, 65
            mem[64] = _1384 + ceil32(return_data.size) + ceil32(ceil32(mem[_1384 + mem[_1384]])) + 1
            mem[_1384 + ceil32(return_data.size)] = _1461
            require _1440 + _1461 + 32 <= return_data.size
            mem[_1384 + ceil32(return_data.size) + 32 len ceil32(_1461)] = mem[_1384 + _1440 + 32 len ceil32(_1461)]
            if ceil32(_1461) > _1461:
                mem[_1384 + ceil32(return_data.size) + _1461 + 32] = 0
            mem[mem[64]] = 32
            mem[mem[64] + 32] = _1461
            mem[mem[64] + 64 len ceil32(_1461)] = mem[_1384 + ceil32(return_data.size) + 32 len ceil32(_1461)]
            if ceil32(_1461) > _1461:
                mem[mem[64] + _1461 + 64] = 0
            return Array(len=_1461, data=mem[mem[64] + 64 len ceil32(_1461)])
        if bool(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0) == stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_1 % 128 < 32:
            revert with 0, 34
        mem[64] = ceil32(ceil32(arg1.length)) + ceil32(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_1 % 128) + 193
        mem[ceil32(ceil32(arg1.length)) + 161] = stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_1 % 128
        if bool(stor[_603].field_0):
            if bool(stor[_603].field_0) == uint255(uint256(stor[_603].field_0)) * 0.5 < 32:
                revert with 0, 34
            if not Mask(256, -1, uint256(stor[_603].field_0)):
                mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
                mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_603])
                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + 197] = msg.sender
                require ext_code.size(address(stor1[_603]))
                staticcall address(stor1[_603])._isNodeOwner(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + 193] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                if not ext_call.return_data[0]:
                    revert with 0, 'NO NODE OWNER'
                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193] = 0xc92819ce00000000000000000000000000000000000000000000000000000000
                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 197] = msg.sender
                require ext_code.size(address(stor1[_603]))
                staticcall address(stor1[_603])._getNodesCreationTime(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + (2 * ceil32(return_data.size)) + 193
                require return_data.size >= 32
                _818 = mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32
                require mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 <= test266151307()
                require ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + return_data.size + 193 > ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 224
                _858 = mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193]
                if mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193] > test266151307():
                    revert with 0, 65
                if ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 1 < 0 or ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + (2 * ceil32(return_data.size)) + ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 194 > test266151307():
                    revert with 0, 65
                mem[64] = ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + (2 * ceil32(return_data.size)) + ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 194
                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + (2 * ceil32(return_data.size)) + 193] = _858
                require _818 + _858 + 32 <= return_data.size
                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + (2 * ceil32(return_data.size)) + 225 len ceil32(_858)] = mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + _818 + 225 len ceil32(_858)]
                if ceil32(_858) > _858:
                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + (2 * ceil32(return_data.size)) + _858 + 225] = 0
                mem[mem[64]] = 32
                mem[mem[64] + 32] = _858
                mem[mem[64] + 64 len ceil32(_858)] = mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + (2 * ceil32(return_data.size)) + 225 len ceil32(_858)]
                if ceil32(_858) > _858:
                    mem[mem[64] + _858 + 64] = 0
                return Array(len=_858, data=mem[mem[64] + 64 len ceil32(_858)])
            if 31 >= uint255(uint256(stor[_603].field_0)) * 0.5:
                mem[ceil32(ceil32(arg1.length)) + 193] = 256 * Mask(248, 0, stor[_603].field_8)
                mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
                mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_603])
                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + 197] = msg.sender
                require ext_code.size(address(stor1[_603]))
                staticcall address(stor1[_603])._isNodeOwner(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + 193] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                if not ext_call.return_data[0]:
                    revert with 0, 'NO NODE OWNER'
                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193] = 0xc92819ce00000000000000000000000000000000000000000000000000000000
                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 197] = msg.sender
                require ext_code.size(address(stor1[_603]))
                staticcall address(stor1[_603])._getNodesCreationTime(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + (2 * ceil32(return_data.size)) + 193
                require return_data.size >= 32
                _860 = mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32
                require mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 <= test266151307()
                require ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + return_data.size + 193 > ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 224
                _886 = mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193]
                if mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193] > test266151307():
                    revert with 0, 65
                if ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 1 < 0 or ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + (2 * ceil32(return_data.size)) + ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 194 > test266151307():
                    revert with 0, 65
                mem[64] = ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + (2 * ceil32(return_data.size)) + ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 194
                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + (2 * ceil32(return_data.size)) + 193] = _886
                require _860 + _886 + 32 <= return_data.size
                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + (2 * ceil32(return_data.size)) + 225 len ceil32(_886)] = mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + _860 + 225 len ceil32(_886)]
                if ceil32(_886) > _886:
                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + (2 * ceil32(return_data.size)) + _886 + 225] = 0
                mem[mem[64]] = 32
                mem[mem[64] + 32] = _886
                mem[mem[64] + 64 len ceil32(_886)] = mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + (2 * ceil32(return_data.size)) + 225 len ceil32(_886)]
                if ceil32(_886) > _886:
                    mem[mem[64] + _886 + 64] = 0
                return Array(len=_886, data=mem[mem[64] + 64 len ceil32(_886)])
            mem[0] = _603
            mem[ceil32(ceil32(arg1.length)) + 193] = uint256(stor[sha3(_603)].field_0)
            idx = ceil32(ceil32(arg1.length)) + 193
            s = 0
            while ceil32(ceil32(arg1.length)) + (uint255(uint256(stor[_603].field_0)) * 0.5) + 161 > idx:
                mem[idx + 32] = uint256(stor[s + sha3(_603) + 1].field_0)
                idx = idx + 32
                s = s + 1
                continue 
            mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
            mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_603])
            mem[mem[64] + 4] = msg.sender
            require ext_code.size(address(stor1[_603]))
            staticcall address(stor1[_603])._isNodeOwner(address arg1) with:
                    gas gas_remaining wei
                   args msg.sender
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1238 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_1238] == bool(mem[_1238])
            if not mem[_1238]:
                revert with 0, 'NO NODE OWNER'
            mem[mem[64]] = 0xc92819ce00000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = msg.sender
            require ext_code.size(address(stor1[_603]))
            staticcall address(stor1[_603])._getNodesCreationTime(address arg1) with:
                    gas gas_remaining wei
                   args msg.sender
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1387 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _1443 = mem[_1387]
            require mem[_1387] <= test266151307()
            require _1387 + return_data.size > _1387 + mem[_1387] + 31
            _1462 = mem[_1387 + mem[_1387]]
            if mem[_1387 + mem[_1387]] > test266151307():
                revert with 0, 65
            if ceil32(ceil32(mem[_1387 + mem[_1387]])) + 1 < 0 or _1387 + ceil32(return_data.size) + ceil32(ceil32(mem[_1387 + mem[_1387]])) + 1 > test266151307():
                revert with 0, 65
            mem[64] = _1387 + ceil32(return_data.size) + ceil32(ceil32(mem[_1387 + mem[_1387]])) + 1
            mem[_1387 + ceil32(return_data.size)] = _1462
            require _1443 + _1462 + 32 <= return_data.size
            mem[_1387 + ceil32(return_data.size) + 32 len ceil32(_1462)] = mem[_1387 + _1443 + 32 len ceil32(_1462)]
            if ceil32(_1462) > _1462:
                mem[_1387 + ceil32(return_data.size) + _1462 + 32] = 0
            mem[mem[64]] = 32
            mem[mem[64] + 32] = _1462
            mem[mem[64] + 64 len ceil32(_1462)] = mem[_1387 + ceil32(return_data.size) + 32 len ceil32(_1462)]
            if ceil32(_1462) > _1462:
                mem[mem[64] + _1462 + 64] = 0
            return Array(len=_1462, data=mem[mem[64] + 64 len ceil32(_1462)])
        if bool(stor[_603].field_0) == stor[_603].field_1 % 128 < 32:
            revert with 0, 34
        if not stor[_603].field_1 % 128:
            mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
            mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_603])
            mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + 197] = msg.sender
            require ext_code.size(address(stor1[_603]))
            staticcall address(stor1[_603])._isNodeOwner(address arg1) with:
                    gas gas_remaining wei
                   args msg.sender
            mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + 193] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == bool(ext_call.return_data[0])
            if not ext_call.return_data[0]:
                revert with 0, 'NO NODE OWNER'
            mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193] = 0xc92819ce00000000000000000000000000000000000000000000000000000000
            mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 197] = msg.sender
            require ext_code.size(address(stor1[_603]))
            staticcall address(stor1[_603])._getNodesCreationTime(address arg1) with:
                    gas gas_remaining wei
                   args msg.sender
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + (2 * ceil32(return_data.size)) + 193
            require return_data.size >= 32
            _840 = mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32
            require mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 <= test266151307()
            require ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + return_data.size + 193 > ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 224
            _873 = mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193]
            if mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193] > test266151307():
                revert with 0, 65
            if ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 1 < 0 or ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + (2 * ceil32(return_data.size)) + ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 194 > test266151307():
                revert with 0, 65
            mem[64] = ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + (2 * ceil32(return_data.size)) + ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 194
            mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + (2 * ceil32(return_data.size)) + 193] = _873
            require _840 + _873 + 32 <= return_data.size
            mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + (2 * ceil32(return_data.size)) + 225 len ceil32(_873)] = mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + _840 + 225 len ceil32(_873)]
            if ceil32(_873) > _873:
                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + (2 * ceil32(return_data.size)) + _873 + 225] = 0
            mem[mem[64]] = 32
            mem[mem[64] + 32] = _873
            mem[mem[64] + 64 len ceil32(_873)] = mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + (2 * ceil32(return_data.size)) + 225 len ceil32(_873)]
            if ceil32(_873) > _873:
                mem[mem[64] + _873 + 64] = 0
            return Array(len=_873, data=mem[mem[64] + 64 len ceil32(_873)])
        if 31 >= stor[_603].field_1 % 128:
            mem[ceil32(ceil32(arg1.length)) + 193] = 256 * Mask(248, 0, stor[_603].field_8)
            mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
            mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_603])
            mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + 197] = msg.sender
            require ext_code.size(address(stor1[_603]))
            staticcall address(stor1[_603])._isNodeOwner(address arg1) with:
                    gas gas_remaining wei
                   args msg.sender
            mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + 193] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == bool(ext_call.return_data[0])
            if not ext_call.return_data[0]:
                revert with 0, 'NO NODE OWNER'
            mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193] = 0xc92819ce00000000000000000000000000000000000000000000000000000000
            mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 197] = msg.sender
            require ext_code.size(address(stor1[_603]))
            staticcall address(stor1[_603])._getNodesCreationTime(address arg1) with:
                    gas gas_remaining wei
                   args msg.sender
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + (2 * ceil32(return_data.size)) + 193
            require return_data.size >= 32
            _875 = mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32
            require mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 <= test266151307()
            require ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + return_data.size + 193 > ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 224
            _895 = mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193]
            if mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193] > test266151307():
                revert with 0, 65
            if ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 1 < 0 or ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + (2 * ceil32(return_data.size)) + ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 194 > test266151307():
                revert with 0, 65
            mem[64] = ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + (2 * ceil32(return_data.size)) + ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 194
            mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + (2 * ceil32(return_data.size)) + 193] = _895
            require _875 + _895 + 32 <= return_data.size
            mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + (2 * ceil32(return_data.size)) + 225 len ceil32(_895)] = mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + _875 + 225 len ceil32(_895)]
            if ceil32(_895) > _895:
                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + (2 * ceil32(return_data.size)) + _895 + 225] = 0
            mem[mem[64]] = 32
            mem[mem[64] + 32] = _895
            mem[mem[64] + 64 len ceil32(_895)] = mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + (2 * ceil32(return_data.size)) + 225 len ceil32(_895)]
            if ceil32(_895) > _895:
                mem[mem[64] + _895 + 64] = 0
            return Array(len=_895, data=mem[mem[64] + 64 len ceil32(_895)])
        mem[0] = _603
        mem[ceil32(ceil32(arg1.length)) + 193] = uint256(stor[sha3(_603)].field_0)
        idx = ceil32(ceil32(arg1.length)) + 193
        s = 0
        while ceil32(ceil32(arg1.length)) + stor[_603].field_1 % 128 + 161 > idx:
            mem[idx + 32] = uint256(stor[s + sha3(_603) + 1].field_0)
            idx = idx + 32
            s = s + 1
            continue 
        mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
        mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_603])
        mem[mem[64] + 4] = msg.sender
        require ext_code.size(address(stor1[_603]))
        staticcall address(stor1[_603])._isNodeOwner(address arg1) with:
                gas gas_remaining wei
               args msg.sender
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _1239 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        require mem[_1239] == bool(mem[_1239])
        if not mem[_1239]:
            revert with 0, 'NO NODE OWNER'
        mem[mem[64]] = 0xc92819ce00000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = msg.sender
        require ext_code.size(address(stor1[_603]))
        staticcall address(stor1[_603])._getNodesCreationTime(address arg1) with:
                gas gas_remaining wei
               args msg.sender
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _1390 = mem[64]
        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _1446 = mem[_1390]
        require mem[_1390] <= test266151307()
        require _1390 + return_data.size > _1390 + mem[_1390] + 31
        _1463 = mem[_1390 + mem[_1390]]
        if mem[_1390 + mem[_1390]] > test266151307():
            revert with 0, 65
        if ceil32(ceil32(mem[_1390 + mem[_1390]])) + 1 < 0 or _1390 + ceil32(return_data.size) + ceil32(ceil32(mem[_1390 + mem[_1390]])) + 1 > test266151307():
            revert with 0, 65
        mem[64] = _1390 + ceil32(return_data.size) + ceil32(ceil32(mem[_1390 + mem[_1390]])) + 1
        mem[_1390 + ceil32(return_data.size)] = _1463
        require _1446 + _1463 + 32 <= return_data.size
        mem[_1390 + ceil32(return_data.size) + 32 len ceil32(_1463)] = mem[_1390 + _1446 + 32 len ceil32(_1463)]
        if ceil32(_1463) <= _1463:
            _1621 = mem[64]
            mem[mem[64]] = 32
            mem[mem[64] + 32] = _1463
            mem[mem[64] + 64 len ceil32(_1463)] = mem[_1390 + ceil32(return_data.size) + 32 len ceil32(_1463)]
            if ceil32(_1463) <= _1463:
                return Array(len=_1463, data=mem[mem[64] + 64 len ceil32(_1463)])
            mem[mem[64] + _1463 + 64] = 0
            return memory
              from mem[64]
               len ceil32(_1463) + _1621 + -mem[64] + 64
        mem[_1390 + ceil32(return_data.size) + _1463 + 32] = 0
        _1661 = mem[64]
        mem[mem[64]] = 32
        mem[mem[64] + 32] = _1463
        mem[mem[64] + 64 len ceil32(_1463)] = mem[_1390 + ceil32(return_data.size) + 32 len ceil32(_1463)]
        if ceil32(_1463) <= _1463:
            return Array(len=_1463, data=mem[mem[64] + 64 len ceil32(_1463)])
        mem[mem[64] + _1463 + 64] = 0
        return memory
          from mem[64]
           len ceil32(_1463) + _1661 + -mem[64] + 64
    _606 = sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])
    if bool(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0):
        if bool(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0) == uint255(uint256(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0)) * 0.5 < 32:
            revert with 0, 34
        mem[64] = ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0)) * 0.5) + 193
        mem[ceil32(ceil32(arg1.length)) + 161] = uint255(uint256(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0)) * 0.5
        if bool(stor[_606].field_0):
            if bool(stor[_606].field_0) == uint255(uint256(stor[_606].field_0)) * 0.5 < 32:
                revert with 0, 34
            if not Mask(256, -1, uint256(stor[_606].field_0)):
                mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
                mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_606])
                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + 197] = msg.sender
                require ext_code.size(address(stor1[_606]))
                staticcall address(stor1[_606])._isNodeOwner(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + 193] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                if not ext_call.return_data[0]:
                    revert with 0, 'NO NODE OWNER'
                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193] = 0xc92819ce00000000000000000000000000000000000000000000000000000000
                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 197] = msg.sender
                require ext_code.size(address(stor1[_606]))
                staticcall address(stor1[_606])._getNodesCreationTime(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 193
                require return_data.size >= 32
                _824 = mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32
                require mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 <= test266151307()
                require ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + return_data.size + 193 > ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 224
                _862 = mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193]
                if mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193] > test266151307():
                    revert with 0, 65
                if ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 1 < 0 or ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 194 > test266151307():
                    revert with 0, 65
                mem[64] = ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 194
                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 193] = _862
                require _824 + _862 + 32 <= return_data.size
                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 225 len ceil32(_862)] = mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + _824 + 225 len ceil32(_862)]
                if ceil32(_862) > _862:
                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + _862 + 225] = 0
                mem[mem[64]] = 32
                mem[mem[64] + 32] = _862
                mem[mem[64] + 64 len ceil32(_862)] = mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 225 len ceil32(_862)]
                if ceil32(_862) > _862:
                    mem[mem[64] + _862 + 64] = 0
                return Array(len=_862, data=mem[mem[64] + 64 len ceil32(_862)])
            if 31 >= uint255(uint256(stor[_606].field_0)) * 0.5:
                mem[ceil32(ceil32(arg1.length)) + 193] = 256 * Mask(248, 0, stor[_606].field_8)
                mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
                mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_606])
                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + 197] = msg.sender
                require ext_code.size(address(stor1[_606]))
                staticcall address(stor1[_606])._isNodeOwner(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + 193] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                if not ext_call.return_data[0]:
                    revert with 0, 'NO NODE OWNER'
                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193] = 0xc92819ce00000000000000000000000000000000000000000000000000000000
                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 197] = msg.sender
                require ext_code.size(address(stor1[_606]))
                staticcall address(stor1[_606])._getNodesCreationTime(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 193
                require return_data.size >= 32
                _864 = mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32
                require mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 <= test266151307()
                require ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + return_data.size + 193 > ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 224
                _888 = mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193]
                if mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193] > test266151307():
                    revert with 0, 65
                if ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 1 < 0 or ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 194 > test266151307():
                    revert with 0, 65
                mem[64] = ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 194
                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 193] = _888
                require _864 + _888 + 32 <= return_data.size
                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 225 len ceil32(_888)] = mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + _864 + 225 len ceil32(_888)]
                if ceil32(_888) > _888:
                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + _888 + 225] = 0
                mem[mem[64]] = 32
                mem[mem[64] + 32] = _888
                mem[mem[64] + 64 len ceil32(_888)] = mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 225 len ceil32(_888)]
                if ceil32(_888) > _888:
                    mem[mem[64] + _888 + 64] = 0
                return Array(len=_888, data=mem[mem[64] + 64 len ceil32(_888)])
            mem[0] = _606
            mem[ceil32(ceil32(arg1.length)) + 193] = uint256(stor[sha3(_606)].field_0)
            idx = ceil32(ceil32(arg1.length)) + 193
            s = 0
            while ceil32(ceil32(arg1.length)) + (uint255(uint256(stor[_606].field_0)) * 0.5) + 161 > idx:
                mem[idx + 32] = uint256(stor[s + sha3(_606) + 1].field_0)
                idx = idx + 32
                s = s + 1
                continue 
            mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
            mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_606])
            mem[mem[64] + 4] = msg.sender
            require ext_code.size(address(stor1[_606]))
            staticcall address(stor1[_606])._isNodeOwner(address arg1) with:
                    gas gas_remaining wei
                   args msg.sender
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1240 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_1240] == bool(mem[_1240])
            if not mem[_1240]:
                revert with 0, 'NO NODE OWNER'
            mem[mem[64]] = 0xc92819ce00000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = msg.sender
            require ext_code.size(address(stor1[_606]))
            staticcall address(stor1[_606])._getNodesCreationTime(address arg1) with:
                    gas gas_remaining wei
                   args msg.sender
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1393 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _1449 = mem[_1393]
            require mem[_1393] <= test266151307()
            require _1393 + return_data.size > _1393 + mem[_1393] + 31
            _1464 = mem[_1393 + mem[_1393]]
            if mem[_1393 + mem[_1393]] > test266151307():
                revert with 0, 65
            if ceil32(ceil32(mem[_1393 + mem[_1393]])) + 1 < 0 or _1393 + ceil32(return_data.size) + ceil32(ceil32(mem[_1393 + mem[_1393]])) + 1 > test266151307():
                revert with 0, 65
            mem[64] = _1393 + ceil32(return_data.size) + ceil32(ceil32(mem[_1393 + mem[_1393]])) + 1
            mem[_1393 + ceil32(return_data.size)] = _1464
            require _1449 + _1464 + 32 <= return_data.size
            mem[_1393 + ceil32(return_data.size) + 32 len ceil32(_1464)] = mem[_1393 + _1449 + 32 len ceil32(_1464)]
            if ceil32(_1464) > _1464:
                mem[_1393 + ceil32(return_data.size) + _1464 + 32] = 0
            mem[mem[64]] = 32
            mem[mem[64] + 32] = _1464
            mem[mem[64] + 64 len ceil32(_1464)] = mem[_1393 + ceil32(return_data.size) + 32 len ceil32(_1464)]
            if ceil32(_1464) > _1464:
                mem[mem[64] + _1464 + 64] = 0
            return Array(len=_1464, data=mem[mem[64] + 64 len ceil32(_1464)])
        if bool(stor[_606].field_0) == stor[_606].field_1 % 128 < 32:
            revert with 0, 34
        if not stor[_606].field_1 % 128:
            mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
            mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_606])
            mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + 197] = msg.sender
            require ext_code.size(address(stor1[_606]))
            staticcall address(stor1[_606])._isNodeOwner(address arg1) with:
                    gas gas_remaining wei
                   args msg.sender
            mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + 193] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == bool(ext_call.return_data[0])
            if not ext_call.return_data[0]:
                revert with 0, 'NO NODE OWNER'
            mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193] = 0xc92819ce00000000000000000000000000000000000000000000000000000000
            mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 197] = msg.sender
            require ext_code.size(address(stor1[_606]))
            staticcall address(stor1[_606])._getNodesCreationTime(address arg1) with:
                    gas gas_remaining wei
                   args msg.sender
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 193
            require return_data.size >= 32
            _845 = mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32
            require mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 <= test266151307()
            require ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + return_data.size + 193 > ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 224
            _876 = mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193]
            if mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193] > test266151307():
                revert with 0, 65
            if ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 1 < 0 or ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 194 > test266151307():
                revert with 0, 65
            mem[64] = ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 194
            mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 193] = _876
            require _845 + _876 + 32 <= return_data.size
            mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 225 len ceil32(_876)] = mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + _845 + 225 len ceil32(_876)]
            if ceil32(_876) > _876:
                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + _876 + 225] = 0
            mem[mem[64]] = 32
            mem[mem[64] + 32] = _876
            mem[mem[64] + 64 len ceil32(_876)] = mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 225 len ceil32(_876)]
            if ceil32(_876) > _876:
                mem[mem[64] + _876 + 64] = 0
            return Array(len=_876, data=mem[mem[64] + 64 len ceil32(_876)])
        if 31 >= stor[_606].field_1 % 128:
            mem[ceil32(ceil32(arg1.length)) + 193] = 256 * Mask(248, 0, stor[_606].field_8)
            mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
            mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_606])
            mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + 197] = msg.sender
            require ext_code.size(address(stor1[_606]))
            staticcall address(stor1[_606])._isNodeOwner(address arg1) with:
                    gas gas_remaining wei
                   args msg.sender
            mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + 193] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == bool(ext_call.return_data[0])
            if not ext_call.return_data[0]:
                revert with 0, 'NO NODE OWNER'
            mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193] = 0xc92819ce00000000000000000000000000000000000000000000000000000000
            mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 197] = msg.sender
            require ext_code.size(address(stor1[_606]))
            staticcall address(stor1[_606])._getNodesCreationTime(address arg1) with:
                    gas gas_remaining wei
                   args msg.sender
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 193
            require return_data.size >= 32
            _878 = mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32
            require mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 <= test266151307()
            require ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + return_data.size + 193 > ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 224
            _897 = mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193]
            if mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193] > test266151307():
                revert with 0, 65
            if ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 1 < 0 or ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 194 > test266151307():
                revert with 0, 65
            mem[64] = ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 194
            mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 193] = _897
            require _878 + _897 + 32 <= return_data.size
            mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 225 len ceil32(_897)] = mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + _878 + 225 len ceil32(_897)]
            if ceil32(_897) > _897:
                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + _897 + 225] = 0
            mem[mem[64]] = 32
            mem[mem[64] + 32] = _897
            mem[mem[64] + 64 len ceil32(_897)] = mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 225 len ceil32(_897)]
            if ceil32(_897) > _897:
                mem[mem[64] + _897 + 64] = 0
            return Array(len=_897, data=mem[mem[64] + 64 len ceil32(_897)])
        mem[0] = _606
        mem[ceil32(ceil32(arg1.length)) + 193] = uint256(stor[sha3(_606)].field_0)
        idx = ceil32(ceil32(arg1.length)) + 193
        s = 0
        while ceil32(ceil32(arg1.length)) + stor[_606].field_1 % 128 + 161 > idx:
            mem[idx + 32] = uint256(stor[s + sha3(_606) + 1].field_0)
            idx = idx + 32
            s = s + 1
            continue 
        mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
        mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_606])
        mem[mem[64] + 4] = msg.sender
        require ext_code.size(address(stor1[_606]))
        staticcall address(stor1[_606])._isNodeOwner(address arg1) with:
                gas gas_remaining wei
               args msg.sender
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _1241 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        require mem[_1241] == bool(mem[_1241])
        if not mem[_1241]:
            revert with 0, 'NO NODE OWNER'
        mem[mem[64]] = 0xc92819ce00000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = msg.sender
        require ext_code.size(address(stor1[_606]))
        staticcall address(stor1[_606])._getNodesCreationTime(address arg1) with:
                gas gas_remaining wei
               args msg.sender
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _1396 = mem[64]
        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _1452 = mem[_1396]
        require mem[_1396] <= test266151307()
        require _1396 + return_data.size > _1396 + mem[_1396] + 31
        _1465 = mem[_1396 + mem[_1396]]
        if mem[_1396 + mem[_1396]] > test266151307():
            revert with 0, 65
        if ceil32(ceil32(mem[_1396 + mem[_1396]])) + 1 < 0 or _1396 + ceil32(return_data.size) + ceil32(ceil32(mem[_1396 + mem[_1396]])) + 1 > test266151307():
            revert with 0, 65
        mem[64] = _1396 + ceil32(return_data.size) + ceil32(ceil32(mem[_1396 + mem[_1396]])) + 1
        mem[_1396 + ceil32(return_data.size)] = _1465
        require _1452 + _1465 + 32 <= return_data.size
        mem[_1396 + ceil32(return_data.size) + 32 len ceil32(_1465)] = mem[_1396 + _1452 + 32 len ceil32(_1465)]
        if ceil32(_1465) > _1465:
            mem[_1396 + ceil32(return_data.size) + _1465 + 32] = 0
        mem[mem[64]] = 32
        mem[mem[64] + 32] = _1465
        mem[mem[64] + 64 len ceil32(_1465)] = mem[_1396 + ceil32(return_data.size) + 32 len ceil32(_1465)]
        if ceil32(_1465) > _1465:
            mem[mem[64] + _1465 + 64] = 0
        return Array(len=_1465, data=mem[mem[64] + 64 len ceil32(_1465)])
    if bool(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0) == stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_1 % 128 < 32:
        revert with 0, 34
    mem[64] = ceil32(ceil32(arg1.length)) + ceil32(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_1 % 128) + 193
    mem[ceil32(ceil32(arg1.length)) + 161] = stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_1 % 128
    if bool(stor[_606].field_0):
        if bool(stor[_606].field_0) == uint255(uint256(stor[_606].field_0)) * 0.5 < 32:
            revert with 0, 34
        if not Mask(256, -1, uint256(stor[_606].field_0)):
            mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
            mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_606])
            mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + 197] = msg.sender
            require ext_code.size(address(stor1[_606]))
            staticcall address(stor1[_606])._isNodeOwner(address arg1) with:
                    gas gas_remaining wei
                   args msg.sender
            mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + 193] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == bool(ext_call.return_data[0])
            if not ext_call.return_data[0]:
                revert with 0, 'NO NODE OWNER'
            mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193] = 0xc92819ce00000000000000000000000000000000000000000000000000000000
            mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 197] = msg.sender
            require ext_code.size(address(stor1[_606]))
            staticcall address(stor1[_606])._getNodesCreationTime(address arg1) with:
                    gas gas_remaining wei
                   args msg.sender
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + (2 * ceil32(return_data.size)) + 193
            require return_data.size >= 32
            _849 = mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32
            require mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 <= test266151307()
            require ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + return_data.size + 193 > ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 224
            _879 = mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193]
            if mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193] > test266151307():
                revert with 0, 65
            if ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 1 < 0 or ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + (2 * ceil32(return_data.size)) + ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 194 > test266151307():
                revert with 0, 65
            mem[64] = ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + (2 * ceil32(return_data.size)) + ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 194
            mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + (2 * ceil32(return_data.size)) + 193] = _879
            require _849 + _879 + 32 <= return_data.size
            mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + (2 * ceil32(return_data.size)) + 225 len ceil32(_879)] = mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + _849 + 225 len ceil32(_879)]
            if ceil32(_879) <= _879:
                _1256 = mem[64]
                mem[mem[64]] = 32
                mem[mem[64] + 32] = _879
                mem[mem[64] + 64 len ceil32(_879)] = mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + (2 * ceil32(return_data.size)) + 225 len ceil32(_879)]
                if ceil32(_879) <= _879:
                    return Array(len=_879, data=mem[mem[64] + 64 len ceil32(_879)])
                mem[mem[64] + _879 + 64] = 0
                return memory
                  from mem[64]
                   len ceil32(_879) + _1256 + -mem[64] + 64
            mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + (2 * ceil32(return_data.size)) + _879 + 225] = 0
            _1278 = mem[64]
            mem[mem[64]] = 32
            mem[mem[64] + 32] = _879
            mem[mem[64] + 64 len ceil32(_879)] = mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + (2 * ceil32(return_data.size)) + 225 len ceil32(_879)]
            if ceil32(_879) <= _879:
                return Array(len=_879, data=mem[mem[64] + 64 len ceil32(_879)])
            mem[mem[64] + _879 + 64] = 0
            return memory
              from mem[64]
               len ceil32(_879) + _1278 + -mem[64] + 64
        if 31 >= uint255(uint256(stor[_606].field_0)) * 0.5:
            mem[ceil32(ceil32(arg1.length)) + 193] = 256 * Mask(248, 0, stor[_606].field_8)
            mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
            mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_606])
            mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + 197] = msg.sender
            require ext_code.size(address(stor1[_606]))
            staticcall address(stor1[_606])._isNodeOwner(address arg1) with:
                    gas gas_remaining wei
                   args msg.sender
            mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + 193] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == bool(ext_call.return_data[0])
            if not ext_call.return_data[0]:
                revert with 0, 'NO NODE OWNER'
            mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193] = 0xc92819ce00000000000000000000000000000000000000000000000000000000
            mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 197] = msg.sender
            require ext_code.size(address(stor1[_606]))
            staticcall address(stor1[_606])._getNodesCreationTime(address arg1) with:
                    gas gas_remaining wei
                   args msg.sender
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + (2 * ceil32(return_data.size)) + 193
            require return_data.size >= 32
            _881 = mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32
            require mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 <= test266151307()
            require ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + return_data.size + 193 > ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 224
            _899 = mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193]
            if mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193] > test266151307():
                revert with 0, 65
            if ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 1 < 0 or ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + (2 * ceil32(return_data.size)) + ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 194 > test266151307():
                revert with 0, 65
            mem[64] = ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + (2 * ceil32(return_data.size)) + ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 194
            mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + (2 * ceil32(return_data.size)) + 193] = _899
            require _881 + _899 + 32 <= return_data.size
            mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + (2 * ceil32(return_data.size)) + 225 len ceil32(_899)] = mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + _881 + 225 len ceil32(_899)]
            if ceil32(_899) > _899:
                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + (2 * ceil32(return_data.size)) + _899 + 225] = 0
            mem[mem[64]] = 32
            mem[mem[64] + 32] = _899
            mem[mem[64] + 64 len ceil32(_899)] = mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + (2 * ceil32(return_data.size)) + 225 len ceil32(_899)]
            if ceil32(_899) > _899:
                mem[mem[64] + _899 + 64] = 0
            return Array(len=_899, data=mem[mem[64] + 64 len ceil32(_899)])
        mem[0] = _606
        mem[ceil32(ceil32(arg1.length)) + 193] = uint256(stor[sha3(_606)].field_0)
        idx = ceil32(ceil32(arg1.length)) + 193
        s = 0
        while ceil32(ceil32(arg1.length)) + (uint255(uint256(stor[_606].field_0)) * 0.5) + 161 > idx:
            mem[idx + 32] = uint256(stor[s + sha3(_606) + 1].field_0)
            idx = idx + 32
            s = s + 1
            continue 
        mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
        mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_606])
        mem[mem[64] + 4] = msg.sender
        require ext_code.size(address(stor1[_606]))
        staticcall address(stor1[_606])._isNodeOwner(address arg1) with:
                gas gas_remaining wei
               args msg.sender
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _1242 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        require mem[_1242] == bool(mem[_1242])
        if not mem[_1242]:
            revert with 0, 'NO NODE OWNER'
        mem[mem[64]] = 0xc92819ce00000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = msg.sender
        require ext_code.size(address(stor1[_606]))
        staticcall address(stor1[_606])._getNodesCreationTime(address arg1) with:
                gas gas_remaining wei
               args msg.sender
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _1399 = mem[64]
        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _1455 = mem[_1399]
        require mem[_1399] <= test266151307()
        require _1399 + return_data.size > _1399 + mem[_1399] + 31
        _1466 = mem[_1399 + mem[_1399]]
        if mem[_1399 + mem[_1399]] > test266151307():
            revert with 0, 65
        if ceil32(ceil32(mem[_1399 + mem[_1399]])) + 1 < 0 or _1399 + ceil32(return_data.size) + ceil32(ceil32(mem[_1399 + mem[_1399]])) + 1 > test266151307():
            revert with 0, 65
        mem[64] = _1399 + ceil32(return_data.size) + ceil32(ceil32(mem[_1399 + mem[_1399]])) + 1
        mem[_1399 + ceil32(return_data.size)] = _1466
        require _1455 + _1466 + 32 <= return_data.size
        mem[_1399 + ceil32(return_data.size) + 32 len ceil32(_1466)] = mem[_1399 + _1455 + 32 len ceil32(_1466)]
        if ceil32(_1466) > _1466:
            mem[_1399 + ceil32(return_data.size) + _1466 + 32] = 0
        mem[mem[64]] = 32
        mem[mem[64] + 32] = _1466
        mem[mem[64] + 64 len ceil32(_1466)] = mem[_1399 + ceil32(return_data.size) + 32 len ceil32(_1466)]
        if ceil32(_1466) > _1466:
            mem[mem[64] + _1466 + 64] = 0
        return Array(len=_1466, data=mem[mem[64] + 64 len ceil32(_1466)])
    if bool(stor[_606].field_0) == stor[_606].field_1 % 128 < 32:
        revert with 0, 34
    if not stor[_606].field_1 % 128:
        mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
        mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_606])
        mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + 197] = msg.sender
        require ext_code.size(address(stor1[_606]))
        staticcall address(stor1[_606])._isNodeOwner(address arg1) with:
                gas gas_remaining wei
               args msg.sender
        mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + 193] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == bool(ext_call.return_data[0])
        if not ext_call.return_data[0]:
            revert with 0, 'NO NODE OWNER'
        mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193] = 0xc92819ce00000000000000000000000000000000000000000000000000000000
        mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 197] = msg.sender
        require ext_code.size(address(stor1[_606]))
        staticcall address(stor1[_606])._getNodesCreationTime(address arg1) with:
                gas gas_remaining wei
               args msg.sender
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193 len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + (2 * ceil32(return_data.size)) + 193
        require return_data.size >= 32
        _867 = mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32
        require mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 <= test266151307()
        require ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + return_data.size + 193 > ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 224
        _889 = mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193]
        if mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193] > test266151307():
            revert with 0, 65
        if ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 1 < 0 or ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + (2 * ceil32(return_data.size)) + ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 194 > test266151307():
            revert with 0, 65
        mem[64] = ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + (2 * ceil32(return_data.size)) + ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 194
        mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + (2 * ceil32(return_data.size)) + 193] = _889
        require _867 + _889 + 32 <= return_data.size
        mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + (2 * ceil32(return_data.size)) + 225 len ceil32(_889)] = mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + _867 + 225 len ceil32(_889)]
        if ceil32(_889) > _889:
            mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + (2 * ceil32(return_data.size)) + _889 + 225] = 0
        mem[mem[64]] = 32
        mem[mem[64] + 32] = _889
        mem[mem[64] + 64 len ceil32(_889)] = mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + (2 * ceil32(return_data.size)) + 225 len ceil32(_889)]
        if ceil32(_889) > _889:
            mem[mem[64] + _889 + 64] = 0
        return Array(len=_889, data=mem[mem[64] + 64 len ceil32(_889)])
    if 31 >= stor[_606].field_1 % 128:
        mem[ceil32(ceil32(arg1.length)) + 193] = 256 * Mask(248, 0, stor[_606].field_8)
        mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
        mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_606])
        mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + 197] = msg.sender
        require ext_code.size(address(stor1[_606]))
        staticcall address(stor1[_606])._isNodeOwner(address arg1) with:
                gas gas_remaining wei
               args msg.sender
        mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + 193] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == bool(ext_call.return_data[0])
        if not ext_call.return_data[0]:
            revert with 0, 'NO NODE OWNER'
        mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193] = 0xc92819ce00000000000000000000000000000000000000000000000000000000
        mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 197] = msg.sender
        require ext_code.size(address(stor1[_606]))
        staticcall address(stor1[_606])._getNodesCreationTime(address arg1) with:
                gas gas_remaining wei
               args msg.sender
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193 len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + (2 * ceil32(return_data.size)) + 193
        require return_data.size >= 32
        _891 = mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32
        require mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 <= test266151307()
        require ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + return_data.size + 193 > ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 224
        _907 = mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193]
        if mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193] > test266151307():
            revert with 0, 65
        if ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 1 < 0 or ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + (2 * ceil32(return_data.size)) + ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 194 > test266151307():
            revert with 0, 65
        mem[64] = ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + (2 * ceil32(return_data.size)) + ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 194
        mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + (2 * ceil32(return_data.size)) + 193] = _907
        require _891 + _907 + 32 <= return_data.size
        mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + (2 * ceil32(return_data.size)) + 225 len ceil32(_907)] = mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + _891 + 225 len ceil32(_907)]
        if ceil32(_907) > _907:
            mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + (2 * ceil32(return_data.size)) + _907 + 225] = 0
        mem[mem[64]] = 32
        mem[mem[64] + 32] = _907
        mem[mem[64] + 64 len ceil32(_907)] = mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + (2 * ceil32(return_data.size)) + 225 len ceil32(_907)]
        if ceil32(_907) > _907:
            mem[mem[64] + _907 + 64] = 0
        return Array(len=_907, data=mem[mem[64] + 64 len ceil32(_907)])
    mem[0] = _606
    mem[ceil32(ceil32(arg1.length)) + 193] = uint256(stor[sha3(_606)].field_0)
    idx = ceil32(ceil32(arg1.length)) + 193
    s = 0
    while ceil32(ceil32(arg1.length)) + stor[_606].field_1 % 128 + 161 > idx:
        mem[idx + 32] = uint256(stor[s + sha3(_606) + 1].field_0)
        idx = idx + 32
        s = s + 1
        continue 
    mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
    mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_606])
    mem[mem[64] + 4] = msg.sender
    require ext_code.size(address(stor1[_606]))
    staticcall address(stor1[_606])._isNodeOwner(address arg1) with:
            gas gas_remaining wei
           args msg.sender
    mem[mem[64]] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _1243 = mem[64]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    require mem[_1243] == bool(mem[_1243])
    if not mem[_1243]:
        revert with 0, 'NO NODE OWNER'
    mem[mem[64]] = 0xc92819ce00000000000000000000000000000000000000000000000000000000
    mem[mem[64] + 4] = msg.sender
    require ext_code.size(address(stor1[_606]))
    staticcall address(stor1[_606])._getNodesCreationTime(address arg1) with:
            gas gas_remaining wei
           args msg.sender
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _1402 = mem[64]
    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    _1458 = mem[_1402]
    require mem[_1402] <= test266151307()
    require _1402 + return_data.size > _1402 + mem[_1402] + 31
    _1467 = mem[_1402 + mem[_1402]]
    if mem[_1402 + mem[_1402]] > test266151307():
        revert with 0, 65
    if ceil32(ceil32(mem[_1402 + mem[_1402]])) + 1 < 0 or _1402 + ceil32(return_data.size) + ceil32(ceil32(mem[_1402 + mem[_1402]])) + 1 > test266151307():
        revert with 0, 65
    mem[64] = _1402 + ceil32(return_data.size) + ceil32(ceil32(mem[_1402 + mem[_1402]])) + 1
    mem[_1402 + ceil32(return_data.size)] = _1467
    require _1458 + _1467 + 32 <= return_data.size
    mem[_1402 + ceil32(return_data.size) + 32 len ceil32(_1467)] = mem[_1402 + _1458 + 32 len ceil32(_1467)]
    if ceil32(_1467) <= _1467:
        _1641 = mem[64]
        mem[mem[64]] = 32
        mem[mem[64] + 32] = _1467
        mem[mem[64] + 64 len ceil32(_1467)] = mem[_1402 + ceil32(return_data.size) + 32 len ceil32(_1467)]
        if ceil32(_1467) <= _1467:
            return Array(len=_1467, data=mem[mem[64] + 64 len ceil32(_1467)])
        mem[mem[64] + _1467 + 64] = 0
        return memory
          from mem[64]
           len ceil32(_1467) + _1641 + -mem[64] + 64
    mem[_1402 + ceil32(return_data.size) + _1467 + 32] = 0
    _1681 = mem[64]
    mem[mem[64]] = 32
    mem[mem[64] + 32] = _1467
    mem[mem[64] + 64 len ceil32(_1467)] = mem[_1402 + ceil32(return_data.size) + 32 len ceil32(_1467)]
    if ceil32(_1467) <= _1467:
        return Array(len=_1467, data=mem[mem[64] + 64 len ceil32(_1467)])
    mem[mem[64] + _1467 + 64] = 0
    return memory
      from mem[64]
       len ceil32(_1467) + _1681 + -mem[64] + 64
}

function sub_a6e45e27(?) {
    require calldata.size - 4 >= 32
    require arg1 <= test266151307()
    require arg1 + 35 < calldata.size
    if arg1.length > test266151307():
        revert with 0, 65
    if ceil32(ceil32(arg1.length)) + 97 < 96 or ceil32(ceil32(arg1.length)) + 97 > test266151307():
        revert with 0, 65
    mem[96] = arg1.length
    require arg1 + arg1.length + 36 <= calldata.size
    mem[128 len arg1.length] = arg1[all]
    mem[arg1.length + 128] = 0
    if not msg.sender:
        revert with 0, 'SENDER CAN'T BE ZERO'
    mem[ceil32(ceil32(arg1.length)) + 97 len ceil32(arg1.length)] = arg1[all], mem[arg1.length + 128 len ceil32(arg1.length) - arg1.length]
    mem[arg1.length + ceil32(ceil32(arg1.length)) + 97] = 24
    if ceil32(arg1.length) <= arg1.length:
        _603 = sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])
        if bool(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0):
            if bool(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0) == uint255(uint256(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0)) * 0.5 < 32:
                revert with 0, 34
            mem[64] = ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0)) * 0.5) + 193
            mem[ceil32(ceil32(arg1.length)) + 161] = uint255(uint256(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0)) * 0.5
            if bool(stor[_603].field_0):
                if bool(stor[_603].field_0) == uint255(uint256(stor[_603].field_0)) * 0.5 < 32:
                    revert with 0, 34
                if not Mask(256, -1, uint256(stor[_603].field_0)):
                    mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
                    mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_603])
                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + 197] = msg.sender
                    require ext_code.size(address(stor1[_603]))
                    staticcall address(stor1[_603])._isNodeOwner(address arg1) with:
                            gas gas_remaining wei
                           args msg.sender
                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + 193] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                    if not ext_call.return_data[0]:
                        revert with 0, 'NO NODE OWNER'
                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193] = 0x5759fb0200000000000000000000000000000000000000000000000000000000
                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 197] = msg.sender
                    require ext_code.size(address(stor1[_603]))
                    staticcall address(stor1[_603])._getNodesLastClaimTime(address arg1) with:
                            gas gas_remaining wei
                           args msg.sender
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 193
                    require return_data.size >= 32
                    _792 = mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32
                    require mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 <= test266151307()
                    require ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + return_data.size + 193 > ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 224
                    _835 = mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193]
                    if mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193] > test266151307():
                        revert with 0, 65
                    if ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 1 < 0 or ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 194 > test266151307():
                        revert with 0, 65
                    mem[64] = ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 194
                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 193] = _835
                    require _792 + _835 + 32 <= return_data.size
                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 225 len ceil32(_835)] = mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + _792 + 225 len ceil32(_835)]
                    if ceil32(_835) <= _835:
                        _1244 = mem[64]
                        mem[mem[64]] = 32
                        mem[mem[64] + 32] = _835
                        mem[mem[64] + 64 len ceil32(_835)] = mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 225 len ceil32(_835)]
                        if ceil32(_835) <= _835:
                            return Array(len=_835, data=mem[mem[64] + 64 len ceil32(_835)])
                        mem[mem[64] + _835 + 64] = 0
                        return memory
                          from mem[64]
                           len ceil32(_835) + _1244 + -mem[64] + 64
                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + _835 + 225] = 0
                    _1260 = mem[64]
                    mem[mem[64]] = 32
                    mem[mem[64] + 32] = _835
                    mem[mem[64] + 64 len ceil32(_835)] = mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 225 len ceil32(_835)]
                    if ceil32(_835) <= _835:
                        return Array(len=_835, data=mem[mem[64] + 64 len ceil32(_835)])
                    mem[mem[64] + _835 + 64] = 0
                    return memory
                      from mem[64]
                       len ceil32(_835) + _1260 + -mem[64] + 64
                if 31 >= uint255(uint256(stor[_603].field_0)) * 0.5:
                    mem[ceil32(ceil32(arg1.length)) + 193] = 256 * Mask(248, 0, stor[_603].field_8)
                    mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
                    mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_603])
                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + 197] = msg.sender
                    require ext_code.size(address(stor1[_603]))
                    staticcall address(stor1[_603])._isNodeOwner(address arg1) with:
                            gas gas_remaining wei
                           args msg.sender
                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + 193] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                    if not ext_call.return_data[0]:
                        revert with 0, 'NO NODE OWNER'
                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193] = 0x5759fb0200000000000000000000000000000000000000000000000000000000
                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 197] = msg.sender
                    require ext_code.size(address(stor1[_603]))
                    staticcall address(stor1[_603])._getNodesLastClaimTime(address arg1) with:
                            gas gas_remaining wei
                           args msg.sender
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 193
                    require return_data.size >= 32
                    _837 = mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32
                    require mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 <= test266151307()
                    require ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + return_data.size + 193 > ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 224
                    _872 = mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193]
                    if mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193] > test266151307():
                        revert with 0, 65
                    if ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 1 < 0 or ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 194 > test266151307():
                        revert with 0, 65
                    mem[64] = ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 194
                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 193] = _872
                    require _837 + _872 + 32 <= return_data.size
                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 225 len ceil32(_872)] = mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + _837 + 225 len ceil32(_872)]
                    if ceil32(_872) > _872:
                        mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + _872 + 225] = 0
                    mem[mem[64]] = 32
                    mem[mem[64] + 32] = _872
                    mem[mem[64] + 64 len ceil32(_872)] = mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 225 len ceil32(_872)]
                    if ceil32(_872) > _872:
                        mem[mem[64] + _872 + 64] = 0
                    return Array(len=_872, data=mem[mem[64] + 64 len ceil32(_872)])
                mem[0] = _603
                mem[ceil32(ceil32(arg1.length)) + 193] = uint256(stor[sha3(_603)].field_0)
                idx = ceil32(ceil32(arg1.length)) + 193
                s = 0
                while ceil32(ceil32(arg1.length)) + (uint255(uint256(stor[_603].field_0)) * 0.5) + 161 > idx:
                    mem[idx + 32] = uint256(stor[s + sha3(_603) + 1].field_0)
                    idx = idx + 32
                    s = s + 1
                    continue 
                mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
                mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_603])
                mem[mem[64] + 4] = msg.sender
                require ext_code.size(address(stor1[_603]))
                staticcall address(stor1[_603])._isNodeOwner(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1236 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_1236] == bool(mem[_1236])
                if not mem[_1236]:
                    revert with 0, 'NO NODE OWNER'
                mem[mem[64]] = 0x5759fb0200000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = msg.sender
                require ext_code.size(address(stor1[_603]))
                staticcall address(stor1[_603])._getNodesLastClaimTime(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1381 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _1437 = mem[_1381]
                require mem[_1381] <= test266151307()
                require _1381 + return_data.size > _1381 + mem[_1381] + 31
                _1460 = mem[_1381 + mem[_1381]]
                if mem[_1381 + mem[_1381]] > test266151307():
                    revert with 0, 65
                if ceil32(ceil32(mem[_1381 + mem[_1381]])) + 1 < 0 or _1381 + ceil32(return_data.size) + ceil32(ceil32(mem[_1381 + mem[_1381]])) + 1 > test266151307():
                    revert with 0, 65
                mem[64] = _1381 + ceil32(return_data.size) + ceil32(ceil32(mem[_1381 + mem[_1381]])) + 1
                mem[_1381 + ceil32(return_data.size)] = _1460
                require _1437 + _1460 + 32 <= return_data.size
                mem[_1381 + ceil32(return_data.size) + 32 len ceil32(_1460)] = mem[_1381 + _1437 + 32 len ceil32(_1460)]
                if ceil32(_1460) > _1460:
                    mem[_1381 + ceil32(return_data.size) + _1460 + 32] = 0
                mem[mem[64]] = 32
                mem[mem[64] + 32] = _1460
                mem[mem[64] + 64 len ceil32(_1460)] = mem[_1381 + ceil32(return_data.size) + 32 len ceil32(_1460)]
                if ceil32(_1460) > _1460:
                    mem[mem[64] + _1460 + 64] = 0
                return Array(len=_1460, data=mem[mem[64] + 64 len ceil32(_1460)])
            if bool(stor[_603].field_0) == stor[_603].field_1 % 128 < 32:
                revert with 0, 34
            if not stor[_603].field_1 % 128:
                mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
                mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_603])
                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + 197] = msg.sender
                require ext_code.size(address(stor1[_603]))
                staticcall address(stor1[_603])._isNodeOwner(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + 193] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                if not ext_call.return_data[0]:
                    revert with 0, 'NO NODE OWNER'
                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193] = 0x5759fb0200000000000000000000000000000000000000000000000000000000
                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 197] = msg.sender
                require ext_code.size(address(stor1[_603]))
                staticcall address(stor1[_603])._getNodesLastClaimTime(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 193
                require return_data.size >= 32
                _814 = mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32
                require mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 <= test266151307()
                require ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + return_data.size + 193 > ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 224
                _855 = mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193]
                if mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193] > test266151307():
                    revert with 0, 65
                if ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 1 < 0 or ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 194 > test266151307():
                    revert with 0, 65
                mem[64] = ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 194
                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 193] = _855
                require _814 + _855 + 32 <= return_data.size
                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 225 len ceil32(_855)] = mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + _814 + 225 len ceil32(_855)]
                if ceil32(_855) > _855:
                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + _855 + 225] = 0
                mem[mem[64]] = 32
                mem[mem[64] + 32] = _855
                mem[mem[64] + 64 len ceil32(_855)] = mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 225 len ceil32(_855)]
                if ceil32(_855) > _855:
                    mem[mem[64] + _855 + 64] = 0
                return Array(len=_855, data=mem[mem[64] + 64 len ceil32(_855)])
            if 31 >= stor[_603].field_1 % 128:
                mem[ceil32(ceil32(arg1.length)) + 193] = 256 * Mask(248, 0, stor[_603].field_8)
                mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
                mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_603])
                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + 197] = msg.sender
                require ext_code.size(address(stor1[_603]))
                staticcall address(stor1[_603])._isNodeOwner(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + 193] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                if not ext_call.return_data[0]:
                    revert with 0, 'NO NODE OWNER'
                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193] = 0x5759fb0200000000000000000000000000000000000000000000000000000000
                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 197] = msg.sender
                require ext_code.size(address(stor1[_603]))
                staticcall address(stor1[_603])._getNodesLastClaimTime(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 193
                require return_data.size >= 32
                _857 = mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32
                require mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 <= test266151307()
                require ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + return_data.size + 193 > ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 224
                _884 = mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193]
                if mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193] > test266151307():
                    revert with 0, 65
                if ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 1 < 0 or ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 194 > test266151307():
                    revert with 0, 65
                mem[64] = ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 194
                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 193] = _884
                require _857 + _884 + 32 <= return_data.size
                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 225 len ceil32(_884)] = mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + ceil32(return_data.size) + _857 + 225 len ceil32(_884)]
                if ceil32(_884) <= _884:
                    _1247 = mem[64]
                    mem[mem[64]] = 32
                    mem[mem[64] + 32] = _884
                    mem[mem[64] + 64 len ceil32(_884)] = mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 225 len ceil32(_884)]
                    if ceil32(_884) <= _884:
                        return Array(len=_884, data=mem[mem[64] + 64 len ceil32(_884)])
                    mem[mem[64] + _884 + 64] = 0
                    return memory
                      from mem[64]
                       len ceil32(_884) + _1247 + -mem[64] + 64
                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + _884 + 225] = 0
                _1265 = mem[64]
                mem[mem[64]] = 32
                mem[mem[64] + 32] = _884
                mem[mem[64] + 64 len ceil32(_884)] = mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_603].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 225 len ceil32(_884)]
                if ceil32(_884) <= _884:
                    return Array(len=_884, data=mem[mem[64] + 64 len ceil32(_884)])
                mem[mem[64] + _884 + 64] = 0
                return memory
                  from mem[64]
                   len ceil32(_884) + _1265 + -mem[64] + 64
            mem[0] = _603
            mem[ceil32(ceil32(arg1.length)) + 193] = uint256(stor[sha3(_603)].field_0)
            idx = ceil32(ceil32(arg1.length)) + 193
            s = 0
            while ceil32(ceil32(arg1.length)) + stor[_603].field_1 % 128 + 161 > idx:
                mem[idx + 32] = uint256(stor[s + sha3(_603) + 1].field_0)
                idx = idx + 32
                s = s + 1
                continue 
            mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
            mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_603])
            mem[mem[64] + 4] = msg.sender
            require ext_code.size(address(stor1[_603]))
            staticcall address(stor1[_603])._isNodeOwner(address arg1) with:
                    gas gas_remaining wei
                   args msg.sender
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1237 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_1237] == bool(mem[_1237])
            if not mem[_1237]:
                revert with 0, 'NO NODE OWNER'
            mem[mem[64]] = 0x5759fb0200000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = msg.sender
            require ext_code.size(address(stor1[_603]))
            staticcall address(stor1[_603])._getNodesLastClaimTime(address arg1) with:
                    gas gas_remaining wei
                   args msg.sender
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1384 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _1440 = mem[_1384]
            require mem[_1384] <= test266151307()
            require _1384 + return_data.size > _1384 + mem[_1384] + 31
            _1461 = mem[_1384 + mem[_1384]]
            if mem[_1384 + mem[_1384]] > test266151307():
                revert with 0, 65
            if ceil32(ceil32(mem[_1384 + mem[_1384]])) + 1 < 0 or _1384 + ceil32(return_data.size) + ceil32(ceil32(mem[_1384 + mem[_1384]])) + 1 > test266151307():
                revert with 0, 65
            mem[64] = _1384 + ceil32(return_data.size) + ceil32(ceil32(mem[_1384 + mem[_1384]])) + 1
            mem[_1384 + ceil32(return_data.size)] = _1461
            require _1440 + _1461 + 32 <= return_data.size
            mem[_1384 + ceil32(return_data.size) + 32 len ceil32(_1461)] = mem[_1384 + _1440 + 32 len ceil32(_1461)]
            if ceil32(_1461) > _1461:
                mem[_1384 + ceil32(return_data.size) + _1461 + 32] = 0
            mem[mem[64]] = 32
            mem[mem[64] + 32] = _1461
            mem[mem[64] + 64 len ceil32(_1461)] = mem[_1384 + ceil32(return_data.size) + 32 len ceil32(_1461)]
            if ceil32(_1461) > _1461:
                mem[mem[64] + _1461 + 64] = 0
            return Array(len=_1461, data=mem[mem[64] + 64 len ceil32(_1461)])
        if bool(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0) == stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_1 % 128 < 32:
            revert with 0, 34
        mem[64] = ceil32(ceil32(arg1.length)) + ceil32(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_1 % 128) + 193
        mem[ceil32(ceil32(arg1.length)) + 161] = stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_1 % 128
        if bool(stor[_603].field_0):
            if bool(stor[_603].field_0) == uint255(uint256(stor[_603].field_0)) * 0.5 < 32:
                revert with 0, 34
            if not Mask(256, -1, uint256(stor[_603].field_0)):
                mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
                mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_603])
                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + 197] = msg.sender
                require ext_code.size(address(stor1[_603]))
                staticcall address(stor1[_603])._isNodeOwner(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + 193] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                if not ext_call.return_data[0]:
                    revert with 0, 'NO NODE OWNER'
                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193] = 0x5759fb0200000000000000000000000000000000000000000000000000000000
                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 197] = msg.sender
                require ext_code.size(address(stor1[_603]))
                staticcall address(stor1[_603])._getNodesLastClaimTime(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + (2 * ceil32(return_data.size)) + 193
                require return_data.size >= 32
                _818 = mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32
                require mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 <= test266151307()
                require ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + return_data.size + 193 > ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 224
                _858 = mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193]
                if mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193] > test266151307():
                    revert with 0, 65
                if ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 1 < 0 or ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + (2 * ceil32(return_data.size)) + ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 194 > test266151307():
                    revert with 0, 65
                mem[64] = ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + (2 * ceil32(return_data.size)) + ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 194
                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + (2 * ceil32(return_data.size)) + 193] = _858
                require _818 + _858 + 32 <= return_data.size
                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + (2 * ceil32(return_data.size)) + 225 len ceil32(_858)] = mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + _818 + 225 len ceil32(_858)]
                if ceil32(_858) > _858:
                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + (2 * ceil32(return_data.size)) + _858 + 225] = 0
                mem[mem[64]] = 32
                mem[mem[64] + 32] = _858
                mem[mem[64] + 64 len ceil32(_858)] = mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + (2 * ceil32(return_data.size)) + 225 len ceil32(_858)]
                if ceil32(_858) > _858:
                    mem[mem[64] + _858 + 64] = 0
                return Array(len=_858, data=mem[mem[64] + 64 len ceil32(_858)])
            if 31 >= uint255(uint256(stor[_603].field_0)) * 0.5:
                mem[ceil32(ceil32(arg1.length)) + 193] = 256 * Mask(248, 0, stor[_603].field_8)
                mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
                mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_603])
                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + 197] = msg.sender
                require ext_code.size(address(stor1[_603]))
                staticcall address(stor1[_603])._isNodeOwner(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + 193] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                if not ext_call.return_data[0]:
                    revert with 0, 'NO NODE OWNER'
                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193] = 0x5759fb0200000000000000000000000000000000000000000000000000000000
                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 197] = msg.sender
                require ext_code.size(address(stor1[_603]))
                staticcall address(stor1[_603])._getNodesLastClaimTime(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + (2 * ceil32(return_data.size)) + 193
                require return_data.size >= 32
                _860 = mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32
                require mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 <= test266151307()
                require ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + return_data.size + 193 > ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 224
                _886 = mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193]
                if mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193] > test266151307():
                    revert with 0, 65
                if ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 1 < 0 or ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + (2 * ceil32(return_data.size)) + ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 194 > test266151307():
                    revert with 0, 65
                mem[64] = ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + (2 * ceil32(return_data.size)) + ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 194
                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + (2 * ceil32(return_data.size)) + 193] = _886
                require _860 + _886 + 32 <= return_data.size
                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + (2 * ceil32(return_data.size)) + 225 len ceil32(_886)] = mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + _860 + 225 len ceil32(_886)]
                if ceil32(_886) > _886:
                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + (2 * ceil32(return_data.size)) + _886 + 225] = 0
                mem[mem[64]] = 32
                mem[mem[64] + 32] = _886
                mem[mem[64] + 64 len ceil32(_886)] = mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + (2 * ceil32(return_data.size)) + 225 len ceil32(_886)]
                if ceil32(_886) > _886:
                    mem[mem[64] + _886 + 64] = 0
                return Array(len=_886, data=mem[mem[64] + 64 len ceil32(_886)])
            mem[0] = _603
            mem[ceil32(ceil32(arg1.length)) + 193] = uint256(stor[sha3(_603)].field_0)
            idx = ceil32(ceil32(arg1.length)) + 193
            s = 0
            while ceil32(ceil32(arg1.length)) + (uint255(uint256(stor[_603].field_0)) * 0.5) + 161 > idx:
                mem[idx + 32] = uint256(stor[s + sha3(_603) + 1].field_0)
                idx = idx + 32
                s = s + 1
                continue 
            mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
            mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_603])
            mem[mem[64] + 4] = msg.sender
            require ext_code.size(address(stor1[_603]))
            staticcall address(stor1[_603])._isNodeOwner(address arg1) with:
                    gas gas_remaining wei
                   args msg.sender
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1238 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_1238] == bool(mem[_1238])
            if not mem[_1238]:
                revert with 0, 'NO NODE OWNER'
            mem[mem[64]] = 0x5759fb0200000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = msg.sender
            require ext_code.size(address(stor1[_603]))
            staticcall address(stor1[_603])._getNodesLastClaimTime(address arg1) with:
                    gas gas_remaining wei
                   args msg.sender
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1387 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _1443 = mem[_1387]
            require mem[_1387] <= test266151307()
            require _1387 + return_data.size > _1387 + mem[_1387] + 31
            _1462 = mem[_1387 + mem[_1387]]
            if mem[_1387 + mem[_1387]] > test266151307():
                revert with 0, 65
            if ceil32(ceil32(mem[_1387 + mem[_1387]])) + 1 < 0 or _1387 + ceil32(return_data.size) + ceil32(ceil32(mem[_1387 + mem[_1387]])) + 1 > test266151307():
                revert with 0, 65
            mem[64] = _1387 + ceil32(return_data.size) + ceil32(ceil32(mem[_1387 + mem[_1387]])) + 1
            mem[_1387 + ceil32(return_data.size)] = _1462
            require _1443 + _1462 + 32 <= return_data.size
            mem[_1387 + ceil32(return_data.size) + 32 len ceil32(_1462)] = mem[_1387 + _1443 + 32 len ceil32(_1462)]
            if ceil32(_1462) > _1462:
                mem[_1387 + ceil32(return_data.size) + _1462 + 32] = 0
            mem[mem[64]] = 32
            mem[mem[64] + 32] = _1462
            mem[mem[64] + 64 len ceil32(_1462)] = mem[_1387 + ceil32(return_data.size) + 32 len ceil32(_1462)]
            if ceil32(_1462) > _1462:
                mem[mem[64] + _1462 + 64] = 0
            return Array(len=_1462, data=mem[mem[64] + 64 len ceil32(_1462)])
        if bool(stor[_603].field_0) == stor[_603].field_1 % 128 < 32:
            revert with 0, 34
        if not stor[_603].field_1 % 128:
            mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
            mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_603])
            mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + 197] = msg.sender
            require ext_code.size(address(stor1[_603]))
            staticcall address(stor1[_603])._isNodeOwner(address arg1) with:
                    gas gas_remaining wei
                   args msg.sender
            mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + 193] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == bool(ext_call.return_data[0])
            if not ext_call.return_data[0]:
                revert with 0, 'NO NODE OWNER'
            mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193] = 0x5759fb0200000000000000000000000000000000000000000000000000000000
            mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 197] = msg.sender
            require ext_code.size(address(stor1[_603]))
            staticcall address(stor1[_603])._getNodesLastClaimTime(address arg1) with:
                    gas gas_remaining wei
                   args msg.sender
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + (2 * ceil32(return_data.size)) + 193
            require return_data.size >= 32
            _840 = mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32
            require mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 <= test266151307()
            require ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + return_data.size + 193 > ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 224
            _873 = mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193]
            if mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193] > test266151307():
                revert with 0, 65
            if ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 1 < 0 or ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + (2 * ceil32(return_data.size)) + ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 194 > test266151307():
                revert with 0, 65
            mem[64] = ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + (2 * ceil32(return_data.size)) + ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 194
            mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + (2 * ceil32(return_data.size)) + 193] = _873
            require _840 + _873 + 32 <= return_data.size
            mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + (2 * ceil32(return_data.size)) + 225 len ceil32(_873)] = mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + _840 + 225 len ceil32(_873)]
            if ceil32(_873) > _873:
                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + (2 * ceil32(return_data.size)) + _873 + 225] = 0
            mem[mem[64]] = 32
            mem[mem[64] + 32] = _873
            mem[mem[64] + 64 len ceil32(_873)] = mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + (2 * ceil32(return_data.size)) + 225 len ceil32(_873)]
            if ceil32(_873) > _873:
                mem[mem[64] + _873 + 64] = 0
            return Array(len=_873, data=mem[mem[64] + 64 len ceil32(_873)])
        if 31 >= stor[_603].field_1 % 128:
            mem[ceil32(ceil32(arg1.length)) + 193] = 256 * Mask(248, 0, stor[_603].field_8)
            mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
            mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_603])
            mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + 197] = msg.sender
            require ext_code.size(address(stor1[_603]))
            staticcall address(stor1[_603])._isNodeOwner(address arg1) with:
                    gas gas_remaining wei
                   args msg.sender
            mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + 193] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == bool(ext_call.return_data[0])
            if not ext_call.return_data[0]:
                revert with 0, 'NO NODE OWNER'
            mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193] = 0x5759fb0200000000000000000000000000000000000000000000000000000000
            mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 197] = msg.sender
            require ext_code.size(address(stor1[_603]))
            staticcall address(stor1[_603])._getNodesLastClaimTime(address arg1) with:
                    gas gas_remaining wei
                   args msg.sender
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + (2 * ceil32(return_data.size)) + 193
            require return_data.size >= 32
            _875 = mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32
            require mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 <= test266151307()
            require ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + return_data.size + 193 > ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 224
            _895 = mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193]
            if mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193] > test266151307():
                revert with 0, 65
            if ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 1 < 0 or ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + (2 * ceil32(return_data.size)) + ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 194 > test266151307():
                revert with 0, 65
            mem[64] = ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + (2 * ceil32(return_data.size)) + ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 194
            mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + (2 * ceil32(return_data.size)) + 193] = _895
            require _875 + _895 + 32 <= return_data.size
            mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + (2 * ceil32(return_data.size)) + 225 len ceil32(_895)] = mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + ceil32(return_data.size) + _875 + 225 len ceil32(_895)]
            if ceil32(_895) > _895:
                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + (2 * ceil32(return_data.size)) + _895 + 225] = 0
            mem[mem[64]] = 32
            mem[mem[64] + 32] = _895
            mem[mem[64] + 64 len ceil32(_895)] = mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_603].field_1 % 128) + (2 * ceil32(return_data.size)) + 225 len ceil32(_895)]
            if ceil32(_895) > _895:
                mem[mem[64] + _895 + 64] = 0
            return Array(len=_895, data=mem[mem[64] + 64 len ceil32(_895)])
        mem[0] = _603
        mem[ceil32(ceil32(arg1.length)) + 193] = uint256(stor[sha3(_603)].field_0)
        idx = ceil32(ceil32(arg1.length)) + 193
        s = 0
        while ceil32(ceil32(arg1.length)) + stor[_603].field_1 % 128 + 161 > idx:
            mem[idx + 32] = uint256(stor[s + sha3(_603) + 1].field_0)
            idx = idx + 32
            s = s + 1
            continue 
        mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
        mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_603])
        mem[mem[64] + 4] = msg.sender
        require ext_code.size(address(stor1[_603]))
        staticcall address(stor1[_603])._isNodeOwner(address arg1) with:
                gas gas_remaining wei
               args msg.sender
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _1239 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        require mem[_1239] == bool(mem[_1239])
        if not mem[_1239]:
            revert with 0, 'NO NODE OWNER'
        mem[mem[64]] = 0x5759fb0200000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = msg.sender
        require ext_code.size(address(stor1[_603]))
        staticcall address(stor1[_603])._getNodesLastClaimTime(address arg1) with:
                gas gas_remaining wei
               args msg.sender
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _1390 = mem[64]
        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _1446 = mem[_1390]
        require mem[_1390] <= test266151307()
        require _1390 + return_data.size > _1390 + mem[_1390] + 31
        _1463 = mem[_1390 + mem[_1390]]
        if mem[_1390 + mem[_1390]] > test266151307():
            revert with 0, 65
        if ceil32(ceil32(mem[_1390 + mem[_1390]])) + 1 < 0 or _1390 + ceil32(return_data.size) + ceil32(ceil32(mem[_1390 + mem[_1390]])) + 1 > test266151307():
            revert with 0, 65
        mem[64] = _1390 + ceil32(return_data.size) + ceil32(ceil32(mem[_1390 + mem[_1390]])) + 1
        mem[_1390 + ceil32(return_data.size)] = _1463
        require _1446 + _1463 + 32 <= return_data.size
        mem[_1390 + ceil32(return_data.size) + 32 len ceil32(_1463)] = mem[_1390 + _1446 + 32 len ceil32(_1463)]
        if ceil32(_1463) <= _1463:
            _1621 = mem[64]
            mem[mem[64]] = 32
            mem[mem[64] + 32] = _1463
            mem[mem[64] + 64 len ceil32(_1463)] = mem[_1390 + ceil32(return_data.size) + 32 len ceil32(_1463)]
            if ceil32(_1463) <= _1463:
                return Array(len=_1463, data=mem[mem[64] + 64 len ceil32(_1463)])
            mem[mem[64] + _1463 + 64] = 0
            return memory
              from mem[64]
               len ceil32(_1463) + _1621 + -mem[64] + 64
        mem[_1390 + ceil32(return_data.size) + _1463 + 32] = 0
        _1661 = mem[64]
        mem[mem[64]] = 32
        mem[mem[64] + 32] = _1463
        mem[mem[64] + 64 len ceil32(_1463)] = mem[_1390 + ceil32(return_data.size) + 32 len ceil32(_1463)]
        if ceil32(_1463) <= _1463:
            return Array(len=_1463, data=mem[mem[64] + 64 len ceil32(_1463)])
        mem[mem[64] + _1463 + 64] = 0
        return memory
          from mem[64]
           len ceil32(_1463) + _1661 + -mem[64] + 64
    _606 = sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])
    if bool(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0):
        if bool(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0) == uint255(uint256(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0)) * 0.5 < 32:
            revert with 0, 34
        mem[64] = ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0)) * 0.5) + 193
        mem[ceil32(ceil32(arg1.length)) + 161] = uint255(uint256(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0)) * 0.5
        if bool(stor[_606].field_0):
            if bool(stor[_606].field_0) == uint255(uint256(stor[_606].field_0)) * 0.5 < 32:
                revert with 0, 34
            if not Mask(256, -1, uint256(stor[_606].field_0)):
                mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
                mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_606])
                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + 197] = msg.sender
                require ext_code.size(address(stor1[_606]))
                staticcall address(stor1[_606])._isNodeOwner(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + 193] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                if not ext_call.return_data[0]:
                    revert with 0, 'NO NODE OWNER'
                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193] = 0x5759fb0200000000000000000000000000000000000000000000000000000000
                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 197] = msg.sender
                require ext_code.size(address(stor1[_606]))
                staticcall address(stor1[_606])._getNodesLastClaimTime(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 193
                require return_data.size >= 32
                _824 = mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32
                require mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 <= test266151307()
                require ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + return_data.size + 193 > ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 224
                _862 = mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193]
                if mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193] > test266151307():
                    revert with 0, 65
                if ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 1 < 0 or ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 194 > test266151307():
                    revert with 0, 65
                mem[64] = ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 194
                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 193] = _862
                require _824 + _862 + 32 <= return_data.size
                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 225 len ceil32(_862)] = mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + _824 + 225 len ceil32(_862)]
                if ceil32(_862) > _862:
                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + _862 + 225] = 0
                mem[mem[64]] = 32
                mem[mem[64] + 32] = _862
                mem[mem[64] + 64 len ceil32(_862)] = mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 225 len ceil32(_862)]
                if ceil32(_862) > _862:
                    mem[mem[64] + _862 + 64] = 0
                return Array(len=_862, data=mem[mem[64] + 64 len ceil32(_862)])
            if 31 >= uint255(uint256(stor[_606].field_0)) * 0.5:
                mem[ceil32(ceil32(arg1.length)) + 193] = 256 * Mask(248, 0, stor[_606].field_8)
                mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
                mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_606])
                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + 197] = msg.sender
                require ext_code.size(address(stor1[_606]))
                staticcall address(stor1[_606])._isNodeOwner(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + 193] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                if not ext_call.return_data[0]:
                    revert with 0, 'NO NODE OWNER'
                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193] = 0x5759fb0200000000000000000000000000000000000000000000000000000000
                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 197] = msg.sender
                require ext_code.size(address(stor1[_606]))
                staticcall address(stor1[_606])._getNodesLastClaimTime(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 193
                require return_data.size >= 32
                _864 = mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32
                require mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 <= test266151307()
                require ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + return_data.size + 193 > ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 224
                _888 = mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193]
                if mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193] > test266151307():
                    revert with 0, 65
                if ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 1 < 0 or ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 194 > test266151307():
                    revert with 0, 65
                mem[64] = ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 194
                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 193] = _888
                require _864 + _888 + 32 <= return_data.size
                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 225 len ceil32(_888)] = mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + _864 + 225 len ceil32(_888)]
                if ceil32(_888) > _888:
                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + _888 + 225] = 0
                mem[mem[64]] = 32
                mem[mem[64] + 32] = _888
                mem[mem[64] + 64 len ceil32(_888)] = mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 225 len ceil32(_888)]
                if ceil32(_888) > _888:
                    mem[mem[64] + _888 + 64] = 0
                return Array(len=_888, data=mem[mem[64] + 64 len ceil32(_888)])
            mem[0] = _606
            mem[ceil32(ceil32(arg1.length)) + 193] = uint256(stor[sha3(_606)].field_0)
            idx = ceil32(ceil32(arg1.length)) + 193
            s = 0
            while ceil32(ceil32(arg1.length)) + (uint255(uint256(stor[_606].field_0)) * 0.5) + 161 > idx:
                mem[idx + 32] = uint256(stor[s + sha3(_606) + 1].field_0)
                idx = idx + 32
                s = s + 1
                continue 
            mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
            mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_606])
            mem[mem[64] + 4] = msg.sender
            require ext_code.size(address(stor1[_606]))
            staticcall address(stor1[_606])._isNodeOwner(address arg1) with:
                    gas gas_remaining wei
                   args msg.sender
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1240 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_1240] == bool(mem[_1240])
            if not mem[_1240]:
                revert with 0, 'NO NODE OWNER'
            mem[mem[64]] = 0x5759fb0200000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = msg.sender
            require ext_code.size(address(stor1[_606]))
            staticcall address(stor1[_606])._getNodesLastClaimTime(address arg1) with:
                    gas gas_remaining wei
                   args msg.sender
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1393 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _1449 = mem[_1393]
            require mem[_1393] <= test266151307()
            require _1393 + return_data.size > _1393 + mem[_1393] + 31
            _1464 = mem[_1393 + mem[_1393]]
            if mem[_1393 + mem[_1393]] > test266151307():
                revert with 0, 65
            if ceil32(ceil32(mem[_1393 + mem[_1393]])) + 1 < 0 or _1393 + ceil32(return_data.size) + ceil32(ceil32(mem[_1393 + mem[_1393]])) + 1 > test266151307():
                revert with 0, 65
            mem[64] = _1393 + ceil32(return_data.size) + ceil32(ceil32(mem[_1393 + mem[_1393]])) + 1
            mem[_1393 + ceil32(return_data.size)] = _1464
            require _1449 + _1464 + 32 <= return_data.size
            mem[_1393 + ceil32(return_data.size) + 32 len ceil32(_1464)] = mem[_1393 + _1449 + 32 len ceil32(_1464)]
            if ceil32(_1464) > _1464:
                mem[_1393 + ceil32(return_data.size) + _1464 + 32] = 0
            mem[mem[64]] = 32
            mem[mem[64] + 32] = _1464
            mem[mem[64] + 64 len ceil32(_1464)] = mem[_1393 + ceil32(return_data.size) + 32 len ceil32(_1464)]
            if ceil32(_1464) > _1464:
                mem[mem[64] + _1464 + 64] = 0
            return Array(len=_1464, data=mem[mem[64] + 64 len ceil32(_1464)])
        if bool(stor[_606].field_0) == stor[_606].field_1 % 128 < 32:
            revert with 0, 34
        if not stor[_606].field_1 % 128:
            mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
            mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_606])
            mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + 197] = msg.sender
            require ext_code.size(address(stor1[_606]))
            staticcall address(stor1[_606])._isNodeOwner(address arg1) with:
                    gas gas_remaining wei
                   args msg.sender
            mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + 193] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == bool(ext_call.return_data[0])
            if not ext_call.return_data[0]:
                revert with 0, 'NO NODE OWNER'
            mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193] = 0x5759fb0200000000000000000000000000000000000000000000000000000000
            mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 197] = msg.sender
            require ext_code.size(address(stor1[_606]))
            staticcall address(stor1[_606])._getNodesLastClaimTime(address arg1) with:
                    gas gas_remaining wei
                   args msg.sender
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 193
            require return_data.size >= 32
            _845 = mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32
            require mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 <= test266151307()
            require ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + return_data.size + 193 > ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 224
            _876 = mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193]
            if mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193] > test266151307():
                revert with 0, 65
            if ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 1 < 0 or ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 194 > test266151307():
                revert with 0, 65
            mem[64] = ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 194
            mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 193] = _876
            require _845 + _876 + 32 <= return_data.size
            mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 225 len ceil32(_876)] = mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + _845 + 225 len ceil32(_876)]
            if ceil32(_876) > _876:
                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + _876 + 225] = 0
            mem[mem[64]] = 32
            mem[mem[64] + 32] = _876
            mem[mem[64] + 64 len ceil32(_876)] = mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 225 len ceil32(_876)]
            if ceil32(_876) > _876:
                mem[mem[64] + _876 + 64] = 0
            return Array(len=_876, data=mem[mem[64] + 64 len ceil32(_876)])
        if 31 >= stor[_606].field_1 % 128:
            mem[ceil32(ceil32(arg1.length)) + 193] = 256 * Mask(248, 0, stor[_606].field_8)
            mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
            mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_606])
            mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + 197] = msg.sender
            require ext_code.size(address(stor1[_606]))
            staticcall address(stor1[_606])._isNodeOwner(address arg1) with:
                    gas gas_remaining wei
                   args msg.sender
            mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + 193] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == bool(ext_call.return_data[0])
            if not ext_call.return_data[0]:
                revert with 0, 'NO NODE OWNER'
            mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193] = 0x5759fb0200000000000000000000000000000000000000000000000000000000
            mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 197] = msg.sender
            require ext_code.size(address(stor1[_606]))
            staticcall address(stor1[_606])._getNodesLastClaimTime(address arg1) with:
                    gas gas_remaining wei
                   args msg.sender
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 193
            require return_data.size >= 32
            _878 = mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32
            require mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 <= test266151307()
            require ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + return_data.size + 193 > ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 224
            _897 = mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193]
            if mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193] > test266151307():
                revert with 0, 65
            if ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 1 < 0 or ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 194 > test266151307():
                revert with 0, 65
            mem[64] = ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 194
            mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 193] = _897
            require _878 + _897 + 32 <= return_data.size
            mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 225 len ceil32(_897)] = mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + ceil32(return_data.size) + _878 + 225 len ceil32(_897)]
            if ceil32(_897) > _897:
                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + _897 + 225] = 0
            mem[mem[64]] = 32
            mem[mem[64] + 32] = _897
            mem[mem[64] + 64 len ceil32(_897)] = mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_606].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 225 len ceil32(_897)]
            if ceil32(_897) > _897:
                mem[mem[64] + _897 + 64] = 0
            return Array(len=_897, data=mem[mem[64] + 64 len ceil32(_897)])
        mem[0] = _606
        mem[ceil32(ceil32(arg1.length)) + 193] = uint256(stor[sha3(_606)].field_0)
        idx = ceil32(ceil32(arg1.length)) + 193
        s = 0
        while ceil32(ceil32(arg1.length)) + stor[_606].field_1 % 128 + 161 > idx:
            mem[idx + 32] = uint256(stor[s + sha3(_606) + 1].field_0)
            idx = idx + 32
            s = s + 1
            continue 
        mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
        mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_606])
        mem[mem[64] + 4] = msg.sender
        require ext_code.size(address(stor1[_606]))
        staticcall address(stor1[_606])._isNodeOwner(address arg1) with:
                gas gas_remaining wei
               args msg.sender
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _1241 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        require mem[_1241] == bool(mem[_1241])
        if not mem[_1241]:
            revert with 0, 'NO NODE OWNER'
        mem[mem[64]] = 0x5759fb0200000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = msg.sender
        require ext_code.size(address(stor1[_606]))
        staticcall address(stor1[_606])._getNodesLastClaimTime(address arg1) with:
                gas gas_remaining wei
               args msg.sender
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _1396 = mem[64]
        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _1452 = mem[_1396]
        require mem[_1396] <= test266151307()
        require _1396 + return_data.size > _1396 + mem[_1396] + 31
        _1465 = mem[_1396 + mem[_1396]]
        if mem[_1396 + mem[_1396]] > test266151307():
            revert with 0, 65
        if ceil32(ceil32(mem[_1396 + mem[_1396]])) + 1 < 0 or _1396 + ceil32(return_data.size) + ceil32(ceil32(mem[_1396 + mem[_1396]])) + 1 > test266151307():
            revert with 0, 65
        mem[64] = _1396 + ceil32(return_data.size) + ceil32(ceil32(mem[_1396 + mem[_1396]])) + 1
        mem[_1396 + ceil32(return_data.size)] = _1465
        require _1452 + _1465 + 32 <= return_data.size
        mem[_1396 + ceil32(return_data.size) + 32 len ceil32(_1465)] = mem[_1396 + _1452 + 32 len ceil32(_1465)]
        if ceil32(_1465) > _1465:
            mem[_1396 + ceil32(return_data.size) + _1465 + 32] = 0
        mem[mem[64]] = 32
        mem[mem[64] + 32] = _1465
        mem[mem[64] + 64 len ceil32(_1465)] = mem[_1396 + ceil32(return_data.size) + 32 len ceil32(_1465)]
        if ceil32(_1465) > _1465:
            mem[mem[64] + _1465 + 64] = 0
        return Array(len=_1465, data=mem[mem[64] + 64 len ceil32(_1465)])
    if bool(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0) == stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_1 % 128 < 32:
        revert with 0, 34
    mem[64] = ceil32(ceil32(arg1.length)) + ceil32(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_1 % 128) + 193
    mem[ceil32(ceil32(arg1.length)) + 161] = stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_1 % 128
    if bool(stor[_606].field_0):
        if bool(stor[_606].field_0) == uint255(uint256(stor[_606].field_0)) * 0.5 < 32:
            revert with 0, 34
        if not Mask(256, -1, uint256(stor[_606].field_0)):
            mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
            mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_606])
            mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + 197] = msg.sender
            require ext_code.size(address(stor1[_606]))
            staticcall address(stor1[_606])._isNodeOwner(address arg1) with:
                    gas gas_remaining wei
                   args msg.sender
            mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + 193] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == bool(ext_call.return_data[0])
            if not ext_call.return_data[0]:
                revert with 0, 'NO NODE OWNER'
            mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193] = 0x5759fb0200000000000000000000000000000000000000000000000000000000
            mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 197] = msg.sender
            require ext_code.size(address(stor1[_606]))
            staticcall address(stor1[_606])._getNodesLastClaimTime(address arg1) with:
                    gas gas_remaining wei
                   args msg.sender
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + (2 * ceil32(return_data.size)) + 193
            require return_data.size >= 32
            _849 = mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32
            require mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 <= test266151307()
            require ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + return_data.size + 193 > ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 224
            _879 = mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193]
            if mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193] > test266151307():
                revert with 0, 65
            if ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 1 < 0 or ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + (2 * ceil32(return_data.size)) + ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 194 > test266151307():
                revert with 0, 65
            mem[64] = ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + (2 * ceil32(return_data.size)) + ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 194
            mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + (2 * ceil32(return_data.size)) + 193] = _879
            require _849 + _879 + 32 <= return_data.size
            mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + (2 * ceil32(return_data.size)) + 225 len ceil32(_879)] = mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + _849 + 225 len ceil32(_879)]
            if ceil32(_879) <= _879:
                _1256 = mem[64]
                mem[mem[64]] = 32
                mem[mem[64] + 32] = _879
                mem[mem[64] + 64 len ceil32(_879)] = mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + (2 * ceil32(return_data.size)) + 225 len ceil32(_879)]
                if ceil32(_879) <= _879:
                    return Array(len=_879, data=mem[mem[64] + 64 len ceil32(_879)])
                mem[mem[64] + _879 + 64] = 0
                return memory
                  from mem[64]
                   len ceil32(_879) + _1256 + -mem[64] + 64
            mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + (2 * ceil32(return_data.size)) + _879 + 225] = 0
            _1278 = mem[64]
            mem[mem[64]] = 32
            mem[mem[64] + 32] = _879
            mem[mem[64] + 64 len ceil32(_879)] = mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + (2 * ceil32(return_data.size)) + 225 len ceil32(_879)]
            if ceil32(_879) <= _879:
                return Array(len=_879, data=mem[mem[64] + 64 len ceil32(_879)])
            mem[mem[64] + _879 + 64] = 0
            return memory
              from mem[64]
               len ceil32(_879) + _1278 + -mem[64] + 64
        if 31 >= uint255(uint256(stor[_606].field_0)) * 0.5:
            mem[ceil32(ceil32(arg1.length)) + 193] = 256 * Mask(248, 0, stor[_606].field_8)
            mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
            mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_606])
            mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + 197] = msg.sender
            require ext_code.size(address(stor1[_606]))
            staticcall address(stor1[_606])._isNodeOwner(address arg1) with:
                    gas gas_remaining wei
                   args msg.sender
            mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + 193] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == bool(ext_call.return_data[0])
            if not ext_call.return_data[0]:
                revert with 0, 'NO NODE OWNER'
            mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193] = 0x5759fb0200000000000000000000000000000000000000000000000000000000
            mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 197] = msg.sender
            require ext_code.size(address(stor1[_606]))
            staticcall address(stor1[_606])._getNodesLastClaimTime(address arg1) with:
                    gas gas_remaining wei
                   args msg.sender
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + (2 * ceil32(return_data.size)) + 193
            require return_data.size >= 32
            _881 = mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32
            require mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 <= test266151307()
            require ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + return_data.size + 193 > ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 224
            _899 = mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193]
            if mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193] > test266151307():
                revert with 0, 65
            if ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 1 < 0 or ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + (2 * ceil32(return_data.size)) + ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 194 > test266151307():
                revert with 0, 65
            mem[64] = ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + (2 * ceil32(return_data.size)) + ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 194
            mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + (2 * ceil32(return_data.size)) + 193] = _899
            require _881 + _899 + 32 <= return_data.size
            mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + (2 * ceil32(return_data.size)) + 225 len ceil32(_899)] = mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + _881 + 225 len ceil32(_899)]
            if ceil32(_899) > _899:
                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + (2 * ceil32(return_data.size)) + _899 + 225] = 0
            mem[mem[64]] = 32
            mem[mem[64] + 32] = _899
            mem[mem[64] + 64 len ceil32(_899)] = mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + (2 * ceil32(return_data.size)) + 225 len ceil32(_899)]
            if ceil32(_899) > _899:
                mem[mem[64] + _899 + 64] = 0
            return Array(len=_899, data=mem[mem[64] + 64 len ceil32(_899)])
        mem[0] = _606
        mem[ceil32(ceil32(arg1.length)) + 193] = uint256(stor[sha3(_606)].field_0)
        idx = ceil32(ceil32(arg1.length)) + 193
        s = 0
        while ceil32(ceil32(arg1.length)) + (uint255(uint256(stor[_606].field_0)) * 0.5) + 161 > idx:
            mem[idx + 32] = uint256(stor[s + sha3(_606) + 1].field_0)
            idx = idx + 32
            s = s + 1
            continue 
        mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
        mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_606])
        mem[mem[64] + 4] = msg.sender
        require ext_code.size(address(stor1[_606]))
        staticcall address(stor1[_606])._isNodeOwner(address arg1) with:
                gas gas_remaining wei
               args msg.sender
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _1242 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        require mem[_1242] == bool(mem[_1242])
        if not mem[_1242]:
            revert with 0, 'NO NODE OWNER'
        mem[mem[64]] = 0x5759fb0200000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = msg.sender
        require ext_code.size(address(stor1[_606]))
        staticcall address(stor1[_606])._getNodesLastClaimTime(address arg1) with:
                gas gas_remaining wei
               args msg.sender
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _1399 = mem[64]
        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _1455 = mem[_1399]
        require mem[_1399] <= test266151307()
        require _1399 + return_data.size > _1399 + mem[_1399] + 31
        _1466 = mem[_1399 + mem[_1399]]
        if mem[_1399 + mem[_1399]] > test266151307():
            revert with 0, 65
        if ceil32(ceil32(mem[_1399 + mem[_1399]])) + 1 < 0 or _1399 + ceil32(return_data.size) + ceil32(ceil32(mem[_1399 + mem[_1399]])) + 1 > test266151307():
            revert with 0, 65
        mem[64] = _1399 + ceil32(return_data.size) + ceil32(ceil32(mem[_1399 + mem[_1399]])) + 1
        mem[_1399 + ceil32(return_data.size)] = _1466
        require _1455 + _1466 + 32 <= return_data.size
        mem[_1399 + ceil32(return_data.size) + 32 len ceil32(_1466)] = mem[_1399 + _1455 + 32 len ceil32(_1466)]
        if ceil32(_1466) > _1466:
            mem[_1399 + ceil32(return_data.size) + _1466 + 32] = 0
        mem[mem[64]] = 32
        mem[mem[64] + 32] = _1466
        mem[mem[64] + 64 len ceil32(_1466)] = mem[_1399 + ceil32(return_data.size) + 32 len ceil32(_1466)]
        if ceil32(_1466) > _1466:
            mem[mem[64] + _1466 + 64] = 0
        return Array(len=_1466, data=mem[mem[64] + 64 len ceil32(_1466)])
    if bool(stor[_606].field_0) == stor[_606].field_1 % 128 < 32:
        revert with 0, 34
    if not stor[_606].field_1 % 128:
        mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
        mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_606])
        mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + 197] = msg.sender
        require ext_code.size(address(stor1[_606]))
        staticcall address(stor1[_606])._isNodeOwner(address arg1) with:
                gas gas_remaining wei
               args msg.sender
        mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + 193] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == bool(ext_call.return_data[0])
        if not ext_call.return_data[0]:
            revert with 0, 'NO NODE OWNER'
        mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193] = 0x5759fb0200000000000000000000000000000000000000000000000000000000
        mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 197] = msg.sender
        require ext_code.size(address(stor1[_606]))
        staticcall address(stor1[_606])._getNodesLastClaimTime(address arg1) with:
                gas gas_remaining wei
               args msg.sender
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193 len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + (2 * ceil32(return_data.size)) + 193
        require return_data.size >= 32
        _867 = mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32
        require mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 <= test266151307()
        require ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + return_data.size + 193 > ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 224
        _889 = mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193]
        if mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193] > test266151307():
            revert with 0, 65
        if ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 1 < 0 or ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + (2 * ceil32(return_data.size)) + ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 194 > test266151307():
            revert with 0, 65
        mem[64] = ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + (2 * ceil32(return_data.size)) + ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 194
        mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + (2 * ceil32(return_data.size)) + 193] = _889
        require _867 + _889 + 32 <= return_data.size
        mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + (2 * ceil32(return_data.size)) + 225 len ceil32(_889)] = mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + _867 + 225 len ceil32(_889)]
        if ceil32(_889) > _889:
            mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + (2 * ceil32(return_data.size)) + _889 + 225] = 0
        mem[mem[64]] = 32
        mem[mem[64] + 32] = _889
        mem[mem[64] + 64 len ceil32(_889)] = mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + (2 * ceil32(return_data.size)) + 225 len ceil32(_889)]
        if ceil32(_889) > _889:
            mem[mem[64] + _889 + 64] = 0
        return Array(len=_889, data=mem[mem[64] + 64 len ceil32(_889)])
    if 31 >= stor[_606].field_1 % 128:
        mem[ceil32(ceil32(arg1.length)) + 193] = 256 * Mask(248, 0, stor[_606].field_8)
        mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
        mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_606])
        mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + 197] = msg.sender
        require ext_code.size(address(stor1[_606]))
        staticcall address(stor1[_606])._isNodeOwner(address arg1) with:
                gas gas_remaining wei
               args msg.sender
        mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + 193] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == bool(ext_call.return_data[0])
        if not ext_call.return_data[0]:
            revert with 0, 'NO NODE OWNER'
        mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193] = 0x5759fb0200000000000000000000000000000000000000000000000000000000
        mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 197] = msg.sender
        require ext_code.size(address(stor1[_606]))
        staticcall address(stor1[_606])._getNodesLastClaimTime(address arg1) with:
                gas gas_remaining wei
               args msg.sender
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193 len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + (2 * ceil32(return_data.size)) + 193
        require return_data.size >= 32
        _891 = mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32
        require mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 <= test266151307()
        require ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + return_data.size + 193 > ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 224
        _907 = mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193]
        if mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193] > test266151307():
            revert with 0, 65
        if ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 1 < 0 or ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + (2 * ceil32(return_data.size)) + ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 194 > test266151307():
            revert with 0, 65
        mem[64] = ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + (2 * ceil32(return_data.size)) + ceil32(ceil32(mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + 193 len 4], Mask(224, 32, msg.sender) >> 32 + 193])) + 194
        mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + (2 * ceil32(return_data.size)) + 193] = _907
        require _891 + _907 + 32 <= return_data.size
        mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + (2 * ceil32(return_data.size)) + 225 len ceil32(_907)] = mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + ceil32(return_data.size) + _891 + 225 len ceil32(_907)]
        if ceil32(_907) > _907:
            mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + (2 * ceil32(return_data.size)) + _907 + 225] = 0
        mem[mem[64]] = 32
        mem[mem[64] + 32] = _907
        mem[mem[64] + 64 len ceil32(_907)] = mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_606].field_1 % 128) + (2 * ceil32(return_data.size)) + 225 len ceil32(_907)]
        if ceil32(_907) > _907:
            mem[mem[64] + _907 + 64] = 0
        return Array(len=_907, data=mem[mem[64] + 64 len ceil32(_907)])
    mem[0] = _606
    mem[ceil32(ceil32(arg1.length)) + 193] = uint256(stor[sha3(_606)].field_0)
    idx = ceil32(ceil32(arg1.length)) + 193
    s = 0
    while ceil32(ceil32(arg1.length)) + stor[_606].field_1 % 128 + 161 > idx:
        mem[idx + 32] = uint256(stor[s + sha3(_606) + 1].field_0)
        idx = idx + 32
        s = s + 1
        continue 
    mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
    mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_606])
    mem[mem[64] + 4] = msg.sender
    require ext_code.size(address(stor1[_606]))
    staticcall address(stor1[_606])._isNodeOwner(address arg1) with:
            gas gas_remaining wei
           args msg.sender
    mem[mem[64]] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _1243 = mem[64]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    require mem[_1243] == bool(mem[_1243])
    if not mem[_1243]:
        revert with 0, 'NO NODE OWNER'
    mem[mem[64]] = 0x5759fb0200000000000000000000000000000000000000000000000000000000
    mem[mem[64] + 4] = msg.sender
    require ext_code.size(address(stor1[_606]))
    staticcall address(stor1[_606])._getNodesLastClaimTime(address arg1) with:
            gas gas_remaining wei
           args msg.sender
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _1402 = mem[64]
    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    _1458 = mem[_1402]
    require mem[_1402] <= test266151307()
    require _1402 + return_data.size > _1402 + mem[_1402] + 31
    _1467 = mem[_1402 + mem[_1402]]
    if mem[_1402 + mem[_1402]] > test266151307():
        revert with 0, 65
    if ceil32(ceil32(mem[_1402 + mem[_1402]])) + 1 < 0 or _1402 + ceil32(return_data.size) + ceil32(ceil32(mem[_1402 + mem[_1402]])) + 1 > test266151307():
        revert with 0, 65
    mem[64] = _1402 + ceil32(return_data.size) + ceil32(ceil32(mem[_1402 + mem[_1402]])) + 1
    mem[_1402 + ceil32(return_data.size)] = _1467
    require _1458 + _1467 + 32 <= return_data.size
    mem[_1402 + ceil32(return_data.size) + 32 len ceil32(_1467)] = mem[_1402 + _1458 + 32 len ceil32(_1467)]
    if ceil32(_1467) <= _1467:
        _1641 = mem[64]
        mem[mem[64]] = 32
        mem[mem[64] + 32] = _1467
        mem[mem[64] + 64 len ceil32(_1467)] = mem[_1402 + ceil32(return_data.size) + 32 len ceil32(_1467)]
        if ceil32(_1467) <= _1467:
            return Array(len=_1467, data=mem[mem[64] + 64 len ceil32(_1467)])
        mem[mem[64] + _1467 + 64] = 0
        return memory
          from mem[64]
           len ceil32(_1467) + _1641 + -mem[64] + 64
    mem[_1402 + ceil32(return_data.size) + _1467 + 32] = 0
    _1681 = mem[64]
    mem[mem[64]] = 32
    mem[mem[64] + 32] = _1467
    mem[mem[64] + 64 len ceil32(_1467)] = mem[_1402 + ceil32(return_data.size) + 32 len ceil32(_1467)]
    if ceil32(_1467) <= _1467:
        return Array(len=_1467, data=mem[mem[64] + 64 len ceil32(_1467)])
    mem[mem[64] + _1467 + 64] = 0
    return memory
      from mem[64]
       len ceil32(_1467) + _1681 + -mem[64] + 64
}

function sub_d23982c1(?) {
    require calldata.size - 4 >= 32
    require arg1 <= test266151307()
    require arg1 + 35 < calldata.size
    if arg1.length > test266151307():
        revert with 0, 65
    if ceil32(ceil32(arg1.length)) + 97 < 96 or ceil32(ceil32(arg1.length)) + 97 > test266151307():
        revert with 0, 65
    mem[96] = arg1.length
    require arg1 + arg1.length + 36 <= calldata.size
    mem[128 len arg1.length] = arg1[all]
    mem[arg1.length + 128] = 0
    mem[ceil32(ceil32(arg1.length)) + 97 len ceil32(arg1.length)] = arg1[all], mem[arg1.length + 128 len ceil32(arg1.length) - arg1.length]
    mem[arg1.length + ceil32(ceil32(arg1.length)) + 97] = 24
    if ceil32(arg1.length) <= arg1.length:
        _2329 = sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])
        if bool(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0):
            if bool(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0) == uint255(uint256(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0)) * 0.5 < 32:
                revert with 0, 34
            mem[64] = ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0)) * 0.5) + 193
            mem[ceil32(ceil32(arg1.length)) + 161] = uint255(uint256(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0)) * 0.5
            if bool(stor[_2329].field_0):
                if bool(stor[_2329].field_0) == uint255(uint256(stor[_2329].field_0)) * 0.5 < 32:
                    revert with 0, 34
                if not Mask(256, -1, uint256(stor[_2329].field_0)):
                    mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
                    mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_2329])
                    if not msg.sender:
                        revert with 0, 'MANIA CSHT:  creation from the zero address'
                    mem[0] = msg.sender
                    mem[32] = 22
                    if stor22[address(msg.sender)]:
                        revert with 0, 'MANIA CSHT: Blacklisted address'
                    if futurUsePoolAddress == msg.sender:
                        revert with 0, 'MANIA CSHT: futur and rewardsPool cannot cashout rewards'
                    if distributionPoolAddress == msg.sender:
                        revert with 0, 'MANIA CSHT: futur and rewardsPool cannot cashout rewards'
                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + 197] = msg.sender
                    require ext_code.size(address(stor1[_2329]))
                    staticcall address(stor1[_2329])._getRewardAmountOf(address arg1) with:
                            gas gas_remaining wei
                           args msg.sender
                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + 193] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if ext_call.return_data[0] <= 0:
                        revert with 0, 'MANIA CSHT: You don't have enough reward to cash out'
                    if not uint8(stor20):
                        require ext_code.size(stor9)
                        call stor9.0x23b872dd with:
                             gas gas_remaining wei
                            args distributionPoolAddress, msg.sender, ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                    else:
                        if not cashoutFee:
                            if ext_call.return_data[0] < 0:
                                revert with 0, 17
                            require ext_code.size(stor9)
                            call stor9.0x23b872dd with:
                                 gas gas_remaining wei
                                args distributionPoolAddress, msg.sender, ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                        else:
                            if not ext_call.return_data[0]:
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + ceil32(return_data.size) + 193] = 26
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + ceil32(return_data.size) + 225] = 'SafeMath: division by zero'
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + ceil32(return_data.size) + 257] = 2
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + ceil32(return_data.size) + 289] = stor9
                                require ext_code.size(uniswapV2RouterAddress)
                                staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                        gas gas_remaining wei
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + ceil32(return_data.size) + 353] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + ceil32(return_data.size) + 321] = ext_call.return_data[12 len 20]
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 357] = uniswapV2RouterAddress
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 389] = 0
                                require ext_code.size(stor9)
                                call stor9.approve(address arg1, uint256 arg2) with:
                                     gas gas_remaining wei
                                    args uniswapV2RouterAddress, 0
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 353] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 353
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 353] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 357] = 0
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 389] = 0
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 421] = 160
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 517] = 2
                                idx = 0
                                s = ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 549
                                t = ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + ceil32(return_data.size) + 289
                                while idx < mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + ceil32(return_data.size) + 257]:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 453] = this.address
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 485] = block.timestamp
                                require ext_code.size(uniswapV2RouterAddress)
                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + (32 * mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + ceil32(return_data.size) + 257]) + -mem[64] + 545]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4763 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4763] = 30
                                mem[_4763 + 32] = 'SafeMath: subtraction overflow'
                                if eth.balance(this.address) > eth.balance(this.address):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if eth.balance(this.address) < eth.balance(this.address):
                                    revert with 0, 17
                                call futurUsePoolAddress with:
                                     gas 2300 wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if ext_call.return_data[0] < 0:
                                    revert with 0, 17
                                mem[mem[64] + 4] = distributionPoolAddress
                                mem[mem[64] + 36] = msg.sender
                                mem[mem[64] + 68] = ext_call.return_data[0]
                                require ext_code.size(stor9)
                                call stor9.0x23b872dd with:
                                     gas gas_remaining wei
                                    args distributionPoolAddress, msg.sender, ext_call.return_data[0]
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _5187 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_5187] == bool(mem[_5187])
                            else:
                                if ext_call.return_data[0] and cashoutFee > -1 / ext_call.return_data[0]:
                                    revert with 0, 17
                                if not ext_call.return_data[0]:
                                    revert with 0, 18
                                if ext_call.return_data[0] * cashoutFee / ext_call.return_data[0] != cashoutFee:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + ceil32(return_data.size) + 193] = 26
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + ceil32(return_data.size) + 225] = 'SafeMath: division by zero'
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + ceil32(return_data.size) + 257] = 2
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + ceil32(return_data.size) + 289] = stor9
                                require ext_code.size(uniswapV2RouterAddress)
                                staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                        gas gas_remaining wei
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + ceil32(return_data.size) + 353] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + ceil32(return_data.size) + 321] = ext_call.return_data[12 len 20]
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 357] = uniswapV2RouterAddress
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 389] = ext_call.return_data[0] * cashoutFee / 100
                                require ext_code.size(stor9)
                                call stor9.approve(address arg1, uint256 arg2) with:
                                     gas gas_remaining wei
                                    args uniswapV2RouterAddress, ext_call.return_data[0] * cashoutFee / 100
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 353] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 353
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 353] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 357] = ext_call.return_data[0] * cashoutFee / 100
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 389] = 0
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 421] = 160
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 517] = 2
                                idx = 0
                                s = ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 549
                                t = ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + ceil32(return_data.size) + 289
                                while idx < mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + ceil32(return_data.size) + 257]:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 453] = this.address
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 485] = block.timestamp
                                require ext_code.size(uniswapV2RouterAddress)
                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + (32 * mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + ceil32(return_data.size) + 257]) + -mem[64] + 545]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4762 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4762] = 30
                                mem[_4762 + 32] = 'SafeMath: subtraction overflow'
                                if eth.balance(this.address) > eth.balance(this.address):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if eth.balance(this.address) < eth.balance(this.address):
                                    revert with 0, 17
                                call futurUsePoolAddress with:
                                     gas 2300 wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if ext_call.return_data[0] < ext_call.return_data[0] * cashoutFee / 100:
                                    revert with 0, 17
                                mem[mem[64] + 4] = distributionPoolAddress
                                mem[mem[64] + 36] = msg.sender
                                mem[mem[64] + 68] = ext_call.return_data[0] - (ext_call.return_data[0] * cashoutFee / 100)
                                require ext_code.size(stor9)
                                call stor9.0x23b872dd with:
                                     gas gas_remaining wei
                                    args distributionPoolAddress, msg.sender, ext_call.return_data[0] - (ext_call.return_data[0] * cashoutFee / 100)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _5186 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_5186] == bool(mem[_5186])
                else:
                    if 31 < uint255(uint256(stor[_2329].field_0)) * 0.5:
                        mem[ceil32(ceil32(arg1.length)) + 193] = uint256(stor[sha3(_2329)].field_0)
                        idx = ceil32(ceil32(arg1.length)) + 193
                        s = 0
                        while ceil32(ceil32(arg1.length)) + (uint255(uint256(stor[_2329].field_0)) * 0.5) + 161 > idx:
                            mem[idx + 32] = uint256(stor[s + sha3(_2329) + 1].field_0)
                            idx = idx + 32
                            s = s + 1
                            continue 
                        mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
                        mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_2329])
                        if not msg.sender:
                            revert with 0, 'MANIA CSHT:  creation from the zero address'
                        mem[0] = msg.sender
                        mem[32] = 22
                        if stor22[address(msg.sender)]:
                            revert with 0, 'MANIA CSHT: Blacklisted address'
                        if futurUsePoolAddress == msg.sender:
                            revert with 0, 'MANIA CSHT: futur and rewardsPool cannot cashout rewards'
                        if distributionPoolAddress == msg.sender:
                            revert with 0, 'MANIA CSHT: futur and rewardsPool cannot cashout rewards'
                        mem[mem[64] + 4] = msg.sender
                        require ext_code.size(address(stor1[_2329]))
                        staticcall address(stor1[_2329])._getRewardAmountOf(address arg1) with:
                                gas gas_remaining wei
                               args msg.sender
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _4874 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _4914 = mem[_4874]
                        if mem[_4874] <= 0:
                            revert with 0, 'MANIA CSHT: You don't have enough reward to cash out'
                        if not uint8(stor20):
                            mem[mem[64] + 4] = distributionPoolAddress
                            mem[mem[64] + 36] = msg.sender
                            mem[mem[64] + 68] = _4914
                            require ext_code.size(stor9)
                            call stor9.0x23b872dd with:
                                 gas gas_remaining wei
                                args distributionPoolAddress, msg.sender, _4914
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _5052 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_5052] == bool(mem[_5052])
                        else:
                            if not cashoutFee:
                                if mem[_4874] < 0:
                                    revert with 0, 17
                                mem[mem[64] + 4] = distributionPoolAddress
                                mem[mem[64] + 36] = msg.sender
                                mem[mem[64] + 68] = _4914
                                require ext_code.size(stor9)
                                call stor9.0x23b872dd with:
                                     gas gas_remaining wei
                                    args distributionPoolAddress, msg.sender, _4914
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _5188 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_5188] == bool(mem[_5188])
                            else:
                                if not mem[_4874]:
                                    _5131 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5131] = 26
                                    mem[_5131 + 32] = 'SafeMath: division by zero'
                                    _5328 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    mem[_5328 + 32 len 64] = call.data[calldata.size len 64]
                                    if not mem[_5328]:
                                        revert with 0, 50
                                    mem[_5328 + 32] = stor9
                                    require ext_code.size(uniswapV2RouterAddress)
                                    staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                            gas gas_remaining wei
                                    mem[_5328 + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = _5328 + ceil32(return_data.size) + 96
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    if 1 >= mem[_5328]:
                                        revert with 0, 50
                                    mem[_5328 + 64] = ext_call.return_data[12 len 20]
                                    mem[_5328 + ceil32(return_data.size) + 100] = uniswapV2RouterAddress
                                    mem[_5328 + ceil32(return_data.size) + 132] = 0
                                    require ext_code.size(stor9)
                                    call stor9.approve(address arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args uniswapV2RouterAddress, 0
                                    mem[_5328 + ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = _5328 + (2 * ceil32(return_data.size)) + 96
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    mem[_5328 + (2 * ceil32(return_data.size)) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                    mem[_5328 + (2 * ceil32(return_data.size)) + 100] = 0
                                    mem[_5328 + (2 * ceil32(return_data.size)) + 132] = 0
                                    mem[_5328 + (2 * ceil32(return_data.size)) + 164] = 160
                                    mem[_5328 + (2 * ceil32(return_data.size)) + 260] = mem[_5328]
                                    idx = 0
                                    s = _5328 + (2 * ceil32(return_data.size)) + 292
                                    t = _5328 + 32
                                    while idx < mem[_5328]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(uniswapV2RouterAddress)
                                    call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args 0, 0, 160, address(this.address), block.timestamp, mem[_5328 + (2 * ceil32(return_data.size)) + 260 len (32 * mem[_5328]) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if eth.balance(this.address) > eth.balance(this.address):
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if eth.balance(this.address) < eth.balance(this.address):
                                        revert with 0, 17
                                    call futurUsePoolAddress with:
                                         gas 2300 wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if _4914 < 0:
                                        revert with 0, 17
                                    require ext_code.size(stor9)
                                    call stor9.0x23b872dd with:
                                         gas gas_remaining wei
                                        args distributionPoolAddress, msg.sender, _4914
                                else:
                                    if mem[_4874] and cashoutFee > -1 / mem[_4874]:
                                        revert with 0, 17
                                    if not mem[_4874]:
                                        revert with 0, 18
                                    if mem[_4874] * cashoutFee / mem[_4874] != cashoutFee:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _5299 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5299] = 26
                                    mem[_5299 + 32] = 'SafeMath: division by zero'
                                    _5530 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    mem[_5530 + 32 len 64] = call.data[calldata.size len 64]
                                    if not mem[_5530]:
                                        revert with 0, 50
                                    mem[_5530 + 32] = stor9
                                    require ext_code.size(uniswapV2RouterAddress)
                                    staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                            gas gas_remaining wei
                                    mem[_5530 + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = _5530 + ceil32(return_data.size) + 96
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    if 1 >= mem[_5530]:
                                        revert with 0, 50
                                    mem[_5530 + 64] = ext_call.return_data[12 len 20]
                                    mem[_5530 + ceil32(return_data.size) + 100] = uniswapV2RouterAddress
                                    mem[_5530 + ceil32(return_data.size) + 132] = _4914 * cashoutFee / 100
                                    require ext_code.size(stor9)
                                    call stor9.approve(address arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args uniswapV2RouterAddress, _4914 * cashoutFee / 100
                                    mem[_5530 + ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = _5530 + (2 * ceil32(return_data.size)) + 96
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    mem[_5530 + (2 * ceil32(return_data.size)) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                    mem[_5530 + (2 * ceil32(return_data.size)) + 100] = _4914 * cashoutFee / 100
                                    mem[_5530 + (2 * ceil32(return_data.size)) + 132] = 0
                                    mem[_5530 + (2 * ceil32(return_data.size)) + 164] = 160
                                    mem[_5530 + (2 * ceil32(return_data.size)) + 260] = mem[_5530]
                                    idx = 0
                                    s = _5530 + (2 * ceil32(return_data.size)) + 292
                                    t = _5530 + 32
                                    while idx < mem[_5530]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(uniswapV2RouterAddress)
                                    call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args _4914 * cashoutFee / 100, 0, 160, address(this.address), block.timestamp, mem[_5530 + (2 * ceil32(return_data.size)) + 260 len (32 * mem[_5530]) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if eth.balance(this.address) > eth.balance(this.address):
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if eth.balance(this.address) < eth.balance(this.address):
                                        revert with 0, 17
                                    call futurUsePoolAddress with:
                                         gas 2300 wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if _4914 < _4914 * cashoutFee / 100:
                                        revert with 0, 17
                                    require ext_code.size(stor9)
                                    call stor9.0x23b872dd with:
                                         gas gas_remaining wei
                                        args distributionPoolAddress, msg.sender, _4914 - (_4914 * cashoutFee / 100)
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                    else:
                        mem[ceil32(ceil32(arg1.length)) + 193] = 256 * Mask(248, 0, stor[_2329].field_8)
                        mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
                        mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_2329])
                        if not msg.sender:
                            revert with 0, 'MANIA CSHT:  creation from the zero address'
                        mem[0] = msg.sender
                        mem[32] = 22
                        if stor22[address(msg.sender)]:
                            revert with 0, 'MANIA CSHT: Blacklisted address'
                        if futurUsePoolAddress == msg.sender:
                            revert with 0, 'MANIA CSHT: futur and rewardsPool cannot cashout rewards'
                        if distributionPoolAddress == msg.sender:
                            revert with 0, 'MANIA CSHT: futur and rewardsPool cannot cashout rewards'
                        mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + 197] = msg.sender
                        require ext_code.size(address(stor1[_2329]))
                        staticcall address(stor1[_2329])._getRewardAmountOf(address arg1) with:
                                gas gas_remaining wei
                               args msg.sender
                        mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + 193] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if ext_call.return_data[0] <= 0:
                            revert with 0, 'MANIA CSHT: You don't have enough reward to cash out'
                        if not uint8(stor20):
                            require ext_code.size(stor9)
                            call stor9.0x23b872dd with:
                                 gas gas_remaining wei
                                args distributionPoolAddress, msg.sender, ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                        else:
                            if not cashoutFee:
                                if ext_call.return_data[0] < 0:
                                    revert with 0, 17
                                require ext_code.size(stor9)
                                call stor9.0x23b872dd with:
                                     gas gas_remaining wei
                                    args distributionPoolAddress, msg.sender, ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                            else:
                                if not ext_call.return_data[0]:
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + ceil32(return_data.size) + 193] = 26
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + ceil32(return_data.size) + 225] = 'SafeMath: division by zero'
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + ceil32(return_data.size) + 257] = 2
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + ceil32(return_data.size) + 289] = stor9
                                    require ext_code.size(uniswapV2RouterAddress)
                                    staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                            gas gas_remaining wei
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + ceil32(return_data.size) + 353] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + ceil32(return_data.size) + 321] = ext_call.return_data[12 len 20]
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 357] = uniswapV2RouterAddress
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 389] = 0
                                    require ext_code.size(stor9)
                                    call stor9.approve(address arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args uniswapV2RouterAddress, 0
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 353] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 353
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 353] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 357] = 0
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 389] = 0
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 421] = 160
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 517] = 2
                                    idx = 0
                                    s = ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 549
                                    t = ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + ceil32(return_data.size) + 289
                                    while idx < mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + ceil32(return_data.size) + 257]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 453] = this.address
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 485] = block.timestamp
                                    require ext_code.size(uniswapV2RouterAddress)
                                    call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + (32 * mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + ceil32(return_data.size) + 257]) + -mem[64] + 545]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _4766 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4766] = 30
                                    mem[_4766 + 32] = 'SafeMath: subtraction overflow'
                                    if eth.balance(this.address) > eth.balance(this.address):
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if eth.balance(this.address) < eth.balance(this.address):
                                        revert with 0, 17
                                    call futurUsePoolAddress with:
                                         gas 2300 wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if ext_call.return_data[0] < 0:
                                        revert with 0, 17
                                    mem[mem[64] + 4] = distributionPoolAddress
                                    mem[mem[64] + 36] = msg.sender
                                    mem[mem[64] + 68] = ext_call.return_data[0]
                                    require ext_code.size(stor9)
                                    call stor9.0x23b872dd with:
                                         gas gas_remaining wei
                                        args distributionPoolAddress, msg.sender, ext_call.return_data[0]
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5190 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_5190] == bool(mem[_5190])
                                else:
                                    if ext_call.return_data[0] and cashoutFee > -1 / ext_call.return_data[0]:
                                        revert with 0, 17
                                    if not ext_call.return_data[0]:
                                        revert with 0, 18
                                    if ext_call.return_data[0] * cashoutFee / ext_call.return_data[0] != cashoutFee:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + ceil32(return_data.size) + 193] = 26
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + ceil32(return_data.size) + 225] = 'SafeMath: division by zero'
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + ceil32(return_data.size) + 257] = 2
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + ceil32(return_data.size) + 289] = stor9
                                    require ext_code.size(uniswapV2RouterAddress)
                                    staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                            gas gas_remaining wei
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + ceil32(return_data.size) + 353] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + ceil32(return_data.size) + 321] = ext_call.return_data[12 len 20]
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 357] = uniswapV2RouterAddress
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 389] = ext_call.return_data[0] * cashoutFee / 100
                                    require ext_code.size(stor9)
                                    call stor9.approve(address arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args uniswapV2RouterAddress, ext_call.return_data[0] * cashoutFee / 100
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 353] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 353
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 353] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 357] = ext_call.return_data[0] * cashoutFee / 100
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 389] = 0
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 421] = 160
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 517] = 2
                                    idx = 0
                                    s = ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 549
                                    t = ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + ceil32(return_data.size) + 289
                                    while idx < mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + ceil32(return_data.size) + 257]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 453] = this.address
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 485] = block.timestamp
                                    require ext_code.size(uniswapV2RouterAddress)
                                    call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + (32 * mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + ceil32(return_data.size) + 257]) + -mem[64] + 545]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _4765 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4765] = 30
                                    mem[_4765 + 32] = 'SafeMath: subtraction overflow'
                                    if eth.balance(this.address) > eth.balance(this.address):
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if eth.balance(this.address) < eth.balance(this.address):
                                        revert with 0, 17
                                    call futurUsePoolAddress with:
                                         gas 2300 wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if ext_call.return_data[0] < ext_call.return_data[0] * cashoutFee / 100:
                                        revert with 0, 17
                                    mem[mem[64] + 4] = distributionPoolAddress
                                    mem[mem[64] + 36] = msg.sender
                                    mem[mem[64] + 68] = ext_call.return_data[0] - (ext_call.return_data[0] * cashoutFee / 100)
                                    require ext_code.size(stor9)
                                    call stor9.0x23b872dd with:
                                         gas gas_remaining wei
                                        args distributionPoolAddress, msg.sender, ext_call.return_data[0] - (ext_call.return_data[0] * cashoutFee / 100)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5189 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_5189] == bool(mem[_5189])
            else:
                if bool(stor[_2329].field_0) == stor[_2329].field_1 % 128 < 32:
                    revert with 0, 34
                if not stor[_2329].field_1 % 128:
                    mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
                    mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_2329])
                    if not msg.sender:
                        revert with 0, 'MANIA CSHT:  creation from the zero address'
                    mem[0] = msg.sender
                    mem[32] = 22
                    if stor22[address(msg.sender)]:
                        revert with 0, 'MANIA CSHT: Blacklisted address'
                    if futurUsePoolAddress == msg.sender:
                        revert with 0, 'MANIA CSHT: futur and rewardsPool cannot cashout rewards'
                    if distributionPoolAddress == msg.sender:
                        revert with 0, 'MANIA CSHT: futur and rewardsPool cannot cashout rewards'
                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + 197] = msg.sender
                    require ext_code.size(address(stor1[_2329]))
                    staticcall address(stor1[_2329])._getRewardAmountOf(address arg1) with:
                            gas gas_remaining wei
                           args msg.sender
                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + 193] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if ext_call.return_data[0] <= 0:
                        revert with 0, 'MANIA CSHT: You don't have enough reward to cash out'
                    if not uint8(stor20):
                        require ext_code.size(stor9)
                        call stor9.0x23b872dd with:
                             gas gas_remaining wei
                            args distributionPoolAddress, msg.sender, ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                    else:
                        if not cashoutFee:
                            if ext_call.return_data[0] < 0:
                                revert with 0, 17
                            require ext_code.size(stor9)
                            call stor9.0x23b872dd with:
                                 gas gas_remaining wei
                                args distributionPoolAddress, msg.sender, ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                        else:
                            if not ext_call.return_data[0]:
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + ceil32(return_data.size) + 193] = 26
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + ceil32(return_data.size) + 225] = 'SafeMath: division by zero'
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + ceil32(return_data.size) + 257] = 2
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + ceil32(return_data.size) + 289] = stor9
                                require ext_code.size(uniswapV2RouterAddress)
                                staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                        gas gas_remaining wei
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + ceil32(return_data.size) + 353] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + ceil32(return_data.size) + 321] = ext_call.return_data[12 len 20]
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 357] = uniswapV2RouterAddress
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 389] = 0
                                require ext_code.size(stor9)
                                call stor9.approve(address arg1, uint256 arg2) with:
                                     gas gas_remaining wei
                                    args uniswapV2RouterAddress, 0
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 353] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 353
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 353] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 357] = 0
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 389] = 0
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 421] = 160
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 517] = 2
                                idx = 0
                                s = ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 549
                                t = ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + ceil32(return_data.size) + 289
                                while idx < mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + ceil32(return_data.size) + 257]:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 453] = this.address
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 485] = block.timestamp
                                require ext_code.size(uniswapV2RouterAddress)
                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + (32 * mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + ceil32(return_data.size) + 257]) + -mem[64] + 545]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4768 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4768] = 30
                                mem[_4768 + 32] = 'SafeMath: subtraction overflow'
                                if eth.balance(this.address) > eth.balance(this.address):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if eth.balance(this.address) < eth.balance(this.address):
                                    revert with 0, 17
                                call futurUsePoolAddress with:
                                     gas 2300 wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if ext_call.return_data[0] < 0:
                                    revert with 0, 17
                                mem[mem[64] + 4] = distributionPoolAddress
                                mem[mem[64] + 36] = msg.sender
                                mem[mem[64] + 68] = ext_call.return_data[0]
                                require ext_code.size(stor9)
                                call stor9.0x23b872dd with:
                                     gas gas_remaining wei
                                    args distributionPoolAddress, msg.sender, ext_call.return_data[0]
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _5192 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_5192] == bool(mem[_5192])
                            else:
                                if ext_call.return_data[0] and cashoutFee > -1 / ext_call.return_data[0]:
                                    revert with 0, 17
                                if not ext_call.return_data[0]:
                                    revert with 0, 18
                                if ext_call.return_data[0] * cashoutFee / ext_call.return_data[0] != cashoutFee:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + ceil32(return_data.size) + 193] = 26
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + ceil32(return_data.size) + 225] = 'SafeMath: division by zero'
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + ceil32(return_data.size) + 257] = 2
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + ceil32(return_data.size) + 289] = stor9
                                require ext_code.size(uniswapV2RouterAddress)
                                staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                        gas gas_remaining wei
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + ceil32(return_data.size) + 353] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + ceil32(return_data.size) + 321] = ext_call.return_data[12 len 20]
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 357] = uniswapV2RouterAddress
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 389] = ext_call.return_data[0] * cashoutFee / 100
                                require ext_code.size(stor9)
                                call stor9.approve(address arg1, uint256 arg2) with:
                                     gas gas_remaining wei
                                    args uniswapV2RouterAddress, ext_call.return_data[0] * cashoutFee / 100
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 353] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 353
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 353] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 357] = ext_call.return_data[0] * cashoutFee / 100
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 389] = 0
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 421] = 160
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 517] = 2
                                idx = 0
                                s = ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 549
                                t = ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + ceil32(return_data.size) + 289
                                while idx < mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + ceil32(return_data.size) + 257]:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 453] = this.address
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 485] = block.timestamp
                                require ext_code.size(uniswapV2RouterAddress)
                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + (32 * mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + ceil32(return_data.size) + 257]) + -mem[64] + 545]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4767 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4767] = 30
                                mem[_4767 + 32] = 'SafeMath: subtraction overflow'
                                if eth.balance(this.address) > eth.balance(this.address):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if eth.balance(this.address) < eth.balance(this.address):
                                    revert with 0, 17
                                call futurUsePoolAddress with:
                                     gas 2300 wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if ext_call.return_data[0] < ext_call.return_data[0] * cashoutFee / 100:
                                    revert with 0, 17
                                mem[mem[64] + 4] = distributionPoolAddress
                                mem[mem[64] + 36] = msg.sender
                                mem[mem[64] + 68] = ext_call.return_data[0] - (ext_call.return_data[0] * cashoutFee / 100)
                                require ext_code.size(stor9)
                                call stor9.0x23b872dd with:
                                     gas gas_remaining wei
                                    args distributionPoolAddress, msg.sender, ext_call.return_data[0] - (ext_call.return_data[0] * cashoutFee / 100)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _5191 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_5191] == bool(mem[_5191])
                else:
                    if 31 < stor[_2329].field_1 % 128:
                        mem[ceil32(ceil32(arg1.length)) + 193] = uint256(stor[sha3(_2329)].field_0)
                        idx = ceil32(ceil32(arg1.length)) + 193
                        s = 0
                        while ceil32(ceil32(arg1.length)) + stor[_2329].field_1 % 128 + 161 > idx:
                            mem[idx + 32] = uint256(stor[s + sha3(_2329) + 1].field_0)
                            idx = idx + 32
                            s = s + 1
                            continue 
                        mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
                        mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_2329])
                        if not msg.sender:
                            revert with 0, 'MANIA CSHT:  creation from the zero address'
                        mem[0] = msg.sender
                        mem[32] = 22
                        if stor22[address(msg.sender)]:
                            revert with 0, 'MANIA CSHT: Blacklisted address'
                        if futurUsePoolAddress == msg.sender:
                            revert with 0, 'MANIA CSHT: futur and rewardsPool cannot cashout rewards'
                        if distributionPoolAddress == msg.sender:
                            revert with 0, 'MANIA CSHT: futur and rewardsPool cannot cashout rewards'
                        mem[mem[64] + 4] = msg.sender
                        require ext_code.size(address(stor1[_2329]))
                        staticcall address(stor1[_2329])._getRewardAmountOf(address arg1) with:
                                gas gas_remaining wei
                               args msg.sender
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _4875 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _4915 = mem[_4875]
                        if mem[_4875] <= 0:
                            revert with 0, 'MANIA CSHT: You don't have enough reward to cash out'
                        if not uint8(stor20):
                            mem[mem[64] + 4] = distributionPoolAddress
                            mem[mem[64] + 36] = msg.sender
                            mem[mem[64] + 68] = _4915
                            require ext_code.size(stor9)
                            call stor9.0x23b872dd with:
                                 gas gas_remaining wei
                                args distributionPoolAddress, msg.sender, _4915
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _5057 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_5057] == bool(mem[_5057])
                        else:
                            if not cashoutFee:
                                if mem[_4875] < 0:
                                    revert with 0, 17
                                mem[mem[64] + 4] = distributionPoolAddress
                                mem[mem[64] + 36] = msg.sender
                                mem[mem[64] + 68] = _4915
                                require ext_code.size(stor9)
                                call stor9.0x23b872dd with:
                                     gas gas_remaining wei
                                    args distributionPoolAddress, msg.sender, _4915
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _5193 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_5193] == bool(mem[_5193])
                            else:
                                if not mem[_4875]:
                                    _5133 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5133] = 26
                                    mem[_5133 + 32] = 'SafeMath: division by zero'
                                    _5340 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    mem[_5340 + 32 len 64] = call.data[calldata.size len 64]
                                    if not mem[_5340]:
                                        revert with 0, 50
                                    mem[_5340 + 32] = stor9
                                    require ext_code.size(uniswapV2RouterAddress)
                                    staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                            gas gas_remaining wei
                                    mem[_5340 + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = _5340 + ceil32(return_data.size) + 96
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    if 1 >= mem[_5340]:
                                        revert with 0, 50
                                    mem[_5340 + 64] = ext_call.return_data[12 len 20]
                                    mem[_5340 + ceil32(return_data.size) + 100] = uniswapV2RouterAddress
                                    mem[_5340 + ceil32(return_data.size) + 132] = 0
                                    require ext_code.size(stor9)
                                    call stor9.approve(address arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args uniswapV2RouterAddress, 0
                                    mem[_5340 + ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = _5340 + (2 * ceil32(return_data.size)) + 96
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    mem[_5340 + (2 * ceil32(return_data.size)) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                    mem[_5340 + (2 * ceil32(return_data.size)) + 100] = 0
                                    mem[_5340 + (2 * ceil32(return_data.size)) + 132] = 0
                                    mem[_5340 + (2 * ceil32(return_data.size)) + 164] = 160
                                    mem[_5340 + (2 * ceil32(return_data.size)) + 260] = mem[_5340]
                                    idx = 0
                                    s = _5340 + (2 * ceil32(return_data.size)) + 292
                                    t = _5340 + 32
                                    while idx < mem[_5340]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(uniswapV2RouterAddress)
                                    call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args 0, 0, 160, address(this.address), block.timestamp, mem[_5340 + (2 * ceil32(return_data.size)) + 260 len (32 * mem[_5340]) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if eth.balance(this.address) > eth.balance(this.address):
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if eth.balance(this.address) < eth.balance(this.address):
                                        revert with 0, 17
                                    call futurUsePoolAddress with:
                                         gas 2300 wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if _4915 < 0:
                                        revert with 0, 17
                                    require ext_code.size(stor9)
                                    call stor9.0x23b872dd with:
                                         gas gas_remaining wei
                                        args distributionPoolAddress, msg.sender, _4915
                                else:
                                    if mem[_4875] and cashoutFee > -1 / mem[_4875]:
                                        revert with 0, 17
                                    if not mem[_4875]:
                                        revert with 0, 18
                                    if mem[_4875] * cashoutFee / mem[_4875] != cashoutFee:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _5301 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5301] = 26
                                    mem[_5301 + 32] = 'SafeMath: division by zero'
                                    _5532 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    mem[_5532 + 32 len 64] = call.data[calldata.size len 64]
                                    if not mem[_5532]:
                                        revert with 0, 50
                                    mem[_5532 + 32] = stor9
                                    require ext_code.size(uniswapV2RouterAddress)
                                    staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                            gas gas_remaining wei
                                    mem[_5532 + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = _5532 + ceil32(return_data.size) + 96
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    if 1 >= mem[_5532]:
                                        revert with 0, 50
                                    mem[_5532 + 64] = ext_call.return_data[12 len 20]
                                    mem[_5532 + ceil32(return_data.size) + 100] = uniswapV2RouterAddress
                                    mem[_5532 + ceil32(return_data.size) + 132] = _4915 * cashoutFee / 100
                                    require ext_code.size(stor9)
                                    call stor9.approve(address arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args uniswapV2RouterAddress, _4915 * cashoutFee / 100
                                    mem[_5532 + ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = _5532 + (2 * ceil32(return_data.size)) + 96
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    mem[_5532 + (2 * ceil32(return_data.size)) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                    mem[_5532 + (2 * ceil32(return_data.size)) + 100] = _4915 * cashoutFee / 100
                                    mem[_5532 + (2 * ceil32(return_data.size)) + 132] = 0
                                    mem[_5532 + (2 * ceil32(return_data.size)) + 164] = 160
                                    mem[_5532 + (2 * ceil32(return_data.size)) + 260] = mem[_5532]
                                    idx = 0
                                    s = _5532 + (2 * ceil32(return_data.size)) + 292
                                    t = _5532 + 32
                                    while idx < mem[_5532]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(uniswapV2RouterAddress)
                                    call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args _4915 * cashoutFee / 100, 0, 160, address(this.address), block.timestamp, mem[_5532 + (2 * ceil32(return_data.size)) + 260 len (32 * mem[_5532]) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if eth.balance(this.address) > eth.balance(this.address):
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if eth.balance(this.address) < eth.balance(this.address):
                                        revert with 0, 17
                                    call futurUsePoolAddress with:
                                         gas 2300 wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if _4915 < _4915 * cashoutFee / 100:
                                        revert with 0, 17
                                    require ext_code.size(stor9)
                                    call stor9.0x23b872dd with:
                                         gas gas_remaining wei
                                        args distributionPoolAddress, msg.sender, _4915 - (_4915 * cashoutFee / 100)
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                    else:
                        mem[ceil32(ceil32(arg1.length)) + 193] = 256 * Mask(248, 0, stor[_2329].field_8)
                        mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
                        mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_2329])
                        if not msg.sender:
                            revert with 0, 'MANIA CSHT:  creation from the zero address'
                        mem[0] = msg.sender
                        mem[32] = 22
                        if stor22[address(msg.sender)]:
                            revert with 0, 'MANIA CSHT: Blacklisted address'
                        if futurUsePoolAddress == msg.sender:
                            revert with 0, 'MANIA CSHT: futur and rewardsPool cannot cashout rewards'
                        if distributionPoolAddress == msg.sender:
                            revert with 0, 'MANIA CSHT: futur and rewardsPool cannot cashout rewards'
                        mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + 197] = msg.sender
                        require ext_code.size(address(stor1[_2329]))
                        staticcall address(stor1[_2329])._getRewardAmountOf(address arg1) with:
                                gas gas_remaining wei
                               args msg.sender
                        mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + 193] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if ext_call.return_data[0] <= 0:
                            revert with 0, 'MANIA CSHT: You don't have enough reward to cash out'
                        if not uint8(stor20):
                            require ext_code.size(stor9)
                            call stor9.0x23b872dd with:
                                 gas gas_remaining wei
                                args distributionPoolAddress, msg.sender, ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                        else:
                            if not cashoutFee:
                                if ext_call.return_data[0] < 0:
                                    revert with 0, 17
                                require ext_code.size(stor9)
                                call stor9.0x23b872dd with:
                                     gas gas_remaining wei
                                    args distributionPoolAddress, msg.sender, ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                            else:
                                if not ext_call.return_data[0]:
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + ceil32(return_data.size) + 193] = 26
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + ceil32(return_data.size) + 225] = 'SafeMath: division by zero'
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + ceil32(return_data.size) + 257] = 2
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + ceil32(return_data.size) + 289] = stor9
                                    require ext_code.size(uniswapV2RouterAddress)
                                    staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                            gas gas_remaining wei
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + ceil32(return_data.size) + 353] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + ceil32(return_data.size) + 321] = ext_call.return_data[12 len 20]
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 357] = uniswapV2RouterAddress
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 389] = 0
                                    require ext_code.size(stor9)
                                    call stor9.approve(address arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args uniswapV2RouterAddress, 0
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 353] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 353
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 353] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 357] = 0
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 389] = 0
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 421] = 160
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 517] = 2
                                    idx = 0
                                    s = ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 549
                                    t = ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + ceil32(return_data.size) + 289
                                    while idx < mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + ceil32(return_data.size) + 257]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 453] = this.address
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 485] = block.timestamp
                                    require ext_code.size(uniswapV2RouterAddress)
                                    call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + (32 * mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + ceil32(return_data.size) + 257]) + -mem[64] + 545]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _4771 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4771] = 30
                                    mem[_4771 + 32] = 'SafeMath: subtraction overflow'
                                    if eth.balance(this.address) > eth.balance(this.address):
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if eth.balance(this.address) < eth.balance(this.address):
                                        revert with 0, 17
                                    call futurUsePoolAddress with:
                                         gas 2300 wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if ext_call.return_data[0] < 0:
                                        revert with 0, 17
                                    mem[mem[64] + 4] = distributionPoolAddress
                                    mem[mem[64] + 36] = msg.sender
                                    mem[mem[64] + 68] = ext_call.return_data[0]
                                    require ext_code.size(stor9)
                                    call stor9.0x23b872dd with:
                                         gas gas_remaining wei
                                        args distributionPoolAddress, msg.sender, ext_call.return_data[0]
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5195 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_5195] == bool(mem[_5195])
                                else:
                                    if ext_call.return_data[0] and cashoutFee > -1 / ext_call.return_data[0]:
                                        revert with 0, 17
                                    if not ext_call.return_data[0]:
                                        revert with 0, 18
                                    if ext_call.return_data[0] * cashoutFee / ext_call.return_data[0] != cashoutFee:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + ceil32(return_data.size) + 193] = 26
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + ceil32(return_data.size) + 225] = 'SafeMath: division by zero'
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + ceil32(return_data.size) + 257] = 2
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + ceil32(return_data.size) + 289] = stor9
                                    require ext_code.size(uniswapV2RouterAddress)
                                    staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                            gas gas_remaining wei
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + ceil32(return_data.size) + 353] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + ceil32(return_data.size) + 321] = ext_call.return_data[12 len 20]
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 357] = uniswapV2RouterAddress
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 389] = ext_call.return_data[0] * cashoutFee / 100
                                    require ext_code.size(stor9)
                                    call stor9.approve(address arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args uniswapV2RouterAddress, ext_call.return_data[0] * cashoutFee / 100
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 353] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 353
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 353] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 357] = ext_call.return_data[0] * cashoutFee / 100
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 389] = 0
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 421] = 160
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 517] = 2
                                    idx = 0
                                    s = ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 549
                                    t = ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + ceil32(return_data.size) + 289
                                    while idx < mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + ceil32(return_data.size) + 257]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 453] = this.address
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 485] = block.timestamp
                                    require ext_code.size(uniswapV2RouterAddress)
                                    call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + (32 * mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2329].field_0)) * 0.5) + ceil32(return_data.size) + 257]) + -mem[64] + 545]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _4770 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4770] = 30
                                    mem[_4770 + 32] = 'SafeMath: subtraction overflow'
                                    if eth.balance(this.address) > eth.balance(this.address):
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if eth.balance(this.address) < eth.balance(this.address):
                                        revert with 0, 17
                                    call futurUsePoolAddress with:
                                         gas 2300 wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if ext_call.return_data[0] < ext_call.return_data[0] * cashoutFee / 100:
                                        revert with 0, 17
                                    mem[mem[64] + 4] = distributionPoolAddress
                                    mem[mem[64] + 36] = msg.sender
                                    mem[mem[64] + 68] = ext_call.return_data[0] - (ext_call.return_data[0] * cashoutFee / 100)
                                    require ext_code.size(stor9)
                                    call stor9.0x23b872dd with:
                                         gas gas_remaining wei
                                        args distributionPoolAddress, msg.sender, ext_call.return_data[0] - (ext_call.return_data[0] * cashoutFee / 100)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5194 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_5194] == bool(mem[_5194])
        else:
            if bool(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0) == stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_1 % 128 < 32:
                revert with 0, 34
            mem[64] = ceil32(ceil32(arg1.length)) + ceil32(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_1 % 128) + 193
            mem[ceil32(ceil32(arg1.length)) + 161] = stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_1 % 128
            if bool(stor[_2329].field_0):
                if bool(stor[_2329].field_0) == uint255(uint256(stor[_2329].field_0)) * 0.5 < 32:
                    revert with 0, 34
                if not Mask(256, -1, uint256(stor[_2329].field_0)):
                    mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
                    mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_2329])
                    if not msg.sender:
                        revert with 0, 'MANIA CSHT:  creation from the zero address'
                    mem[0] = msg.sender
                    mem[32] = 22
                    if stor22[address(msg.sender)]:
                        revert with 0, 'MANIA CSHT: Blacklisted address'
                    if futurUsePoolAddress == msg.sender:
                        revert with 0, 'MANIA CSHT: futur and rewardsPool cannot cashout rewards'
                    if distributionPoolAddress == msg.sender:
                        revert with 0, 'MANIA CSHT: futur and rewardsPool cannot cashout rewards'
                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + 197] = msg.sender
                    require ext_code.size(address(stor1[_2329]))
                    staticcall address(stor1[_2329])._getRewardAmountOf(address arg1) with:
                            gas gas_remaining wei
                           args msg.sender
                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + 193] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if ext_call.return_data[0] <= 0:
                        revert with 0, 'MANIA CSHT: You don't have enough reward to cash out'
                    if not uint8(stor20):
                        require ext_code.size(stor9)
                        call stor9.0x23b872dd with:
                             gas gas_remaining wei
                            args distributionPoolAddress, msg.sender, ext_call.return_data[0]
                    else:
                        if not cashoutFee:
                            if ext_call.return_data[0] < 0:
                                revert with 0, 17
                            require ext_code.size(stor9)
                            call stor9.0x23b872dd with:
                                 gas gas_remaining wei
                                args distributionPoolAddress, msg.sender, ext_call.return_data[0]
                        else:
                            if not ext_call.return_data[0]:
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + ceil32(return_data.size) + 257] = 2
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + ceil32(return_data.size) + 289] = stor9
                                require ext_code.size(uniswapV2RouterAddress)
                                staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                        gas gas_remaining wei
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + ceil32(return_data.size) + 353] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + ceil32(return_data.size) + 321] = ext_call.return_data[12 len 20]
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (2 * ceil32(return_data.size)) + 357] = uniswapV2RouterAddress
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (2 * ceil32(return_data.size)) + 389] = 0
                                require ext_code.size(stor9)
                                call stor9.approve(address arg1, uint256 arg2) with:
                                     gas gas_remaining wei
                                    args uniswapV2RouterAddress, 0
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (2 * ceil32(return_data.size)) + 353] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + 353
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + 353] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + 357] = 0
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + 389] = 0
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + 421] = 160
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + 517] = 2
                                idx = 0
                                s = ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + 549
                                t = ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + ceil32(return_data.size) + 289
                                while idx < mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + ceil32(return_data.size) + 257]:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + 453] = this.address
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + 485] = block.timestamp
                                require ext_code.size(uniswapV2RouterAddress)
                                call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                     gas gas_remaining wei
                                    args 0, 0, 160, address(this.address), block.timestamp, mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + 517 len (32 * mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + ceil32(return_data.size) + 257]) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if eth.balance(this.address) > eth.balance(this.address):
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + 417] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + 421] = 32
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + 453] = 30
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + 485] = 'SafeMath: subtraction overflow'
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + 515] = 0
                                    revert with memory
                                      from ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + 417
                                       len (5 * ceil32(return_data.size)) + 100
                                if eth.balance(this.address) < eth.balance(this.address):
                                    revert with 0, 17
                                call futurUsePoolAddress with:
                                     gas 2300 wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if ext_call.return_data[0] < 0:
                                    revert with 0, 17
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + 421] = distributionPoolAddress
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + 453] = msg.sender
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + 485] = ext_call.return_data[0]
                            else:
                                if ext_call.return_data[0] and cashoutFee > -1 / ext_call.return_data[0]:
                                    revert with 0, 17
                                if not ext_call.return_data[0]:
                                    revert with 0, 18
                                if ext_call.return_data[0] * cashoutFee / ext_call.return_data[0] != cashoutFee:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + ceil32(return_data.size) + 257] = 2
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + ceil32(return_data.size) + 289] = stor9
                                require ext_code.size(uniswapV2RouterAddress)
                                staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                        gas gas_remaining wei
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + ceil32(return_data.size) + 353] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + ceil32(return_data.size) + 321] = ext_call.return_data[12 len 20]
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (2 * ceil32(return_data.size)) + 357] = uniswapV2RouterAddress
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (2 * ceil32(return_data.size)) + 389] = ext_call.return_data[0] * cashoutFee / 100
                                require ext_code.size(stor9)
                                call stor9.approve(address arg1, uint256 arg2) with:
                                     gas gas_remaining wei
                                    args uniswapV2RouterAddress, ext_call.return_data[0] * cashoutFee / 100
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (2 * ceil32(return_data.size)) + 353] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + 353
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + 353] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + 357] = ext_call.return_data[0] * cashoutFee / 100
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + 389] = 0
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + 421] = 160
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + 517] = 2
                                idx = 0
                                s = ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + 549
                                t = ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + ceil32(return_data.size) + 289
                                while idx < mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + ceil32(return_data.size) + 257]:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + 453] = this.address
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + 485] = block.timestamp
                                require ext_code.size(uniswapV2RouterAddress)
                                call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0] * cashoutFee / 100, 0, 160, address(this.address), block.timestamp, mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + 517 len (32 * mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + ceil32(return_data.size) + 257]) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if eth.balance(this.address) > eth.balance(this.address):
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + 417] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + 421] = 32
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + 453] = 30
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + 485] = 'SafeMath: subtraction overflow'
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + 515] = 0
                                    revert with memory
                                      from ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + 417
                                       len (5 * ceil32(return_data.size)) + 100
                                if eth.balance(this.address) < eth.balance(this.address):
                                    revert with 0, 17
                                call futurUsePoolAddress with:
                                     gas 2300 wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if ext_call.return_data[0] < ext_call.return_data[0] * cashoutFee / 100:
                                    revert with 0, 17
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + 421] = distributionPoolAddress
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + 453] = msg.sender
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + 485] = ext_call.return_data[0] - (ext_call.return_data[0] * cashoutFee / 100)
                            require ext_code.size(stor9)
                            call stor9.0x23b872dd with:
                                 gas gas_remaining wei
                                args mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + 421 len (5 * ceil32(return_data.size)) + 96]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                else:
                    if 31 < uint255(uint256(stor[_2329].field_0)) * 0.5:
                        mem[ceil32(ceil32(arg1.length)) + 193] = uint256(stor[sha3(_2329)].field_0)
                        idx = ceil32(ceil32(arg1.length)) + 193
                        s = 0
                        while ceil32(ceil32(arg1.length)) + (uint255(uint256(stor[_2329].field_0)) * 0.5) + 161 > idx:
                            mem[idx + 32] = uint256(stor[s + sha3(_2329) + 1].field_0)
                            idx = idx + 32
                            s = s + 1
                            continue 
                        mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
                        mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_2329])
                        if not msg.sender:
                            revert with 0, 'MANIA CSHT:  creation from the zero address'
                        mem[0] = msg.sender
                        mem[32] = 22
                        if stor22[address(msg.sender)]:
                            revert with 0, 'MANIA CSHT: Blacklisted address'
                        if futurUsePoolAddress == msg.sender:
                            revert with 0, 'MANIA CSHT: futur and rewardsPool cannot cashout rewards'
                        if distributionPoolAddress == msg.sender:
                            revert with 0, 'MANIA CSHT: futur and rewardsPool cannot cashout rewards'
                        mem[mem[64] + 4] = msg.sender
                        require ext_code.size(address(stor1[_2329]))
                        staticcall address(stor1[_2329])._getRewardAmountOf(address arg1) with:
                                gas gas_remaining wei
                               args msg.sender
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _4876 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _4916 = mem[_4876]
                        if mem[_4876] <= 0:
                            revert with 0, 'MANIA CSHT: You don't have enough reward to cash out'
                        if not uint8(stor20):
                            mem[mem[64] + 4] = distributionPoolAddress
                            mem[mem[64] + 36] = msg.sender
                            mem[mem[64] + 68] = _4916
                            require ext_code.size(stor9)
                            call stor9.0x23b872dd with:
                                 gas gas_remaining wei
                                args distributionPoolAddress, msg.sender, _4916
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _5062 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_5062] == bool(mem[_5062])
                        else:
                            if not cashoutFee:
                                if mem[_4876] < 0:
                                    revert with 0, 17
                                mem[mem[64] + 4] = distributionPoolAddress
                                mem[mem[64] + 36] = msg.sender
                                mem[mem[64] + 68] = _4916
                                require ext_code.size(stor9)
                                call stor9.0x23b872dd with:
                                     gas gas_remaining wei
                                    args distributionPoolAddress, msg.sender, _4916
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _5198 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_5198] == bool(mem[_5198])
                            else:
                                if not mem[_4876]:
                                    _5135 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5135] = 26
                                    mem[_5135 + 32] = 'SafeMath: division by zero'
                                    _5352 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    mem[_5352 + 32 len 64] = call.data[calldata.size len 64]
                                    if not mem[_5352]:
                                        revert with 0, 50
                                    mem[_5352 + 32] = stor9
                                    require ext_code.size(uniswapV2RouterAddress)
                                    staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                            gas gas_remaining wei
                                    mem[_5352 + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = _5352 + ceil32(return_data.size) + 96
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    if 1 >= mem[_5352]:
                                        revert with 0, 50
                                    mem[_5352 + 64] = ext_call.return_data[12 len 20]
                                    mem[_5352 + ceil32(return_data.size) + 100] = uniswapV2RouterAddress
                                    mem[_5352 + ceil32(return_data.size) + 132] = 0
                                    require ext_code.size(stor9)
                                    call stor9.approve(address arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args uniswapV2RouterAddress, 0
                                    mem[_5352 + ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = _5352 + (2 * ceil32(return_data.size)) + 96
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    mem[_5352 + (2 * ceil32(return_data.size)) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                    mem[_5352 + (2 * ceil32(return_data.size)) + 100] = 0
                                    mem[_5352 + (2 * ceil32(return_data.size)) + 132] = 0
                                    mem[_5352 + (2 * ceil32(return_data.size)) + 164] = 160
                                    mem[_5352 + (2 * ceil32(return_data.size)) + 260] = mem[_5352]
                                    idx = 0
                                    s = _5352 + (2 * ceil32(return_data.size)) + 292
                                    t = _5352 + 32
                                    while idx < mem[_5352]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(uniswapV2RouterAddress)
                                    call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args 0, 0, 160, address(this.address), block.timestamp, mem[_5352 + (2 * ceil32(return_data.size)) + 260 len (32 * mem[_5352]) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if eth.balance(this.address) > eth.balance(this.address):
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if eth.balance(this.address) < eth.balance(this.address):
                                        revert with 0, 17
                                    call futurUsePoolAddress with:
                                         gas 2300 wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if _4916 < 0:
                                        revert with 0, 17
                                    require ext_code.size(stor9)
                                    call stor9.0x23b872dd with:
                                         gas gas_remaining wei
                                        args distributionPoolAddress, msg.sender, _4916
                                else:
                                    if mem[_4876] and cashoutFee > -1 / mem[_4876]:
                                        revert with 0, 17
                                    if not mem[_4876]:
                                        revert with 0, 18
                                    if mem[_4876] * cashoutFee / mem[_4876] != cashoutFee:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _5303 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5303] = 26
                                    mem[_5303 + 32] = 'SafeMath: division by zero'
                                    _5534 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    mem[_5534 + 32 len 64] = call.data[calldata.size len 64]
                                    if not mem[_5534]:
                                        revert with 0, 50
                                    mem[_5534 + 32] = stor9
                                    require ext_code.size(uniswapV2RouterAddress)
                                    staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                            gas gas_remaining wei
                                    mem[_5534 + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = _5534 + ceil32(return_data.size) + 96
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    if 1 >= mem[_5534]:
                                        revert with 0, 50
                                    mem[_5534 + 64] = ext_call.return_data[12 len 20]
                                    mem[_5534 + ceil32(return_data.size) + 100] = uniswapV2RouterAddress
                                    mem[_5534 + ceil32(return_data.size) + 132] = _4916 * cashoutFee / 100
                                    require ext_code.size(stor9)
                                    call stor9.approve(address arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args uniswapV2RouterAddress, _4916 * cashoutFee / 100
                                    mem[_5534 + ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = _5534 + (2 * ceil32(return_data.size)) + 96
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    mem[_5534 + (2 * ceil32(return_data.size)) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                    mem[_5534 + (2 * ceil32(return_data.size)) + 100] = _4916 * cashoutFee / 100
                                    mem[_5534 + (2 * ceil32(return_data.size)) + 132] = 0
                                    mem[_5534 + (2 * ceil32(return_data.size)) + 164] = 160
                                    mem[_5534 + (2 * ceil32(return_data.size)) + 260] = mem[_5534]
                                    idx = 0
                                    s = _5534 + (2 * ceil32(return_data.size)) + 292
                                    t = _5534 + 32
                                    while idx < mem[_5534]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(uniswapV2RouterAddress)
                                    call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args _4916 * cashoutFee / 100, 0, 160, address(this.address), block.timestamp, mem[_5534 + (2 * ceil32(return_data.size)) + 260 len (32 * mem[_5534]) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if eth.balance(this.address) > eth.balance(this.address):
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if eth.balance(this.address) < eth.balance(this.address):
                                        revert with 0, 17
                                    call futurUsePoolAddress with:
                                         gas 2300 wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if _4916 < _4916 * cashoutFee / 100:
                                        revert with 0, 17
                                    require ext_code.size(stor9)
                                    call stor9.0x23b872dd with:
                                         gas gas_remaining wei
                                        args distributionPoolAddress, msg.sender, _4916 - (_4916 * cashoutFee / 100)
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                    else:
                        mem[ceil32(ceil32(arg1.length)) + 193] = 256 * Mask(248, 0, stor[_2329].field_8)
                        mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
                        mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_2329])
                        if not msg.sender:
                            revert with 0, 'MANIA CSHT:  creation from the zero address'
                        mem[0] = msg.sender
                        mem[32] = 22
                        if stor22[address(msg.sender)]:
                            revert with 0, 'MANIA CSHT: Blacklisted address'
                        if futurUsePoolAddress == msg.sender:
                            revert with 0, 'MANIA CSHT: futur and rewardsPool cannot cashout rewards'
                        if distributionPoolAddress == msg.sender:
                            revert with 0, 'MANIA CSHT: futur and rewardsPool cannot cashout rewards'
                        mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + 197] = msg.sender
                        require ext_code.size(address(stor1[_2329]))
                        staticcall address(stor1[_2329])._getRewardAmountOf(address arg1) with:
                                gas gas_remaining wei
                               args msg.sender
                        mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + 193] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if ext_call.return_data[0] <= 0:
                            revert with 0, 'MANIA CSHT: You don't have enough reward to cash out'
                        if not uint8(stor20):
                            require ext_code.size(stor9)
                            call stor9.0x23b872dd with:
                                 gas gas_remaining wei
                                args distributionPoolAddress, msg.sender, ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                        else:
                            if not cashoutFee:
                                if ext_call.return_data[0] < 0:
                                    revert with 0, 17
                                require ext_code.size(stor9)
                                call stor9.0x23b872dd with:
                                     gas gas_remaining wei
                                    args distributionPoolAddress, msg.sender, ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                            else:
                                if not ext_call.return_data[0]:
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + ceil32(return_data.size) + 257] = 2
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + ceil32(return_data.size) + 289] = stor9
                                    require ext_code.size(uniswapV2RouterAddress)
                                    staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                            gas gas_remaining wei
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + ceil32(return_data.size) + 353] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + ceil32(return_data.size) + 321] = ext_call.return_data[12 len 20]
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (2 * ceil32(return_data.size)) + 357] = uniswapV2RouterAddress
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (2 * ceil32(return_data.size)) + 389] = 0
                                    require ext_code.size(stor9)
                                    call stor9.approve(address arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args uniswapV2RouterAddress, 0
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (2 * ceil32(return_data.size)) + 353] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + 353
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + 353] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + 357] = 0
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + 389] = 0
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + 421] = 160
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + 517] = 2
                                    idx = 0
                                    s = ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + 549
                                    t = ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + ceil32(return_data.size) + 289
                                    while idx < mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + ceil32(return_data.size) + 257]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + 453] = this.address
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + 485] = block.timestamp
                                    require ext_code.size(uniswapV2RouterAddress)
                                    call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args 0, 0, 160, address(this.address), block.timestamp, mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + 517 len (32 * mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + ceil32(return_data.size) + 257]) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if eth.balance(this.address) > eth.balance(this.address):
                                        mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + 417] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + 421] = 32
                                        mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + 453] = 30
                                        mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + 485] = 'SafeMath: subtraction overflow'
                                        mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + 515] = 0
                                        revert with memory
                                          from ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + 417
                                           len (5 * ceil32(return_data.size)) + 100
                                    if eth.balance(this.address) < eth.balance(this.address):
                                        revert with 0, 17
                                    call futurUsePoolAddress with:
                                         gas 2300 wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if ext_call.return_data[0] < 0:
                                        revert with 0, 17
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + 421] = distributionPoolAddress
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + 453] = msg.sender
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + 485] = ext_call.return_data[0]
                                    require ext_code.size(stor9)
                                    call stor9.0x23b872dd with:
                                         gas gas_remaining wei
                                        args mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + 421 len (5 * ceil32(return_data.size)) + 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                else:
                                    if ext_call.return_data[0] and cashoutFee > -1 / ext_call.return_data[0]:
                                        revert with 0, 17
                                    if not ext_call.return_data[0]:
                                        revert with 0, 18
                                    if ext_call.return_data[0] * cashoutFee / ext_call.return_data[0] != cashoutFee:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + ceil32(return_data.size) + 193] = 26
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + ceil32(return_data.size) + 225] = 'SafeMath: division by zero'
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + ceil32(return_data.size) + 257] = 2
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + ceil32(return_data.size) + 289] = stor9
                                    require ext_code.size(uniswapV2RouterAddress)
                                    staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                            gas gas_remaining wei
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + ceil32(return_data.size) + 353] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + ceil32(return_data.size) + 321] = ext_call.return_data[12 len 20]
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (2 * ceil32(return_data.size)) + 357] = uniswapV2RouterAddress
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (2 * ceil32(return_data.size)) + 389] = ext_call.return_data[0] * cashoutFee / 100
                                    require ext_code.size(stor9)
                                    call stor9.approve(address arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args uniswapV2RouterAddress, ext_call.return_data[0] * cashoutFee / 100
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (2 * ceil32(return_data.size)) + 353] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + 353
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + 353] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + 357] = ext_call.return_data[0] * cashoutFee / 100
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + 389] = 0
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + 421] = 160
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + 517] = 2
                                    idx = 0
                                    s = ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + 549
                                    t = ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + ceil32(return_data.size) + 289
                                    while idx < mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + ceil32(return_data.size) + 257]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + 453] = this.address
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + 485] = block.timestamp
                                    require ext_code.size(uniswapV2RouterAddress)
                                    call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + (32 * mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + ceil32(return_data.size) + 257]) + -mem[64] + 545]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _4775 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4775] = 30
                                    mem[_4775 + 32] = 'SafeMath: subtraction overflow'
                                    if eth.balance(this.address) > eth.balance(this.address):
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if eth.balance(this.address) < eth.balance(this.address):
                                        revert with 0, 17
                                    call futurUsePoolAddress with:
                                         gas 2300 wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if ext_call.return_data[0] < ext_call.return_data[0] * cashoutFee / 100:
                                        revert with 0, 17
                                    mem[mem[64] + 4] = distributionPoolAddress
                                    mem[mem[64] + 36] = msg.sender
                                    mem[mem[64] + 68] = ext_call.return_data[0] - (ext_call.return_data[0] * cashoutFee / 100)
                                    require ext_code.size(stor9)
                                    call stor9.0x23b872dd with:
                                         gas gas_remaining wei
                                        args distributionPoolAddress, msg.sender, ext_call.return_data[0] - (ext_call.return_data[0] * cashoutFee / 100)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5199 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_5199] == bool(mem[_5199])
            else:
                if bool(stor[_2329].field_0) == stor[_2329].field_1 % 128 < 32:
                    revert with 0, 34
                if not stor[_2329].field_1 % 128:
                    mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
                    mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_2329])
                    if not msg.sender:
                        revert with 0, 'MANIA CSHT:  creation from the zero address'
                    mem[0] = msg.sender
                    mem[32] = 22
                    if stor22[address(msg.sender)]:
                        revert with 0, 'MANIA CSHT: Blacklisted address'
                    if futurUsePoolAddress == msg.sender:
                        revert with 0, 'MANIA CSHT: futur and rewardsPool cannot cashout rewards'
                    if distributionPoolAddress == msg.sender:
                        revert with 0, 'MANIA CSHT: futur and rewardsPool cannot cashout rewards'
                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + 197] = msg.sender
                    require ext_code.size(address(stor1[_2329]))
                    staticcall address(stor1[_2329])._getRewardAmountOf(address arg1) with:
                            gas gas_remaining wei
                           args msg.sender
                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + 193] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if ext_call.return_data[0] <= 0:
                        revert with 0, 'MANIA CSHT: You don't have enough reward to cash out'
                    if not uint8(stor20):
                        require ext_code.size(stor9)
                        call stor9.0x23b872dd with:
                             gas gas_remaining wei
                            args distributionPoolAddress, msg.sender, ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                    else:
                        if not cashoutFee:
                            if ext_call.return_data[0] < 0:
                                revert with 0, 17
                            require ext_code.size(stor9)
                            call stor9.0x23b872dd with:
                                 gas gas_remaining wei
                                args distributionPoolAddress, msg.sender, ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                        else:
                            if not ext_call.return_data[0]:
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + ceil32(return_data.size) + 257] = 2
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + ceil32(return_data.size) + 289] = stor9
                                require ext_code.size(uniswapV2RouterAddress)
                                staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                        gas gas_remaining wei
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + ceil32(return_data.size) + 353] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + ceil32(return_data.size) + 321] = ext_call.return_data[12 len 20]
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (2 * ceil32(return_data.size)) + 357] = uniswapV2RouterAddress
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (2 * ceil32(return_data.size)) + 389] = 0
                                require ext_code.size(stor9)
                                call stor9.approve(address arg1, uint256 arg2) with:
                                     gas gas_remaining wei
                                    args uniswapV2RouterAddress, 0
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (2 * ceil32(return_data.size)) + 353] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + 353
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + 353] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + 357] = 0
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + 389] = 0
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + 421] = 160
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + 517] = 2
                                idx = 0
                                s = ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + 549
                                t = ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + ceil32(return_data.size) + 289
                                while idx < mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + ceil32(return_data.size) + 257]:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + 453] = this.address
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + 485] = block.timestamp
                                require ext_code.size(uniswapV2RouterAddress)
                                call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                     gas gas_remaining wei
                                    args 0, 0, 160, address(this.address), block.timestamp, mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + 517 len (32 * mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + ceil32(return_data.size) + 257]) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if eth.balance(this.address) > eth.balance(this.address):
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + 417] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + 421] = 32
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + 453] = 30
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + 485] = 'SafeMath: subtraction overflow'
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + 515] = 0
                                    revert with memory
                                      from ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + 417
                                       len (5 * ceil32(return_data.size)) + 100
                                if eth.balance(this.address) < eth.balance(this.address):
                                    revert with 0, 17
                                call futurUsePoolAddress with:
                                     gas 2300 wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if ext_call.return_data[0] < 0:
                                    revert with 0, 17
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + 421] = distributionPoolAddress
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + 453] = msg.sender
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + 485] = ext_call.return_data[0]
                                require ext_code.size(stor9)
                                call stor9.0x23b872dd with:
                                     gas gas_remaining wei
                                    args mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + 421 len (5 * ceil32(return_data.size)) + 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                            else:
                                if ext_call.return_data[0] and cashoutFee > -1 / ext_call.return_data[0]:
                                    revert with 0, 17
                                if not ext_call.return_data[0]:
                                    revert with 0, 18
                                if ext_call.return_data[0] * cashoutFee / ext_call.return_data[0] != cashoutFee:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + ceil32(return_data.size) + 193] = 26
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + ceil32(return_data.size) + 225] = 'SafeMath: division by zero'
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + ceil32(return_data.size) + 257] = 2
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + ceil32(return_data.size) + 289] = stor9
                                require ext_code.size(uniswapV2RouterAddress)
                                staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                        gas gas_remaining wei
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + ceil32(return_data.size) + 353] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + ceil32(return_data.size) + 321] = ext_call.return_data[12 len 20]
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (2 * ceil32(return_data.size)) + 357] = uniswapV2RouterAddress
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (2 * ceil32(return_data.size)) + 389] = ext_call.return_data[0] * cashoutFee / 100
                                require ext_code.size(stor9)
                                call stor9.approve(address arg1, uint256 arg2) with:
                                     gas gas_remaining wei
                                    args uniswapV2RouterAddress, ext_call.return_data[0] * cashoutFee / 100
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (2 * ceil32(return_data.size)) + 353] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + 353
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + 353] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + 357] = ext_call.return_data[0] * cashoutFee / 100
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + 389] = 0
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + 421] = 160
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + 517] = 2
                                idx = 0
                                s = ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + 549
                                t = ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + ceil32(return_data.size) + 289
                                while idx < mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + ceil32(return_data.size) + 257]:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + 453] = this.address
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + 485] = block.timestamp
                                require ext_code.size(uniswapV2RouterAddress)
                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + (32 * mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + ceil32(return_data.size) + 257]) + -mem[64] + 545]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4777 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4777] = 30
                                mem[_4777 + 32] = 'SafeMath: subtraction overflow'
                                if eth.balance(this.address) > eth.balance(this.address):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if eth.balance(this.address) < eth.balance(this.address):
                                    revert with 0, 17
                                call futurUsePoolAddress with:
                                     gas 2300 wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if ext_call.return_data[0] < ext_call.return_data[0] * cashoutFee / 100:
                                    revert with 0, 17
                                mem[mem[64] + 4] = distributionPoolAddress
                                mem[mem[64] + 36] = msg.sender
                                mem[mem[64] + 68] = ext_call.return_data[0] - (ext_call.return_data[0] * cashoutFee / 100)
                                require ext_code.size(stor9)
                                call stor9.0x23b872dd with:
                                     gas gas_remaining wei
                                    args distributionPoolAddress, msg.sender, ext_call.return_data[0] - (ext_call.return_data[0] * cashoutFee / 100)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _5201 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_5201] == bool(mem[_5201])
                else:
                    if 31 >= stor[_2329].field_1 % 128:
                        mem[ceil32(ceil32(arg1.length)) + 193] = 256 * Mask(248, 0, stor[_2329].field_8)
                        mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
                        mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_2329])
                        if not msg.sender:
                            revert with 0, 'MANIA CSHT:  creation from the zero address'
                        mem[0] = msg.sender
                        mem[32] = 22
                        if stor22[address(msg.sender)]:
                            revert with 0, 'MANIA CSHT: Blacklisted address'
                        if futurUsePoolAddress == msg.sender:
                            revert with 0, 'MANIA CSHT: futur and rewardsPool cannot cashout rewards'
                        if distributionPoolAddress == msg.sender:
                            revert with 0, 'MANIA CSHT: futur and rewardsPool cannot cashout rewards'
                        mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + 197] = msg.sender
                        require ext_code.size(address(stor1[_2329]))
                        staticcall address(stor1[_2329])._getRewardAmountOf(address arg1) with:
                                gas gas_remaining wei
                               args msg.sender
                        mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + 193] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if ext_call.return_data[0] <= 0:
                            revert with 0, 'MANIA CSHT: You don't have enough reward to cash out'
                        if not uint8(stor20):
                            require ext_code.size(stor9)
                            call stor9.0x23b872dd with:
                                 gas gas_remaining wei
                                args distributionPoolAddress, msg.sender, ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                        else:
                            if not cashoutFee:
                                if ext_call.return_data[0] < 0:
                                    revert with 0, 17
                                require ext_code.size(stor9)
                                call stor9.0x23b872dd with:
                                     gas gas_remaining wei
                                    args distributionPoolAddress, msg.sender, ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                            else:
                                if not ext_call.return_data[0]:
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + ceil32(return_data.size) + 193] = 26
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + ceil32(return_data.size) + 225] = 'SafeMath: division by zero'
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + ceil32(return_data.size) + 257] = 2
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + ceil32(return_data.size) + 289] = stor9
                                    require ext_code.size(uniswapV2RouterAddress)
                                    staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                            gas gas_remaining wei
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + ceil32(return_data.size) + 353] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + ceil32(return_data.size) + 321] = ext_call.return_data[12 len 20]
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (2 * ceil32(return_data.size)) + 357] = uniswapV2RouterAddress
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (2 * ceil32(return_data.size)) + 389] = 0
                                    require ext_code.size(stor9)
                                    call stor9.approve(address arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args uniswapV2RouterAddress, 0
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (2 * ceil32(return_data.size)) + 353] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + 353
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + 353] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + 357] = 0
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + 389] = 0
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + 421] = 160
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + 517] = 2
                                    idx = 0
                                    s = ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + 549
                                    t = ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + ceil32(return_data.size) + 289
                                    while idx < mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + ceil32(return_data.size) + 257]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + 453] = this.address
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + 485] = block.timestamp
                                    require ext_code.size(uniswapV2RouterAddress)
                                    call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + (32 * mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + ceil32(return_data.size) + 257]) + -mem[64] + 545]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _4781 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4781] = 30
                                    mem[_4781 + 32] = 'SafeMath: subtraction overflow'
                                    if eth.balance(this.address) > eth.balance(this.address):
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if eth.balance(this.address) < eth.balance(this.address):
                                        revert with 0, 17
                                    call futurUsePoolAddress with:
                                         gas 2300 wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if ext_call.return_data[0] < 0:
                                        revert with 0, 17
                                    mem[mem[64] + 4] = distributionPoolAddress
                                    mem[mem[64] + 36] = msg.sender
                                    mem[mem[64] + 68] = ext_call.return_data[0]
                                    require ext_code.size(stor9)
                                    call stor9.0x23b872dd with:
                                         gas gas_remaining wei
                                        args distributionPoolAddress, msg.sender, ext_call.return_data[0]
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5205 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_5205] == bool(mem[_5205])
                                else:
                                    if ext_call.return_data[0] and cashoutFee > -1 / ext_call.return_data[0]:
                                        revert with 0, 17
                                    if not ext_call.return_data[0]:
                                        revert with 0, 18
                                    if ext_call.return_data[0] * cashoutFee / ext_call.return_data[0] != cashoutFee:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + ceil32(return_data.size) + 193] = 26
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + ceil32(return_data.size) + 225] = 'SafeMath: division by zero'
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + ceil32(return_data.size) + 257] = 2
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + ceil32(return_data.size) + 289] = stor9
                                    require ext_code.size(uniswapV2RouterAddress)
                                    staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                            gas gas_remaining wei
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + ceil32(return_data.size) + 353] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + ceil32(return_data.size) + 321] = ext_call.return_data[12 len 20]
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (2 * ceil32(return_data.size)) + 357] = uniswapV2RouterAddress
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (2 * ceil32(return_data.size)) + 389] = ext_call.return_data[0] * cashoutFee / 100
                                    require ext_code.size(stor9)
                                    call stor9.approve(address arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args uniswapV2RouterAddress, ext_call.return_data[0] * cashoutFee / 100
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (2 * ceil32(return_data.size)) + 353] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + 353
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + 353] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + 357] = ext_call.return_data[0] * cashoutFee / 100
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + 389] = 0
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + 421] = 160
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + 517] = 2
                                    idx = 0
                                    s = ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + 549
                                    t = ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + ceil32(return_data.size) + 289
                                    while idx < mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + ceil32(return_data.size) + 257]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + 453] = this.address
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + 485] = block.timestamp
                                    require ext_code.size(uniswapV2RouterAddress)
                                    call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + (4 * ceil32(return_data.size)) + (32 * mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2329].field_1 % 128) + ceil32(return_data.size) + 257]) + -mem[64] + 545]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _4780 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4780] = 30
                                    mem[_4780 + 32] = 'SafeMath: subtraction overflow'
                                    if eth.balance(this.address) > eth.balance(this.address):
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if eth.balance(this.address) < eth.balance(this.address):
                                        revert with 0, 17
                                    call futurUsePoolAddress with:
                                         gas 2300 wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if ext_call.return_data[0] < ext_call.return_data[0] * cashoutFee / 100:
                                        revert with 0, 17
                                    mem[mem[64] + 4] = distributionPoolAddress
                                    mem[mem[64] + 36] = msg.sender
                                    mem[mem[64] + 68] = ext_call.return_data[0] - (ext_call.return_data[0] * cashoutFee / 100)
                                    require ext_code.size(stor9)
                                    call stor9.0x23b872dd with:
                                         gas gas_remaining wei
                                        args distributionPoolAddress, msg.sender, ext_call.return_data[0] - (ext_call.return_data[0] * cashoutFee / 100)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5204 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_5204] == bool(mem[_5204])
                    else:
                        mem[ceil32(ceil32(arg1.length)) + 193] = uint256(stor[sha3(_2329)].field_0)
                        idx = ceil32(ceil32(arg1.length)) + 193
                        s = 0
                        while ceil32(ceil32(arg1.length)) + stor[_2329].field_1 % 128 + 161 > idx:
                            mem[idx + 32] = uint256(stor[s + sha3(_2329) + 1].field_0)
                            idx = idx + 32
                            s = s + 1
                            continue 
                        mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
                        mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_2329])
                        if not msg.sender:
                            revert with 0, 'MANIA CSHT:  creation from the zero address'
                        mem[0] = msg.sender
                        mem[32] = 22
                        if stor22[address(msg.sender)]:
                            revert with 0, 'MANIA CSHT: Blacklisted address'
                        if futurUsePoolAddress == msg.sender:
                            revert with 0, 'MANIA CSHT: futur and rewardsPool cannot cashout rewards'
                        if distributionPoolAddress == msg.sender:
                            revert with 0, 'MANIA CSHT: futur and rewardsPool cannot cashout rewards'
                        mem[mem[64] + 4] = msg.sender
                        require ext_code.size(address(stor1[_2329]))
                        staticcall address(stor1[_2329])._getRewardAmountOf(address arg1) with:
                                gas gas_remaining wei
                               args msg.sender
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _4877 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _4917 = mem[_4877]
                        if mem[_4877] <= 0:
                            revert with 0, 'MANIA CSHT: You don't have enough reward to cash out'
                        if not uint8(stor20):
                            mem[mem[64] + 4] = distributionPoolAddress
                            mem[mem[64] + 36] = msg.sender
                            mem[mem[64] + 68] = _4917
                            require ext_code.size(stor9)
                            call stor9.0x23b872dd with:
                                 gas gas_remaining wei
                                args distributionPoolAddress, msg.sender, _4917
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _5067 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_5067] == bool(mem[_5067])
                        else:
                            if not cashoutFee:
                                if mem[_4877] < 0:
                                    revert with 0, 17
                                mem[mem[64] + 4] = distributionPoolAddress
                                mem[mem[64] + 36] = msg.sender
                                mem[mem[64] + 68] = _4917
                                require ext_code.size(stor9)
                                call stor9.0x23b872dd with:
                                     gas gas_remaining wei
                                    args distributionPoolAddress, msg.sender, _4917
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _5203 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_5203] == bool(mem[_5203])
                            else:
                                if not mem[_4877]:
                                    _5137 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5137] = 26
                                    mem[_5137 + 32] = 'SafeMath: division by zero'
                                    _5364 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    mem[_5364 + 32 len 64] = call.data[calldata.size len 64]
                                    if not mem[_5364]:
                                        revert with 0, 50
                                    mem[_5364 + 32] = stor9
                                    require ext_code.size(uniswapV2RouterAddress)
                                    staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                            gas gas_remaining wei
                                    mem[_5364 + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = _5364 + ceil32(return_data.size) + 96
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    if 1 >= mem[_5364]:
                                        revert with 0, 50
                                    mem[_5364 + 64] = ext_call.return_data[12 len 20]
                                    mem[_5364 + ceil32(return_data.size) + 100] = uniswapV2RouterAddress
                                    mem[_5364 + ceil32(return_data.size) + 132] = 0
                                    require ext_code.size(stor9)
                                    call stor9.approve(address arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args uniswapV2RouterAddress, 0
                                    mem[_5364 + ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = _5364 + (2 * ceil32(return_data.size)) + 96
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    mem[_5364 + (2 * ceil32(return_data.size)) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                    mem[_5364 + (2 * ceil32(return_data.size)) + 100] = 0
                                    mem[_5364 + (2 * ceil32(return_data.size)) + 132] = 0
                                    mem[_5364 + (2 * ceil32(return_data.size)) + 164] = 160
                                    mem[_5364 + (2 * ceil32(return_data.size)) + 260] = mem[_5364]
                                    idx = 0
                                    s = _5364 + (2 * ceil32(return_data.size)) + 292
                                    t = _5364 + 32
                                    while idx < mem[_5364]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5364 + (2 * ceil32(return_data.size)) + 196] = this.address
                                    mem[_5364 + (2 * ceil32(return_data.size)) + 228] = block.timestamp
                                    require ext_code.size(uniswapV2RouterAddress)
                                    call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5364 + (2 * ceil32(return_data.size)) + (32 * mem[_5364]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _6079 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6079] = 30
                                    mem[_6079 + 32] = 'SafeMath: subtraction overflow'
                                    if eth.balance(this.address) > eth.balance(this.address):
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if eth.balance(this.address) < eth.balance(this.address):
                                        revert with 0, 17
                                    call futurUsePoolAddress with:
                                         gas 2300 wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if _4917 < 0:
                                        revert with 0, 17
                                    mem[mem[64] + 4] = distributionPoolAddress
                                    mem[mem[64] + 36] = msg.sender
                                    mem[mem[64] + 68] = _4917
                                    require ext_code.size(stor9)
                                    call stor9.0x23b872dd with:
                                         gas gas_remaining wei
                                        args distributionPoolAddress, msg.sender, _4917
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _6241 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_6241] == bool(mem[_6241])
                                else:
                                    if mem[_4877] and cashoutFee > -1 / mem[_4877]:
                                        revert with 0, 17
                                    if not mem[_4877]:
                                        revert with 0, 18
                                    if mem[_4877] * cashoutFee / mem[_4877] != cashoutFee:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _5305 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5305] = 26
                                    mem[_5305 + 32] = 'SafeMath: division by zero'
                                    _5536 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    mem[_5536 + 32 len 64] = call.data[calldata.size len 64]
                                    if not mem[_5536]:
                                        revert with 0, 50
                                    mem[_5536 + 32] = stor9
                                    require ext_code.size(uniswapV2RouterAddress)
                                    staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                            gas gas_remaining wei
                                    mem[_5536 + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = _5536 + ceil32(return_data.size) + 96
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    if 1 >= mem[_5536]:
                                        revert with 0, 50
                                    mem[_5536 + 64] = ext_call.return_data[12 len 20]
                                    mem[_5536 + ceil32(return_data.size) + 100] = uniswapV2RouterAddress
                                    mem[_5536 + ceil32(return_data.size) + 132] = _4917 * cashoutFee / 100
                                    require ext_code.size(stor9)
                                    call stor9.approve(address arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args uniswapV2RouterAddress, _4917 * cashoutFee / 100
                                    mem[_5536 + ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = _5536 + (2 * ceil32(return_data.size)) + 96
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    mem[_5536 + (2 * ceil32(return_data.size)) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                    mem[_5536 + (2 * ceil32(return_data.size)) + 100] = _4917 * cashoutFee / 100
                                    mem[_5536 + (2 * ceil32(return_data.size)) + 132] = 0
                                    mem[_5536 + (2 * ceil32(return_data.size)) + 164] = 160
                                    mem[_5536 + (2 * ceil32(return_data.size)) + 260] = mem[_5536]
                                    idx = 0
                                    s = _5536 + (2 * ceil32(return_data.size)) + 292
                                    t = _5536 + 32
                                    while idx < mem[_5536]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5536 + (2 * ceil32(return_data.size)) + 196] = this.address
                                    mem[_5536 + (2 * ceil32(return_data.size)) + 228] = block.timestamp
                                    require ext_code.size(uniswapV2RouterAddress)
                                    call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5536 + (2 * ceil32(return_data.size)) + (32 * mem[_5536]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _6078 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6078] = 30
                                    mem[_6078 + 32] = 'SafeMath: subtraction overflow'
                                    if eth.balance(this.address) > eth.balance(this.address):
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if eth.balance(this.address) < eth.balance(this.address):
                                        revert with 0, 17
                                    call futurUsePoolAddress with:
                                         gas 2300 wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if _4917 < _4917 * cashoutFee / 100:
                                        revert with 0, 17
                                    mem[mem[64] + 4] = distributionPoolAddress
                                    mem[mem[64] + 36] = msg.sender
                                    mem[mem[64] + 68] = _4917 - (_4917 * cashoutFee / 100)
                                    require ext_code.size(stor9)
                                    call stor9.0x23b872dd with:
                                         gas gas_remaining wei
                                        args distributionPoolAddress, msg.sender, _4917 - (_4917 * cashoutFee / 100)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _6240 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_6240] == bool(mem[_6240])
        require ext_code.size(address(stor1[_2329]))
        call address(stor1[_2329])._cashoutAllNodesReward(address arg1) with:
             gas gas_remaining wei
            args msg.sender
    else:
        _2332 = sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])
        if bool(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0):
            if bool(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0) == uint255(uint256(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0)) * 0.5 < 32:
                revert with 0, 34
            mem[64] = ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0)) * 0.5) + 193
            mem[ceil32(ceil32(arg1.length)) + 161] = uint255(uint256(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0)) * 0.5
            if bool(stor[_2332].field_0):
                if bool(stor[_2332].field_0) == uint255(uint256(stor[_2332].field_0)) * 0.5 < 32:
                    revert with 0, 34
                if not Mask(256, -1, uint256(stor[_2332].field_0)):
                    mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
                    mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_2332])
                    if not msg.sender:
                        revert with 0, 'MANIA CSHT:  creation from the zero address'
                    mem[0] = msg.sender
                    mem[32] = 22
                    if stor22[address(msg.sender)]:
                        revert with 0, 'MANIA CSHT: Blacklisted address'
                    if futurUsePoolAddress == msg.sender:
                        revert with 0, 'MANIA CSHT: futur and rewardsPool cannot cashout rewards'
                    if distributionPoolAddress == msg.sender:
                        revert with 0, 'MANIA CSHT: futur and rewardsPool cannot cashout rewards'
                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + 197] = msg.sender
                    require ext_code.size(address(stor1[_2332]))
                    staticcall address(stor1[_2332])._getRewardAmountOf(address arg1) with:
                            gas gas_remaining wei
                           args msg.sender
                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + 193] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if ext_call.return_data[0] <= 0:
                        revert with 0, 'MANIA CSHT: You don't have enough reward to cash out'
                    if not uint8(stor20):
                        require ext_code.size(stor9)
                        call stor9.0x23b872dd with:
                             gas gas_remaining wei
                            args distributionPoolAddress, msg.sender, ext_call.return_data[0]
                    else:
                        if not cashoutFee:
                            if ext_call.return_data[0] < 0:
                                revert with 0, 17
                            require ext_code.size(stor9)
                            call stor9.0x23b872dd with:
                                 gas gas_remaining wei
                                args distributionPoolAddress, msg.sender, ext_call.return_data[0]
                        else:
                            if not ext_call.return_data[0]:
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + ceil32(return_data.size) + 257] = 2
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + ceil32(return_data.size) + 289] = stor9
                                require ext_code.size(uniswapV2RouterAddress)
                                staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                        gas gas_remaining wei
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + ceil32(return_data.size) + 353] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + ceil32(return_data.size) + 321] = ext_call.return_data[12 len 20]
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 357] = uniswapV2RouterAddress
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 389] = 0
                                require ext_code.size(stor9)
                                call stor9.approve(address arg1, uint256 arg2) with:
                                     gas gas_remaining wei
                                    args uniswapV2RouterAddress, 0
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 353] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 353
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 353] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 357] = 0
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 389] = 0
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 421] = 160
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 517] = 2
                                idx = 0
                                s = ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 549
                                t = ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + ceil32(return_data.size) + 289
                                while idx < mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + ceil32(return_data.size) + 257]:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 453] = this.address
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 485] = block.timestamp
                                require ext_code.size(uniswapV2RouterAddress)
                                call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                     gas gas_remaining wei
                                    args 0, 0, 160, address(this.address), block.timestamp, mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 517 len (32 * mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + ceil32(return_data.size) + 257]) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if eth.balance(this.address) > eth.balance(this.address):
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 417] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 421] = 32
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 453] = 30
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 485] = 'SafeMath: subtraction overflow'
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 515] = 0
                                    revert with memory
                                      from ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 417
                                       len (5 * ceil32(return_data.size)) + 100
                                if eth.balance(this.address) < eth.balance(this.address):
                                    revert with 0, 17
                                call futurUsePoolAddress with:
                                     gas 2300 wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if ext_call.return_data[0] < 0:
                                    revert with 0, 17
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 421] = distributionPoolAddress
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 453] = msg.sender
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 485] = ext_call.return_data[0]
                            else:
                                if ext_call.return_data[0] and cashoutFee > -1 / ext_call.return_data[0]:
                                    revert with 0, 17
                                if not ext_call.return_data[0]:
                                    revert with 0, 18
                                if ext_call.return_data[0] * cashoutFee / ext_call.return_data[0] != cashoutFee:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + ceil32(return_data.size) + 257] = 2
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + ceil32(return_data.size) + 289] = stor9
                                require ext_code.size(uniswapV2RouterAddress)
                                staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                        gas gas_remaining wei
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + ceil32(return_data.size) + 353] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + ceil32(return_data.size) + 321] = ext_call.return_data[12 len 20]
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 357] = uniswapV2RouterAddress
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 389] = ext_call.return_data[0] * cashoutFee / 100
                                require ext_code.size(stor9)
                                call stor9.approve(address arg1, uint256 arg2) with:
                                     gas gas_remaining wei
                                    args uniswapV2RouterAddress, ext_call.return_data[0] * cashoutFee / 100
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 353] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 353
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 353] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 357] = ext_call.return_data[0] * cashoutFee / 100
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 389] = 0
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 421] = 160
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 517] = 2
                                idx = 0
                                s = ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 549
                                t = ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + ceil32(return_data.size) + 289
                                while idx < mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + ceil32(return_data.size) + 257]:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 453] = this.address
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 485] = block.timestamp
                                require ext_code.size(uniswapV2RouterAddress)
                                call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0] * cashoutFee / 100, 0, 160, address(this.address), block.timestamp, mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 517 len (32 * mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + ceil32(return_data.size) + 257]) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if eth.balance(this.address) > eth.balance(this.address):
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 417] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 421] = 32
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 453] = 30
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 485] = 'SafeMath: subtraction overflow'
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 515] = 0
                                    revert with memory
                                      from ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 417
                                       len (5 * ceil32(return_data.size)) + 100
                                if eth.balance(this.address) < eth.balance(this.address):
                                    revert with 0, 17
                                call futurUsePoolAddress with:
                                     gas 2300 wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if ext_call.return_data[0] < ext_call.return_data[0] * cashoutFee / 100:
                                    revert with 0, 17
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 421] = distributionPoolAddress
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 453] = msg.sender
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 485] = ext_call.return_data[0] - (ext_call.return_data[0] * cashoutFee / 100)
                            require ext_code.size(stor9)
                            call stor9.0x23b872dd with:
                                 gas gas_remaining wei
                                args mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 421 len (5 * ceil32(return_data.size)) + 96]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                else:
                    if 31 >= uint255(uint256(stor[_2332].field_0)) * 0.5:
                        mem[ceil32(ceil32(arg1.length)) + 193] = 256 * Mask(248, 0, stor[_2332].field_8)
                        mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
                        mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_2332])
                        if not msg.sender:
                            revert with 0, 'MANIA CSHT:  creation from the zero address'
                        mem[0] = msg.sender
                        mem[32] = 22
                        if stor22[address(msg.sender)]:
                            revert with 0, 'MANIA CSHT: Blacklisted address'
                        if futurUsePoolAddress == msg.sender:
                            revert with 0, 'MANIA CSHT: futur and rewardsPool cannot cashout rewards'
                        if distributionPoolAddress == msg.sender:
                            revert with 0, 'MANIA CSHT: futur and rewardsPool cannot cashout rewards'
                        mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + 197] = msg.sender
                        require ext_code.size(address(stor1[_2332]))
                        staticcall address(stor1[_2332])._getRewardAmountOf(address arg1) with:
                                gas gas_remaining wei
                               args msg.sender
                        mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + 193] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if ext_call.return_data[0] <= 0:
                            revert with 0, 'MANIA CSHT: You don't have enough reward to cash out'
                        if not uint8(stor20):
                            require ext_code.size(stor9)
                            call stor9.0x23b872dd with:
                                 gas gas_remaining wei
                                args distributionPoolAddress, msg.sender, ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                        else:
                            if not cashoutFee:
                                if ext_call.return_data[0] < 0:
                                    revert with 0, 17
                                require ext_code.size(stor9)
                                call stor9.0x23b872dd with:
                                     gas gas_remaining wei
                                    args distributionPoolAddress, msg.sender, ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                            else:
                                if ext_call.return_data[0]:
                                    if ext_call.return_data[0] and cashoutFee > -1 / ext_call.return_data[0]:
                                        revert with 0, 17
                                    if not ext_call.return_data[0]:
                                        revert with 0, 18
                                    if ext_call.return_data[0] * cashoutFee / ext_call.return_data[0] != cashoutFee:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + ceil32(return_data.size) + 257] = 2
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + ceil32(return_data.size) + 289] = stor9
                                    require ext_code.size(uniswapV2RouterAddress)
                                    staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                            gas gas_remaining wei
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + ceil32(return_data.size) + 353] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + ceil32(return_data.size) + 321] = ext_call.return_data[12 len 20]
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 357] = uniswapV2RouterAddress
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 389] = ext_call.return_data[0] * cashoutFee / 100
                                    require ext_code.size(stor9)
                                    call stor9.approve(address arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args uniswapV2RouterAddress, ext_call.return_data[0] * cashoutFee / 100
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 353] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 353
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 353] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 357] = ext_call.return_data[0] * cashoutFee / 100
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 389] = 0
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 421] = 160
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 517] = 2
                                    idx = 0
                                    s = ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 549
                                    t = ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + ceil32(return_data.size) + 289
                                    while idx < mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + ceil32(return_data.size) + 257]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 453] = this.address
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 485] = block.timestamp
                                    require ext_code.size(uniswapV2RouterAddress)
                                    call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0] * cashoutFee / 100, 0, 160, address(this.address), block.timestamp, mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 517 len (32 * mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + ceil32(return_data.size) + 257]) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if eth.balance(this.address) > eth.balance(this.address):
                                        mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 417] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 421] = 32
                                        mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 453] = 30
                                        mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 485] = 'SafeMath: subtraction overflow'
                                        mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 515] = 0
                                        revert with memory
                                          from ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 417
                                           len (5 * ceil32(return_data.size)) + 100
                                    if eth.balance(this.address) < eth.balance(this.address):
                                        revert with 0, 17
                                    call futurUsePoolAddress with:
                                         gas 2300 wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if ext_call.return_data[0] < ext_call.return_data[0] * cashoutFee / 100:
                                        revert with 0, 17
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 421] = distributionPoolAddress
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 453] = msg.sender
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 485] = ext_call.return_data[0] - (ext_call.return_data[0] * cashoutFee / 100)
                                    require ext_code.size(stor9)
                                    call stor9.0x23b872dd with:
                                         gas gas_remaining wei
                                        args mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 421 len (5 * ceil32(return_data.size)) + 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                else:
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + ceil32(return_data.size) + 193] = 26
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + ceil32(return_data.size) + 225] = 'SafeMath: division by zero'
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + ceil32(return_data.size) + 257] = 2
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + ceil32(return_data.size) + 289] = stor9
                                    require ext_code.size(uniswapV2RouterAddress)
                                    staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                            gas gas_remaining wei
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + ceil32(return_data.size) + 353] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + ceil32(return_data.size) + 321] = ext_call.return_data[12 len 20]
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 357] = uniswapV2RouterAddress
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 389] = 0
                                    require ext_code.size(stor9)
                                    call stor9.approve(address arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args uniswapV2RouterAddress, 0
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 353] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 353
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 353] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 357] = 0
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 389] = 0
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 421] = 160
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 517] = 2
                                    idx = 0
                                    s = ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 549
                                    t = ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + ceil32(return_data.size) + 289
                                    while idx < mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + ceil32(return_data.size) + 257]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 453] = this.address
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 485] = block.timestamp
                                    require ext_code.size(uniswapV2RouterAddress)
                                    call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + (32 * mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + ceil32(return_data.size) + 257]) + -mem[64] + 545]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _4786 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4786] = 30
                                    mem[_4786 + 32] = 'SafeMath: subtraction overflow'
                                    if eth.balance(this.address) > eth.balance(this.address):
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if eth.balance(this.address) < eth.balance(this.address):
                                        revert with 0, 17
                                    call futurUsePoolAddress with:
                                         gas 2300 wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if ext_call.return_data[0] < 0:
                                        revert with 0, 17
                                    mem[mem[64] + 4] = distributionPoolAddress
                                    mem[mem[64] + 36] = msg.sender
                                    mem[mem[64] + 68] = ext_call.return_data[0]
                                    require ext_code.size(stor9)
                                    call stor9.0x23b872dd with:
                                         gas gas_remaining wei
                                        args distributionPoolAddress, msg.sender, ext_call.return_data[0]
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5210 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_5210] == bool(mem[_5210])
                    else:
                        mem[ceil32(ceil32(arg1.length)) + 193] = uint256(stor[sha3(_2332)].field_0)
                        idx = ceil32(ceil32(arg1.length)) + 193
                        s = 0
                        while ceil32(ceil32(arg1.length)) + (uint255(uint256(stor[_2332].field_0)) * 0.5) + 161 > idx:
                            mem[idx + 32] = uint256(stor[s + sha3(_2332) + 1].field_0)
                            idx = idx + 32
                            s = s + 1
                            continue 
                        mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
                        mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_2332])
                        if not msg.sender:
                            revert with 0, 'MANIA CSHT:  creation from the zero address'
                        mem[0] = msg.sender
                        mem[32] = 22
                        if stor22[address(msg.sender)]:
                            revert with 0, 'MANIA CSHT: Blacklisted address'
                        if futurUsePoolAddress == msg.sender:
                            revert with 0, 'MANIA CSHT: futur and rewardsPool cannot cashout rewards'
                        if distributionPoolAddress == msg.sender:
                            revert with 0, 'MANIA CSHT: futur and rewardsPool cannot cashout rewards'
                        mem[mem[64] + 4] = msg.sender
                        require ext_code.size(address(stor1[_2332]))
                        staticcall address(stor1[_2332])._getRewardAmountOf(address arg1) with:
                                gas gas_remaining wei
                               args msg.sender
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _4878 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _4918 = mem[_4878]
                        if mem[_4878] <= 0:
                            revert with 0, 'MANIA CSHT: You don't have enough reward to cash out'
                        if not uint8(stor20):
                            mem[mem[64] + 4] = distributionPoolAddress
                            mem[mem[64] + 36] = msg.sender
                            mem[mem[64] + 68] = _4918
                            require ext_code.size(stor9)
                            call stor9.0x23b872dd with:
                                 gas gas_remaining wei
                                args distributionPoolAddress, msg.sender, _4918
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _5072 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_5072] == bool(mem[_5072])
                        else:
                            if not cashoutFee:
                                if mem[_4878] < 0:
                                    revert with 0, 17
                                mem[mem[64] + 4] = distributionPoolAddress
                                mem[mem[64] + 36] = msg.sender
                                mem[mem[64] + 68] = _4918
                                require ext_code.size(stor9)
                                call stor9.0x23b872dd with:
                                     gas gas_remaining wei
                                    args distributionPoolAddress, msg.sender, _4918
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _5208 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_5208] == bool(mem[_5208])
                            else:
                                if not mem[_4878]:
                                    _5139 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5139] = 26
                                    mem[_5139 + 32] = 'SafeMath: division by zero'
                                    _5376 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    mem[_5376 + 32 len 64] = call.data[calldata.size len 64]
                                    if not mem[_5376]:
                                        revert with 0, 50
                                    mem[_5376 + 32] = stor9
                                    require ext_code.size(uniswapV2RouterAddress)
                                    staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                            gas gas_remaining wei
                                    mem[_5376 + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = _5376 + ceil32(return_data.size) + 96
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    if 1 >= mem[_5376]:
                                        revert with 0, 50
                                    mem[_5376 + 64] = ext_call.return_data[12 len 20]
                                    mem[_5376 + ceil32(return_data.size) + 100] = uniswapV2RouterAddress
                                    mem[_5376 + ceil32(return_data.size) + 132] = 0
                                    require ext_code.size(stor9)
                                    call stor9.approve(address arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args uniswapV2RouterAddress, 0
                                    mem[_5376 + ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = _5376 + (2 * ceil32(return_data.size)) + 96
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    mem[_5376 + (2 * ceil32(return_data.size)) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                    mem[_5376 + (2 * ceil32(return_data.size)) + 100] = 0
                                    mem[_5376 + (2 * ceil32(return_data.size)) + 132] = 0
                                    mem[_5376 + (2 * ceil32(return_data.size)) + 164] = 160
                                    mem[_5376 + (2 * ceil32(return_data.size)) + 260] = mem[_5376]
                                    idx = 0
                                    s = _5376 + (2 * ceil32(return_data.size)) + 292
                                    t = _5376 + 32
                                    while idx < mem[_5376]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(uniswapV2RouterAddress)
                                    call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args 0, 0, 160, address(this.address), block.timestamp, mem[_5376 + (2 * ceil32(return_data.size)) + 260 len (32 * mem[_5376]) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if eth.balance(this.address) > eth.balance(this.address):
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if eth.balance(this.address) < eth.balance(this.address):
                                        revert with 0, 17
                                    call futurUsePoolAddress with:
                                         gas 2300 wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if _4918 < 0:
                                        revert with 0, 17
                                    require ext_code.size(stor9)
                                    call stor9.0x23b872dd with:
                                         gas gas_remaining wei
                                        args distributionPoolAddress, msg.sender, _4918
                                else:
                                    if mem[_4878] and cashoutFee > -1 / mem[_4878]:
                                        revert with 0, 17
                                    if not mem[_4878]:
                                        revert with 0, 18
                                    if mem[_4878] * cashoutFee / mem[_4878] != cashoutFee:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _5307 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5307] = 26
                                    mem[_5307 + 32] = 'SafeMath: division by zero'
                                    _5538 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    mem[_5538 + 32 len 64] = call.data[calldata.size len 64]
                                    if not mem[_5538]:
                                        revert with 0, 50
                                    mem[_5538 + 32] = stor9
                                    require ext_code.size(uniswapV2RouterAddress)
                                    staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                            gas gas_remaining wei
                                    mem[_5538 + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = _5538 + ceil32(return_data.size) + 96
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    if 1 >= mem[_5538]:
                                        revert with 0, 50
                                    mem[_5538 + 64] = ext_call.return_data[12 len 20]
                                    mem[_5538 + ceil32(return_data.size) + 100] = uniswapV2RouterAddress
                                    mem[_5538 + ceil32(return_data.size) + 132] = _4918 * cashoutFee / 100
                                    require ext_code.size(stor9)
                                    call stor9.approve(address arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args uniswapV2RouterAddress, _4918 * cashoutFee / 100
                                    mem[_5538 + ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = _5538 + (2 * ceil32(return_data.size)) + 96
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    mem[_5538 + (2 * ceil32(return_data.size)) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                    mem[_5538 + (2 * ceil32(return_data.size)) + 100] = _4918 * cashoutFee / 100
                                    mem[_5538 + (2 * ceil32(return_data.size)) + 132] = 0
                                    mem[_5538 + (2 * ceil32(return_data.size)) + 164] = 160
                                    mem[_5538 + (2 * ceil32(return_data.size)) + 260] = mem[_5538]
                                    idx = 0
                                    s = _5538 + (2 * ceil32(return_data.size)) + 292
                                    t = _5538 + 32
                                    while idx < mem[_5538]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(uniswapV2RouterAddress)
                                    call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args _4918 * cashoutFee / 100, 0, 160, address(this.address), block.timestamp, mem[_5538 + (2 * ceil32(return_data.size)) + 260 len (32 * mem[_5538]) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if eth.balance(this.address) > eth.balance(this.address):
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if eth.balance(this.address) < eth.balance(this.address):
                                        revert with 0, 17
                                    call futurUsePoolAddress with:
                                         gas 2300 wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if _4918 < _4918 * cashoutFee / 100:
                                        revert with 0, 17
                                    require ext_code.size(stor9)
                                    call stor9.0x23b872dd with:
                                         gas gas_remaining wei
                                        args distributionPoolAddress, msg.sender, _4918 - (_4918 * cashoutFee / 100)
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
            else:
                if bool(stor[_2332].field_0) == stor[_2332].field_1 % 128 < 32:
                    revert with 0, 34
                if not stor[_2332].field_1 % 128:
                    mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
                    mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_2332])
                    if not msg.sender:
                        revert with 0, 'MANIA CSHT:  creation from the zero address'
                    mem[0] = msg.sender
                    mem[32] = 22
                    if stor22[address(msg.sender)]:
                        revert with 0, 'MANIA CSHT: Blacklisted address'
                    if futurUsePoolAddress == msg.sender:
                        revert with 0, 'MANIA CSHT: futur and rewardsPool cannot cashout rewards'
                    if distributionPoolAddress == msg.sender:
                        revert with 0, 'MANIA CSHT: futur and rewardsPool cannot cashout rewards'
                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + 197] = msg.sender
                    require ext_code.size(address(stor1[_2332]))
                    staticcall address(stor1[_2332])._getRewardAmountOf(address arg1) with:
                            gas gas_remaining wei
                           args msg.sender
                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + 193] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if ext_call.return_data[0] <= 0:
                        revert with 0, 'MANIA CSHT: You don't have enough reward to cash out'
                    if not uint8(stor20):
                        require ext_code.size(stor9)
                        call stor9.0x23b872dd with:
                             gas gas_remaining wei
                            args distributionPoolAddress, msg.sender, ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                    else:
                        if not cashoutFee:
                            if ext_call.return_data[0] < 0:
                                revert with 0, 17
                            require ext_code.size(stor9)
                            call stor9.0x23b872dd with:
                                 gas gas_remaining wei
                                args distributionPoolAddress, msg.sender, ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                        else:
                            if not ext_call.return_data[0]:
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + ceil32(return_data.size) + 257] = 2
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + ceil32(return_data.size) + 289] = stor9
                                require ext_code.size(uniswapV2RouterAddress)
                                staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                        gas gas_remaining wei
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + ceil32(return_data.size) + 353] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + ceil32(return_data.size) + 321] = ext_call.return_data[12 len 20]
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 357] = uniswapV2RouterAddress
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 389] = 0
                                require ext_code.size(stor9)
                                call stor9.approve(address arg1, uint256 arg2) with:
                                     gas gas_remaining wei
                                    args uniswapV2RouterAddress, 0
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 353] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 353
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 353] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 357] = 0
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 389] = 0
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 421] = 160
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 517] = 2
                                idx = 0
                                s = ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 549
                                t = ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + ceil32(return_data.size) + 289
                                while idx < mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + ceil32(return_data.size) + 257]:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 453] = this.address
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 485] = block.timestamp
                                require ext_code.size(uniswapV2RouterAddress)
                                call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                     gas gas_remaining wei
                                    args 0, 0, 160, address(this.address), block.timestamp, mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 517 len (32 * mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + ceil32(return_data.size) + 257]) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if eth.balance(this.address) > eth.balance(this.address):
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 417] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 421] = 32
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 453] = 30
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 485] = 'SafeMath: subtraction overflow'
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 515] = 0
                                    revert with memory
                                      from ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 417
                                       len (5 * ceil32(return_data.size)) + 100
                                if eth.balance(this.address) < eth.balance(this.address):
                                    revert with 0, 17
                                call futurUsePoolAddress with:
                                     gas 2300 wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if ext_call.return_data[0] < 0:
                                    revert with 0, 17
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 421] = distributionPoolAddress
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 453] = msg.sender
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 485] = ext_call.return_data[0]
                                require ext_code.size(stor9)
                                call stor9.0x23b872dd with:
                                     gas gas_remaining wei
                                    args mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 421 len (5 * ceil32(return_data.size)) + 96]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                            else:
                                if ext_call.return_data[0] and cashoutFee > -1 / ext_call.return_data[0]:
                                    revert with 0, 17
                                if not ext_call.return_data[0]:
                                    revert with 0, 18
                                if ext_call.return_data[0] * cashoutFee / ext_call.return_data[0] != cashoutFee:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + ceil32(return_data.size) + 193] = 26
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + ceil32(return_data.size) + 225] = 'SafeMath: division by zero'
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + ceil32(return_data.size) + 257] = 2
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + ceil32(return_data.size) + 289] = stor9
                                require ext_code.size(uniswapV2RouterAddress)
                                staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                        gas gas_remaining wei
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + ceil32(return_data.size) + 353] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + ceil32(return_data.size) + 321] = ext_call.return_data[12 len 20]
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 357] = uniswapV2RouterAddress
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 389] = ext_call.return_data[0] * cashoutFee / 100
                                require ext_code.size(stor9)
                                call stor9.approve(address arg1, uint256 arg2) with:
                                     gas gas_remaining wei
                                    args uniswapV2RouterAddress, ext_call.return_data[0] * cashoutFee / 100
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 353] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 353
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 353] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 357] = ext_call.return_data[0] * cashoutFee / 100
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 389] = 0
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 421] = 160
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 517] = 2
                                idx = 0
                                s = ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 549
                                t = ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + ceil32(return_data.size) + 289
                                while idx < mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + ceil32(return_data.size) + 257]:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 453] = this.address
                                mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 485] = block.timestamp
                                require ext_code.size(uniswapV2RouterAddress)
                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + (32 * mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + ceil32(return_data.size) + 257]) + -mem[64] + 545]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4787 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4787] = 30
                                mem[_4787 + 32] = 'SafeMath: subtraction overflow'
                                if eth.balance(this.address) > eth.balance(this.address):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if eth.balance(this.address) < eth.balance(this.address):
                                    revert with 0, 17
                                call futurUsePoolAddress with:
                                     gas 2300 wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if ext_call.return_data[0] < ext_call.return_data[0] * cashoutFee / 100:
                                    revert with 0, 17
                                mem[mem[64] + 4] = distributionPoolAddress
                                mem[mem[64] + 36] = msg.sender
                                mem[mem[64] + 68] = ext_call.return_data[0] - (ext_call.return_data[0] * cashoutFee / 100)
                                require ext_code.size(stor9)
                                call stor9.0x23b872dd with:
                                     gas gas_remaining wei
                                    args distributionPoolAddress, msg.sender, ext_call.return_data[0] - (ext_call.return_data[0] * cashoutFee / 100)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _5211 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_5211] == bool(mem[_5211])
                else:
                    if 31 < stor[_2332].field_1 % 128:
                        mem[ceil32(ceil32(arg1.length)) + 193] = uint256(stor[sha3(_2332)].field_0)
                        idx = ceil32(ceil32(arg1.length)) + 193
                        s = 0
                        while ceil32(ceil32(arg1.length)) + stor[_2332].field_1 % 128 + 161 > idx:
                            mem[idx + 32] = uint256(stor[s + sha3(_2332) + 1].field_0)
                            idx = idx + 32
                            s = s + 1
                            continue 
                        mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
                        mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_2332])
                        if not msg.sender:
                            revert with 0, 'MANIA CSHT:  creation from the zero address'
                        mem[0] = msg.sender
                        mem[32] = 22
                        if stor22[address(msg.sender)]:
                            revert with 0, 'MANIA CSHT: Blacklisted address'
                        if futurUsePoolAddress == msg.sender:
                            revert with 0, 'MANIA CSHT: futur and rewardsPool cannot cashout rewards'
                        if distributionPoolAddress == msg.sender:
                            revert with 0, 'MANIA CSHT: futur and rewardsPool cannot cashout rewards'
                        mem[mem[64] + 4] = msg.sender
                        require ext_code.size(address(stor1[_2332]))
                        staticcall address(stor1[_2332])._getRewardAmountOf(address arg1) with:
                                gas gas_remaining wei
                               args msg.sender
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _4879 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _4919 = mem[_4879]
                        if mem[_4879] <= 0:
                            revert with 0, 'MANIA CSHT: You don't have enough reward to cash out'
                        if not uint8(stor20):
                            mem[mem[64] + 4] = distributionPoolAddress
                            mem[mem[64] + 36] = msg.sender
                            mem[mem[64] + 68] = _4919
                            require ext_code.size(stor9)
                            call stor9.0x23b872dd with:
                                 gas gas_remaining wei
                                args distributionPoolAddress, msg.sender, _4919
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _5077 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_5077] == bool(mem[_5077])
                        else:
                            if not cashoutFee:
                                if mem[_4879] < 0:
                                    revert with 0, 17
                                mem[mem[64] + 4] = distributionPoolAddress
                                mem[mem[64] + 36] = msg.sender
                                mem[mem[64] + 68] = _4919
                                require ext_code.size(stor9)
                                call stor9.0x23b872dd with:
                                     gas gas_remaining wei
                                    args distributionPoolAddress, msg.sender, _4919
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _5213 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_5213] == bool(mem[_5213])
                            else:
                                if not mem[_4879]:
                                    _5141 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5141] = 26
                                    mem[_5141 + 32] = 'SafeMath: division by zero'
                                    _5388 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    mem[_5388 + 32 len 64] = call.data[calldata.size len 64]
                                    if not mem[_5388]:
                                        revert with 0, 50
                                    mem[_5388 + 32] = stor9
                                    require ext_code.size(uniswapV2RouterAddress)
                                    staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                            gas gas_remaining wei
                                    mem[_5388 + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = _5388 + ceil32(return_data.size) + 96
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    if 1 >= mem[_5388]:
                                        revert with 0, 50
                                    mem[_5388 + 64] = ext_call.return_data[12 len 20]
                                    mem[_5388 + ceil32(return_data.size) + 100] = uniswapV2RouterAddress
                                    mem[_5388 + ceil32(return_data.size) + 132] = 0
                                    require ext_code.size(stor9)
                                    call stor9.approve(address arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args uniswapV2RouterAddress, 0
                                    mem[_5388 + ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = _5388 + (2 * ceil32(return_data.size)) + 96
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    mem[_5388 + (2 * ceil32(return_data.size)) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                    mem[_5388 + (2 * ceil32(return_data.size)) + 100] = 0
                                    mem[_5388 + (2 * ceil32(return_data.size)) + 132] = 0
                                    mem[_5388 + (2 * ceil32(return_data.size)) + 164] = 160
                                    mem[_5388 + (2 * ceil32(return_data.size)) + 260] = mem[_5388]
                                    idx = 0
                                    s = _5388 + (2 * ceil32(return_data.size)) + 292
                                    t = _5388 + 32
                                    while idx < mem[_5388]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(uniswapV2RouterAddress)
                                    call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args 0, 0, 160, address(this.address), block.timestamp, mem[_5388 + (2 * ceil32(return_data.size)) + 260 len (32 * mem[_5388]) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if eth.balance(this.address) > eth.balance(this.address):
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if eth.balance(this.address) < eth.balance(this.address):
                                        revert with 0, 17
                                    call futurUsePoolAddress with:
                                         gas 2300 wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if _4919 < 0:
                                        revert with 0, 17
                                    require ext_code.size(stor9)
                                    call stor9.0x23b872dd with:
                                         gas gas_remaining wei
                                        args distributionPoolAddress, msg.sender, _4919
                                else:
                                    if mem[_4879] and cashoutFee > -1 / mem[_4879]:
                                        revert with 0, 17
                                    if not mem[_4879]:
                                        revert with 0, 18
                                    if mem[_4879] * cashoutFee / mem[_4879] != cashoutFee:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _5309 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5309] = 26
                                    mem[_5309 + 32] = 'SafeMath: division by zero'
                                    _5540 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    mem[_5540 + 32 len 64] = call.data[calldata.size len 64]
                                    if not mem[_5540]:
                                        revert with 0, 50
                                    mem[_5540 + 32] = stor9
                                    require ext_code.size(uniswapV2RouterAddress)
                                    staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                            gas gas_remaining wei
                                    mem[_5540 + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = _5540 + ceil32(return_data.size) + 96
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    if 1 >= mem[_5540]:
                                        revert with 0, 50
                                    mem[_5540 + 64] = ext_call.return_data[12 len 20]
                                    mem[_5540 + ceil32(return_data.size) + 100] = uniswapV2RouterAddress
                                    mem[_5540 + ceil32(return_data.size) + 132] = _4919 * cashoutFee / 100
                                    require ext_code.size(stor9)
                                    call stor9.approve(address arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args uniswapV2RouterAddress, _4919 * cashoutFee / 100
                                    mem[_5540 + ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = _5540 + (2 * ceil32(return_data.size)) + 96
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    mem[_5540 + (2 * ceil32(return_data.size)) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                    mem[_5540 + (2 * ceil32(return_data.size)) + 100] = _4919 * cashoutFee / 100
                                    mem[_5540 + (2 * ceil32(return_data.size)) + 132] = 0
                                    mem[_5540 + (2 * ceil32(return_data.size)) + 164] = 160
                                    mem[_5540 + (2 * ceil32(return_data.size)) + 260] = mem[_5540]
                                    idx = 0
                                    s = _5540 + (2 * ceil32(return_data.size)) + 292
                                    t = _5540 + 32
                                    while idx < mem[_5540]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(uniswapV2RouterAddress)
                                    call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args _4919 * cashoutFee / 100, 0, 160, address(this.address), block.timestamp, mem[_5540 + (2 * ceil32(return_data.size)) + 260 len (32 * mem[_5540]) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if eth.balance(this.address) > eth.balance(this.address):
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if eth.balance(this.address) < eth.balance(this.address):
                                        revert with 0, 17
                                    call futurUsePoolAddress with:
                                         gas 2300 wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if _4919 < _4919 * cashoutFee / 100:
                                        revert with 0, 17
                                    require ext_code.size(stor9)
                                    call stor9.0x23b872dd with:
                                         gas gas_remaining wei
                                        args distributionPoolAddress, msg.sender, _4919 - (_4919 * cashoutFee / 100)
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                    else:
                        mem[ceil32(ceil32(arg1.length)) + 193] = 256 * Mask(248, 0, stor[_2332].field_8)
                        mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
                        mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_2332])
                        if not msg.sender:
                            revert with 0, 'MANIA CSHT:  creation from the zero address'
                        mem[0] = msg.sender
                        mem[32] = 22
                        if stor22[address(msg.sender)]:
                            revert with 0, 'MANIA CSHT: Blacklisted address'
                        if futurUsePoolAddress == msg.sender:
                            revert with 0, 'MANIA CSHT: futur and rewardsPool cannot cashout rewards'
                        if distributionPoolAddress == msg.sender:
                            revert with 0, 'MANIA CSHT: futur and rewardsPool cannot cashout rewards'
                        mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + 197] = msg.sender
                        require ext_code.size(address(stor1[_2332]))
                        staticcall address(stor1[_2332])._getRewardAmountOf(address arg1) with:
                                gas gas_remaining wei
                               args msg.sender
                        mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + 193] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if ext_call.return_data[0] <= 0:
                            revert with 0, 'MANIA CSHT: You don't have enough reward to cash out'
                        if not uint8(stor20):
                            require ext_code.size(stor9)
                            call stor9.0x23b872dd with:
                                 gas gas_remaining wei
                                args distributionPoolAddress, msg.sender, ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                        else:
                            if not cashoutFee:
                                if ext_call.return_data[0] < 0:
                                    revert with 0, 17
                                require ext_code.size(stor9)
                                call stor9.0x23b872dd with:
                                     gas gas_remaining wei
                                    args distributionPoolAddress, msg.sender, ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                            else:
                                if not ext_call.return_data[0]:
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + ceil32(return_data.size) + 193] = 26
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + ceil32(return_data.size) + 225] = 'SafeMath: division by zero'
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + ceil32(return_data.size) + 257] = 2
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + ceil32(return_data.size) + 289] = stor9
                                    require ext_code.size(uniswapV2RouterAddress)
                                    staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                            gas gas_remaining wei
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + ceil32(return_data.size) + 353] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + ceil32(return_data.size) + 321] = ext_call.return_data[12 len 20]
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 357] = uniswapV2RouterAddress
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 389] = 0
                                    require ext_code.size(stor9)
                                    call stor9.approve(address arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args uniswapV2RouterAddress, 0
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 353] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 353
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 353] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 357] = 0
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 389] = 0
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 421] = 160
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 517] = 2
                                    idx = 0
                                    s = ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 549
                                    t = ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + ceil32(return_data.size) + 289
                                    while idx < mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + ceil32(return_data.size) + 257]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 453] = this.address
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 485] = block.timestamp
                                    require ext_code.size(uniswapV2RouterAddress)
                                    call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + (32 * mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + ceil32(return_data.size) + 257]) + -mem[64] + 545]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _4791 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4791] = 30
                                    mem[_4791 + 32] = 'SafeMath: subtraction overflow'
                                    if eth.balance(this.address) > eth.balance(this.address):
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if eth.balance(this.address) < eth.balance(this.address):
                                        revert with 0, 17
                                    call futurUsePoolAddress with:
                                         gas 2300 wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if ext_call.return_data[0] < 0:
                                        revert with 0, 17
                                    mem[mem[64] + 4] = distributionPoolAddress
                                    mem[mem[64] + 36] = msg.sender
                                    mem[mem[64] + 68] = ext_call.return_data[0]
                                    require ext_code.size(stor9)
                                    call stor9.0x23b872dd with:
                                         gas gas_remaining wei
                                        args distributionPoolAddress, msg.sender, ext_call.return_data[0]
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5215 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_5215] == bool(mem[_5215])
                                else:
                                    if ext_call.return_data[0] and cashoutFee > -1 / ext_call.return_data[0]:
                                        revert with 0, 17
                                    if not ext_call.return_data[0]:
                                        revert with 0, 18
                                    if ext_call.return_data[0] * cashoutFee / ext_call.return_data[0] != cashoutFee:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + ceil32(return_data.size) + 193] = 26
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + ceil32(return_data.size) + 225] = 'SafeMath: division by zero'
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + ceil32(return_data.size) + 257] = 2
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + ceil32(return_data.size) + 289] = stor9
                                    require ext_code.size(uniswapV2RouterAddress)
                                    staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                            gas gas_remaining wei
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + ceil32(return_data.size) + 353] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + ceil32(return_data.size) + 321] = ext_call.return_data[12 len 20]
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 357] = uniswapV2RouterAddress
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 389] = ext_call.return_data[0] * cashoutFee / 100
                                    require ext_code.size(stor9)
                                    call stor9.approve(address arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args uniswapV2RouterAddress, ext_call.return_data[0] * cashoutFee / 100
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (2 * ceil32(return_data.size)) + 353] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 353
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 353] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 357] = ext_call.return_data[0] * cashoutFee / 100
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 389] = 0
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 421] = 160
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 517] = 2
                                    idx = 0
                                    s = ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 549
                                    t = ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + ceil32(return_data.size) + 289
                                    while idx < mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + ceil32(return_data.size) + 257]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 453] = this.address
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + 485] = block.timestamp
                                    require ext_code.size(uniswapV2RouterAddress)
                                    call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + (4 * ceil32(return_data.size)) + (32 * mem[ceil32(ceil32(arg1.length)) + ceil32(uint255(uint256(stor[_2332].field_0)) * 0.5) + ceil32(return_data.size) + 257]) + -mem[64] + 545]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _4790 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4790] = 30
                                    mem[_4790 + 32] = 'SafeMath: subtraction overflow'
                                    if eth.balance(this.address) > eth.balance(this.address):
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if eth.balance(this.address) < eth.balance(this.address):
                                        revert with 0, 17
                                    call futurUsePoolAddress with:
                                         gas 2300 wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if ext_call.return_data[0] < ext_call.return_data[0] * cashoutFee / 100:
                                        revert with 0, 17
                                    mem[mem[64] + 4] = distributionPoolAddress
                                    mem[mem[64] + 36] = msg.sender
                                    mem[mem[64] + 68] = ext_call.return_data[0] - (ext_call.return_data[0] * cashoutFee / 100)
                                    require ext_code.size(stor9)
                                    call stor9.0x23b872dd with:
                                         gas gas_remaining wei
                                        args distributionPoolAddress, msg.sender, ext_call.return_data[0] - (ext_call.return_data[0] * cashoutFee / 100)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5214 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_5214] == bool(mem[_5214])
        else:
            if bool(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_0) == stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_1 % 128 < 32:
                revert with 0, 34
            mem[64] = ceil32(ceil32(arg1.length)) + ceil32(stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_1 % 128) + 193
            mem[ceil32(ceil32(arg1.length)) + 161] = stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])].field_1 % 128
            if bool(stor[_2332].field_0):
                if bool(stor[_2332].field_0) == uint255(uint256(stor[_2332].field_0)) * 0.5 < 32:
                    revert with 0, 34
                if not Mask(256, -1, uint256(stor[_2332].field_0)):
                    mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
                    mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_2332])
                    if not msg.sender:
                        revert with 0, 'MANIA CSHT:  creation from the zero address'
                    mem[0] = msg.sender
                    mem[32] = 22
                    if stor22[address(msg.sender)]:
                        revert with 0, 'MANIA CSHT: Blacklisted address'
                    if futurUsePoolAddress == msg.sender:
                        revert with 0, 'MANIA CSHT: futur and rewardsPool cannot cashout rewards'
                    if distributionPoolAddress == msg.sender:
                        revert with 0, 'MANIA CSHT: futur and rewardsPool cannot cashout rewards'
                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + 197] = msg.sender
                    require ext_code.size(address(stor1[_2332]))
                    staticcall address(stor1[_2332])._getRewardAmountOf(address arg1) with:
                            gas gas_remaining wei
                           args msg.sender
                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + 193] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if ext_call.return_data[0] <= 0:
                        revert with 0, 'MANIA CSHT: You don't have enough reward to cash out'
                    if not uint8(stor20):
                        require ext_code.size(stor9)
                        call stor9.0x23b872dd with:
                             gas gas_remaining wei
                            args distributionPoolAddress, msg.sender, ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                    else:
                        if not cashoutFee:
                            if ext_call.return_data[0] < 0:
                                revert with 0, 17
                            require ext_code.size(stor9)
                            call stor9.0x23b872dd with:
                                 gas gas_remaining wei
                                args distributionPoolAddress, msg.sender, ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                        else:
                            if not ext_call.return_data[0]:
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + ceil32(return_data.size) + 193] = 26
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + ceil32(return_data.size) + 225] = 'SafeMath: division by zero'
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + ceil32(return_data.size) + 257] = 2
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + ceil32(return_data.size) + 289] = stor9
                                require ext_code.size(uniswapV2RouterAddress)
                                staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                        gas gas_remaining wei
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + ceil32(return_data.size) + 353] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + ceil32(return_data.size) + 321] = ext_call.return_data[12 len 20]
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (2 * ceil32(return_data.size)) + 357] = uniswapV2RouterAddress
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (2 * ceil32(return_data.size)) + 389] = 0
                                require ext_code.size(stor9)
                                call stor9.approve(address arg1, uint256 arg2) with:
                                     gas gas_remaining wei
                                    args uniswapV2RouterAddress, 0
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (2 * ceil32(return_data.size)) + 353] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 353
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 353] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 357] = 0
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 389] = 0
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 421] = 160
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 517] = 2
                                idx = 0
                                s = ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 549
                                t = ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + ceil32(return_data.size) + 289
                                while idx < mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + ceil32(return_data.size) + 257]:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 453] = this.address
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 485] = block.timestamp
                                require ext_code.size(uniswapV2RouterAddress)
                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + (32 * mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + ceil32(return_data.size) + 257]) + -mem[64] + 545]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4793 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4793] = 30
                                mem[_4793 + 32] = 'SafeMath: subtraction overflow'
                                if eth.balance(this.address) > eth.balance(this.address):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if eth.balance(this.address) < eth.balance(this.address):
                                    revert with 0, 17
                                call futurUsePoolAddress with:
                                     gas 2300 wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if ext_call.return_data[0] < 0:
                                    revert with 0, 17
                                mem[mem[64] + 4] = distributionPoolAddress
                                mem[mem[64] + 36] = msg.sender
                                mem[mem[64] + 68] = ext_call.return_data[0]
                                require ext_code.size(stor9)
                                call stor9.0x23b872dd with:
                                     gas gas_remaining wei
                                    args distributionPoolAddress, msg.sender, ext_call.return_data[0]
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _5217 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_5217] == bool(mem[_5217])
                            else:
                                if ext_call.return_data[0] and cashoutFee > -1 / ext_call.return_data[0]:
                                    revert with 0, 17
                                if not ext_call.return_data[0]:
                                    revert with 0, 18
                                if ext_call.return_data[0] * cashoutFee / ext_call.return_data[0] != cashoutFee:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + ceil32(return_data.size) + 193] = 26
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + ceil32(return_data.size) + 225] = 'SafeMath: division by zero'
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + ceil32(return_data.size) + 257] = 2
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + ceil32(return_data.size) + 289] = stor9
                                require ext_code.size(uniswapV2RouterAddress)
                                staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                        gas gas_remaining wei
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + ceil32(return_data.size) + 353] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + ceil32(return_data.size) + 321] = ext_call.return_data[12 len 20]
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (2 * ceil32(return_data.size)) + 357] = uniswapV2RouterAddress
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (2 * ceil32(return_data.size)) + 389] = ext_call.return_data[0] * cashoutFee / 100
                                require ext_code.size(stor9)
                                call stor9.approve(address arg1, uint256 arg2) with:
                                     gas gas_remaining wei
                                    args uniswapV2RouterAddress, ext_call.return_data[0] * cashoutFee / 100
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (2 * ceil32(return_data.size)) + 353] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 353
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 353] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 357] = ext_call.return_data[0] * cashoutFee / 100
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 389] = 0
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 421] = 160
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 517] = 2
                                idx = 0
                                s = ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 549
                                t = ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + ceil32(return_data.size) + 289
                                while idx < mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + ceil32(return_data.size) + 257]:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 453] = this.address
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 485] = block.timestamp
                                require ext_code.size(uniswapV2RouterAddress)
                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + (32 * mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + ceil32(return_data.size) + 257]) + -mem[64] + 545]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _4792 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4792] = 30
                                mem[_4792 + 32] = 'SafeMath: subtraction overflow'
                                if eth.balance(this.address) > eth.balance(this.address):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if eth.balance(this.address) < eth.balance(this.address):
                                    revert with 0, 17
                                call futurUsePoolAddress with:
                                     gas 2300 wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if ext_call.return_data[0] < ext_call.return_data[0] * cashoutFee / 100:
                                    revert with 0, 17
                                mem[mem[64] + 4] = distributionPoolAddress
                                mem[mem[64] + 36] = msg.sender
                                mem[mem[64] + 68] = ext_call.return_data[0] - (ext_call.return_data[0] * cashoutFee / 100)
                                require ext_code.size(stor9)
                                call stor9.0x23b872dd with:
                                     gas gas_remaining wei
                                    args distributionPoolAddress, msg.sender, ext_call.return_data[0] - (ext_call.return_data[0] * cashoutFee / 100)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _5216 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_5216] == bool(mem[_5216])
                else:
                    if 31 >= uint255(uint256(stor[_2332].field_0)) * 0.5:
                        mem[ceil32(ceil32(arg1.length)) + 193] = 256 * Mask(248, 0, stor[_2332].field_8)
                        mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
                        mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_2332])
                        if not msg.sender:
                            revert with 0, 'MANIA CSHT:  creation from the zero address'
                        mem[0] = msg.sender
                        mem[32] = 22
                        if stor22[address(msg.sender)]:
                            revert with 0, 'MANIA CSHT: Blacklisted address'
                        if futurUsePoolAddress == msg.sender:
                            revert with 0, 'MANIA CSHT: futur and rewardsPool cannot cashout rewards'
                        if distributionPoolAddress == msg.sender:
                            revert with 0, 'MANIA CSHT: futur and rewardsPool cannot cashout rewards'
                        mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + 197] = msg.sender
                        require ext_code.size(address(stor1[_2332]))
                        staticcall address(stor1[_2332])._getRewardAmountOf(address arg1) with:
                                gas gas_remaining wei
                               args msg.sender
                        mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + 193] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if ext_call.return_data[0] <= 0:
                            revert with 0, 'MANIA CSHT: You don't have enough reward to cash out'
                        if not uint8(stor20):
                            require ext_code.size(stor9)
                            call stor9.0x23b872dd with:
                                 gas gas_remaining wei
                                args distributionPoolAddress, msg.sender, ext_call.return_data[0]
                        else:
                            if not cashoutFee:
                                if ext_call.return_data[0] < 0:
                                    revert with 0, 17
                                require ext_code.size(stor9)
                                call stor9.0x23b872dd with:
                                     gas gas_remaining wei
                                    args distributionPoolAddress, msg.sender, ext_call.return_data[0]
                            else:
                                if not ext_call.return_data[0]:
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + ceil32(return_data.size) + 257] = 2
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + ceil32(return_data.size) + 289] = stor9
                                    require ext_code.size(uniswapV2RouterAddress)
                                    staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                            gas gas_remaining wei
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + ceil32(return_data.size) + 353] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + ceil32(return_data.size) + 321] = ext_call.return_data[12 len 20]
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (2 * ceil32(return_data.size)) + 357] = uniswapV2RouterAddress
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (2 * ceil32(return_data.size)) + 389] = 0
                                    require ext_code.size(stor9)
                                    call stor9.approve(address arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args uniswapV2RouterAddress, 0
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (2 * ceil32(return_data.size)) + 353] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 353
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 353] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 357] = 0
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 389] = 0
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 421] = 160
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 517] = 2
                                    idx = 0
                                    s = ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 549
                                    t = ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + ceil32(return_data.size) + 289
                                    while idx < mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + ceil32(return_data.size) + 257]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 453] = this.address
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 485] = block.timestamp
                                    require ext_code.size(uniswapV2RouterAddress)
                                    call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args 0, 0, 160, address(this.address), block.timestamp, mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 517 len (32 * mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + ceil32(return_data.size) + 257]) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if eth.balance(this.address) > eth.balance(this.address):
                                        mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 417] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 421] = 32
                                        mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 453] = 30
                                        mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 485] = 'SafeMath: subtraction overflow'
                                        mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 515] = 0
                                        revert with memory
                                          from ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 417
                                           len (5 * ceil32(return_data.size)) + 100
                                    if eth.balance(this.address) < eth.balance(this.address):
                                        revert with 0, 17
                                    call futurUsePoolAddress with:
                                         gas 2300 wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if ext_call.return_data[0] < 0:
                                        revert with 0, 17
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 421] = distributionPoolAddress
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 453] = msg.sender
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 485] = ext_call.return_data[0]
                                else:
                                    if ext_call.return_data[0] and cashoutFee > -1 / ext_call.return_data[0]:
                                        revert with 0, 17
                                    if not ext_call.return_data[0]:
                                        revert with 0, 18
                                    if ext_call.return_data[0] * cashoutFee / ext_call.return_data[0] != cashoutFee:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + ceil32(return_data.size) + 257] = 2
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + ceil32(return_data.size) + 289] = stor9
                                    require ext_code.size(uniswapV2RouterAddress)
                                    staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                            gas gas_remaining wei
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + ceil32(return_data.size) + 353] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + ceil32(return_data.size) + 321] = ext_call.return_data[12 len 20]
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (2 * ceil32(return_data.size)) + 357] = uniswapV2RouterAddress
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (2 * ceil32(return_data.size)) + 389] = ext_call.return_data[0] * cashoutFee / 100
                                    require ext_code.size(stor9)
                                    call stor9.approve(address arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args uniswapV2RouterAddress, ext_call.return_data[0] * cashoutFee / 100
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (2 * ceil32(return_data.size)) + 353] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 353
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 353] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 357] = ext_call.return_data[0] * cashoutFee / 100
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 389] = 0
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 421] = 160
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 517] = 2
                                    idx = 0
                                    s = ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 549
                                    t = ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + ceil32(return_data.size) + 289
                                    while idx < mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + ceil32(return_data.size) + 257]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 453] = this.address
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 485] = block.timestamp
                                    require ext_code.size(uniswapV2RouterAddress)
                                    call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0] * cashoutFee / 100, 0, 160, address(this.address), block.timestamp, mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 517 len (32 * mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + ceil32(return_data.size) + 257]) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if eth.balance(this.address) > eth.balance(this.address):
                                        mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 417] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 421] = 32
                                        mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 453] = 30
                                        mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 485] = 'SafeMath: subtraction overflow'
                                        mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 515] = 0
                                        revert with memory
                                          from ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 417
                                           len (5 * ceil32(return_data.size)) + 100
                                    if eth.balance(this.address) < eth.balance(this.address):
                                        revert with 0, 17
                                    call futurUsePoolAddress with:
                                         gas 2300 wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if ext_call.return_data[0] < ext_call.return_data[0] * cashoutFee / 100:
                                        revert with 0, 17
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 421] = distributionPoolAddress
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 453] = msg.sender
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 485] = ext_call.return_data[0] - (ext_call.return_data[0] * cashoutFee / 100)
                                require ext_code.size(stor9)
                                call stor9.0x23b872dd with:
                                     gas gas_remaining wei
                                    args mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 421 len (5 * ceil32(return_data.size)) + 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                    else:
                        mem[ceil32(ceil32(arg1.length)) + 193] = uint256(stor[sha3(_2332)].field_0)
                        idx = ceil32(ceil32(arg1.length)) + 193
                        s = 0
                        while ceil32(ceil32(arg1.length)) + (uint255(uint256(stor[_2332].field_0)) * 0.5) + 161 > idx:
                            mem[idx + 32] = uint256(stor[s + sha3(_2332) + 1].field_0)
                            idx = idx + 32
                            s = s + 1
                            continue 
                        mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
                        mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_2332])
                        if not msg.sender:
                            revert with 0, 'MANIA CSHT:  creation from the zero address'
                        mem[0] = msg.sender
                        mem[32] = 22
                        if stor22[address(msg.sender)]:
                            revert with 0, 'MANIA CSHT: Blacklisted address'
                        if futurUsePoolAddress == msg.sender:
                            revert with 0, 'MANIA CSHT: futur and rewardsPool cannot cashout rewards'
                        if distributionPoolAddress == msg.sender:
                            revert with 0, 'MANIA CSHT: futur and rewardsPool cannot cashout rewards'
                        mem[mem[64] + 4] = msg.sender
                        require ext_code.size(address(stor1[_2332]))
                        staticcall address(stor1[_2332])._getRewardAmountOf(address arg1) with:
                                gas gas_remaining wei
                               args msg.sender
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _4880 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _4920 = mem[_4880]
                        if mem[_4880] <= 0:
                            revert with 0, 'MANIA CSHT: You don't have enough reward to cash out'
                        if not uint8(stor20):
                            mem[mem[64] + 4] = distributionPoolAddress
                            mem[mem[64] + 36] = msg.sender
                            mem[mem[64] + 68] = _4920
                            require ext_code.size(stor9)
                            call stor9.0x23b872dd with:
                                 gas gas_remaining wei
                                args distributionPoolAddress, msg.sender, _4920
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _5082 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_5082] == bool(mem[_5082])
                        else:
                            if not cashoutFee:
                                if mem[_4880] < 0:
                                    revert with 0, 17
                                mem[mem[64] + 4] = distributionPoolAddress
                                mem[mem[64] + 36] = msg.sender
                                mem[mem[64] + 68] = _4920
                                require ext_code.size(stor9)
                                call stor9.0x23b872dd with:
                                     gas gas_remaining wei
                                    args distributionPoolAddress, msg.sender, _4920
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _5218 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_5218] == bool(mem[_5218])
                            else:
                                if not mem[_4880]:
                                    _5143 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5143] = 26
                                    mem[_5143 + 32] = 'SafeMath: division by zero'
                                    _5400 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    mem[_5400 + 32 len 64] = call.data[calldata.size len 64]
                                    if not mem[_5400]:
                                        revert with 0, 50
                                    mem[_5400 + 32] = stor9
                                    require ext_code.size(uniswapV2RouterAddress)
                                    staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                            gas gas_remaining wei
                                    mem[_5400 + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = _5400 + ceil32(return_data.size) + 96
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    if 1 >= mem[_5400]:
                                        revert with 0, 50
                                    mem[_5400 + 64] = ext_call.return_data[12 len 20]
                                    mem[_5400 + ceil32(return_data.size) + 100] = uniswapV2RouterAddress
                                    mem[_5400 + ceil32(return_data.size) + 132] = 0
                                    require ext_code.size(stor9)
                                    call stor9.approve(address arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args uniswapV2RouterAddress, 0
                                    mem[_5400 + ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = _5400 + (2 * ceil32(return_data.size)) + 96
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    mem[_5400 + (2 * ceil32(return_data.size)) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                    mem[_5400 + (2 * ceil32(return_data.size)) + 100] = 0
                                    mem[_5400 + (2 * ceil32(return_data.size)) + 132] = 0
                                    mem[_5400 + (2 * ceil32(return_data.size)) + 164] = 160
                                    mem[_5400 + (2 * ceil32(return_data.size)) + 260] = mem[_5400]
                                    idx = 0
                                    s = _5400 + (2 * ceil32(return_data.size)) + 292
                                    t = _5400 + 32
                                    while idx < mem[_5400]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(uniswapV2RouterAddress)
                                    call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args 0, 0, 160, address(this.address), block.timestamp, mem[_5400 + (2 * ceil32(return_data.size)) + 260 len (32 * mem[_5400]) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if eth.balance(this.address) > eth.balance(this.address):
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if eth.balance(this.address) < eth.balance(this.address):
                                        revert with 0, 17
                                    call futurUsePoolAddress with:
                                         gas 2300 wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if _4920 < 0:
                                        revert with 0, 17
                                    require ext_code.size(stor9)
                                    call stor9.0x23b872dd with:
                                         gas gas_remaining wei
                                        args distributionPoolAddress, msg.sender, _4920
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                else:
                                    if mem[_4880] and cashoutFee > -1 / mem[_4880]:
                                        revert with 0, 17
                                    if not mem[_4880]:
                                        revert with 0, 18
                                    if mem[_4880] * cashoutFee / mem[_4880] != cashoutFee:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _5311 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5311] = 26
                                    mem[_5311 + 32] = 'SafeMath: division by zero'
                                    _5542 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    mem[_5542 + 32 len 64] = call.data[calldata.size len 64]
                                    if not mem[_5542]:
                                        revert with 0, 50
                                    mem[_5542 + 32] = stor9
                                    require ext_code.size(uniswapV2RouterAddress)
                                    staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                            gas gas_remaining wei
                                    mem[_5542 + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = _5542 + ceil32(return_data.size) + 96
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    if 1 >= mem[_5542]:
                                        revert with 0, 50
                                    mem[_5542 + 64] = ext_call.return_data[12 len 20]
                                    mem[_5542 + ceil32(return_data.size) + 100] = uniswapV2RouterAddress
                                    mem[_5542 + ceil32(return_data.size) + 132] = _4920 * cashoutFee / 100
                                    require ext_code.size(stor9)
                                    call stor9.approve(address arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args uniswapV2RouterAddress, _4920 * cashoutFee / 100
                                    mem[_5542 + ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = _5542 + (2 * ceil32(return_data.size)) + 96
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    mem[_5542 + (2 * ceil32(return_data.size)) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                    mem[_5542 + (2 * ceil32(return_data.size)) + 100] = _4920 * cashoutFee / 100
                                    mem[_5542 + (2 * ceil32(return_data.size)) + 132] = 0
                                    mem[_5542 + (2 * ceil32(return_data.size)) + 164] = 160
                                    mem[_5542 + (2 * ceil32(return_data.size)) + 260] = mem[_5542]
                                    idx = 0
                                    s = _5542 + (2 * ceil32(return_data.size)) + 292
                                    t = _5542 + 32
                                    while idx < mem[_5542]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5542 + (2 * ceil32(return_data.size)) + 196] = this.address
                                    mem[_5542 + (2 * ceil32(return_data.size)) + 228] = block.timestamp
                                    require ext_code.size(uniswapV2RouterAddress)
                                    call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5542 + (2 * ceil32(return_data.size)) + (32 * mem[_5542]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _6096 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6096] = 30
                                    mem[_6096 + 32] = 'SafeMath: subtraction overflow'
                                    if eth.balance(this.address) > eth.balance(this.address):
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if eth.balance(this.address) < eth.balance(this.address):
                                        revert with 0, 17
                                    call futurUsePoolAddress with:
                                         gas 2300 wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if _4920 < _4920 * cashoutFee / 100:
                                        revert with 0, 17
                                    mem[mem[64] + 4] = distributionPoolAddress
                                    mem[mem[64] + 36] = msg.sender
                                    mem[mem[64] + 68] = _4920 - (_4920 * cashoutFee / 100)
                                    require ext_code.size(stor9)
                                    call stor9.0x23b872dd with:
                                         gas gas_remaining wei
                                        args distributionPoolAddress, msg.sender, _4920 - (_4920 * cashoutFee / 100)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _6246 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_6246] == bool(mem[_6246])
            else:
                if bool(stor[_2332].field_0) == stor[_2332].field_1 % 128 < 32:
                    revert with 0, 34
                if not stor[_2332].field_1 % 128:
                    mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
                    mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_2332])
                    if not msg.sender:
                        revert with 0, 'MANIA CSHT:  creation from the zero address'
                    mem[0] = msg.sender
                    mem[32] = 22
                    if stor22[address(msg.sender)]:
                        revert with 0, 'MANIA CSHT: Blacklisted address'
                    if futurUsePoolAddress == msg.sender:
                        revert with 0, 'MANIA CSHT: futur and rewardsPool cannot cashout rewards'
                    if distributionPoolAddress == msg.sender:
                        revert with 0, 'MANIA CSHT: futur and rewardsPool cannot cashout rewards'
                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + 197] = msg.sender
                    require ext_code.size(address(stor1[_2332]))
                    staticcall address(stor1[_2332])._getRewardAmountOf(address arg1) with:
                            gas gas_remaining wei
                           args msg.sender
                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + 193] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if ext_call.return_data[0] <= 0:
                        revert with 0, 'MANIA CSHT: You don't have enough reward to cash out'
                    if not uint8(stor20):
                        require ext_code.size(stor9)
                        call stor9.0x23b872dd with:
                             gas gas_remaining wei
                            args distributionPoolAddress, msg.sender, ext_call.return_data[0]
                    else:
                        if not cashoutFee:
                            if ext_call.return_data[0] < 0:
                                revert with 0, 17
                            require ext_code.size(stor9)
                            call stor9.0x23b872dd with:
                                 gas gas_remaining wei
                                args distributionPoolAddress, msg.sender, ext_call.return_data[0]
                        else:
                            if not ext_call.return_data[0]:
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + ceil32(return_data.size) + 257] = 2
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + ceil32(return_data.size) + 289] = stor9
                                require ext_code.size(uniswapV2RouterAddress)
                                staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                        gas gas_remaining wei
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + ceil32(return_data.size) + 353] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + ceil32(return_data.size) + 321] = ext_call.return_data[12 len 20]
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (2 * ceil32(return_data.size)) + 357] = uniswapV2RouterAddress
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (2 * ceil32(return_data.size)) + 389] = 0
                                require ext_code.size(stor9)
                                call stor9.approve(address arg1, uint256 arg2) with:
                                     gas gas_remaining wei
                                    args uniswapV2RouterAddress, 0
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (2 * ceil32(return_data.size)) + 353] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 353
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 353] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 357] = 0
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 389] = 0
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 421] = 160
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 517] = 2
                                idx = 0
                                s = ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 549
                                t = ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + ceil32(return_data.size) + 289
                                while idx < mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + ceil32(return_data.size) + 257]:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 453] = this.address
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 485] = block.timestamp
                                require ext_code.size(uniswapV2RouterAddress)
                                call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                     gas gas_remaining wei
                                    args 0, 0, 160, address(this.address), block.timestamp, mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 517 len (32 * mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + ceil32(return_data.size) + 257]) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if eth.balance(this.address) > eth.balance(this.address):
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 417] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 421] = 32
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 453] = 30
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 485] = 'SafeMath: subtraction overflow'
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 515] = 0
                                    revert with memory
                                      from ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 417
                                       len (5 * ceil32(return_data.size)) + 100
                                if eth.balance(this.address) < eth.balance(this.address):
                                    revert with 0, 17
                                call futurUsePoolAddress with:
                                     gas 2300 wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if ext_call.return_data[0] < 0:
                                    revert with 0, 17
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 421] = distributionPoolAddress
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 453] = msg.sender
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 485] = ext_call.return_data[0]
                            else:
                                if ext_call.return_data[0] and cashoutFee > -1 / ext_call.return_data[0]:
                                    revert with 0, 17
                                if not ext_call.return_data[0]:
                                    revert with 0, 18
                                if ext_call.return_data[0] * cashoutFee / ext_call.return_data[0] != cashoutFee:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + ceil32(return_data.size) + 257] = 2
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + ceil32(return_data.size) + 289] = stor9
                                require ext_code.size(uniswapV2RouterAddress)
                                staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                        gas gas_remaining wei
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + ceil32(return_data.size) + 353] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + ceil32(return_data.size) + 321] = ext_call.return_data[12 len 20]
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (2 * ceil32(return_data.size)) + 357] = uniswapV2RouterAddress
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (2 * ceil32(return_data.size)) + 389] = ext_call.return_data[0] * cashoutFee / 100
                                require ext_code.size(stor9)
                                call stor9.approve(address arg1, uint256 arg2) with:
                                     gas gas_remaining wei
                                    args uniswapV2RouterAddress, ext_call.return_data[0] * cashoutFee / 100
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (2 * ceil32(return_data.size)) + 353] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 353
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 353] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 357] = ext_call.return_data[0] * cashoutFee / 100
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 389] = 0
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 421] = 160
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 517] = 2
                                idx = 0
                                s = ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 549
                                t = ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + ceil32(return_data.size) + 289
                                while idx < mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + ceil32(return_data.size) + 257]:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 453] = this.address
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 485] = block.timestamp
                                require ext_code.size(uniswapV2RouterAddress)
                                call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0] * cashoutFee / 100, 0, 160, address(this.address), block.timestamp, mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 517 len (32 * mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + ceil32(return_data.size) + 257]) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if eth.balance(this.address) > eth.balance(this.address):
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 417] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 421] = 32
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 453] = 30
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 485] = 'SafeMath: subtraction overflow'
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 515] = 0
                                    revert with memory
                                      from ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 417
                                       len (5 * ceil32(return_data.size)) + 100
                                if eth.balance(this.address) < eth.balance(this.address):
                                    revert with 0, 17
                                call futurUsePoolAddress with:
                                     gas 2300 wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if ext_call.return_data[0] < ext_call.return_data[0] * cashoutFee / 100:
                                    revert with 0, 17
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 421] = distributionPoolAddress
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 453] = msg.sender
                                mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 485] = ext_call.return_data[0] - (ext_call.return_data[0] * cashoutFee / 100)
                            require ext_code.size(stor9)
                            call stor9.0x23b872dd with:
                                 gas gas_remaining wei
                                args mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 421 len (5 * ceil32(return_data.size)) + 96]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                else:
                    if 31 >= stor[_2332].field_1 % 128:
                        mem[ceil32(ceil32(arg1.length)) + 193] = 256 * Mask(248, 0, stor[_2332].field_8)
                        mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
                        mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_2332])
                        if not msg.sender:
                            revert with 0, 'MANIA CSHT:  creation from the zero address'
                        mem[0] = msg.sender
                        mem[32] = 22
                        if stor22[address(msg.sender)]:
                            revert with 0, 'MANIA CSHT: Blacklisted address'
                        if futurUsePoolAddress == msg.sender:
                            revert with 0, 'MANIA CSHT: futur and rewardsPool cannot cashout rewards'
                        if distributionPoolAddress == msg.sender:
                            revert with 0, 'MANIA CSHT: futur and rewardsPool cannot cashout rewards'
                        mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + 197] = msg.sender
                        require ext_code.size(address(stor1[_2332]))
                        staticcall address(stor1[_2332])._getRewardAmountOf(address arg1) with:
                                gas gas_remaining wei
                               args msg.sender
                        mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + 193] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if ext_call.return_data[0] <= 0:
                            revert with 0, 'MANIA CSHT: You don't have enough reward to cash out'
                        if not uint8(stor20):
                            require ext_code.size(stor9)
                            call stor9.0x23b872dd with:
                                 gas gas_remaining wei
                                args distributionPoolAddress, msg.sender, ext_call.return_data[0]
                        else:
                            if not cashoutFee:
                                if ext_call.return_data[0] < 0:
                                    revert with 0, 17
                                require ext_code.size(stor9)
                                call stor9.0x23b872dd with:
                                     gas gas_remaining wei
                                    args distributionPoolAddress, msg.sender, ext_call.return_data[0]
                            else:
                                if not ext_call.return_data[0]:
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + ceil32(return_data.size) + 257] = 2
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + ceil32(return_data.size) + 289] = stor9
                                    require ext_code.size(uniswapV2RouterAddress)
                                    staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                            gas gas_remaining wei
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + ceil32(return_data.size) + 353] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + ceil32(return_data.size) + 321] = ext_call.return_data[12 len 20]
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (2 * ceil32(return_data.size)) + 357] = uniswapV2RouterAddress
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (2 * ceil32(return_data.size)) + 389] = 0
                                    require ext_code.size(stor9)
                                    call stor9.approve(address arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args uniswapV2RouterAddress, 0
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (2 * ceil32(return_data.size)) + 353] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 353
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 353] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 357] = 0
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 389] = 0
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 421] = 160
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 517] = 2
                                    idx = 0
                                    s = ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 549
                                    t = ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + ceil32(return_data.size) + 289
                                    while idx < mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + ceil32(return_data.size) + 257]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 453] = this.address
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 485] = block.timestamp
                                    require ext_code.size(uniswapV2RouterAddress)
                                    call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args 0, 0, 160, address(this.address), block.timestamp, mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 517 len (32 * mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + ceil32(return_data.size) + 257]) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if eth.balance(this.address) > eth.balance(this.address):
                                        mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 417] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 421] = 32
                                        mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 453] = 30
                                        mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 485] = 'SafeMath: subtraction overflow'
                                        mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 515] = 0
                                        revert with memory
                                          from ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 417
                                           len (5 * ceil32(return_data.size)) + 100
                                    if eth.balance(this.address) < eth.balance(this.address):
                                        revert with 0, 17
                                    call futurUsePoolAddress with:
                                         gas 2300 wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if ext_call.return_data[0] < 0:
                                        revert with 0, 17
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 421] = distributionPoolAddress
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 453] = msg.sender
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 485] = ext_call.return_data[0]
                                else:
                                    if ext_call.return_data[0] and cashoutFee > -1 / ext_call.return_data[0]:
                                        revert with 0, 17
                                    if not ext_call.return_data[0]:
                                        revert with 0, 18
                                    if ext_call.return_data[0] * cashoutFee / ext_call.return_data[0] != cashoutFee:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + ceil32(return_data.size) + 257] = 2
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + ceil32(return_data.size) + 289] = stor9
                                    require ext_code.size(uniswapV2RouterAddress)
                                    staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                            gas gas_remaining wei
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + ceil32(return_data.size) + 353] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + ceil32(return_data.size) + 321] = ext_call.return_data[12 len 20]
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (2 * ceil32(return_data.size)) + 357] = uniswapV2RouterAddress
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (2 * ceil32(return_data.size)) + 389] = ext_call.return_data[0] * cashoutFee / 100
                                    require ext_code.size(stor9)
                                    call stor9.approve(address arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args uniswapV2RouterAddress, ext_call.return_data[0] * cashoutFee / 100
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (2 * ceil32(return_data.size)) + 353] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 353
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 353] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 357] = ext_call.return_data[0] * cashoutFee / 100
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 389] = 0
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 421] = 160
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 517] = 2
                                    idx = 0
                                    s = ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 549
                                    t = ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + ceil32(return_data.size) + 289
                                    while idx < mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + ceil32(return_data.size) + 257]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 453] = this.address
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 485] = block.timestamp
                                    require ext_code.size(uniswapV2RouterAddress)
                                    call uniswapV2RouterAddress.swapExactTokensForAVAXSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0] * cashoutFee / 100, 0, 160, address(this.address), block.timestamp, mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 517 len (32 * mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + ceil32(return_data.size) + 257]) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if eth.balance(this.address) > eth.balance(this.address):
                                        mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 417] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 421] = 32
                                        mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 453] = 30
                                        mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 485] = 'SafeMath: subtraction overflow'
                                        mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 515] = 0
                                        revert with memory
                                          from ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 417
                                           len (5 * ceil32(return_data.size)) + 100
                                    if eth.balance(this.address) < eth.balance(this.address):
                                        revert with 0, 17
                                    call futurUsePoolAddress with:
                                         gas 2300 wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if ext_call.return_data[0] < ext_call.return_data[0] * cashoutFee / 100:
                                        revert with 0, 17
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 421] = distributionPoolAddress
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 453] = msg.sender
                                    mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 485] = ext_call.return_data[0] - (ext_call.return_data[0] * cashoutFee / 100)
                                require ext_code.size(stor9)
                                call stor9.0x23b872dd with:
                                     gas gas_remaining wei
                                    args mem[ceil32(ceil32(arg1.length)) + ceil32(stor[_2332].field_1 % 128) + (4 * ceil32(return_data.size)) + 421 len (5 * ceil32(return_data.size)) + 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                    else:
                        mem[ceil32(ceil32(arg1.length)) + 193] = uint256(stor[sha3(_2332)].field_0)
                        idx = ceil32(ceil32(arg1.length)) + 193
                        s = 0
                        while ceil32(ceil32(arg1.length)) + stor[_2332].field_1 % 128 + 161 > idx:
                            mem[idx + 32] = uint256(stor[s + sha3(_2332) + 1].field_0)
                            idx = idx + 32
                            s = s + 1
                            continue 
                        mem[ceil32(ceil32(arg1.length)) + 97] = ceil32(ceil32(arg1.length)) + 161
                        mem[ceil32(ceil32(arg1.length)) + 129] = address(stor1[_2332])
                        if not msg.sender:
                            revert with 0, 'MANIA CSHT:  creation from the zero address'
                        mem[0] = msg.sender
                        mem[32] = 22
                        if stor22[address(msg.sender)]:
                            revert with 0, 'MANIA CSHT: Blacklisted address'
                        if futurUsePoolAddress == msg.sender:
                            revert with 0, 'MANIA CSHT: futur and rewardsPool cannot cashout rewards'
                        if distributionPoolAddress == msg.sender:
                            revert with 0, 'MANIA CSHT: futur and rewardsPool cannot cashout rewards'
                        mem[mem[64] + 4] = msg.sender
                        require ext_code.size(address(stor1[_2332]))
                        staticcall address(stor1[_2332])._getRewardAmountOf(address arg1) with:
                                gas gas_remaining wei
                               args msg.sender
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _4881 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _4921 = mem[_4881]
                        if mem[_4881] <= 0:
                            revert with 0, 'MANIA CSHT: You don't have enough reward to cash out'
                        if not uint8(stor20):
                            mem[mem[64] + 4] = distributionPoolAddress
                            mem[mem[64] + 36] = msg.sender
                            mem[mem[64] + 68] = _4921
                            require ext_code.size(stor9)
                            call stor9.0x23b872dd with:
                                 gas gas_remaining wei
                                args distributionPoolAddress, msg.sender, _4921
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _5087 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_5087] == bool(mem[_5087])
                        else:
                            if not cashoutFee:
                                if mem[_4881] < 0:
                                    revert with 0, 17
                                mem[mem[64] + 4] = distributionPoolAddress
                                mem[mem[64] + 36] = msg.sender
                                mem[mem[64] + 68] = _4921
                                require ext_code.size(stor9)
                                call stor9.0x23b872dd with:
                                     gas gas_remaining wei
                                    args distributionPoolAddress, msg.sender, _4921
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _5223 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_5223] == bool(mem[_5223])
                            else:
                                if not mem[_4881]:
                                    _5145 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5145] = 26
                                    mem[_5145 + 32] = 'SafeMath: division by zero'
                                    _5412 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    mem[_5412 + 32 len 64] = call.data[calldata.size len 64]
                                    if not mem[_5412]:
                                        revert with 0, 50
                                    mem[_5412 + 32] = stor9
                                    require ext_code.size(uniswapV2RouterAddress)
                                    staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                            gas gas_remaining wei
                                    mem[_5412 + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = _5412 + ceil32(return_data.size) + 96
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    if 1 >= mem[_5412]:
                                        revert with 0, 50
                                    mem[_5412 + 64] = ext_call.return_data[12 len 20]
                                    mem[_5412 + ceil32(return_data.size) + 100] = uniswapV2RouterAddress
                                    mem[_5412 + ceil32(return_data.size) + 132] = 0
                                    require ext_code.size(stor9)
                                    call stor9.approve(address arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args uniswapV2RouterAddress, 0
                                    mem[_5412 + ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = _5412 + (2 * ceil32(return_data.size)) + 96
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    mem[_5412 + (2 * ceil32(return_data.size)) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                    mem[_5412 + (2 * ceil32(return_data.size)) + 100] = 0
                                    mem[_5412 + (2 * ceil32(return_data.size)) + 132] = 0
                                    mem[_5412 + (2 * ceil32(return_data.size)) + 164] = 160
                                    mem[_5412 + (2 * ceil32(return_data.size)) + 260] = mem[_5412]
                                    idx = 0
                                    s = _5412 + (2 * ceil32(return_data.size)) + 292
                                    t = _5412 + 32
                                    while idx < mem[_5412]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5412 + (2 * ceil32(return_data.size)) + 196] = this.address
                                    mem[_5412 + (2 * ceil32(return_data.size)) + 228] = block.timestamp
                                    require ext_code.size(uniswapV2RouterAddress)
                                    call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5412 + (2 * ceil32(return_data.size)) + (32 * mem[_5412]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _6103 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6103] = 30
                                    mem[_6103 + 32] = 'SafeMath: subtraction overflow'
                                    if eth.balance(this.address) > eth.balance(this.address):
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if eth.balance(this.address) < eth.balance(this.address):
                                        revert with 0, 17
                                    call futurUsePoolAddress with:
                                         gas 2300 wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if _4921 < 0:
                                        revert with 0, 17
                                    mem[mem[64] + 4] = distributionPoolAddress
                                    mem[mem[64] + 36] = msg.sender
                                    mem[mem[64] + 68] = _4921
                                    require ext_code.size(stor9)
                                    call stor9.0x23b872dd with:
                                         gas gas_remaining wei
                                        args distributionPoolAddress, msg.sender, _4921
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _6249 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_6249] == bool(mem[_6249])
                                else:
                                    if mem[_4881] and cashoutFee > -1 / mem[_4881]:
                                        revert with 0, 17
                                    if not mem[_4881]:
                                        revert with 0, 18
                                    if mem[_4881] * cashoutFee / mem[_4881] != cashoutFee:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _5313 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5313] = 26
                                    mem[_5313 + 32] = 'SafeMath: division by zero'
                                    _5544 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    mem[_5544 + 32 len 64] = call.data[calldata.size len 64]
                                    if not mem[_5544]:
                                        revert with 0, 50
                                    mem[_5544 + 32] = stor9
                                    require ext_code.size(uniswapV2RouterAddress)
                                    staticcall uniswapV2RouterAddress.0x73b295c2 with:
                                            gas gas_remaining wei
                                    mem[_5544 + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = _5544 + ceil32(return_data.size) + 96
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    if 1 >= mem[_5544]:
                                        revert with 0, 50
                                    mem[_5544 + 64] = ext_call.return_data[12 len 20]
                                    mem[_5544 + ceil32(return_data.size) + 100] = uniswapV2RouterAddress
                                    mem[_5544 + ceil32(return_data.size) + 132] = _4921 * cashoutFee / 100
                                    require ext_code.size(stor9)
                                    call stor9.approve(address arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args uniswapV2RouterAddress, _4921 * cashoutFee / 100
                                    mem[_5544 + ceil32(return_data.size) + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = _5544 + (2 * ceil32(return_data.size)) + 96
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    mem[_5544 + (2 * ceil32(return_data.size)) + 96] = 0x762b156200000000000000000000000000000000000000000000000000000000
                                    mem[_5544 + (2 * ceil32(return_data.size)) + 100] = _4921 * cashoutFee / 100
                                    mem[_5544 + (2 * ceil32(return_data.size)) + 132] = 0
                                    mem[_5544 + (2 * ceil32(return_data.size)) + 164] = 160
                                    mem[_5544 + (2 * ceil32(return_data.size)) + 260] = mem[_5544]
                                    idx = 0
                                    s = _5544 + (2 * ceil32(return_data.size)) + 292
                                    t = _5544 + 32
                                    while idx < mem[_5544]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5544 + (2 * ceil32(return_data.size)) + 196] = this.address
                                    mem[_5544 + (2 * ceil32(return_data.size)) + 228] = block.timestamp
                                    require ext_code.size(uniswapV2RouterAddress)
                                    call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5544 + (2 * ceil32(return_data.size)) + (32 * mem[_5544]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _6102 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6102] = 30
                                    mem[_6102 + 32] = 'SafeMath: subtraction overflow'
                                    if eth.balance(this.address) > eth.balance(this.address):
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if eth.balance(this.address) < eth.balance(this.address):
                                        revert with 0, 17
                                    call futurUsePoolAddress with:
                                         gas 2300 wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if _4921 < _4921 * cashoutFee / 100:
                                        revert with 0, 17
                                    mem[mem[64] + 4] = distributionPoolAddress
                                    mem[mem[64] + 36] = msg.sender
                                    mem[mem[64] + 68] = _4921 - (_4921 * cashoutFee / 100)
                                    require ext_code.size(stor9)
                                    call stor9.0x23b872dd with:
                                         gas gas_remaining wei
                                        args distributionPoolAddress, msg.sender, _4921 - (_4921 * cashoutFee / 100)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _6248 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_6248] == bool(mem[_6248])
        require ext_code.size(address(stor1[_2332]))
        call address(stor1[_2332])._cashoutAllNodesReward(address arg1) with:
             gas gas_remaining wei
            args msg.sender
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
}



}

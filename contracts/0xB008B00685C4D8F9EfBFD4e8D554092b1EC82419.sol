contract main {




// =====================  Runtime code  =====================


#
#  - sub_e9807cfa(?)
#
address owner;
address nominatedOwner;
address stor2;
address stor3;
address stor4;
address stor5;
address routerAddress;
address sub_1c1d3e8dAddress;
address sub_3c8a5d8dAddress;
address sub_ccccbcf7Address;
address sub_3fd82e21Address;
address account;
address sub_e36c61f1Address;

function sub_1c1d3e8d(?) {
    return sub_1c1d3e8dAddress
}

function sub_3c8a5d8d(?) {
    return sub_3c8a5d8dAddress
}

function sub_3fd82e21(?) {
    return sub_3fd82e21Address
}

function nominatedOwner() {
    return nominatedOwner
}

function account() {
    return account
}

function owner() {
    return owner
}

function sub_ccccbcf7(?) {
    return sub_ccccbcf7Address
}

function sub_e36c61f1(?) {
    return sub_e36c61f1Address
}

function router() {
    return routerAddress
}

function receive() payable {
  stop
}

function _fallback() payable {
  stop
}

function nominateNewOwner(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Only the contract owner may perform this action'
    nominatedOwner = arg1
    emit OwnerNominated(arg1);
}

function acceptOwnership() {
    if nominatedOwner != msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    'You must be nominated before you can accept ownership'
    emit OwnerChanged(owner, nominatedOwner);
    owner = nominatedOwner
    nominatedOwner = 0
}

function sub_3e70dabf(?) {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    require ext_code.size(address(arg1))
    staticcall address(arg1).0x70a08231 with:
            gas gas_remaining wei
           args this.address
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    return ext_call.return_data[0]
}

function sub_71894652(?) {
    require calldata.size - 4 >= 96
    require arg1 == address(arg1)
    require arg2 == address(arg2)
    require ext_code.size(address(arg1))
    call address(arg1).approve(address arg1, uint256 arg2) with:
         gas gas_remaining wei
        args address(arg2), arg3
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
}

function withdraw(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Only the contract owner may perform this action'
    require ext_code.size(arg1)
    staticcall arg1.0x70a08231 with:
            gas gas_remaining wei
           args this.address
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_code.size(arg1)
    call arg1.0xa9059cbb with:
         gas gas_remaining wei
        args msg.sender, ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
}

function sub_432b99a3(?) {
    require calldata.size - 4 >= 64
    require arg1 == address(arg1)
    require arg2 == address(arg2)
    if owner != msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Only the contract owner may perform this action'
    routerAddress = address(arg1)
    require ext_code.size(address(arg1))
    staticcall address(arg1).WAVAX() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    stor4 = ext_call.return_data[12 len 20]
    require ext_code.size(routerAddress)
    staticcall routerAddress.factory() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    stor2 = ext_call.return_data[12 len 20]
    sub_e36c61f1Address = address(arg2)
    stor5 = address(arg2)
}

function sub_4fe05a51(?) {
    require calldata.size - 4 >= 160
    require arg1 == address(arg1)
    require arg3 == address(arg3)
    require arg5 <= test266151307()
    require arg5 + 35 < calldata.size
    if arg5.length > test266151307():
        revert with 0, 65
    if ceil32(ceil32(arg5.length)) + 97 < 96 or ceil32(ceil32(arg5.length)) + 97 > test266151307():
        revert with 0, 65
    mem[96] = arg5.length
    require arg5 + arg5.length + 36 <= calldata.size
    mem[128 len arg5.length] = arg5[all]
    if not sub_ccccbcf7Address:
        require ext_code.size(stor4)
        call stor4.0x2e1a7d4d with:
             gas gas_remaining wei
            args arg2
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        mem[ceil32(ceil32(arg5.length)) + 133] = sub_3c8a5d8dAddress
        require ext_code.size(sub_1c1d3e8dAddress)
        call sub_1c1d3e8dAddress.liquidateBorrow(address arg1, address arg2) with:
           value arg2 wei
             gas gas_remaining wei
            args account, sub_3c8a5d8dAddress
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        mem[ceil32(ceil32(arg5.length)) + 101] = this.address
        require ext_code.size(sub_3c8a5d8dAddress)
        staticcall sub_3c8a5d8dAddress.0x70a08231 with:
                gas gas_remaining wei
               args this.address
        mem[ceil32(ceil32(arg5.length)) + 97] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        mem[ceil32(ceil32(arg5.length)) + ceil32(return_data.size) + 101] = ext_call.return_data[0]
        require ext_code.size(sub_3c8a5d8dAddress)
        call sub_3c8a5d8dAddress.redeem(uint256 arg1) with:
             gas gas_remaining wei
            args ext_call.return_data[0]
        mem[ceil32(ceil32(arg5.length)) + ceil32(return_data.size) + 97] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if not sub_3fd82e21Address:
            require ext_code.size(stor4)
            call stor4.deposit() with:
               value arg4 wei
                 gas gas_remaining wei
        else:
            mem[ceil32(ceil32(arg5.length)) + (2 * ceil32(return_data.size)) + 101] = this.address
            require ext_code.size(sub_3fd82e21Address)
            staticcall sub_3fd82e21Address.0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            mem[ceil32(ceil32(arg5.length)) + (2 * ceil32(return_data.size)) + 97] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if stor4 == sub_3fd82e21Address:
                require ext_code.size(stor4)
                staticcall stor4.0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if ext_call.return_data[0] < arg4:
                    revert with 0, 17
                require ext_code.size(stor4)
                call stor4.0x2e1a7d4d with:
                     gas gas_remaining wei
                    args (ext_call.return_data[0] - arg4)
            else:
                if sub_ccccbcf7Address != sub_3fd82e21Address:
                    mem[ceil32(ceil32(arg5.length)) + (4 * ceil32(return_data.size)) + 97] = 2
                    mem[ceil32(ceil32(arg5.length)) + (4 * ceil32(return_data.size)) + 129] = sub_3fd82e21Address
                    mem[ceil32(ceil32(arg5.length)) + (4 * ceil32(return_data.size)) + 161] = stor4
                    if 3600 > !block.timestamp:
                        revert with 0, 17
                    mem[ceil32(ceil32(arg5.length)) + (4 * ceil32(return_data.size)) + 193] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                    mem[ceil32(ceil32(arg5.length)) + (4 * ceil32(return_data.size)) + 197] = ext_call.return_data[0]
                    mem[ceil32(ceil32(arg5.length)) + (4 * ceil32(return_data.size)) + 229] = 0
                    mem[ceil32(ceil32(arg5.length)) + (4 * ceil32(return_data.size)) + 261] = 160
                    mem[ceil32(ceil32(arg5.length)) + (4 * ceil32(return_data.size)) + 357] = 2
                    idx = 0
                    s = ceil32(ceil32(arg5.length)) + (4 * ceil32(return_data.size)) + 389
                    t = ceil32(ceil32(arg5.length)) + (4 * ceil32(return_data.size)) + 129
                    while idx < 2:
                        mem[s] = mem[t + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[ceil32(ceil32(arg5.length)) + (4 * ceil32(return_data.size)) + 293] = this.address
                    mem[ceil32(ceil32(arg5.length)) + (4 * ceil32(return_data.size)) + 325] = block.timestamp + 3600
                    require ext_code.size(routerAddress)
                    call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                         gas gas_remaining wei
                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 3600, 2, mem[ceil32(ceil32(arg5.length)) + (4 * ceil32(return_data.size)) + 389 len 64]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[ceil32(ceil32(arg5.length)) + (4 * ceil32(return_data.size)) + 193 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = ceil32(ceil32(arg5.length)) + (6 * ceil32(return_data.size)) + 193
                    require return_data.size >= 32
                    _146 = mem[ceil32(ceil32(arg5.length)) + (4 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28]
                    require mem[ceil32(ceil32(arg5.length)) + (4 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] <= test266151307()
                    require ceil32(ceil32(arg5.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg5.length)) + (4 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 224 < ceil32(ceil32(arg5.length)) + (4 * ceil32(return_data.size)) + return_data.size + 193
                    _150 = mem[ceil32(ceil32(arg5.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg5.length)) + (4 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 193]
                    if mem[ceil32(ceil32(arg5.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg5.length)) + (4 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 193] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[ceil32(ceil32(arg5.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg5.length)) + (4 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 193]) + 1 < 0 or ceil32(ceil32(arg5.length)) + (6 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(arg5.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg5.length)) + (4 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 193]) + 194 > test266151307():
                        revert with 0, 65
                    mem[64] = ceil32(ceil32(arg5.length)) + (6 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(arg5.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg5.length)) + (4 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 193]) + 194
                    mem[ceil32(ceil32(arg5.length)) + (6 * ceil32(return_data.size)) + 193] = _150
                    require return_data.size >= _146 + (32 * _150) + 32
                    mem[ceil32(ceil32(arg5.length)) + (6 * ceil32(return_data.size)) + 225 len 32 * _150] = mem[ceil32(ceil32(arg5.length)) + (4 * ceil32(return_data.size)) + _146 + 225 len 32 * _150]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(stor4)
                    staticcall stor4.0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _202 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if mem[_202] < arg4:
                        revert with 0, 17
                    require ext_code.size(stor4)
                    call stor4.0x2e1a7d4d with:
                         gas gas_remaining wei
                        args (mem[_202] - arg4)
                else:
                    mem[ceil32(ceil32(arg5.length)) + (4 * ceil32(return_data.size)) + 97] = 3
                    mem[ceil32(ceil32(arg5.length)) + (4 * ceil32(return_data.size)) + 129] = sub_3fd82e21Address
                    mem[ceil32(ceil32(arg5.length)) + (4 * ceil32(return_data.size)) + 161] = sub_e36c61f1Address
                    mem[ceil32(ceil32(arg5.length)) + (4 * ceil32(return_data.size)) + 193] = stor4
                    if 3600 > !block.timestamp:
                        revert with 0, 17
                    mem[ceil32(ceil32(arg5.length)) + (4 * ceil32(return_data.size)) + 225] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                    mem[ceil32(ceil32(arg5.length)) + (4 * ceil32(return_data.size)) + 229] = ext_call.return_data[0]
                    mem[ceil32(ceil32(arg5.length)) + (4 * ceil32(return_data.size)) + 261] = 0
                    mem[ceil32(ceil32(arg5.length)) + (4 * ceil32(return_data.size)) + 293] = 160
                    mem[ceil32(ceil32(arg5.length)) + (4 * ceil32(return_data.size)) + 389] = 3
                    idx = 0
                    s = ceil32(ceil32(arg5.length)) + (4 * ceil32(return_data.size)) + 421
                    t = ceil32(ceil32(arg5.length)) + (4 * ceil32(return_data.size)) + 129
                    while idx < 3:
                        mem[s] = mem[t + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[ceil32(ceil32(arg5.length)) + (4 * ceil32(return_data.size)) + 325] = this.address
                    mem[ceil32(ceil32(arg5.length)) + (4 * ceil32(return_data.size)) + 357] = block.timestamp + 3600
                    require ext_code.size(routerAddress)
                    call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                         gas gas_remaining wei
                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 3600, 3, mem[ceil32(ceil32(arg5.length)) + (4 * ceil32(return_data.size)) + 421 len 96]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[ceil32(ceil32(arg5.length)) + (4 * ceil32(return_data.size)) + 225 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = ceil32(ceil32(arg5.length)) + (6 * ceil32(return_data.size)) + 225
                    require return_data.size >= 32
                    _147 = mem[ceil32(ceil32(arg5.length)) + (4 * ceil32(return_data.size)) + 225 len 4], ext_call.return_data[0 len 28]
                    require mem[ceil32(ceil32(arg5.length)) + (4 * ceil32(return_data.size)) + 225 len 4], ext_call.return_data[0 len 28] <= test266151307()
                    require ceil32(ceil32(arg5.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg5.length)) + (4 * ceil32(return_data.size)) + 225 len 4], ext_call.return_data[0 len 28] + 256 < ceil32(ceil32(arg5.length)) + (4 * ceil32(return_data.size)) + return_data.size + 225
                    _151 = mem[ceil32(ceil32(arg5.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg5.length)) + (4 * ceil32(return_data.size)) + 225 len 4], ext_call.return_data[0 len 28] + 225]
                    if mem[ceil32(ceil32(arg5.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg5.length)) + (4 * ceil32(return_data.size)) + 225 len 4], ext_call.return_data[0 len 28] + 225] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[ceil32(ceil32(arg5.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg5.length)) + (4 * ceil32(return_data.size)) + 225 len 4], ext_call.return_data[0 len 28] + 225]) + 1 < 0 or ceil32(ceil32(arg5.length)) + (6 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(arg5.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg5.length)) + (4 * ceil32(return_data.size)) + 225 len 4], ext_call.return_data[0 len 28] + 225]) + 226 > test266151307():
                        revert with 0, 65
                    mem[64] = ceil32(ceil32(arg5.length)) + (6 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(arg5.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg5.length)) + (4 * ceil32(return_data.size)) + 225 len 4], ext_call.return_data[0 len 28] + 225]) + 226
                    mem[ceil32(ceil32(arg5.length)) + (6 * ceil32(return_data.size)) + 225] = _151
                    require return_data.size >= _147 + (32 * _151) + 32
                    mem[ceil32(ceil32(arg5.length)) + (6 * ceil32(return_data.size)) + 257 len 32 * _151] = mem[ceil32(ceil32(arg5.length)) + (4 * ceil32(return_data.size)) + _147 + 257 len 32 * _151]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(stor4)
                    staticcall stor4.0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _203 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if mem[_203] < arg4:
                        revert with 0, 17
                    require ext_code.size(stor4)
                    call stor4.0x2e1a7d4d with:
                         gas gas_remaining wei
                        args (mem[_203] - arg4)
    else:
        mem[ceil32(ceil32(arg5.length)) + 101] = account
        mem[ceil32(ceil32(arg5.length)) + 133] = arg2
        mem[ceil32(ceil32(arg5.length)) + 165] = sub_3c8a5d8dAddress
        require ext_code.size(sub_1c1d3e8dAddress)
        call sub_1c1d3e8dAddress.liquidateBorrow(address arg1, uint256 arg2, address arg3) with:
             gas gas_remaining wei
            args account, arg2, sub_3c8a5d8dAddress
        mem[ceil32(ceil32(arg5.length)) + 97] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        mem[ceil32(ceil32(arg5.length)) + ceil32(return_data.size) + 101] = this.address
        require ext_code.size(sub_3c8a5d8dAddress)
        staticcall sub_3c8a5d8dAddress.0x70a08231 with:
                gas gas_remaining wei
               args this.address
        mem[ceil32(ceil32(arg5.length)) + ceil32(return_data.size) + 97] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        mem[ceil32(ceil32(arg5.length)) + (2 * ceil32(return_data.size)) + 101] = ext_call.return_data[0]
        require ext_code.size(sub_3c8a5d8dAddress)
        call sub_3c8a5d8dAddress.redeem(uint256 arg1) with:
             gas gas_remaining wei
            args ext_call.return_data[0]
        mem[ceil32(ceil32(arg5.length)) + (2 * ceil32(return_data.size)) + 97] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if not sub_3fd82e21Address:
            require ext_code.size(stor4)
            call stor4.deposit() with:
               value arg4 wei
                 gas gas_remaining wei
        else:
            mem[ceil32(ceil32(arg5.length)) + (4 * ceil32(return_data.size)) + 101] = this.address
            require ext_code.size(sub_3fd82e21Address)
            staticcall sub_3fd82e21Address.0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            mem[ceil32(ceil32(arg5.length)) + (4 * ceil32(return_data.size)) + 97] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if stor4 == sub_3fd82e21Address:
                require ext_code.size(stor4)
                staticcall stor4.0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if ext_call.return_data[0] < arg4:
                    revert with 0, 17
                require ext_code.size(stor4)
                call stor4.0x2e1a7d4d with:
                     gas gas_remaining wei
                    args (ext_call.return_data[0] - arg4)
            else:
                if sub_ccccbcf7Address != sub_3fd82e21Address:
                    mem[ceil32(ceil32(arg5.length)) + (6 * ceil32(return_data.size)) + 97] = 2
                    mem[ceil32(ceil32(arg5.length)) + (6 * ceil32(return_data.size)) + 129] = sub_3fd82e21Address
                    mem[ceil32(ceil32(arg5.length)) + (6 * ceil32(return_data.size)) + 161] = stor4
                    if 3600 > !block.timestamp:
                        revert with 0, 17
                    mem[ceil32(ceil32(arg5.length)) + (6 * ceil32(return_data.size)) + 193] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                    mem[ceil32(ceil32(arg5.length)) + (6 * ceil32(return_data.size)) + 197] = ext_call.return_data[0]
                    mem[ceil32(ceil32(arg5.length)) + (6 * ceil32(return_data.size)) + 229] = 0
                    mem[ceil32(ceil32(arg5.length)) + (6 * ceil32(return_data.size)) + 261] = 160
                    mem[ceil32(ceil32(arg5.length)) + (6 * ceil32(return_data.size)) + 357] = 2
                    idx = 0
                    s = ceil32(ceil32(arg5.length)) + (6 * ceil32(return_data.size)) + 389
                    t = ceil32(ceil32(arg5.length)) + (6 * ceil32(return_data.size)) + 129
                    while idx < 2:
                        mem[s] = mem[t + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[ceil32(ceil32(arg5.length)) + (6 * ceil32(return_data.size)) + 293] = this.address
                    mem[ceil32(ceil32(arg5.length)) + (6 * ceil32(return_data.size)) + 325] = block.timestamp + 3600
                    require ext_code.size(routerAddress)
                    call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                         gas gas_remaining wei
                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 3600, 2, mem[ceil32(ceil32(arg5.length)) + (6 * ceil32(return_data.size)) + 389 len 64]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[ceil32(ceil32(arg5.length)) + (6 * ceil32(return_data.size)) + 193 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = ceil32(ceil32(arg5.length)) + (7 * ceil32(return_data.size)) + 193
                    require return_data.size >= 32
                    _144 = mem[ceil32(ceil32(arg5.length)) + (6 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28]
                    require mem[ceil32(ceil32(arg5.length)) + (6 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] <= test266151307()
                    require ceil32(ceil32(arg5.length)) + (6 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg5.length)) + (6 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 224 < ceil32(ceil32(arg5.length)) + (6 * ceil32(return_data.size)) + return_data.size + 193
                    _148 = mem[ceil32(ceil32(arg5.length)) + (6 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg5.length)) + (6 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 193]
                    if mem[ceil32(ceil32(arg5.length)) + (6 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg5.length)) + (6 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 193] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[ceil32(ceil32(arg5.length)) + (6 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg5.length)) + (6 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 193]) + 1 < 0 or ceil32(ceil32(arg5.length)) + (7 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(arg5.length)) + (6 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg5.length)) + (6 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 193]) + 194 > test266151307():
                        revert with 0, 65
                    mem[64] = ceil32(ceil32(arg5.length)) + (7 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(arg5.length)) + (6 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg5.length)) + (6 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 193]) + 194
                    mem[ceil32(ceil32(arg5.length)) + (7 * ceil32(return_data.size)) + 193] = _148
                    require return_data.size >= _144 + (32 * _148) + 32
                    mem[ceil32(ceil32(arg5.length)) + (7 * ceil32(return_data.size)) + 225 len 32 * _148] = mem[ceil32(ceil32(arg5.length)) + (6 * ceil32(return_data.size)) + _144 + 225 len 32 * _148]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(stor4)
                    staticcall stor4.0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _200 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if mem[_200] < arg4:
                        revert with 0, 17
                    require ext_code.size(stor4)
                    call stor4.0x2e1a7d4d with:
                         gas gas_remaining wei
                        args (mem[_200] - arg4)
                else:
                    mem[ceil32(ceil32(arg5.length)) + (6 * ceil32(return_data.size)) + 97] = 3
                    mem[ceil32(ceil32(arg5.length)) + (6 * ceil32(return_data.size)) + 129] = sub_3fd82e21Address
                    mem[ceil32(ceil32(arg5.length)) + (6 * ceil32(return_data.size)) + 161] = sub_e36c61f1Address
                    mem[ceil32(ceil32(arg5.length)) + (6 * ceil32(return_data.size)) + 193] = stor4
                    if 3600 > !block.timestamp:
                        revert with 0, 17
                    mem[ceil32(ceil32(arg5.length)) + (6 * ceil32(return_data.size)) + 225] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                    mem[ceil32(ceil32(arg5.length)) + (6 * ceil32(return_data.size)) + 229] = ext_call.return_data[0]
                    mem[ceil32(ceil32(arg5.length)) + (6 * ceil32(return_data.size)) + 261] = 0
                    mem[ceil32(ceil32(arg5.length)) + (6 * ceil32(return_data.size)) + 293] = 160
                    mem[ceil32(ceil32(arg5.length)) + (6 * ceil32(return_data.size)) + 389] = 3
                    idx = 0
                    s = ceil32(ceil32(arg5.length)) + (6 * ceil32(return_data.size)) + 421
                    t = ceil32(ceil32(arg5.length)) + (6 * ceil32(return_data.size)) + 129
                    while idx < 3:
                        mem[s] = mem[t + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[ceil32(ceil32(arg5.length)) + (6 * ceil32(return_data.size)) + 325] = this.address
                    mem[ceil32(ceil32(arg5.length)) + (6 * ceil32(return_data.size)) + 357] = block.timestamp + 3600
                    require ext_code.size(routerAddress)
                    call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                         gas gas_remaining wei
                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 3600, 3, mem[ceil32(ceil32(arg5.length)) + (6 * ceil32(return_data.size)) + 421 len 96]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[ceil32(ceil32(arg5.length)) + (6 * ceil32(return_data.size)) + 225 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = ceil32(ceil32(arg5.length)) + (7 * ceil32(return_data.size)) + 225
                    require return_data.size >= 32
                    _145 = mem[ceil32(ceil32(arg5.length)) + (6 * ceil32(return_data.size)) + 225 len 4], ext_call.return_data[0 len 28]
                    require mem[ceil32(ceil32(arg5.length)) + (6 * ceil32(return_data.size)) + 225 len 4], ext_call.return_data[0 len 28] <= test266151307()
                    require ceil32(ceil32(arg5.length)) + (6 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg5.length)) + (6 * ceil32(return_data.size)) + 225 len 4], ext_call.return_data[0 len 28] + 256 < ceil32(ceil32(arg5.length)) + (6 * ceil32(return_data.size)) + return_data.size + 225
                    _149 = mem[ceil32(ceil32(arg5.length)) + (6 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg5.length)) + (6 * ceil32(return_data.size)) + 225 len 4], ext_call.return_data[0 len 28] + 225]
                    if mem[ceil32(ceil32(arg5.length)) + (6 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg5.length)) + (6 * ceil32(return_data.size)) + 225 len 4], ext_call.return_data[0 len 28] + 225] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[ceil32(ceil32(arg5.length)) + (6 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg5.length)) + (6 * ceil32(return_data.size)) + 225 len 4], ext_call.return_data[0 len 28] + 225]) + 1 < 0 or ceil32(ceil32(arg5.length)) + (7 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(arg5.length)) + (6 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg5.length)) + (6 * ceil32(return_data.size)) + 225 len 4], ext_call.return_data[0 len 28] + 225]) + 226 > test266151307():
                        revert with 0, 65
                    mem[64] = ceil32(ceil32(arg5.length)) + (7 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(arg5.length)) + (6 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg5.length)) + (6 * ceil32(return_data.size)) + 225 len 4], ext_call.return_data[0 len 28] + 225]) + 226
                    mem[ceil32(ceil32(arg5.length)) + (7 * ceil32(return_data.size)) + 225] = _149
                    require return_data.size >= _145 + (32 * _149) + 32
                    mem[ceil32(ceil32(arg5.length)) + (7 * ceil32(return_data.size)) + 257 len 32 * _149] = mem[ceil32(ceil32(arg5.length)) + (6 * ceil32(return_data.size)) + _145 + 257 len 32 * _149]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(stor4)
                    staticcall stor4.0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _201 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if mem[_201] < arg4:
                        revert with 0, 17
                    require ext_code.size(stor4)
                    call stor4.0x2e1a7d4d with:
                         gas gas_remaining wei
                        args (mem[_201] - arg4)
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    call tx.origin with:
       value eth.balance(this.address) wei
         gas 2300 * is_zero(value) wei
}

function joeCall(address arg1, uint256 arg2, uint256 arg3, bytes arg4) {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg4 <= test266151307()
    require arg4 + 35 < calldata.size
    require arg4.length <= test266151307()
    require arg4 + arg4.length + 36 <= calldata.size
    if stor3 != msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'only permissioned UniswapV2 pair can call'
    if arg1 != this.address:
        revert with 0, 'only this contract may initiate'
    require arg4.length >= 256
    require cd[(arg4 + 36)] < 3
    require cd[(arg4 + 68)] == address(cd[(arg4 + 68)])
    require cd[(arg4 + 132)] == address(cd[(arg4 + 132)])
    require cd[(arg4 + 164)] == bool(cd[(arg4 + 164)])
    require cd[(arg4 + 196)] == bool(cd[(arg4 + 196)])
    require cd[(arg4 + 228)] <= test266151307()
    require arg4 + cd[(arg4 + 228)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 228)] + 36)] > test266151307():
        revert with 0, 65
    if ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + 97 < 96 or ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + 97 > test266151307():
        revert with 0, 65
    mem[96] = cd[(arg4 + cd[(arg4 + 228)] + 36)]
    require cd[(arg4 + 228)] + cd[(arg4 + cd[(arg4 + 228)] + 36)] + 68 <= arg4.length + 36
    mem[128 len cd[(arg4 + cd[(arg4 + 228)] + 36)]] = call.data[arg4 + cd[(arg4 + 228)] + 68 len cd[(arg4 + cd[(arg4 + 228)] + 36)]]
    mem[cd[(arg4 + cd[(arg4 + 228)] + 36)] + 128] = 0
    require cd[(arg4 + 260)] <= test266151307()
    require arg4 + cd[(arg4 + 260)] + 67 < arg4 + arg4.length + 36
    if cd[(arg4 + cd[(arg4 + 260)] + 36)] > test266151307():
        revert with 0, 65
    if ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + 98 < 97 or ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + 98 > test266151307():
        revert with 0, 65
    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + 97] = cd[(arg4 + cd[(arg4 + 260)] + 36)]
    require cd[(arg4 + 260)] + cd[(arg4 + cd[(arg4 + 260)] + 36)] + 68 <= arg4.length + 36
    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + 129 len cd[(arg4 + cd[(arg4 + 260)] + 36)]] = call.data[arg4 + cd[(arg4 + 260)] + 68 len cd[(arg4 + cd[(arg4 + 260)] + 36)]]
    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + cd[(arg4 + cd[(arg4 + 260)] + 36)] + 129] = 0
    if cd[(arg4 + 36)] > 2:
        revert with 0, 33
    if not cd[(arg4 + 36)]:
        if not cd[(arg4 + 164)]:
            if cd[(arg4 + 100)] > 0x5555555555555555555555555555555555555555555555555555555555555555:
                revert with 0, 17
            if 1 > !(3 * cd[(arg4 + 100)] / 997):
                revert with 0, 17
            if cd[(arg4 + 100)] > !((3 * cd[(arg4 + 100)] / 997) + 1):
                revert with 0, 17
            if cd[(arg4 + 164)]:
                if cd[(arg4 + 196)]:
                    if not sub_ccccbcf7Address:
                        require ext_code.size(stor4)
                        call stor4.0x2e1a7d4d with:
                             gas gas_remaining wei
                            args cd[(arg4 + 100)]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + 134] = sub_3c8a5d8dAddress
                        require ext_code.size(sub_1c1d3e8dAddress)
                        call sub_1c1d3e8dAddress.liquidateBorrow(address arg1, address arg2) with:
                           value cd[(arg4 + 100)] wei
                             gas gas_remaining wei
                            args account, sub_3c8a5d8dAddress
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + 102] = this.address
                        require ext_code.size(sub_3c8a5d8dAddress)
                        staticcall sub_3c8a5d8dAddress.0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + 98] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + ceil32(return_data.size) + 102] = ext_call.return_data[0]
                        require ext_code.size(sub_3c8a5d8dAddress)
                        call sub_3c8a5d8dAddress.redeem(uint256 arg1) with:
                             gas gas_remaining wei
                            args ext_call.return_data[0]
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + ceil32(return_data.size) + 98] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if not sub_3fd82e21Address:
                            require ext_code.size(stor4)
                            call stor4.deposit() with:
                               value cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1 wei
                                 gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            call tx.origin with:
                               value eth.balance(this.address) wei
                                 gas 2300 * is_zero(value) wei
                            if cd[(arg4 + 196)]:
                                require ext_code.size(stor4)
                                call stor4.deposit() with:
                                   value cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1 wei
                                     gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(address(cd[(arg4 + 68)]))
                            call address(cd[(arg4 + 68)]).0xa9059cbb with:
                                 gas gas_remaining wei
                                args msg.sender, cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                        else:
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (2 * ceil32(return_data.size)) + 102] = this.address
                            require ext_code.size(sub_3fd82e21Address)
                            staticcall sub_3fd82e21Address.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (2 * ceil32(return_data.size)) + 98] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if stor4 == sub_3fd82e21Address:
                                require ext_code.size(stor4)
                                staticcall stor4.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if ext_call.return_data[0] < cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1:
                                    revert with 0, 17
                                require ext_code.size(stor4)
                                call stor4.0x2e1a7d4d with:
                                     gas gas_remaining wei
                                    args (ext_call.return_data[0] + -cd[(arg4 + 100)] + -(3 * cd[(arg4 + 100)] / 997) - 1)
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                call tx.origin with:
                                   value eth.balance(this.address) wei
                                     gas 2300 * is_zero(value) wei
                                if cd[(arg4 + 196)]:
                                    require ext_code.size(stor4)
                                    call stor4.deposit() with:
                                       value cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1 wei
                                         gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(address(cd[(arg4 + 68)]))
                                call address(cd[(arg4 + 68)]).0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                            else:
                                if sub_ccccbcf7Address != sub_3fd82e21Address:
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 98] = 2
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 130] = sub_3fd82e21Address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 162] = stor4
                                    if 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 194] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 198] = ext_call.return_data[0]
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 230] = 0
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 262] = 160
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 358] = 2
                                    idx = 0
                                    s = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 390
                                    t = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 130
                                    while idx < 2:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 294] = this.address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 326] = block.timestamp + 3600
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 3600, 2, mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 390 len 64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 194 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 194
                                    require return_data.size >= 32
                                    _4964 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28]
                                    require mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 225 < ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + return_data.size + 194
                                    _5040 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]
                                    if mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194] > test266151307():
                                        revert with 0, 65
                                    if ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]) + 1 < 0 or ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]) + 195 > test266151307():
                                        revert with 0, 65
                                    mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]) + 195
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 194] = _5040
                                    require return_data.size >= _4964 + (32 * _5040) + 32
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 226 len 32 * _5040] = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + _4964 + 226 len 32 * _5040]
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(stor4)
                                    staticcall stor4.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7948 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if mem[_7948] < cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1:
                                        revert with 0, 17
                                    require ext_code.size(stor4)
                                    call stor4.0x2e1a7d4d with:
                                         gas gas_remaining wei
                                        args (mem[_7948] + -cd[(arg4 + 100)] + -(3 * cd[(arg4 + 100)] / 997) - 1)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    call tx.origin with:
                                       value eth.balance(this.address) wei
                                         gas 2300 * is_zero(value) wei
                                    if not cd[(arg4 + 196)]:
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        require ext_code.size(address(cd[(arg4 + 68)]))
                                        call address(cd[(arg4 + 68)]).0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _8844 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_8844] == bool(mem[_8844])
                                    else:
                                        require ext_code.size(stor4)
                                        call stor4.deposit() with:
                                           value cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1 wei
                                             gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        require ext_code.size(address(cd[(arg4 + 68)]))
                                        call address(cd[(arg4 + 68)]).0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9068 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_9068] == bool(mem[_9068])
                                else:
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 98] = 3
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 130] = sub_3fd82e21Address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 162] = sub_e36c61f1Address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 194] = stor4
                                    if 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 226] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 230] = ext_call.return_data[0]
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 262] = 0
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 294] = 160
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 390] = 3
                                    idx = 0
                                    s = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 422
                                    t = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 130
                                    while idx < 3:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 326] = this.address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 358] = block.timestamp + 3600
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 3600, 3, mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 422 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 226 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 226
                                    require return_data.size >= 32
                                    _4965 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28]
                                    require mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 257 < ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + return_data.size + 226
                                    _5041 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]
                                    if mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226] > test266151307():
                                        revert with 0, 65
                                    if ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 1 < 0 or ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 227 > test266151307():
                                        revert with 0, 65
                                    mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 227
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 226] = _5041
                                    require return_data.size >= _4965 + (32 * _5041) + 32
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 258 len 32 * _5041] = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + _4965 + 258 len 32 * _5041]
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(stor4)
                                    staticcall stor4.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7949 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if mem[_7949] < cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1:
                                        revert with 0, 17
                                    require ext_code.size(stor4)
                                    call stor4.0x2e1a7d4d with:
                                         gas gas_remaining wei
                                        args (mem[_7949] + -cd[(arg4 + 100)] + -(3 * cd[(arg4 + 100)] / 997) - 1)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    call tx.origin with:
                                       value eth.balance(this.address) wei
                                         gas 2300 * is_zero(value) wei
                                    if not cd[(arg4 + 196)]:
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        require ext_code.size(address(cd[(arg4 + 68)]))
                                        call address(cd[(arg4 + 68)]).0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _8845 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_8845] == bool(mem[_8845])
                                    else:
                                        require ext_code.size(stor4)
                                        call stor4.deposit() with:
                                           value cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1 wei
                                             gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        require ext_code.size(address(cd[(arg4 + 68)]))
                                        call address(cd[(arg4 + 68)]).0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9069 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_9069] == bool(mem[_9069])
                    else:
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + 102] = account
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + 134] = cd[(arg4 + 100)]
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + 166] = sub_3c8a5d8dAddress
                        require ext_code.size(sub_1c1d3e8dAddress)
                        call sub_1c1d3e8dAddress.liquidateBorrow(address arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args account, cd[(arg4 + 100)], sub_3c8a5d8dAddress
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + 98] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + ceil32(return_data.size) + 102] = this.address
                        require ext_code.size(sub_3c8a5d8dAddress)
                        staticcall sub_3c8a5d8dAddress.0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + ceil32(return_data.size) + 98] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (2 * ceil32(return_data.size)) + 102] = ext_call.return_data[0]
                        require ext_code.size(sub_3c8a5d8dAddress)
                        call sub_3c8a5d8dAddress.redeem(uint256 arg1) with:
                             gas gas_remaining wei
                            args ext_call.return_data[0]
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (2 * ceil32(return_data.size)) + 98] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if not sub_3fd82e21Address:
                            require ext_code.size(stor4)
                            call stor4.deposit() with:
                               value cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1 wei
                                 gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            call tx.origin with:
                               value eth.balance(this.address) wei
                                 gas 2300 * is_zero(value) wei
                            if cd[(arg4 + 196)]:
                                require ext_code.size(stor4)
                                call stor4.deposit() with:
                                   value cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1 wei
                                     gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(address(cd[(arg4 + 68)]))
                            call address(cd[(arg4 + 68)]).0xa9059cbb with:
                                 gas gas_remaining wei
                                args msg.sender, cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                        else:
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 102] = this.address
                            require ext_code.size(sub_3fd82e21Address)
                            staticcall sub_3fd82e21Address.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 98] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if stor4 == sub_3fd82e21Address:
                                require ext_code.size(stor4)
                                staticcall stor4.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if ext_call.return_data[0] < cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1:
                                    revert with 0, 17
                                require ext_code.size(stor4)
                                call stor4.0x2e1a7d4d with:
                                     gas gas_remaining wei
                                    args (ext_call.return_data[0] + -cd[(arg4 + 100)] + -(3 * cd[(arg4 + 100)] / 997) - 1)
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                call tx.origin with:
                                   value eth.balance(this.address) wei
                                     gas 2300 * is_zero(value) wei
                                if cd[(arg4 + 196)]:
                                    require ext_code.size(stor4)
                                    call stor4.deposit() with:
                                       value cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1 wei
                                         gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(address(cd[(arg4 + 68)]))
                                call address(cd[(arg4 + 68)]).0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                            else:
                                if sub_ccccbcf7Address != sub_3fd82e21Address:
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 98] = 2
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 130] = sub_3fd82e21Address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 162] = stor4
                                    if 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 194] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 198] = ext_call.return_data[0]
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 230] = 0
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 262] = 160
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 358] = 2
                                    idx = 0
                                    s = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 390
                                    t = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 130
                                    while idx < 2:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 294] = this.address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 326] = block.timestamp + 3600
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 3600, 2, mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 390 len 64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 194 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 194
                                    require return_data.size >= 32
                                    _4962 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28]
                                    require mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 225 < ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + return_data.size + 194
                                    _5038 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]
                                    if mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194] > test266151307():
                                        revert with 0, 65
                                    if ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]) + 1 < 0 or ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]) + 195 > test266151307():
                                        revert with 0, 65
                                    mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]) + 195
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 194] = _5038
                                    require return_data.size >= _4962 + (32 * _5038) + 32
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 226 len 32 * _5038] = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + _4962 + 226 len 32 * _5038]
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(stor4)
                                    staticcall stor4.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7946 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if mem[_7946] < cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1:
                                        revert with 0, 17
                                    require ext_code.size(stor4)
                                    call stor4.0x2e1a7d4d with:
                                         gas gas_remaining wei
                                        args (mem[_7946] + -cd[(arg4 + 100)] + -(3 * cd[(arg4 + 100)] / 997) - 1)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    call tx.origin with:
                                       value eth.balance(this.address) wei
                                         gas 2300 * is_zero(value) wei
                                    if not cd[(arg4 + 196)]:
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        require ext_code.size(address(cd[(arg4 + 68)]))
                                        call address(cd[(arg4 + 68)]).0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _8842 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_8842] == bool(mem[_8842])
                                    else:
                                        require ext_code.size(stor4)
                                        call stor4.deposit() with:
                                           value cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1 wei
                                             gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        require ext_code.size(address(cd[(arg4 + 68)]))
                                        call address(cd[(arg4 + 68)]).0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9066 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_9066] == bool(mem[_9066])
                                else:
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 98] = 3
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 130] = sub_3fd82e21Address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 162] = sub_e36c61f1Address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 194] = stor4
                                    if 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 226] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 230] = ext_call.return_data[0]
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 262] = 0
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 294] = 160
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 390] = 3
                                    idx = 0
                                    s = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 422
                                    t = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 130
                                    while idx < 3:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 326] = this.address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 358] = block.timestamp + 3600
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 3600, 3, mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 422 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 226 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 226
                                    require return_data.size >= 32
                                    _4963 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28]
                                    require mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 257 < ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + return_data.size + 226
                                    _5039 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]
                                    if mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226] > test266151307():
                                        revert with 0, 65
                                    if ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 1 < 0 or ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 227 > test266151307():
                                        revert with 0, 65
                                    mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 227
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 226] = _5039
                                    require return_data.size >= _4963 + (32 * _5039) + 32
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 258 len 32 * _5039] = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + _4963 + 258 len 32 * _5039]
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(stor4)
                                    staticcall stor4.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7947 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if mem[_7947] < cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1:
                                        revert with 0, 17
                                    require ext_code.size(stor4)
                                    call stor4.0x2e1a7d4d with:
                                         gas gas_remaining wei
                                        args (mem[_7947] + -cd[(arg4 + 100)] + -(3 * cd[(arg4 + 100)] / 997) - 1)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    call tx.origin with:
                                       value eth.balance(this.address) wei
                                         gas 2300 * is_zero(value) wei
                                    if not cd[(arg4 + 196)]:
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        require ext_code.size(address(cd[(arg4 + 68)]))
                                        call address(cd[(arg4 + 68)]).0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _8843 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_8843] == bool(mem[_8843])
                                    else:
                                        require ext_code.size(stor4)
                                        call stor4.deposit() with:
                                           value cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1 wei
                                             gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        require ext_code.size(address(cd[(arg4 + 68)]))
                                        call address(cd[(arg4 + 68)]).0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9067 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_9067] == bool(mem[_9067])
                else:
                    if not sub_ccccbcf7Address:
                        require ext_code.size(stor4)
                        call stor4.0x2e1a7d4d with:
                             gas gas_remaining wei
                            args cd[(arg4 + 100)]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + 134] = sub_3c8a5d8dAddress
                        require ext_code.size(sub_1c1d3e8dAddress)
                        call sub_1c1d3e8dAddress.liquidateBorrow(address arg1, address arg2) with:
                           value cd[(arg4 + 100)] wei
                             gas gas_remaining wei
                            args account, sub_3c8a5d8dAddress
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + 102] = this.address
                        require ext_code.size(sub_3c8a5d8dAddress)
                        staticcall sub_3c8a5d8dAddress.0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + 98] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + ceil32(return_data.size) + 102] = ext_call.return_data[0]
                        require ext_code.size(sub_3c8a5d8dAddress)
                        call sub_3c8a5d8dAddress.redeem(uint256 arg1) with:
                             gas gas_remaining wei
                            args ext_call.return_data[0]
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + ceil32(return_data.size) + 98] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if not sub_3fd82e21Address:
                            require ext_code.size(stor4)
                            call stor4.deposit() with:
                               value cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1 wei
                                 gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            call tx.origin with:
                               value eth.balance(this.address) wei
                                 gas 2300 * is_zero(value) wei
                            if cd[(arg4 + 196)]:
                                require ext_code.size(stor4)
                                call stor4.deposit() with:
                                   value cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1 wei
                                     gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(address(cd[(arg4 + 68)]))
                            call address(cd[(arg4 + 68)]).0xa9059cbb with:
                                 gas gas_remaining wei
                                args msg.sender, cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                        else:
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (2 * ceil32(return_data.size)) + 102] = this.address
                            require ext_code.size(sub_3fd82e21Address)
                            staticcall sub_3fd82e21Address.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (2 * ceil32(return_data.size)) + 98] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if stor4 == sub_3fd82e21Address:
                                require ext_code.size(stor4)
                                staticcall stor4.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if ext_call.return_data[0] < cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1:
                                    revert with 0, 17
                                require ext_code.size(stor4)
                                call stor4.0x2e1a7d4d with:
                                     gas gas_remaining wei
                                    args (ext_call.return_data[0] + -cd[(arg4 + 100)] + -(3 * cd[(arg4 + 100)] / 997) - 1)
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                call tx.origin with:
                                   value eth.balance(this.address) wei
                                     gas 2300 * is_zero(value) wei
                                if cd[(arg4 + 196)]:
                                    require ext_code.size(stor4)
                                    call stor4.deposit() with:
                                       value cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1 wei
                                         gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(address(cd[(arg4 + 68)]))
                                call address(cd[(arg4 + 68)]).0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                            else:
                                if sub_ccccbcf7Address != sub_3fd82e21Address:
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 98] = 2
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 130] = sub_3fd82e21Address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 162] = stor4
                                    if 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 194] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 198] = ext_call.return_data[0]
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 230] = 0
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 262] = 160
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 358] = 2
                                    idx = 0
                                    s = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 390
                                    t = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 130
                                    while idx < 2:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 294] = this.address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 326] = block.timestamp + 3600
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 3600, 2, mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 390 len 64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 194 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 194
                                    require return_data.size >= 32
                                    _4968 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28]
                                    require mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 225 < ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + return_data.size + 194
                                    _5044 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]
                                    if mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194] > test266151307():
                                        revert with 0, 65
                                    if ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]) + 1 < 0 or ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]) + 195 > test266151307():
                                        revert with 0, 65
                                    mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]) + 195
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 194] = _5044
                                    require return_data.size >= _4968 + (32 * _5044) + 32
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 226 len 32 * _5044] = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + _4968 + 226 len 32 * _5044]
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(stor4)
                                    staticcall stor4.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7952 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if mem[_7952] < cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1:
                                        revert with 0, 17
                                    require ext_code.size(stor4)
                                    call stor4.0x2e1a7d4d with:
                                         gas gas_remaining wei
                                        args (mem[_7952] + -cd[(arg4 + 100)] + -(3 * cd[(arg4 + 100)] / 997) - 1)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    call tx.origin with:
                                       value eth.balance(this.address) wei
                                         gas 2300 * is_zero(value) wei
                                    if not cd[(arg4 + 196)]:
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        require ext_code.size(address(cd[(arg4 + 68)]))
                                        call address(cd[(arg4 + 68)]).0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _8848 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_8848] == bool(mem[_8848])
                                    else:
                                        require ext_code.size(stor4)
                                        call stor4.deposit() with:
                                           value cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1 wei
                                             gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        require ext_code.size(address(cd[(arg4 + 68)]))
                                        call address(cd[(arg4 + 68)]).0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9072 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_9072] == bool(mem[_9072])
                                else:
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 98] = 3
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 130] = sub_3fd82e21Address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 162] = sub_e36c61f1Address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 194] = stor4
                                    if 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 226] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 230] = ext_call.return_data[0]
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 262] = 0
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 294] = 160
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 390] = 3
                                    idx = 0
                                    s = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 422
                                    t = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 130
                                    while idx < 3:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 326] = this.address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 358] = block.timestamp + 3600
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 3600, 3, mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 422 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 226 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 226
                                    require return_data.size >= 32
                                    _4969 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28]
                                    require mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 257 < ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + return_data.size + 226
                                    _5045 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]
                                    if mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226] > test266151307():
                                        revert with 0, 65
                                    if ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 1 < 0 or ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 227 > test266151307():
                                        revert with 0, 65
                                    mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 227
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 226] = _5045
                                    require return_data.size >= _4969 + (32 * _5045) + 32
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 258 len 32 * _5045] = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + _4969 + 258 len 32 * _5045]
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(stor4)
                                    staticcall stor4.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7953 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if mem[_7953] < cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1:
                                        revert with 0, 17
                                    require ext_code.size(stor4)
                                    call stor4.0x2e1a7d4d with:
                                         gas gas_remaining wei
                                        args (mem[_7953] + -cd[(arg4 + 100)] + -(3 * cd[(arg4 + 100)] / 997) - 1)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    call tx.origin with:
                                       value eth.balance(this.address) wei
                                         gas 2300 * is_zero(value) wei
                                    if not cd[(arg4 + 196)]:
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        require ext_code.size(address(cd[(arg4 + 68)]))
                                        call address(cd[(arg4 + 68)]).0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _8849 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_8849] == bool(mem[_8849])
                                    else:
                                        require ext_code.size(stor4)
                                        call stor4.deposit() with:
                                           value cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1 wei
                                             gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        require ext_code.size(address(cd[(arg4 + 68)]))
                                        call address(cd[(arg4 + 68)]).0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9073 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_9073] == bool(mem[_9073])
                    else:
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + 102] = account
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + 134] = cd[(arg4 + 100)]
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + 166] = sub_3c8a5d8dAddress
                        require ext_code.size(sub_1c1d3e8dAddress)
                        call sub_1c1d3e8dAddress.liquidateBorrow(address arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args account, cd[(arg4 + 100)], sub_3c8a5d8dAddress
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + 98] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + ceil32(return_data.size) + 102] = this.address
                        require ext_code.size(sub_3c8a5d8dAddress)
                        staticcall sub_3c8a5d8dAddress.0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + ceil32(return_data.size) + 98] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (2 * ceil32(return_data.size)) + 102] = ext_call.return_data[0]
                        require ext_code.size(sub_3c8a5d8dAddress)
                        call sub_3c8a5d8dAddress.redeem(uint256 arg1) with:
                             gas gas_remaining wei
                            args ext_call.return_data[0]
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (2 * ceil32(return_data.size)) + 98] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if not sub_3fd82e21Address:
                            require ext_code.size(stor4)
                            call stor4.deposit() with:
                               value cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1 wei
                                 gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            call tx.origin with:
                               value eth.balance(this.address) wei
                                 gas 2300 * is_zero(value) wei
                            if cd[(arg4 + 196)]:
                                require ext_code.size(stor4)
                                call stor4.deposit() with:
                                   value cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1 wei
                                     gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(address(cd[(arg4 + 68)]))
                            call address(cd[(arg4 + 68)]).0xa9059cbb with:
                                 gas gas_remaining wei
                                args msg.sender, cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                        else:
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 102] = this.address
                            require ext_code.size(sub_3fd82e21Address)
                            staticcall sub_3fd82e21Address.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 98] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if stor4 == sub_3fd82e21Address:
                                require ext_code.size(stor4)
                                staticcall stor4.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if ext_call.return_data[0] < cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1:
                                    revert with 0, 17
                                require ext_code.size(stor4)
                                call stor4.0x2e1a7d4d with:
                                     gas gas_remaining wei
                                    args (ext_call.return_data[0] + -cd[(arg4 + 100)] + -(3 * cd[(arg4 + 100)] / 997) - 1)
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                call tx.origin with:
                                   value eth.balance(this.address) wei
                                     gas 2300 * is_zero(value) wei
                                if cd[(arg4 + 196)]:
                                    require ext_code.size(stor4)
                                    call stor4.deposit() with:
                                       value cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1 wei
                                         gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(address(cd[(arg4 + 68)]))
                                call address(cd[(arg4 + 68)]).0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                            else:
                                if sub_ccccbcf7Address != sub_3fd82e21Address:
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 98] = 2
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 130] = sub_3fd82e21Address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 162] = stor4
                                    if 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 194] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 198] = ext_call.return_data[0]
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 230] = 0
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 262] = 160
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 358] = 2
                                    idx = 0
                                    s = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 390
                                    t = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 130
                                    while idx < 2:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 294] = this.address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 326] = block.timestamp + 3600
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 3600, 2, mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 390 len 64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 194 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 194
                                    require return_data.size >= 32
                                    _4966 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28]
                                    require mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 225 < ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + return_data.size + 194
                                    _5042 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]
                                    if mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194] > test266151307():
                                        revert with 0, 65
                                    if ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]) + 1 < 0 or ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]) + 195 > test266151307():
                                        revert with 0, 65
                                    mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]) + 195
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 194] = _5042
                                    require return_data.size >= _4966 + (32 * _5042) + 32
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 226 len 32 * _5042] = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + _4966 + 226 len 32 * _5042]
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(stor4)
                                    staticcall stor4.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7950 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if mem[_7950] < cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1:
                                        revert with 0, 17
                                    require ext_code.size(stor4)
                                    call stor4.0x2e1a7d4d with:
                                         gas gas_remaining wei
                                        args (mem[_7950] + -cd[(arg4 + 100)] + -(3 * cd[(arg4 + 100)] / 997) - 1)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    call tx.origin with:
                                       value eth.balance(this.address) wei
                                         gas 2300 * is_zero(value) wei
                                    if not cd[(arg4 + 196)]:
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        require ext_code.size(address(cd[(arg4 + 68)]))
                                        call address(cd[(arg4 + 68)]).0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _8846 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_8846] == bool(mem[_8846])
                                    else:
                                        require ext_code.size(stor4)
                                        call stor4.deposit() with:
                                           value cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1 wei
                                             gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        require ext_code.size(address(cd[(arg4 + 68)]))
                                        call address(cd[(arg4 + 68)]).0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9070 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_9070] == bool(mem[_9070])
                                else:
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 98] = 3
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 130] = sub_3fd82e21Address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 162] = sub_e36c61f1Address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 194] = stor4
                                    if 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 226] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 230] = ext_call.return_data[0]
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 262] = 0
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 294] = 160
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 390] = 3
                                    idx = 0
                                    s = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 422
                                    t = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 130
                                    while idx < 3:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 326] = this.address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 358] = block.timestamp + 3600
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 3600, 3, mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 422 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 226 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 226
                                    require return_data.size >= 32
                                    _4967 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28]
                                    require mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 257 < ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + return_data.size + 226
                                    _5043 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]
                                    if mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226] > test266151307():
                                        revert with 0, 65
                                    if ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 1 < 0 or ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 227 > test266151307():
                                        revert with 0, 65
                                    mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 227
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 226] = _5043
                                    require return_data.size >= _4967 + (32 * _5043) + 32
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 258 len 32 * _5043] = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + _4967 + 258 len 32 * _5043]
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(stor4)
                                    staticcall stor4.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7951 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if mem[_7951] < cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1:
                                        revert with 0, 17
                                    require ext_code.size(stor4)
                                    call stor4.0x2e1a7d4d with:
                                         gas gas_remaining wei
                                        args (mem[_7951] + -cd[(arg4 + 100)] + -(3 * cd[(arg4 + 100)] / 997) - 1)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    call tx.origin with:
                                       value eth.balance(this.address) wei
                                         gas 2300 * is_zero(value) wei
                                    if not cd[(arg4 + 196)]:
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        require ext_code.size(address(cd[(arg4 + 68)]))
                                        call address(cd[(arg4 + 68)]).0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _8847 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_8847] == bool(mem[_8847])
                                    else:
                                        require ext_code.size(stor4)
                                        call stor4.deposit() with:
                                           value cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1 wei
                                             gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        require ext_code.size(address(cd[(arg4 + 68)]))
                                        call address(cd[(arg4 + 68)]).0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9071 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_9071] == bool(mem[_9071])
            else:
                if cd[(arg4 + 196)]:
                    if not sub_ccccbcf7Address:
                        require ext_code.size(stor4)
                        call stor4.0x2e1a7d4d with:
                             gas gas_remaining wei
                            args cd[(arg4 + 100)]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + 134] = sub_3c8a5d8dAddress
                        require ext_code.size(sub_1c1d3e8dAddress)
                        call sub_1c1d3e8dAddress.liquidateBorrow(address arg1, address arg2) with:
                           value cd[(arg4 + 100)] wei
                             gas gas_remaining wei
                            args account, sub_3c8a5d8dAddress
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + 102] = this.address
                        require ext_code.size(sub_3c8a5d8dAddress)
                        staticcall sub_3c8a5d8dAddress.0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + 98] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + ceil32(return_data.size) + 102] = ext_call.return_data[0]
                        require ext_code.size(sub_3c8a5d8dAddress)
                        call sub_3c8a5d8dAddress.redeem(uint256 arg1) with:
                             gas gas_remaining wei
                            args ext_call.return_data[0]
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + ceil32(return_data.size) + 98] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if not sub_3fd82e21Address:
                            require ext_code.size(stor4)
                            call stor4.deposit() with:
                               value cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1 wei
                                 gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            call tx.origin with:
                               value eth.balance(this.address) wei
                                 gas 2300 * is_zero(value) wei
                            if cd[(arg4 + 196)]:
                                require ext_code.size(stor4)
                                call stor4.deposit() with:
                                   value cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1 wei
                                     gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(address(cd[(arg4 + 68)]))
                            call address(cd[(arg4 + 68)]).0xa9059cbb with:
                                 gas gas_remaining wei
                                args msg.sender, cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                        else:
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (2 * ceil32(return_data.size)) + 102] = this.address
                            require ext_code.size(sub_3fd82e21Address)
                            staticcall sub_3fd82e21Address.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (2 * ceil32(return_data.size)) + 98] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if stor4 == sub_3fd82e21Address:
                                require ext_code.size(stor4)
                                staticcall stor4.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if ext_call.return_data[0] < cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1:
                                    revert with 0, 17
                                require ext_code.size(stor4)
                                call stor4.0x2e1a7d4d with:
                                     gas gas_remaining wei
                                    args (ext_call.return_data[0] + -cd[(arg4 + 100)] + -(3 * cd[(arg4 + 100)] / 997) - 1)
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                call tx.origin with:
                                   value eth.balance(this.address) wei
                                     gas 2300 * is_zero(value) wei
                                if cd[(arg4 + 196)]:
                                    require ext_code.size(stor4)
                                    call stor4.deposit() with:
                                       value cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1 wei
                                         gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(address(cd[(arg4 + 68)]))
                                call address(cd[(arg4 + 68)]).0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                            else:
                                if sub_ccccbcf7Address != sub_3fd82e21Address:
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 98] = 2
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 130] = sub_3fd82e21Address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 162] = stor4
                                    if 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 194] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 198] = ext_call.return_data[0]
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 230] = 0
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 262] = 160
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 358] = 2
                                    idx = 0
                                    s = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 390
                                    t = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 130
                                    while idx < 2:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 294] = this.address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 326] = block.timestamp + 3600
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 3600, 2, mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 390 len 64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 194 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 194
                                    require return_data.size >= 32
                                    _4972 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28]
                                    require mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 225 < ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + return_data.size + 194
                                    _5048 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]
                                    if mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194] > test266151307():
                                        revert with 0, 65
                                    if ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]) + 1 < 0 or ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]) + 195 > test266151307():
                                        revert with 0, 65
                                    mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]) + 195
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 194] = _5048
                                    require return_data.size >= _4972 + (32 * _5048) + 32
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 226 len 32 * _5048] = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + _4972 + 226 len 32 * _5048]
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(stor4)
                                    staticcall stor4.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7956 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if mem[_7956] < cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1:
                                        revert with 0, 17
                                    require ext_code.size(stor4)
                                    call stor4.0x2e1a7d4d with:
                                         gas gas_remaining wei
                                        args (mem[_7956] + -cd[(arg4 + 100)] + -(3 * cd[(arg4 + 100)] / 997) - 1)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    call tx.origin with:
                                       value eth.balance(this.address) wei
                                         gas 2300 * is_zero(value) wei
                                    if not cd[(arg4 + 196)]:
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        require ext_code.size(address(cd[(arg4 + 68)]))
                                        call address(cd[(arg4 + 68)]).0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _8852 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_8852] == bool(mem[_8852])
                                    else:
                                        require ext_code.size(stor4)
                                        call stor4.deposit() with:
                                           value cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1 wei
                                             gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        require ext_code.size(address(cd[(arg4 + 68)]))
                                        call address(cd[(arg4 + 68)]).0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9076 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_9076] == bool(mem[_9076])
                                else:
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 98] = 3
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 130] = sub_3fd82e21Address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 162] = sub_e36c61f1Address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 194] = stor4
                                    if 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 226] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 230] = ext_call.return_data[0]
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 262] = 0
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 294] = 160
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 390] = 3
                                    idx = 0
                                    s = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 422
                                    t = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 130
                                    while idx < 3:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 326] = this.address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 358] = block.timestamp + 3600
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 3600, 3, mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 422 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 226 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 226
                                    require return_data.size >= 32
                                    _4973 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28]
                                    require mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 257 < ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + return_data.size + 226
                                    _5049 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]
                                    if mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226] > test266151307():
                                        revert with 0, 65
                                    if ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 1 < 0 or ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 227 > test266151307():
                                        revert with 0, 65
                                    mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 227
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 226] = _5049
                                    require return_data.size >= _4973 + (32 * _5049) + 32
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 258 len 32 * _5049] = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + _4973 + 258 len 32 * _5049]
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(stor4)
                                    staticcall stor4.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7957 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if mem[_7957] < cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1:
                                        revert with 0, 17
                                    require ext_code.size(stor4)
                                    call stor4.0x2e1a7d4d with:
                                         gas gas_remaining wei
                                        args (mem[_7957] + -cd[(arg4 + 100)] + -(3 * cd[(arg4 + 100)] / 997) - 1)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    call tx.origin with:
                                       value eth.balance(this.address) wei
                                         gas 2300 * is_zero(value) wei
                                    if not cd[(arg4 + 196)]:
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        require ext_code.size(address(cd[(arg4 + 68)]))
                                        call address(cd[(arg4 + 68)]).0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _8853 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_8853] == bool(mem[_8853])
                                    else:
                                        require ext_code.size(stor4)
                                        call stor4.deposit() with:
                                           value cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1 wei
                                             gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        require ext_code.size(address(cd[(arg4 + 68)]))
                                        call address(cd[(arg4 + 68)]).0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9077 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_9077] == bool(mem[_9077])
                    else:
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + 102] = account
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + 134] = cd[(arg4 + 100)]
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + 166] = sub_3c8a5d8dAddress
                        require ext_code.size(sub_1c1d3e8dAddress)
                        call sub_1c1d3e8dAddress.liquidateBorrow(address arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args account, cd[(arg4 + 100)], sub_3c8a5d8dAddress
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + 98] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + ceil32(return_data.size) + 102] = this.address
                        require ext_code.size(sub_3c8a5d8dAddress)
                        staticcall sub_3c8a5d8dAddress.0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + ceil32(return_data.size) + 98] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (2 * ceil32(return_data.size)) + 102] = ext_call.return_data[0]
                        require ext_code.size(sub_3c8a5d8dAddress)
                        call sub_3c8a5d8dAddress.redeem(uint256 arg1) with:
                             gas gas_remaining wei
                            args ext_call.return_data[0]
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (2 * ceil32(return_data.size)) + 98] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if not sub_3fd82e21Address:
                            require ext_code.size(stor4)
                            call stor4.deposit() with:
                               value cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1 wei
                                 gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            call tx.origin with:
                               value eth.balance(this.address) wei
                                 gas 2300 * is_zero(value) wei
                            if cd[(arg4 + 196)]:
                                require ext_code.size(stor4)
                                call stor4.deposit() with:
                                   value cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1 wei
                                     gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(address(cd[(arg4 + 68)]))
                            call address(cd[(arg4 + 68)]).0xa9059cbb with:
                                 gas gas_remaining wei
                                args msg.sender, cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                        else:
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 102] = this.address
                            require ext_code.size(sub_3fd82e21Address)
                            staticcall sub_3fd82e21Address.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 98] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if stor4 == sub_3fd82e21Address:
                                require ext_code.size(stor4)
                                staticcall stor4.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if ext_call.return_data[0] < cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1:
                                    revert with 0, 17
                                require ext_code.size(stor4)
                                call stor4.0x2e1a7d4d with:
                                     gas gas_remaining wei
                                    args (ext_call.return_data[0] + -cd[(arg4 + 100)] + -(3 * cd[(arg4 + 100)] / 997) - 1)
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                call tx.origin with:
                                   value eth.balance(this.address) wei
                                     gas 2300 * is_zero(value) wei
                                if cd[(arg4 + 196)]:
                                    require ext_code.size(stor4)
                                    call stor4.deposit() with:
                                       value cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1 wei
                                         gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(address(cd[(arg4 + 68)]))
                                call address(cd[(arg4 + 68)]).0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                            else:
                                if sub_ccccbcf7Address != sub_3fd82e21Address:
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 98] = 2
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 130] = sub_3fd82e21Address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 162] = stor4
                                    if 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 194] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 198] = ext_call.return_data[0]
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 230] = 0
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 262] = 160
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 358] = 2
                                    idx = 0
                                    s = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 390
                                    t = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 130
                                    while idx < 2:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 294] = this.address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 326] = block.timestamp + 3600
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 3600, 2, mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 390 len 64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 194 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 194
                                    require return_data.size >= 32
                                    _4970 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28]
                                    require mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 225 < ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + return_data.size + 194
                                    _5046 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]
                                    if mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194] > test266151307():
                                        revert with 0, 65
                                    if ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]) + 1 < 0 or ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]) + 195 > test266151307():
                                        revert with 0, 65
                                    mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]) + 195
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 194] = _5046
                                    require return_data.size >= _4970 + (32 * _5046) + 32
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 226 len 32 * _5046] = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + _4970 + 226 len 32 * _5046]
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(stor4)
                                    staticcall stor4.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7954 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if mem[_7954] < cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1:
                                        revert with 0, 17
                                    require ext_code.size(stor4)
                                    call stor4.0x2e1a7d4d with:
                                         gas gas_remaining wei
                                        args (mem[_7954] + -cd[(arg4 + 100)] + -(3 * cd[(arg4 + 100)] / 997) - 1)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    call tx.origin with:
                                       value eth.balance(this.address) wei
                                         gas 2300 * is_zero(value) wei
                                    if not cd[(arg4 + 196)]:
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        require ext_code.size(address(cd[(arg4 + 68)]))
                                        call address(cd[(arg4 + 68)]).0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _8850 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_8850] == bool(mem[_8850])
                                    else:
                                        require ext_code.size(stor4)
                                        call stor4.deposit() with:
                                           value cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1 wei
                                             gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        require ext_code.size(address(cd[(arg4 + 68)]))
                                        call address(cd[(arg4 + 68)]).0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9074 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_9074] == bool(mem[_9074])
                                else:
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 98] = 3
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 130] = sub_3fd82e21Address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 162] = sub_e36c61f1Address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 194] = stor4
                                    if 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 226] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 230] = ext_call.return_data[0]
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 262] = 0
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 294] = 160
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 390] = 3
                                    idx = 0
                                    s = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 422
                                    t = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 130
                                    while idx < 3:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 326] = this.address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 358] = block.timestamp + 3600
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 3600, 3, mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 422 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 226 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 226
                                    require return_data.size >= 32
                                    _4971 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28]
                                    require mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 257 < ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + return_data.size + 226
                                    _5047 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]
                                    if mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226] > test266151307():
                                        revert with 0, 65
                                    if ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 1 < 0 or ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 227 > test266151307():
                                        revert with 0, 65
                                    mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 227
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 226] = _5047
                                    require return_data.size >= _4971 + (32 * _5047) + 32
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 258 len 32 * _5047] = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + _4971 + 258 len 32 * _5047]
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(stor4)
                                    staticcall stor4.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7955 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if mem[_7955] < cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1:
                                        revert with 0, 17
                                    require ext_code.size(stor4)
                                    call stor4.0x2e1a7d4d with:
                                         gas gas_remaining wei
                                        args (mem[_7955] + -cd[(arg4 + 100)] + -(3 * cd[(arg4 + 100)] / 997) - 1)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    call tx.origin with:
                                       value eth.balance(this.address) wei
                                         gas 2300 * is_zero(value) wei
                                    if not cd[(arg4 + 196)]:
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        require ext_code.size(address(cd[(arg4 + 68)]))
                                        call address(cd[(arg4 + 68)]).0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _8851 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_8851] == bool(mem[_8851])
                                    else:
                                        require ext_code.size(stor4)
                                        call stor4.deposit() with:
                                           value cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1 wei
                                             gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        require ext_code.size(address(cd[(arg4 + 68)]))
                                        call address(cd[(arg4 + 68)]).0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9075 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_9075] == bool(mem[_9075])
                else:
                    if not sub_ccccbcf7Address:
                        require ext_code.size(stor4)
                        call stor4.0x2e1a7d4d with:
                             gas gas_remaining wei
                            args cd[(arg4 + 100)]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + 134] = sub_3c8a5d8dAddress
                        require ext_code.size(sub_1c1d3e8dAddress)
                        call sub_1c1d3e8dAddress.liquidateBorrow(address arg1, address arg2) with:
                           value cd[(arg4 + 100)] wei
                             gas gas_remaining wei
                            args account, sub_3c8a5d8dAddress
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + 102] = this.address
                        require ext_code.size(sub_3c8a5d8dAddress)
                        staticcall sub_3c8a5d8dAddress.0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + 98] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + ceil32(return_data.size) + 102] = ext_call.return_data[0]
                        require ext_code.size(sub_3c8a5d8dAddress)
                        call sub_3c8a5d8dAddress.redeem(uint256 arg1) with:
                             gas gas_remaining wei
                            args ext_call.return_data[0]
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + ceil32(return_data.size) + 98] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if not sub_3fd82e21Address:
                            require ext_code.size(stor4)
                            call stor4.deposit() with:
                               value cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1 wei
                                 gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            call tx.origin with:
                               value eth.balance(this.address) wei
                                 gas 2300 * is_zero(value) wei
                            if cd[(arg4 + 196)]:
                                require ext_code.size(stor4)
                                call stor4.deposit() with:
                                   value cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1 wei
                                     gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(address(cd[(arg4 + 68)]))
                            call address(cd[(arg4 + 68)]).0xa9059cbb with:
                                 gas gas_remaining wei
                                args msg.sender, cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                        else:
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (2 * ceil32(return_data.size)) + 102] = this.address
                            require ext_code.size(sub_3fd82e21Address)
                            staticcall sub_3fd82e21Address.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (2 * ceil32(return_data.size)) + 98] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if stor4 == sub_3fd82e21Address:
                                require ext_code.size(stor4)
                                staticcall stor4.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if ext_call.return_data[0] < cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1:
                                    revert with 0, 17
                                require ext_code.size(stor4)
                                call stor4.0x2e1a7d4d with:
                                     gas gas_remaining wei
                                    args (ext_call.return_data[0] + -cd[(arg4 + 100)] + -(3 * cd[(arg4 + 100)] / 997) - 1)
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                call tx.origin with:
                                   value eth.balance(this.address) wei
                                     gas 2300 * is_zero(value) wei
                                if cd[(arg4 + 196)]:
                                    require ext_code.size(stor4)
                                    call stor4.deposit() with:
                                       value cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1 wei
                                         gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(address(cd[(arg4 + 68)]))
                                call address(cd[(arg4 + 68)]).0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                            else:
                                if sub_ccccbcf7Address != sub_3fd82e21Address:
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 98] = 2
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 130] = sub_3fd82e21Address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 162] = stor4
                                    if 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 194] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 198] = ext_call.return_data[0]
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 230] = 0
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 262] = 160
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 358] = 2
                                    idx = 0
                                    s = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 390
                                    t = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 130
                                    while idx < 2:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 294] = this.address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 326] = block.timestamp + 3600
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 3600, 2, mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 390 len 64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 194 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 194
                                    require return_data.size >= 32
                                    _4976 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28]
                                    require mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 225 < ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + return_data.size + 194
                                    _5052 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]
                                    if mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194] > test266151307():
                                        revert with 0, 65
                                    if ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]) + 1 < 0 or ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]) + 195 > test266151307():
                                        revert with 0, 65
                                    mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]) + 195
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 194] = _5052
                                    require return_data.size >= _4976 + (32 * _5052) + 32
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 226 len 32 * _5052] = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + _4976 + 226 len 32 * _5052]
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(stor4)
                                    staticcall stor4.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7960 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if mem[_7960] < cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1:
                                        revert with 0, 17
                                    require ext_code.size(stor4)
                                    call stor4.0x2e1a7d4d with:
                                         gas gas_remaining wei
                                        args (mem[_7960] + -cd[(arg4 + 100)] + -(3 * cd[(arg4 + 100)] / 997) - 1)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    call tx.origin with:
                                       value eth.balance(this.address) wei
                                         gas 2300 * is_zero(value) wei
                                    if not cd[(arg4 + 196)]:
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        require ext_code.size(address(cd[(arg4 + 68)]))
                                        call address(cd[(arg4 + 68)]).0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _8856 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_8856] == bool(mem[_8856])
                                    else:
                                        require ext_code.size(stor4)
                                        call stor4.deposit() with:
                                           value cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1 wei
                                             gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        require ext_code.size(address(cd[(arg4 + 68)]))
                                        call address(cd[(arg4 + 68)]).0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9080 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_9080] == bool(mem[_9080])
                                else:
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 98] = 3
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 130] = sub_3fd82e21Address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 162] = sub_e36c61f1Address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 194] = stor4
                                    if 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 226] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 230] = ext_call.return_data[0]
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 262] = 0
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 294] = 160
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 390] = 3
                                    idx = 0
                                    s = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 422
                                    t = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 130
                                    while idx < 3:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 326] = this.address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 358] = block.timestamp + 3600
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 3600, 3, mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 422 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 226 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 226
                                    require return_data.size >= 32
                                    _4977 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28]
                                    require mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 257 < ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + return_data.size + 226
                                    _5053 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]
                                    if mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226] > test266151307():
                                        revert with 0, 65
                                    if ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 1 < 0 or ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 227 > test266151307():
                                        revert with 0, 65
                                    mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 227
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 226] = _5053
                                    require return_data.size >= _4977 + (32 * _5053) + 32
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 258 len 32 * _5053] = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + _4977 + 258 len 32 * _5053]
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(stor4)
                                    staticcall stor4.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7961 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if mem[_7961] < cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1:
                                        revert with 0, 17
                                    require ext_code.size(stor4)
                                    call stor4.0x2e1a7d4d with:
                                         gas gas_remaining wei
                                        args (mem[_7961] + -cd[(arg4 + 100)] + -(3 * cd[(arg4 + 100)] / 997) - 1)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    call tx.origin with:
                                       value eth.balance(this.address) wei
                                         gas 2300 * is_zero(value) wei
                                    if not cd[(arg4 + 196)]:
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        require ext_code.size(address(cd[(arg4 + 68)]))
                                        call address(cd[(arg4 + 68)]).0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _8857 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_8857] == bool(mem[_8857])
                                    else:
                                        require ext_code.size(stor4)
                                        call stor4.deposit() with:
                                           value cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1 wei
                                             gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        require ext_code.size(address(cd[(arg4 + 68)]))
                                        call address(cd[(arg4 + 68)]).0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9081 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_9081] == bool(mem[_9081])
                    else:
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + 102] = account
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + 134] = cd[(arg4 + 100)]
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + 166] = sub_3c8a5d8dAddress
                        require ext_code.size(sub_1c1d3e8dAddress)
                        call sub_1c1d3e8dAddress.liquidateBorrow(address arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args account, cd[(arg4 + 100)], sub_3c8a5d8dAddress
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + 98] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + ceil32(return_data.size) + 102] = this.address
                        require ext_code.size(sub_3c8a5d8dAddress)
                        staticcall sub_3c8a5d8dAddress.0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + ceil32(return_data.size) + 98] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (2 * ceil32(return_data.size)) + 102] = ext_call.return_data[0]
                        require ext_code.size(sub_3c8a5d8dAddress)
                        call sub_3c8a5d8dAddress.redeem(uint256 arg1) with:
                             gas gas_remaining wei
                            args ext_call.return_data[0]
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (2 * ceil32(return_data.size)) + 98] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if not sub_3fd82e21Address:
                            require ext_code.size(stor4)
                            call stor4.deposit() with:
                               value cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1 wei
                                 gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            call tx.origin with:
                               value eth.balance(this.address) wei
                                 gas 2300 * is_zero(value) wei
                            if cd[(arg4 + 196)]:
                                require ext_code.size(stor4)
                                call stor4.deposit() with:
                                   value cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1 wei
                                     gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(address(cd[(arg4 + 68)]))
                            call address(cd[(arg4 + 68)]).0xa9059cbb with:
                                 gas gas_remaining wei
                                args msg.sender, cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                        else:
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 102] = this.address
                            require ext_code.size(sub_3fd82e21Address)
                            staticcall sub_3fd82e21Address.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 98] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if stor4 == sub_3fd82e21Address:
                                require ext_code.size(stor4)
                                staticcall stor4.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if ext_call.return_data[0] < cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1:
                                    revert with 0, 17
                                require ext_code.size(stor4)
                                call stor4.0x2e1a7d4d with:
                                     gas gas_remaining wei
                                    args (ext_call.return_data[0] + -cd[(arg4 + 100)] + -(3 * cd[(arg4 + 100)] / 997) - 1)
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                call tx.origin with:
                                   value eth.balance(this.address) wei
                                     gas 2300 * is_zero(value) wei
                                if cd[(arg4 + 196)]:
                                    require ext_code.size(stor4)
                                    call stor4.deposit() with:
                                       value cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1 wei
                                         gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(address(cd[(arg4 + 68)]))
                                call address(cd[(arg4 + 68)]).0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                            else:
                                if sub_ccccbcf7Address != sub_3fd82e21Address:
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 98] = 2
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 130] = sub_3fd82e21Address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 162] = stor4
                                    if 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 194] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 198] = ext_call.return_data[0]
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 230] = 0
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 262] = 160
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 358] = 2
                                    idx = 0
                                    s = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 390
                                    t = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 130
                                    while idx < 2:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 294] = this.address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 326] = block.timestamp + 3600
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 3600, 2, mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 390 len 64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 194 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 194
                                    require return_data.size >= 32
                                    _4974 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28]
                                    require mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 225 < ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + return_data.size + 194
                                    _5050 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]
                                    if mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194] > test266151307():
                                        revert with 0, 65
                                    if ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]) + 1 < 0 or ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]) + 195 > test266151307():
                                        revert with 0, 65
                                    mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]) + 195
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 194] = _5050
                                    require return_data.size >= _4974 + (32 * _5050) + 32
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 226 len 32 * _5050] = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + _4974 + 226 len 32 * _5050]
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(stor4)
                                    staticcall stor4.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7958 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if mem[_7958] < cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1:
                                        revert with 0, 17
                                    require ext_code.size(stor4)
                                    call stor4.0x2e1a7d4d with:
                                         gas gas_remaining wei
                                        args (mem[_7958] + -cd[(arg4 + 100)] + -(3 * cd[(arg4 + 100)] / 997) - 1)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    call tx.origin with:
                                       value eth.balance(this.address) wei
                                         gas 2300 * is_zero(value) wei
                                    if not cd[(arg4 + 196)]:
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        require ext_code.size(address(cd[(arg4 + 68)]))
                                        call address(cd[(arg4 + 68)]).0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _8854 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_8854] == bool(mem[_8854])
                                    else:
                                        require ext_code.size(stor4)
                                        call stor4.deposit() with:
                                           value cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1 wei
                                             gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        require ext_code.size(address(cd[(arg4 + 68)]))
                                        call address(cd[(arg4 + 68)]).0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9078 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_9078] == bool(mem[_9078])
                                else:
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 98] = 3
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 130] = sub_3fd82e21Address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 162] = sub_e36c61f1Address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 194] = stor4
                                    if 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 226] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 230] = ext_call.return_data[0]
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 262] = 0
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 294] = 160
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 390] = 3
                                    idx = 0
                                    s = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 422
                                    t = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 130
                                    while idx < 3:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 326] = this.address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 358] = block.timestamp + 3600
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 3600, 3, mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 422 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 226 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 226
                                    require return_data.size >= 32
                                    _4975 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28]
                                    require mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 257 < ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + return_data.size + 226
                                    _5051 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]
                                    if mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226] > test266151307():
                                        revert with 0, 65
                                    if ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 1 < 0 or ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 227 > test266151307():
                                        revert with 0, 65
                                    mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 227
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 226] = _5051
                                    require return_data.size >= _4975 + (32 * _5051) + 32
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 258 len 32 * _5051] = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + _4975 + 258 len 32 * _5051]
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(stor4)
                                    staticcall stor4.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7959 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if mem[_7959] < cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1:
                                        revert with 0, 17
                                    require ext_code.size(stor4)
                                    call stor4.0x2e1a7d4d with:
                                         gas gas_remaining wei
                                        args (mem[_7959] + -cd[(arg4 + 100)] + -(3 * cd[(arg4 + 100)] / 997) - 1)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    call tx.origin with:
                                       value eth.balance(this.address) wei
                                         gas 2300 * is_zero(value) wei
                                    if not cd[(arg4 + 196)]:
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        require ext_code.size(address(cd[(arg4 + 68)]))
                                        call address(cd[(arg4 + 68)]).0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _8855 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_8855] == bool(mem[_8855])
                                    else:
                                        require ext_code.size(stor4)
                                        call stor4.deposit() with:
                                           value cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1 wei
                                             gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        require ext_code.size(address(cd[(arg4 + 68)]))
                                        call address(cd[(arg4 + 68)]).0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9079 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_9079] == bool(mem[_9079])
        else:
            require ext_code.size(stor4)
            call stor4.0x2e1a7d4d with:
                 gas gas_remaining wei
                args cd[(arg4 + 100)]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if cd[(arg4 + 100)] > 0x5555555555555555555555555555555555555555555555555555555555555555:
                revert with 0, 17
            if 1 > !(3 * cd[(arg4 + 100)] / 997):
                revert with 0, 17
            if cd[(arg4 + 100)] > !((3 * cd[(arg4 + 100)] / 997) + 1):
                revert with 0, 17
            if cd[(arg4 + 164)]:
                if cd[(arg4 + 196)]:
                    if not sub_ccccbcf7Address:
                        require ext_code.size(stor4)
                        call stor4.0x2e1a7d4d with:
                             gas gas_remaining wei
                            args cd[(arg4 + 100)]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + 134] = sub_3c8a5d8dAddress
                        require ext_code.size(sub_1c1d3e8dAddress)
                        call sub_1c1d3e8dAddress.liquidateBorrow(address arg1, address arg2) with:
                           value cd[(arg4 + 100)] wei
                             gas gas_remaining wei
                            args account, sub_3c8a5d8dAddress
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + 102] = this.address
                        require ext_code.size(sub_3c8a5d8dAddress)
                        staticcall sub_3c8a5d8dAddress.0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + 98] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + ceil32(return_data.size) + 102] = ext_call.return_data[0]
                        require ext_code.size(sub_3c8a5d8dAddress)
                        call sub_3c8a5d8dAddress.redeem(uint256 arg1) with:
                             gas gas_remaining wei
                            args ext_call.return_data[0]
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + ceil32(return_data.size) + 98] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if not sub_3fd82e21Address:
                            require ext_code.size(stor4)
                            call stor4.deposit() with:
                               value cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1 wei
                                 gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            call tx.origin with:
                               value eth.balance(this.address) wei
                                 gas 2300 * is_zero(value) wei
                            if cd[(arg4 + 196)]:
                                require ext_code.size(stor4)
                                call stor4.deposit() with:
                                   value cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1 wei
                                     gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(address(cd[(arg4 + 68)]))
                            call address(cd[(arg4 + 68)]).0xa9059cbb with:
                                 gas gas_remaining wei
                                args msg.sender, cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                        else:
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (2 * ceil32(return_data.size)) + 102] = this.address
                            require ext_code.size(sub_3fd82e21Address)
                            staticcall sub_3fd82e21Address.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (2 * ceil32(return_data.size)) + 98] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if stor4 == sub_3fd82e21Address:
                                require ext_code.size(stor4)
                                staticcall stor4.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if ext_call.return_data[0] < cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1:
                                    revert with 0, 17
                                require ext_code.size(stor4)
                                call stor4.0x2e1a7d4d with:
                                     gas gas_remaining wei
                                    args (ext_call.return_data[0] + -cd[(arg4 + 100)] + -(3 * cd[(arg4 + 100)] / 997) - 1)
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                call tx.origin with:
                                   value eth.balance(this.address) wei
                                     gas 2300 * is_zero(value) wei
                                if cd[(arg4 + 196)]:
                                    require ext_code.size(stor4)
                                    call stor4.deposit() with:
                                       value cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1 wei
                                         gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(address(cd[(arg4 + 68)]))
                                call address(cd[(arg4 + 68)]).0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                            else:
                                if sub_ccccbcf7Address != sub_3fd82e21Address:
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 98] = 2
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 130] = sub_3fd82e21Address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 162] = stor4
                                    if 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 194] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 198] = ext_call.return_data[0]
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 230] = 0
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 262] = 160
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 358] = 2
                                    idx = 0
                                    s = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 390
                                    t = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 130
                                    while idx < 2:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 294] = this.address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 326] = block.timestamp + 3600
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 3600, 2, mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 390 len 64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 194 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 194
                                    require return_data.size >= 32
                                    _4980 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28]
                                    require mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 225 < ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + return_data.size + 194
                                    _5056 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]
                                    if mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194] > test266151307():
                                        revert with 0, 65
                                    if ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]) + 1 < 0 or ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]) + 195 > test266151307():
                                        revert with 0, 65
                                    mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]) + 195
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 194] = _5056
                                    require return_data.size >= _4980 + (32 * _5056) + 32
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 226 len 32 * _5056] = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + _4980 + 226 len 32 * _5056]
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(stor4)
                                    staticcall stor4.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7964 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if mem[_7964] < cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1:
                                        revert with 0, 17
                                    require ext_code.size(stor4)
                                    call stor4.0x2e1a7d4d with:
                                         gas gas_remaining wei
                                        args (mem[_7964] + -cd[(arg4 + 100)] + -(3 * cd[(arg4 + 100)] / 997) - 1)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    call tx.origin with:
                                       value eth.balance(this.address) wei
                                         gas 2300 * is_zero(value) wei
                                    if not cd[(arg4 + 196)]:
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        require ext_code.size(address(cd[(arg4 + 68)]))
                                        call address(cd[(arg4 + 68)]).0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _8860 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_8860] == bool(mem[_8860])
                                    else:
                                        require ext_code.size(stor4)
                                        call stor4.deposit() with:
                                           value cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1 wei
                                             gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        require ext_code.size(address(cd[(arg4 + 68)]))
                                        call address(cd[(arg4 + 68)]).0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9084 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_9084] == bool(mem[_9084])
                                else:
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 98] = 3
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 130] = sub_3fd82e21Address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 162] = sub_e36c61f1Address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 194] = stor4
                                    if 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 226] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 230] = ext_call.return_data[0]
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 262] = 0
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 294] = 160
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 390] = 3
                                    idx = 0
                                    s = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 422
                                    t = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 130
                                    while idx < 3:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 326] = this.address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 358] = block.timestamp + 3600
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 3600, 3, mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 422 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 226 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 226
                                    require return_data.size >= 32
                                    _4981 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28]
                                    require mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 257 < ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + return_data.size + 226
                                    _5057 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]
                                    if mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226] > test266151307():
                                        revert with 0, 65
                                    if ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 1 < 0 or ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 227 > test266151307():
                                        revert with 0, 65
                                    mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 227
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 226] = _5057
                                    require return_data.size >= _4981 + (32 * _5057) + 32
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 258 len 32 * _5057] = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + _4981 + 258 len 32 * _5057]
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(stor4)
                                    staticcall stor4.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7965 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if mem[_7965] < cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1:
                                        revert with 0, 17
                                    require ext_code.size(stor4)
                                    call stor4.0x2e1a7d4d with:
                                         gas gas_remaining wei
                                        args (mem[_7965] + -cd[(arg4 + 100)] + -(3 * cd[(arg4 + 100)] / 997) - 1)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    call tx.origin with:
                                       value eth.balance(this.address) wei
                                         gas 2300 * is_zero(value) wei
                                    if not cd[(arg4 + 196)]:
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        require ext_code.size(address(cd[(arg4 + 68)]))
                                        call address(cd[(arg4 + 68)]).0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _8861 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_8861] == bool(mem[_8861])
                                    else:
                                        require ext_code.size(stor4)
                                        call stor4.deposit() with:
                                           value cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1 wei
                                             gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        require ext_code.size(address(cd[(arg4 + 68)]))
                                        call address(cd[(arg4 + 68)]).0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9085 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_9085] == bool(mem[_9085])
                    else:
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + 102] = account
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + 134] = cd[(arg4 + 100)]
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + 166] = sub_3c8a5d8dAddress
                        require ext_code.size(sub_1c1d3e8dAddress)
                        call sub_1c1d3e8dAddress.liquidateBorrow(address arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args account, cd[(arg4 + 100)], sub_3c8a5d8dAddress
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + 98] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + ceil32(return_data.size) + 102] = this.address
                        require ext_code.size(sub_3c8a5d8dAddress)
                        staticcall sub_3c8a5d8dAddress.0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + ceil32(return_data.size) + 98] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (2 * ceil32(return_data.size)) + 102] = ext_call.return_data[0]
                        require ext_code.size(sub_3c8a5d8dAddress)
                        call sub_3c8a5d8dAddress.redeem(uint256 arg1) with:
                             gas gas_remaining wei
                            args ext_call.return_data[0]
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (2 * ceil32(return_data.size)) + 98] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if not sub_3fd82e21Address:
                            require ext_code.size(stor4)
                            call stor4.deposit() with:
                               value cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1 wei
                                 gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            call tx.origin with:
                               value eth.balance(this.address) wei
                                 gas 2300 * is_zero(value) wei
                            if cd[(arg4 + 196)]:
                                require ext_code.size(stor4)
                                call stor4.deposit() with:
                                   value cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1 wei
                                     gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(address(cd[(arg4 + 68)]))
                            call address(cd[(arg4 + 68)]).0xa9059cbb with:
                                 gas gas_remaining wei
                                args msg.sender, cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                        else:
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 102] = this.address
                            require ext_code.size(sub_3fd82e21Address)
                            staticcall sub_3fd82e21Address.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 98] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if stor4 == sub_3fd82e21Address:
                                require ext_code.size(stor4)
                                staticcall stor4.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if ext_call.return_data[0] < cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1:
                                    revert with 0, 17
                                require ext_code.size(stor4)
                                call stor4.0x2e1a7d4d with:
                                     gas gas_remaining wei
                                    args (ext_call.return_data[0] + -cd[(arg4 + 100)] + -(3 * cd[(arg4 + 100)] / 997) - 1)
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                call tx.origin with:
                                   value eth.balance(this.address) wei
                                     gas 2300 * is_zero(value) wei
                                if cd[(arg4 + 196)]:
                                    require ext_code.size(stor4)
                                    call stor4.deposit() with:
                                       value cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1 wei
                                         gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(address(cd[(arg4 + 68)]))
                                call address(cd[(arg4 + 68)]).0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                            else:
                                if sub_ccccbcf7Address != sub_3fd82e21Address:
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 98] = 2
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 130] = sub_3fd82e21Address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 162] = stor4
                                    if 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 194] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 198] = ext_call.return_data[0]
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 230] = 0
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 262] = 160
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 358] = 2
                                    idx = 0
                                    s = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 390
                                    t = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 130
                                    while idx < 2:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 294] = this.address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 326] = block.timestamp + 3600
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 3600, 2, mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 390 len 64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 194 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 194
                                    require return_data.size >= 32
                                    _4978 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28]
                                    require mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 225 < ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + return_data.size + 194
                                    _5054 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]
                                    if mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194] > test266151307():
                                        revert with 0, 65
                                    if ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]) + 1 < 0 or ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]) + 195 > test266151307():
                                        revert with 0, 65
                                    mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]) + 195
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 194] = _5054
                                    require return_data.size >= _4978 + (32 * _5054) + 32
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 226 len 32 * _5054] = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + _4978 + 226 len 32 * _5054]
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(stor4)
                                    staticcall stor4.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7962 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if mem[_7962] < cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1:
                                        revert with 0, 17
                                    require ext_code.size(stor4)
                                    call stor4.0x2e1a7d4d with:
                                         gas gas_remaining wei
                                        args (mem[_7962] + -cd[(arg4 + 100)] + -(3 * cd[(arg4 + 100)] / 997) - 1)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    call tx.origin with:
                                       value eth.balance(this.address) wei
                                         gas 2300 * is_zero(value) wei
                                    if not cd[(arg4 + 196)]:
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        require ext_code.size(address(cd[(arg4 + 68)]))
                                        call address(cd[(arg4 + 68)]).0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _8858 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_8858] == bool(mem[_8858])
                                    else:
                                        require ext_code.size(stor4)
                                        call stor4.deposit() with:
                                           value cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1 wei
                                             gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        require ext_code.size(address(cd[(arg4 + 68)]))
                                        call address(cd[(arg4 + 68)]).0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9082 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_9082] == bool(mem[_9082])
                                else:
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 98] = 3
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 130] = sub_3fd82e21Address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 162] = sub_e36c61f1Address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 194] = stor4
                                    if 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 226] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 230] = ext_call.return_data[0]
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 262] = 0
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 294] = 160
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 390] = 3
                                    idx = 0
                                    s = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 422
                                    t = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 130
                                    while idx < 3:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 326] = this.address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 358] = block.timestamp + 3600
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 3600, 3, mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 422 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 226 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 226
                                    require return_data.size >= 32
                                    _4979 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28]
                                    require mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 257 < ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + return_data.size + 226
                                    _5055 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]
                                    if mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226] > test266151307():
                                        revert with 0, 65
                                    if ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 1 < 0 or ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 227 > test266151307():
                                        revert with 0, 65
                                    mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 227
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 226] = _5055
                                    require return_data.size >= _4979 + (32 * _5055) + 32
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 258 len 32 * _5055] = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + _4979 + 258 len 32 * _5055]
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(stor4)
                                    staticcall stor4.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7963 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if mem[_7963] < cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1:
                                        revert with 0, 17
                                    require ext_code.size(stor4)
                                    call stor4.0x2e1a7d4d with:
                                         gas gas_remaining wei
                                        args (mem[_7963] + -cd[(arg4 + 100)] + -(3 * cd[(arg4 + 100)] / 997) - 1)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    call tx.origin with:
                                       value eth.balance(this.address) wei
                                         gas 2300 * is_zero(value) wei
                                    if not cd[(arg4 + 196)]:
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        require ext_code.size(address(cd[(arg4 + 68)]))
                                        call address(cd[(arg4 + 68)]).0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _8859 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_8859] == bool(mem[_8859])
                                    else:
                                        require ext_code.size(stor4)
                                        call stor4.deposit() with:
                                           value cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1 wei
                                             gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        require ext_code.size(address(cd[(arg4 + 68)]))
                                        call address(cd[(arg4 + 68)]).0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9083 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_9083] == bool(mem[_9083])
                else:
                    if not sub_ccccbcf7Address:
                        require ext_code.size(stor4)
                        call stor4.0x2e1a7d4d with:
                             gas gas_remaining wei
                            args cd[(arg4 + 100)]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + 134] = sub_3c8a5d8dAddress
                        require ext_code.size(sub_1c1d3e8dAddress)
                        call sub_1c1d3e8dAddress.liquidateBorrow(address arg1, address arg2) with:
                           value cd[(arg4 + 100)] wei
                             gas gas_remaining wei
                            args account, sub_3c8a5d8dAddress
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + 102] = this.address
                        require ext_code.size(sub_3c8a5d8dAddress)
                        staticcall sub_3c8a5d8dAddress.0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + 98] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + ceil32(return_data.size) + 102] = ext_call.return_data[0]
                        require ext_code.size(sub_3c8a5d8dAddress)
                        call sub_3c8a5d8dAddress.redeem(uint256 arg1) with:
                             gas gas_remaining wei
                            args ext_call.return_data[0]
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + ceil32(return_data.size) + 98] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if not sub_3fd82e21Address:
                            require ext_code.size(stor4)
                            call stor4.deposit() with:
                               value cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1 wei
                                 gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            call tx.origin with:
                               value eth.balance(this.address) wei
                                 gas 2300 * is_zero(value) wei
                            if cd[(arg4 + 196)]:
                                require ext_code.size(stor4)
                                call stor4.deposit() with:
                                   value cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1 wei
                                     gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(address(cd[(arg4 + 68)]))
                            call address(cd[(arg4 + 68)]).0xa9059cbb with:
                                 gas gas_remaining wei
                                args msg.sender, cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                        else:
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (2 * ceil32(return_data.size)) + 102] = this.address
                            require ext_code.size(sub_3fd82e21Address)
                            staticcall sub_3fd82e21Address.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (2 * ceil32(return_data.size)) + 98] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if stor4 == sub_3fd82e21Address:
                                require ext_code.size(stor4)
                                staticcall stor4.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if ext_call.return_data[0] < cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1:
                                    revert with 0, 17
                                require ext_code.size(stor4)
                                call stor4.0x2e1a7d4d with:
                                     gas gas_remaining wei
                                    args (ext_call.return_data[0] + -cd[(arg4 + 100)] + -(3 * cd[(arg4 + 100)] / 997) - 1)
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                call tx.origin with:
                                   value eth.balance(this.address) wei
                                     gas 2300 * is_zero(value) wei
                                if cd[(arg4 + 196)]:
                                    require ext_code.size(stor4)
                                    call stor4.deposit() with:
                                       value cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1 wei
                                         gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(address(cd[(arg4 + 68)]))
                                call address(cd[(arg4 + 68)]).0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                            else:
                                if sub_ccccbcf7Address != sub_3fd82e21Address:
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 98] = 2
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 130] = sub_3fd82e21Address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 162] = stor4
                                    if 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 194] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 198] = ext_call.return_data[0]
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 230] = 0
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 262] = 160
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 358] = 2
                                    idx = 0
                                    s = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 390
                                    t = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 130
                                    while idx < 2:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 294] = this.address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 326] = block.timestamp + 3600
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 3600, 2, mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 390 len 64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 194 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 194
                                    require return_data.size >= 32
                                    _4984 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28]
                                    require mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 225 < ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + return_data.size + 194
                                    _5060 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]
                                    if mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194] > test266151307():
                                        revert with 0, 65
                                    if ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]) + 1 < 0 or ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]) + 195 > test266151307():
                                        revert with 0, 65
                                    mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]) + 195
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 194] = _5060
                                    require return_data.size >= _4984 + (32 * _5060) + 32
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 226 len 32 * _5060] = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + _4984 + 226 len 32 * _5060]
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(stor4)
                                    staticcall stor4.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7968 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if mem[_7968] < cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1:
                                        revert with 0, 17
                                    require ext_code.size(stor4)
                                    call stor4.0x2e1a7d4d with:
                                         gas gas_remaining wei
                                        args (mem[_7968] + -cd[(arg4 + 100)] + -(3 * cd[(arg4 + 100)] / 997) - 1)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    call tx.origin with:
                                       value eth.balance(this.address) wei
                                         gas 2300 * is_zero(value) wei
                                    if not cd[(arg4 + 196)]:
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        require ext_code.size(address(cd[(arg4 + 68)]))
                                        call address(cd[(arg4 + 68)]).0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _8864 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_8864] == bool(mem[_8864])
                                    else:
                                        require ext_code.size(stor4)
                                        call stor4.deposit() with:
                                           value cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1 wei
                                             gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        require ext_code.size(address(cd[(arg4 + 68)]))
                                        call address(cd[(arg4 + 68)]).0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9088 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_9088] == bool(mem[_9088])
                                else:
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 98] = 3
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 130] = sub_3fd82e21Address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 162] = sub_e36c61f1Address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 194] = stor4
                                    if 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 226] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 230] = ext_call.return_data[0]
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 262] = 0
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 294] = 160
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 390] = 3
                                    idx = 0
                                    s = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 422
                                    t = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 130
                                    while idx < 3:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 326] = this.address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 358] = block.timestamp + 3600
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 3600, 3, mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 422 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 226 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 226
                                    require return_data.size >= 32
                                    _4985 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28]
                                    require mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 257 < ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + return_data.size + 226
                                    _5061 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]
                                    if mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226] > test266151307():
                                        revert with 0, 65
                                    if ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 1 < 0 or ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 227 > test266151307():
                                        revert with 0, 65
                                    mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 227
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 226] = _5061
                                    require return_data.size >= _4985 + (32 * _5061) + 32
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 258 len 32 * _5061] = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + _4985 + 258 len 32 * _5061]
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(stor4)
                                    staticcall stor4.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7969 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if mem[_7969] < cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1:
                                        revert with 0, 17
                                    require ext_code.size(stor4)
                                    call stor4.0x2e1a7d4d with:
                                         gas gas_remaining wei
                                        args (mem[_7969] + -cd[(arg4 + 100)] + -(3 * cd[(arg4 + 100)] / 997) - 1)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    call tx.origin with:
                                       value eth.balance(this.address) wei
                                         gas 2300 * is_zero(value) wei
                                    if not cd[(arg4 + 196)]:
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        require ext_code.size(address(cd[(arg4 + 68)]))
                                        call address(cd[(arg4 + 68)]).0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _8865 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_8865] == bool(mem[_8865])
                                    else:
                                        require ext_code.size(stor4)
                                        call stor4.deposit() with:
                                           value cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1 wei
                                             gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        require ext_code.size(address(cd[(arg4 + 68)]))
                                        call address(cd[(arg4 + 68)]).0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9089 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_9089] == bool(mem[_9089])
                    else:
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + 102] = account
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + 134] = cd[(arg4 + 100)]
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + 166] = sub_3c8a5d8dAddress
                        require ext_code.size(sub_1c1d3e8dAddress)
                        call sub_1c1d3e8dAddress.liquidateBorrow(address arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args account, cd[(arg4 + 100)], sub_3c8a5d8dAddress
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + 98] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + ceil32(return_data.size) + 102] = this.address
                        require ext_code.size(sub_3c8a5d8dAddress)
                        staticcall sub_3c8a5d8dAddress.0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + ceil32(return_data.size) + 98] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (2 * ceil32(return_data.size)) + 102] = ext_call.return_data[0]
                        require ext_code.size(sub_3c8a5d8dAddress)
                        call sub_3c8a5d8dAddress.redeem(uint256 arg1) with:
                             gas gas_remaining wei
                            args ext_call.return_data[0]
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (2 * ceil32(return_data.size)) + 98] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if not sub_3fd82e21Address:
                            require ext_code.size(stor4)
                            call stor4.deposit() with:
                               value cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1 wei
                                 gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            call tx.origin with:
                               value eth.balance(this.address) wei
                                 gas 2300 * is_zero(value) wei
                            if cd[(arg4 + 196)]:
                                require ext_code.size(stor4)
                                call stor4.deposit() with:
                                   value cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1 wei
                                     gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(address(cd[(arg4 + 68)]))
                            call address(cd[(arg4 + 68)]).0xa9059cbb with:
                                 gas gas_remaining wei
                                args msg.sender, cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                        else:
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 102] = this.address
                            require ext_code.size(sub_3fd82e21Address)
                            staticcall sub_3fd82e21Address.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 98] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if stor4 == sub_3fd82e21Address:
                                require ext_code.size(stor4)
                                staticcall stor4.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if ext_call.return_data[0] < cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1:
                                    revert with 0, 17
                                require ext_code.size(stor4)
                                call stor4.0x2e1a7d4d with:
                                     gas gas_remaining wei
                                    args (ext_call.return_data[0] + -cd[(arg4 + 100)] + -(3 * cd[(arg4 + 100)] / 997) - 1)
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                call tx.origin with:
                                   value eth.balance(this.address) wei
                                     gas 2300 * is_zero(value) wei
                                if cd[(arg4 + 196)]:
                                    require ext_code.size(stor4)
                                    call stor4.deposit() with:
                                       value cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1 wei
                                         gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(address(cd[(arg4 + 68)]))
                                call address(cd[(arg4 + 68)]).0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                            else:
                                if sub_ccccbcf7Address != sub_3fd82e21Address:
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 98] = 2
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 130] = sub_3fd82e21Address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 162] = stor4
                                    if 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 194] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 198] = ext_call.return_data[0]
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 230] = 0
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 262] = 160
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 358] = 2
                                    idx = 0
                                    s = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 390
                                    t = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 130
                                    while idx < 2:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 294] = this.address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 326] = block.timestamp + 3600
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 3600, 2, mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 390 len 64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 194 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 194
                                    require return_data.size >= 32
                                    _4982 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28]
                                    require mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 225 < ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + return_data.size + 194
                                    _5058 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]
                                    if mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194] > test266151307():
                                        revert with 0, 65
                                    if ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]) + 1 < 0 or ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]) + 195 > test266151307():
                                        revert with 0, 65
                                    mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]) + 195
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 194] = _5058
                                    require return_data.size >= _4982 + (32 * _5058) + 32
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 226 len 32 * _5058] = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + _4982 + 226 len 32 * _5058]
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(stor4)
                                    staticcall stor4.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7966 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if mem[_7966] < cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1:
                                        revert with 0, 17
                                    require ext_code.size(stor4)
                                    call stor4.0x2e1a7d4d with:
                                         gas gas_remaining wei
                                        args (mem[_7966] + -cd[(arg4 + 100)] + -(3 * cd[(arg4 + 100)] / 997) - 1)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    call tx.origin with:
                                       value eth.balance(this.address) wei
                                         gas 2300 * is_zero(value) wei
                                    if not cd[(arg4 + 196)]:
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        require ext_code.size(address(cd[(arg4 + 68)]))
                                        call address(cd[(arg4 + 68)]).0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _8862 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_8862] == bool(mem[_8862])
                                    else:
                                        require ext_code.size(stor4)
                                        call stor4.deposit() with:
                                           value cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1 wei
                                             gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        require ext_code.size(address(cd[(arg4 + 68)]))
                                        call address(cd[(arg4 + 68)]).0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9086 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_9086] == bool(mem[_9086])
                                else:
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 98] = 3
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 130] = sub_3fd82e21Address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 162] = sub_e36c61f1Address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 194] = stor4
                                    if 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 226] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 230] = ext_call.return_data[0]
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 262] = 0
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 294] = 160
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 390] = 3
                                    idx = 0
                                    s = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 422
                                    t = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 130
                                    while idx < 3:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 326] = this.address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 358] = block.timestamp + 3600
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 3600, 3, mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 422 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 226 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 226
                                    require return_data.size >= 32
                                    _4983 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28]
                                    require mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 257 < ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + return_data.size + 226
                                    _5059 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]
                                    if mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226] > test266151307():
                                        revert with 0, 65
                                    if ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 1 < 0 or ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 227 > test266151307():
                                        revert with 0, 65
                                    mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 227
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 226] = _5059
                                    require return_data.size >= _4983 + (32 * _5059) + 32
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 258 len 32 * _5059] = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + _4983 + 258 len 32 * _5059]
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(stor4)
                                    staticcall stor4.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7967 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if mem[_7967] < cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1:
                                        revert with 0, 17
                                    require ext_code.size(stor4)
                                    call stor4.0x2e1a7d4d with:
                                         gas gas_remaining wei
                                        args (mem[_7967] + -cd[(arg4 + 100)] + -(3 * cd[(arg4 + 100)] / 997) - 1)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    call tx.origin with:
                                       value eth.balance(this.address) wei
                                         gas 2300 * is_zero(value) wei
                                    if not cd[(arg4 + 196)]:
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        require ext_code.size(address(cd[(arg4 + 68)]))
                                        call address(cd[(arg4 + 68)]).0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _8863 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_8863] == bool(mem[_8863])
                                    else:
                                        require ext_code.size(stor4)
                                        call stor4.deposit() with:
                                           value cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1 wei
                                             gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        require ext_code.size(address(cd[(arg4 + 68)]))
                                        call address(cd[(arg4 + 68)]).0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9087 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_9087] == bool(mem[_9087])
            else:
                if cd[(arg4 + 196)]:
                    if not sub_ccccbcf7Address:
                        require ext_code.size(stor4)
                        call stor4.0x2e1a7d4d with:
                             gas gas_remaining wei
                            args cd[(arg4 + 100)]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + 134] = sub_3c8a5d8dAddress
                        require ext_code.size(sub_1c1d3e8dAddress)
                        call sub_1c1d3e8dAddress.liquidateBorrow(address arg1, address arg2) with:
                           value cd[(arg4 + 100)] wei
                             gas gas_remaining wei
                            args account, sub_3c8a5d8dAddress
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + 102] = this.address
                        require ext_code.size(sub_3c8a5d8dAddress)
                        staticcall sub_3c8a5d8dAddress.0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + 98] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + ceil32(return_data.size) + 102] = ext_call.return_data[0]
                        require ext_code.size(sub_3c8a5d8dAddress)
                        call sub_3c8a5d8dAddress.redeem(uint256 arg1) with:
                             gas gas_remaining wei
                            args ext_call.return_data[0]
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + ceil32(return_data.size) + 98] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if not sub_3fd82e21Address:
                            require ext_code.size(stor4)
                            call stor4.deposit() with:
                               value cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1 wei
                                 gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            call tx.origin with:
                               value eth.balance(this.address) wei
                                 gas 2300 * is_zero(value) wei
                            if cd[(arg4 + 196)]:
                                require ext_code.size(stor4)
                                call stor4.deposit() with:
                                   value cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1 wei
                                     gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(address(cd[(arg4 + 68)]))
                            call address(cd[(arg4 + 68)]).0xa9059cbb with:
                                 gas gas_remaining wei
                                args msg.sender, cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                        else:
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (2 * ceil32(return_data.size)) + 102] = this.address
                            require ext_code.size(sub_3fd82e21Address)
                            staticcall sub_3fd82e21Address.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (2 * ceil32(return_data.size)) + 98] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if stor4 == sub_3fd82e21Address:
                                require ext_code.size(stor4)
                                staticcall stor4.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if ext_call.return_data[0] < cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1:
                                    revert with 0, 17
                                require ext_code.size(stor4)
                                call stor4.0x2e1a7d4d with:
                                     gas gas_remaining wei
                                    args (ext_call.return_data[0] + -cd[(arg4 + 100)] + -(3 * cd[(arg4 + 100)] / 997) - 1)
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                call tx.origin with:
                                   value eth.balance(this.address) wei
                                     gas 2300 * is_zero(value) wei
                                if cd[(arg4 + 196)]:
                                    require ext_code.size(stor4)
                                    call stor4.deposit() with:
                                       value cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1 wei
                                         gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(address(cd[(arg4 + 68)]))
                                call address(cd[(arg4 + 68)]).0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                            else:
                                if sub_ccccbcf7Address != sub_3fd82e21Address:
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 98] = 2
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 130] = sub_3fd82e21Address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 162] = stor4
                                    if 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 194] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 198] = ext_call.return_data[0]
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 230] = 0
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 262] = 160
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 358] = 2
                                    idx = 0
                                    s = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 390
                                    t = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 130
                                    while idx < 2:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 294] = this.address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 326] = block.timestamp + 3600
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 3600, 2, mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 390 len 64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 194 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 194
                                    require return_data.size >= 32
                                    _4988 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28]
                                    require mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 225 < ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + return_data.size + 194
                                    _5064 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]
                                    if mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194] > test266151307():
                                        revert with 0, 65
                                    if ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]) + 1 < 0 or ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]) + 195 > test266151307():
                                        revert with 0, 65
                                    mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]) + 195
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 194] = _5064
                                    require return_data.size >= _4988 + (32 * _5064) + 32
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 226 len 32 * _5064] = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + _4988 + 226 len 32 * _5064]
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(stor4)
                                    staticcall stor4.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7972 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if mem[_7972] < cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1:
                                        revert with 0, 17
                                    require ext_code.size(stor4)
                                    call stor4.0x2e1a7d4d with:
                                         gas gas_remaining wei
                                        args (mem[_7972] + -cd[(arg4 + 100)] + -(3 * cd[(arg4 + 100)] / 997) - 1)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    call tx.origin with:
                                       value eth.balance(this.address) wei
                                         gas 2300 * is_zero(value) wei
                                    if not cd[(arg4 + 196)]:
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        require ext_code.size(address(cd[(arg4 + 68)]))
                                        call address(cd[(arg4 + 68)]).0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _8868 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_8868] == bool(mem[_8868])
                                    else:
                                        require ext_code.size(stor4)
                                        call stor4.deposit() with:
                                           value cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1 wei
                                             gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        require ext_code.size(address(cd[(arg4 + 68)]))
                                        call address(cd[(arg4 + 68)]).0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9092 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_9092] == bool(mem[_9092])
                                else:
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 98] = 3
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 130] = sub_3fd82e21Address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 162] = sub_e36c61f1Address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 194] = stor4
                                    if 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 226] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 230] = ext_call.return_data[0]
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 262] = 0
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 294] = 160
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 390] = 3
                                    idx = 0
                                    s = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 422
                                    t = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 130
                                    while idx < 3:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 326] = this.address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 358] = block.timestamp + 3600
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 3600, 3, mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 422 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 226 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 226
                                    require return_data.size >= 32
                                    _4989 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28]
                                    require mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 257 < ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + return_data.size + 226
                                    _5065 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]
                                    if mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226] > test266151307():
                                        revert with 0, 65
                                    if ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 1 < 0 or ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 227 > test266151307():
                                        revert with 0, 65
                                    mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 227
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 226] = _5065
                                    require return_data.size >= _4989 + (32 * _5065) + 32
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 258 len 32 * _5065] = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + _4989 + 258 len 32 * _5065]
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(stor4)
                                    staticcall stor4.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7973 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if mem[_7973] < cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1:
                                        revert with 0, 17
                                    require ext_code.size(stor4)
                                    call stor4.0x2e1a7d4d with:
                                         gas gas_remaining wei
                                        args (mem[_7973] + -cd[(arg4 + 100)] + -(3 * cd[(arg4 + 100)] / 997) - 1)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    call tx.origin with:
                                       value eth.balance(this.address) wei
                                         gas 2300 * is_zero(value) wei
                                    if not cd[(arg4 + 196)]:
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        require ext_code.size(address(cd[(arg4 + 68)]))
                                        call address(cd[(arg4 + 68)]).0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _8869 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_8869] == bool(mem[_8869])
                                    else:
                                        require ext_code.size(stor4)
                                        call stor4.deposit() with:
                                           value cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1 wei
                                             gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        require ext_code.size(address(cd[(arg4 + 68)]))
                                        call address(cd[(arg4 + 68)]).0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9093 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_9093] == bool(mem[_9093])
                    else:
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + 102] = account
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + 134] = cd[(arg4 + 100)]
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + 166] = sub_3c8a5d8dAddress
                        require ext_code.size(sub_1c1d3e8dAddress)
                        call sub_1c1d3e8dAddress.liquidateBorrow(address arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args account, cd[(arg4 + 100)], sub_3c8a5d8dAddress
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + 98] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + ceil32(return_data.size) + 102] = this.address
                        require ext_code.size(sub_3c8a5d8dAddress)
                        staticcall sub_3c8a5d8dAddress.0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + ceil32(return_data.size) + 98] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (2 * ceil32(return_data.size)) + 102] = ext_call.return_data[0]
                        require ext_code.size(sub_3c8a5d8dAddress)
                        call sub_3c8a5d8dAddress.redeem(uint256 arg1) with:
                             gas gas_remaining wei
                            args ext_call.return_data[0]
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (2 * ceil32(return_data.size)) + 98] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if not sub_3fd82e21Address:
                            require ext_code.size(stor4)
                            call stor4.deposit() with:
                               value cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1 wei
                                 gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            call tx.origin with:
                               value eth.balance(this.address) wei
                                 gas 2300 * is_zero(value) wei
                            if cd[(arg4 + 196)]:
                                require ext_code.size(stor4)
                                call stor4.deposit() with:
                                   value cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1 wei
                                     gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(address(cd[(arg4 + 68)]))
                            call address(cd[(arg4 + 68)]).0xa9059cbb with:
                                 gas gas_remaining wei
                                args msg.sender, cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                        else:
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 102] = this.address
                            require ext_code.size(sub_3fd82e21Address)
                            staticcall sub_3fd82e21Address.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 98] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if stor4 == sub_3fd82e21Address:
                                require ext_code.size(stor4)
                                staticcall stor4.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if ext_call.return_data[0] < cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1:
                                    revert with 0, 17
                                require ext_code.size(stor4)
                                call stor4.0x2e1a7d4d with:
                                     gas gas_remaining wei
                                    args (ext_call.return_data[0] + -cd[(arg4 + 100)] + -(3 * cd[(arg4 + 100)] / 997) - 1)
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                call tx.origin with:
                                   value eth.balance(this.address) wei
                                     gas 2300 * is_zero(value) wei
                                if cd[(arg4 + 196)]:
                                    require ext_code.size(stor4)
                                    call stor4.deposit() with:
                                       value cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1 wei
                                         gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(address(cd[(arg4 + 68)]))
                                call address(cd[(arg4 + 68)]).0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                            else:
                                if sub_ccccbcf7Address != sub_3fd82e21Address:
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 98] = 2
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 130] = sub_3fd82e21Address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 162] = stor4
                                    if 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 194] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 198] = ext_call.return_data[0]
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 230] = 0
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 262] = 160
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 358] = 2
                                    idx = 0
                                    s = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 390
                                    t = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 130
                                    while idx < 2:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 294] = this.address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 326] = block.timestamp + 3600
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 3600, 2, mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 390 len 64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 194 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 194
                                    require return_data.size >= 32
                                    _4986 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28]
                                    require mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 225 < ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + return_data.size + 194
                                    _5062 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]
                                    if mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194] > test266151307():
                                        revert with 0, 65
                                    if ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]) + 1 < 0 or ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]) + 195 > test266151307():
                                        revert with 0, 65
                                    mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]) + 195
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 194] = _5062
                                    require return_data.size >= _4986 + (32 * _5062) + 32
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 226 len 32 * _5062] = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + _4986 + 226 len 32 * _5062]
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(stor4)
                                    staticcall stor4.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7970 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if mem[_7970] < cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1:
                                        revert with 0, 17
                                    require ext_code.size(stor4)
                                    call stor4.0x2e1a7d4d with:
                                         gas gas_remaining wei
                                        args (mem[_7970] + -cd[(arg4 + 100)] + -(3 * cd[(arg4 + 100)] / 997) - 1)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    call tx.origin with:
                                       value eth.balance(this.address) wei
                                         gas 2300 * is_zero(value) wei
                                    if not cd[(arg4 + 196)]:
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        require ext_code.size(address(cd[(arg4 + 68)]))
                                        call address(cd[(arg4 + 68)]).0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _8866 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_8866] == bool(mem[_8866])
                                    else:
                                        require ext_code.size(stor4)
                                        call stor4.deposit() with:
                                           value cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1 wei
                                             gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        require ext_code.size(address(cd[(arg4 + 68)]))
                                        call address(cd[(arg4 + 68)]).0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9090 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_9090] == bool(mem[_9090])
                                else:
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 98] = 3
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 130] = sub_3fd82e21Address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 162] = sub_e36c61f1Address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 194] = stor4
                                    if 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 226] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 230] = ext_call.return_data[0]
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 262] = 0
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 294] = 160
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 390] = 3
                                    idx = 0
                                    s = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 422
                                    t = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 130
                                    while idx < 3:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 326] = this.address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 358] = block.timestamp + 3600
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 3600, 3, mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 422 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 226 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 226
                                    require return_data.size >= 32
                                    _4987 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28]
                                    require mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 257 < ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + return_data.size + 226
                                    _5063 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]
                                    if mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226] > test266151307():
                                        revert with 0, 65
                                    if ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 1 < 0 or ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 227 > test266151307():
                                        revert with 0, 65
                                    mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 227
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 226] = _5063
                                    require return_data.size >= _4987 + (32 * _5063) + 32
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 258 len 32 * _5063] = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + _4987 + 258 len 32 * _5063]
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(stor4)
                                    staticcall stor4.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7971 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if mem[_7971] < cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1:
                                        revert with 0, 17
                                    require ext_code.size(stor4)
                                    call stor4.0x2e1a7d4d with:
                                         gas gas_remaining wei
                                        args (mem[_7971] + -cd[(arg4 + 100)] + -(3 * cd[(arg4 + 100)] / 997) - 1)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    call tx.origin with:
                                       value eth.balance(this.address) wei
                                         gas 2300 * is_zero(value) wei
                                    if not cd[(arg4 + 196)]:
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        require ext_code.size(address(cd[(arg4 + 68)]))
                                        call address(cd[(arg4 + 68)]).0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _8867 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_8867] == bool(mem[_8867])
                                    else:
                                        require ext_code.size(stor4)
                                        call stor4.deposit() with:
                                           value cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1 wei
                                             gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        require ext_code.size(address(cd[(arg4 + 68)]))
                                        call address(cd[(arg4 + 68)]).0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9091 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_9091] == bool(mem[_9091])
                else:
                    if not sub_ccccbcf7Address:
                        require ext_code.size(stor4)
                        call stor4.0x2e1a7d4d with:
                             gas gas_remaining wei
                            args cd[(arg4 + 100)]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + 134] = sub_3c8a5d8dAddress
                        require ext_code.size(sub_1c1d3e8dAddress)
                        call sub_1c1d3e8dAddress.liquidateBorrow(address arg1, address arg2) with:
                           value cd[(arg4 + 100)] wei
                             gas gas_remaining wei
                            args account, sub_3c8a5d8dAddress
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + 102] = this.address
                        require ext_code.size(sub_3c8a5d8dAddress)
                        staticcall sub_3c8a5d8dAddress.0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + 98] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + ceil32(return_data.size) + 102] = ext_call.return_data[0]
                        require ext_code.size(sub_3c8a5d8dAddress)
                        call sub_3c8a5d8dAddress.redeem(uint256 arg1) with:
                             gas gas_remaining wei
                            args ext_call.return_data[0]
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + ceil32(return_data.size) + 98] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if not sub_3fd82e21Address:
                            require ext_code.size(stor4)
                            call stor4.deposit() with:
                               value cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1 wei
                                 gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            call tx.origin with:
                               value eth.balance(this.address) wei
                                 gas 2300 * is_zero(value) wei
                            if cd[(arg4 + 196)]:
                                require ext_code.size(stor4)
                                call stor4.deposit() with:
                                   value cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1 wei
                                     gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(address(cd[(arg4 + 68)]))
                            call address(cd[(arg4 + 68)]).0xa9059cbb with:
                                 gas gas_remaining wei
                                args msg.sender, cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                        else:
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (2 * ceil32(return_data.size)) + 102] = this.address
                            require ext_code.size(sub_3fd82e21Address)
                            staticcall sub_3fd82e21Address.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (2 * ceil32(return_data.size)) + 98] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if stor4 == sub_3fd82e21Address:
                                require ext_code.size(stor4)
                                staticcall stor4.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if ext_call.return_data[0] < cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1:
                                    revert with 0, 17
                                require ext_code.size(stor4)
                                call stor4.0x2e1a7d4d with:
                                     gas gas_remaining wei
                                    args (ext_call.return_data[0] + -cd[(arg4 + 100)] + -(3 * cd[(arg4 + 100)] / 997) - 1)
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                call tx.origin with:
                                   value eth.balance(this.address) wei
                                     gas 2300 * is_zero(value) wei
                                if cd[(arg4 + 196)]:
                                    require ext_code.size(stor4)
                                    call stor4.deposit() with:
                                       value cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1 wei
                                         gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(address(cd[(arg4 + 68)]))
                                call address(cd[(arg4 + 68)]).0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                            else:
                                if sub_ccccbcf7Address != sub_3fd82e21Address:
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 98] = 2
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 130] = sub_3fd82e21Address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 162] = stor4
                                    if 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 194] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 198] = ext_call.return_data[0]
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 230] = 0
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 262] = 160
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 358] = 2
                                    idx = 0
                                    s = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 390
                                    t = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 130
                                    while idx < 2:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 294] = this.address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 326] = block.timestamp + 3600
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 3600, 2, mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 390 len 64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 194 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 194
                                    require return_data.size >= 32
                                    _4992 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28]
                                    require mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 225 < ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + return_data.size + 194
                                    _5068 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]
                                    if mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194] > test266151307():
                                        revert with 0, 65
                                    if ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]) + 1 < 0 or ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]) + 195 > test266151307():
                                        revert with 0, 65
                                    mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]) + 195
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 194] = _5068
                                    require return_data.size >= _4992 + (32 * _5068) + 32
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 226 len 32 * _5068] = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + _4992 + 226 len 32 * _5068]
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(stor4)
                                    staticcall stor4.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7976 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if mem[_7976] < cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1:
                                        revert with 0, 17
                                    require ext_code.size(stor4)
                                    call stor4.0x2e1a7d4d with:
                                         gas gas_remaining wei
                                        args (mem[_7976] + -cd[(arg4 + 100)] + -(3 * cd[(arg4 + 100)] / 997) - 1)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    call tx.origin with:
                                       value eth.balance(this.address) wei
                                         gas 2300 * is_zero(value) wei
                                    if not cd[(arg4 + 196)]:
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        require ext_code.size(address(cd[(arg4 + 68)]))
                                        call address(cd[(arg4 + 68)]).0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _8872 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_8872] == bool(mem[_8872])
                                    else:
                                        require ext_code.size(stor4)
                                        call stor4.deposit() with:
                                           value cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1 wei
                                             gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        require ext_code.size(address(cd[(arg4 + 68)]))
                                        call address(cd[(arg4 + 68)]).0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9096 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_9096] == bool(mem[_9096])
                                else:
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 98] = 3
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 130] = sub_3fd82e21Address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 162] = sub_e36c61f1Address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 194] = stor4
                                    if 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 226] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 230] = ext_call.return_data[0]
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 262] = 0
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 294] = 160
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 390] = 3
                                    idx = 0
                                    s = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 422
                                    t = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 130
                                    while idx < 3:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 326] = this.address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 358] = block.timestamp + 3600
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 3600, 3, mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 422 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 226 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 226
                                    require return_data.size >= 32
                                    _4993 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28]
                                    require mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 257 < ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + return_data.size + 226
                                    _5069 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]
                                    if mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226] > test266151307():
                                        revert with 0, 65
                                    if ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 1 < 0 or ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 227 > test266151307():
                                        revert with 0, 65
                                    mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 227
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 226] = _5069
                                    require return_data.size >= _4993 + (32 * _5069) + 32
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 258 len 32 * _5069] = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + _4993 + 258 len 32 * _5069]
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(stor4)
                                    staticcall stor4.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7977 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if mem[_7977] < cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1:
                                        revert with 0, 17
                                    require ext_code.size(stor4)
                                    call stor4.0x2e1a7d4d with:
                                         gas gas_remaining wei
                                        args (mem[_7977] + -cd[(arg4 + 100)] + -(3 * cd[(arg4 + 100)] / 997) - 1)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    call tx.origin with:
                                       value eth.balance(this.address) wei
                                         gas 2300 * is_zero(value) wei
                                    if not cd[(arg4 + 196)]:
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        require ext_code.size(address(cd[(arg4 + 68)]))
                                        call address(cd[(arg4 + 68)]).0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _8873 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_8873] == bool(mem[_8873])
                                    else:
                                        require ext_code.size(stor4)
                                        call stor4.deposit() with:
                                           value cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1 wei
                                             gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        require ext_code.size(address(cd[(arg4 + 68)]))
                                        call address(cd[(arg4 + 68)]).0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9097 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_9097] == bool(mem[_9097])
                    else:
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + 102] = account
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + 134] = cd[(arg4 + 100)]
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + 166] = sub_3c8a5d8dAddress
                        require ext_code.size(sub_1c1d3e8dAddress)
                        call sub_1c1d3e8dAddress.liquidateBorrow(address arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args account, cd[(arg4 + 100)], sub_3c8a5d8dAddress
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + 98] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + ceil32(return_data.size) + 102] = this.address
                        require ext_code.size(sub_3c8a5d8dAddress)
                        staticcall sub_3c8a5d8dAddress.0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + ceil32(return_data.size) + 98] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (2 * ceil32(return_data.size)) + 102] = ext_call.return_data[0]
                        require ext_code.size(sub_3c8a5d8dAddress)
                        call sub_3c8a5d8dAddress.redeem(uint256 arg1) with:
                             gas gas_remaining wei
                            args ext_call.return_data[0]
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (2 * ceil32(return_data.size)) + 98] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if not sub_3fd82e21Address:
                            require ext_code.size(stor4)
                            call stor4.deposit() with:
                               value cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1 wei
                                 gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            call tx.origin with:
                               value eth.balance(this.address) wei
                                 gas 2300 * is_zero(value) wei
                            if cd[(arg4 + 196)]:
                                require ext_code.size(stor4)
                                call stor4.deposit() with:
                                   value cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1 wei
                                     gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(address(cd[(arg4 + 68)]))
                            call address(cd[(arg4 + 68)]).0xa9059cbb with:
                                 gas gas_remaining wei
                                args msg.sender, cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                        else:
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 102] = this.address
                            require ext_code.size(sub_3fd82e21Address)
                            staticcall sub_3fd82e21Address.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 98] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if stor4 == sub_3fd82e21Address:
                                require ext_code.size(stor4)
                                staticcall stor4.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if ext_call.return_data[0] < cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1:
                                    revert with 0, 17
                                require ext_code.size(stor4)
                                call stor4.0x2e1a7d4d with:
                                     gas gas_remaining wei
                                    args (ext_call.return_data[0] + -cd[(arg4 + 100)] + -(3 * cd[(arg4 + 100)] / 997) - 1)
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                call tx.origin with:
                                   value eth.balance(this.address) wei
                                     gas 2300 * is_zero(value) wei
                                if cd[(arg4 + 196)]:
                                    require ext_code.size(stor4)
                                    call stor4.deposit() with:
                                       value cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1 wei
                                         gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(address(cd[(arg4 + 68)]))
                                call address(cd[(arg4 + 68)]).0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                            else:
                                if sub_ccccbcf7Address != sub_3fd82e21Address:
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 98] = 2
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 130] = sub_3fd82e21Address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 162] = stor4
                                    if 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 194] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 198] = ext_call.return_data[0]
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 230] = 0
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 262] = 160
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 358] = 2
                                    idx = 0
                                    s = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 390
                                    t = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 130
                                    while idx < 2:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 294] = this.address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 326] = block.timestamp + 3600
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 3600, 2, mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 390 len 64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 194 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 194
                                    require return_data.size >= 32
                                    _4990 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28]
                                    require mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 225 < ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + return_data.size + 194
                                    _5066 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]
                                    if mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194] > test266151307():
                                        revert with 0, 65
                                    if ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]) + 1 < 0 or ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]) + 195 > test266151307():
                                        revert with 0, 65
                                    mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]) + 195
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 194] = _5066
                                    require return_data.size >= _4990 + (32 * _5066) + 32
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 226 len 32 * _5066] = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + _4990 + 226 len 32 * _5066]
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(stor4)
                                    staticcall stor4.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7974 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if mem[_7974] < cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1:
                                        revert with 0, 17
                                    require ext_code.size(stor4)
                                    call stor4.0x2e1a7d4d with:
                                         gas gas_remaining wei
                                        args (mem[_7974] + -cd[(arg4 + 100)] + -(3 * cd[(arg4 + 100)] / 997) - 1)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    call tx.origin with:
                                       value eth.balance(this.address) wei
                                         gas 2300 * is_zero(value) wei
                                    if not cd[(arg4 + 196)]:
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        require ext_code.size(address(cd[(arg4 + 68)]))
                                        call address(cd[(arg4 + 68)]).0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _8870 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_8870] == bool(mem[_8870])
                                    else:
                                        require ext_code.size(stor4)
                                        call stor4.deposit() with:
                                           value cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1 wei
                                             gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        require ext_code.size(address(cd[(arg4 + 68)]))
                                        call address(cd[(arg4 + 68)]).0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9094 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_9094] == bool(mem[_9094])
                                else:
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 98] = 3
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 130] = sub_3fd82e21Address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 162] = sub_e36c61f1Address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 194] = stor4
                                    if 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 226] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 230] = ext_call.return_data[0]
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 262] = 0
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 294] = 160
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 390] = 3
                                    idx = 0
                                    s = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 422
                                    t = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 130
                                    while idx < 3:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 326] = this.address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 358] = block.timestamp + 3600
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 3600, 3, mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 422 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 226 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 226
                                    require return_data.size >= 32
                                    _4991 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28]
                                    require mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 257 < ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + return_data.size + 226
                                    _5067 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]
                                    if mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226] > test266151307():
                                        revert with 0, 65
                                    if ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 1 < 0 or ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 227 > test266151307():
                                        revert with 0, 65
                                    mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 227
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 226] = _5067
                                    require return_data.size >= _4991 + (32 * _5067) + 32
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 258 len 32 * _5067] = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + _4991 + 258 len 32 * _5067]
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(stor4)
                                    staticcall stor4.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7975 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if mem[_7975] < cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1:
                                        revert with 0, 17
                                    require ext_code.size(stor4)
                                    call stor4.0x2e1a7d4d with:
                                         gas gas_remaining wei
                                        args (mem[_7975] + -cd[(arg4 + 100)] + -(3 * cd[(arg4 + 100)] / 997) - 1)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    call tx.origin with:
                                       value eth.balance(this.address) wei
                                         gas 2300 * is_zero(value) wei
                                    if not cd[(arg4 + 196)]:
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        require ext_code.size(address(cd[(arg4 + 68)]))
                                        call address(cd[(arg4 + 68)]).0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _8871 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_8871] == bool(mem[_8871])
                                    else:
                                        require ext_code.size(stor4)
                                        call stor4.deposit() with:
                                           value cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1 wei
                                             gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        require ext_code.size(address(cd[(arg4 + 68)]))
                                        call address(cd[(arg4 + 68)]).0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, cd[(arg4 + 100)] + (3 * cd[(arg4 + 100)] / 997) + 1
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _9095 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_9095] == bool(mem[_9095])
    else:
        if cd[(arg4 + 36)] > 2:
            revert with 0, 33
        if cd[(arg4 + 36)] == 1:
            if not cd[(arg4 + 164)]:
                mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + 102] = stor3
                require ext_code.size(address(cd[(arg4 + 68)]))
                staticcall address(cd[(arg4 + 68)]).0x70a08231 with:
                        gas gas_remaining wei
                       args stor3
                mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + 98] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + ceil32(return_data.size) + 102] = stor3
                require ext_code.size(address(cd[(arg4 + 132)]))
                staticcall address(cd[(arg4 + 132)]).0x70a08231 with:
                        gas gas_remaining wei
                       args stor3
                mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + ceil32(return_data.size) + 98] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if ext_call.return_data[0] > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                    revert with 0, 17
                if ext_call.return_data[0] > 0x4189374bc6a7ef9db22d0e5604189374bc6a7ef9db22d0e5604189374bc6a7:
                    revert with 0, 17
                if 1000 * ext_call.return_data[0] and cd[(arg4 + 100)] > -1 / 1000 * ext_call.return_data[0]:
                    revert with 0, 17
                if not 997 * ext_call.return_data[0]:
                    revert with 0, 18
                if 1 > !(1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]):
                    revert with 0, 17
                if cd[(arg4 + 164)]:
                    if cd[(arg4 + 196)]:
                        if not sub_ccccbcf7Address:
                            require ext_code.size(stor4)
                            call stor4.0x2e1a7d4d with:
                                 gas gas_remaining wei
                                args cd[(arg4 + 100)]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (2 * ceil32(return_data.size)) + 134] = sub_3c8a5d8dAddress
                            require ext_code.size(sub_1c1d3e8dAddress)
                            call sub_1c1d3e8dAddress.liquidateBorrow(address arg1, address arg2) with:
                               value cd[(arg4 + 100)] wei
                                 gas gas_remaining wei
                                args account, sub_3c8a5d8dAddress
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (2 * ceil32(return_data.size)) + 102] = this.address
                            require ext_code.size(sub_3c8a5d8dAddress)
                            staticcall sub_3c8a5d8dAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (2 * ceil32(return_data.size)) + 98] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 102] = ext_call.return_data[0]
                            require ext_code.size(sub_3c8a5d8dAddress)
                            call sub_3c8a5d8dAddress.redeem(uint256 arg1) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0]
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 98] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if not sub_3fd82e21Address:
                                require ext_code.size(stor4)
                                call stor4.deposit() with:
                                   value (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1 wei
                                     gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                call tx.origin with:
                                   value eth.balance(this.address) wei
                                     gas 2300 * is_zero(value) wei
                                if cd[(arg4 + 196)]:
                                    require ext_code.size(stor4)
                                    call stor4.deposit() with:
                                       value (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1 wei
                                         gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(address(cd[(arg4 + 132)]))
                                call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                            else:
                                mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 102] = this.address
                                require ext_code.size(sub_3fd82e21Address)
                                staticcall sub_3fd82e21Address.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 98] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if stor4 == sub_3fd82e21Address:
                                    require ext_code.size(stor4)
                                    staticcall stor4.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if ext_call.return_data[0] < (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1:
                                        revert with 0, 17
                                    require ext_code.size(stor4)
                                    call stor4.0x2e1a7d4d with:
                                         gas gas_remaining wei
                                        args (ext_call.return_data[0] + -(1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) - 1)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    call tx.origin with:
                                       value eth.balance(this.address) wei
                                         gas 2300 * is_zero(value) wei
                                    if cd[(arg4 + 196)]:
                                        require ext_code.size(stor4)
                                        call stor4.deposit() with:
                                           value (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1 wei
                                             gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(address(cd[(arg4 + 132)]))
                                    call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                else:
                                    if sub_ccccbcf7Address != sub_3fd82e21Address:
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 98] = 2
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 130] = sub_3fd82e21Address
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 162] = stor4
                                        if 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 194] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 198] = ext_call.return_data[0]
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 230] = 0
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 262] = 160
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 358] = 2
                                        idx = 0
                                        s = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 390
                                        t = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 130
                                        while idx < 2:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 294] = this.address
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 326] = block.timestamp + 3600
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 3600, 2, mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 390 len 64]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 194 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 194
                                        require return_data.size >= 32
                                        _4932 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28]
                                        require mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                        require ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 225 < ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + return_data.size + 194
                                        _5008 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]
                                        if mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194] > test266151307():
                                            revert with 0, 65
                                        if ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]) + 1 < 0 or ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]) + 195 > test266151307():
                                            revert with 0, 65
                                        mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]) + 195
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 194] = _5008
                                        require return_data.size >= _4932 + (32 * _5008) + 32
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 226 len 32 * _5008] = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + _4932 + 226 len 32 * _5008]
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(stor4)
                                        staticcall stor4.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7916 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if mem[_7916] < (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1:
                                            revert with 0, 17
                                        require ext_code.size(stor4)
                                        call stor4.0x2e1a7d4d with:
                                             gas gas_remaining wei
                                            args (mem[_7916] + -(1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) - 1)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        call tx.origin with:
                                           value eth.balance(this.address) wei
                                             gas 2300 * is_zero(value) wei
                                        if not cd[(arg4 + 196)]:
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            require ext_code.size(address(cd[(arg4 + 132)]))
                                            call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8812 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_8812] == bool(mem[_8812])
                                        else:
                                            require ext_code.size(stor4)
                                            call stor4.deposit() with:
                                               value (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1 wei
                                                 gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            require ext_code.size(address(cd[(arg4 + 132)]))
                                            call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9036 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_9036] == bool(mem[_9036])
                                    else:
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 98] = 3
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 130] = sub_3fd82e21Address
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 162] = sub_e36c61f1Address
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 194] = stor4
                                        if 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 226] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 230] = ext_call.return_data[0]
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 262] = 0
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 294] = 160
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 390] = 3
                                        idx = 0
                                        s = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 422
                                        t = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 130
                                        while idx < 3:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 326] = this.address
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 358] = block.timestamp + 3600
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 3600, 3, mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 422 len 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 226 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 226
                                        require return_data.size >= 32
                                        _4933 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28]
                                        require mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                        require ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 257 < ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + return_data.size + 226
                                        _5009 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]
                                        if mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226] > test266151307():
                                            revert with 0, 65
                                        if ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 1 < 0 or ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 227 > test266151307():
                                            revert with 0, 65
                                        mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 227
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 226] = _5009
                                        require return_data.size >= _4933 + (32 * _5009) + 32
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 258 len 32 * _5009] = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + _4933 + 258 len 32 * _5009]
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(stor4)
                                        staticcall stor4.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7917 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if mem[_7917] < (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1:
                                            revert with 0, 17
                                        require ext_code.size(stor4)
                                        call stor4.0x2e1a7d4d with:
                                             gas gas_remaining wei
                                            args (mem[_7917] + -(1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) - 1)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        call tx.origin with:
                                           value eth.balance(this.address) wei
                                             gas 2300 * is_zero(value) wei
                                        if not cd[(arg4 + 196)]:
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            require ext_code.size(address(cd[(arg4 + 132)]))
                                            call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8813 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_8813] == bool(mem[_8813])
                                        else:
                                            require ext_code.size(stor4)
                                            call stor4.deposit() with:
                                               value (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1 wei
                                                 gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            require ext_code.size(address(cd[(arg4 + 132)]))
                                            call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9037 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_9037] == bool(mem[_9037])
                        else:
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (2 * ceil32(return_data.size)) + 102] = account
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (2 * ceil32(return_data.size)) + 134] = cd[(arg4 + 100)]
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (2 * ceil32(return_data.size)) + 166] = sub_3c8a5d8dAddress
                            require ext_code.size(sub_1c1d3e8dAddress)
                            call sub_1c1d3e8dAddress.liquidateBorrow(address arg1, uint256 arg2, address arg3) with:
                                 gas gas_remaining wei
                                args account, cd[(arg4 + 100)], sub_3c8a5d8dAddress
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (2 * ceil32(return_data.size)) + 98] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 102] = this.address
                            require ext_code.size(sub_3c8a5d8dAddress)
                            staticcall sub_3c8a5d8dAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 98] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 102] = ext_call.return_data[0]
                            require ext_code.size(sub_3c8a5d8dAddress)
                            call sub_3c8a5d8dAddress.redeem(uint256 arg1) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0]
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 98] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if not sub_3fd82e21Address:
                                require ext_code.size(stor4)
                                call stor4.deposit() with:
                                   value (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1 wei
                                     gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                call tx.origin with:
                                   value eth.balance(this.address) wei
                                     gas 2300 * is_zero(value) wei
                                if cd[(arg4 + 196)]:
                                    require ext_code.size(stor4)
                                    call stor4.deposit() with:
                                       value (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1 wei
                                         gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(address(cd[(arg4 + 132)]))
                                call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                            else:
                                mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 102] = this.address
                                require ext_code.size(sub_3fd82e21Address)
                                staticcall sub_3fd82e21Address.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 98] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if stor4 == sub_3fd82e21Address:
                                    require ext_code.size(stor4)
                                    staticcall stor4.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if ext_call.return_data[0] < (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1:
                                        revert with 0, 17
                                    require ext_code.size(stor4)
                                    call stor4.0x2e1a7d4d with:
                                         gas gas_remaining wei
                                        args (ext_call.return_data[0] + -(1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) - 1)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    call tx.origin with:
                                       value eth.balance(this.address) wei
                                         gas 2300 * is_zero(value) wei
                                    if cd[(arg4 + 196)]:
                                        require ext_code.size(stor4)
                                        call stor4.deposit() with:
                                           value (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1 wei
                                             gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(address(cd[(arg4 + 132)]))
                                    call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                else:
                                    if sub_ccccbcf7Address != sub_3fd82e21Address:
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 98] = 2
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 130] = sub_3fd82e21Address
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 162] = stor4
                                        if 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 194] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 198] = ext_call.return_data[0]
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 230] = 0
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 262] = 160
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 358] = 2
                                        idx = 0
                                        s = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 390
                                        t = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 130
                                        while idx < 2:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 294] = this.address
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 326] = block.timestamp + 3600
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 3600, 2, mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 390 len 64]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 194 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (10 * ceil32(return_data.size)) + 194
                                        require return_data.size >= 32
                                        _4930 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28]
                                        require mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                        require ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 225 < ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + return_data.size + 194
                                        _5006 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]
                                        if mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194] > test266151307():
                                            revert with 0, 65
                                        if ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]) + 1 < 0 or ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (10 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]) + 195 > test266151307():
                                            revert with 0, 65
                                        mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (10 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]) + 195
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (10 * ceil32(return_data.size)) + 194] = _5006
                                        require return_data.size >= _4930 + (32 * _5006) + 32
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (10 * ceil32(return_data.size)) + 226 len 32 * _5006] = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + _4930 + 226 len 32 * _5006]
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(stor4)
                                        staticcall stor4.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7914 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if mem[_7914] < (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1:
                                            revert with 0, 17
                                        require ext_code.size(stor4)
                                        call stor4.0x2e1a7d4d with:
                                             gas gas_remaining wei
                                            args (mem[_7914] + -(1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) - 1)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        call tx.origin with:
                                           value eth.balance(this.address) wei
                                             gas 2300 * is_zero(value) wei
                                        if not cd[(arg4 + 196)]:
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            require ext_code.size(address(cd[(arg4 + 132)]))
                                            call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8810 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_8810] == bool(mem[_8810])
                                        else:
                                            require ext_code.size(stor4)
                                            call stor4.deposit() with:
                                               value (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1 wei
                                                 gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            require ext_code.size(address(cd[(arg4 + 132)]))
                                            call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9034 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_9034] == bool(mem[_9034])
                                    else:
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 98] = 3
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 130] = sub_3fd82e21Address
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 162] = sub_e36c61f1Address
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 194] = stor4
                                        if 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 226] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 230] = ext_call.return_data[0]
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 262] = 0
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 294] = 160
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 390] = 3
                                        idx = 0
                                        s = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 422
                                        t = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 130
                                        while idx < 3:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 326] = this.address
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 358] = block.timestamp + 3600
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 3600, 3, mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 422 len 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 226 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (10 * ceil32(return_data.size)) + 226
                                        require return_data.size >= 32
                                        _4931 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28]
                                        require mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                        require ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 257 < ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + return_data.size + 226
                                        _5007 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]
                                        if mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226] > test266151307():
                                            revert with 0, 65
                                        if ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 1 < 0 or ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (10 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 227 > test266151307():
                                            revert with 0, 65
                                        mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (10 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 227
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (10 * ceil32(return_data.size)) + 226] = _5007
                                        require return_data.size >= _4931 + (32 * _5007) + 32
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (10 * ceil32(return_data.size)) + 258 len 32 * _5007] = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + _4931 + 258 len 32 * _5007]
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(stor4)
                                        staticcall stor4.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7915 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if mem[_7915] < (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1:
                                            revert with 0, 17
                                        require ext_code.size(stor4)
                                        call stor4.0x2e1a7d4d with:
                                             gas gas_remaining wei
                                            args (mem[_7915] + -(1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) - 1)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        call tx.origin with:
                                           value eth.balance(this.address) wei
                                             gas 2300 * is_zero(value) wei
                                        if not cd[(arg4 + 196)]:
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            require ext_code.size(address(cd[(arg4 + 132)]))
                                            call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8811 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_8811] == bool(mem[_8811])
                                        else:
                                            require ext_code.size(stor4)
                                            call stor4.deposit() with:
                                               value (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1 wei
                                                 gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            require ext_code.size(address(cd[(arg4 + 132)]))
                                            call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9035 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_9035] == bool(mem[_9035])
                    else:
                        if not sub_ccccbcf7Address:
                            require ext_code.size(stor4)
                            call stor4.0x2e1a7d4d with:
                                 gas gas_remaining wei
                                args cd[(arg4 + 100)]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (2 * ceil32(return_data.size)) + 134] = sub_3c8a5d8dAddress
                            require ext_code.size(sub_1c1d3e8dAddress)
                            call sub_1c1d3e8dAddress.liquidateBorrow(address arg1, address arg2) with:
                               value cd[(arg4 + 100)] wei
                                 gas gas_remaining wei
                                args account, sub_3c8a5d8dAddress
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (2 * ceil32(return_data.size)) + 102] = this.address
                            require ext_code.size(sub_3c8a5d8dAddress)
                            staticcall sub_3c8a5d8dAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (2 * ceil32(return_data.size)) + 98] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 102] = ext_call.return_data[0]
                            require ext_code.size(sub_3c8a5d8dAddress)
                            call sub_3c8a5d8dAddress.redeem(uint256 arg1) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0]
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 98] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if not sub_3fd82e21Address:
                                require ext_code.size(stor4)
                                call stor4.deposit() with:
                                   value (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1 wei
                                     gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                call tx.origin with:
                                   value eth.balance(this.address) wei
                                     gas 2300 * is_zero(value) wei
                                if cd[(arg4 + 196)]:
                                    require ext_code.size(stor4)
                                    call stor4.deposit() with:
                                       value (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1 wei
                                         gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(address(cd[(arg4 + 132)]))
                                call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                            else:
                                mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 102] = this.address
                                require ext_code.size(sub_3fd82e21Address)
                                staticcall sub_3fd82e21Address.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 98] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if stor4 == sub_3fd82e21Address:
                                    require ext_code.size(stor4)
                                    staticcall stor4.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if ext_call.return_data[0] < (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1:
                                        revert with 0, 17
                                    require ext_code.size(stor4)
                                    call stor4.0x2e1a7d4d with:
                                         gas gas_remaining wei
                                        args (ext_call.return_data[0] + -(1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) - 1)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    call tx.origin with:
                                       value eth.balance(this.address) wei
                                         gas 2300 * is_zero(value) wei
                                    if cd[(arg4 + 196)]:
                                        require ext_code.size(stor4)
                                        call stor4.deposit() with:
                                           value (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1 wei
                                             gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(address(cd[(arg4 + 132)]))
                                    call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                else:
                                    if sub_ccccbcf7Address != sub_3fd82e21Address:
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 98] = 2
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 130] = sub_3fd82e21Address
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 162] = stor4
                                        if 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 194] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 198] = ext_call.return_data[0]
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 230] = 0
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 262] = 160
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 358] = 2
                                        idx = 0
                                        s = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 390
                                        t = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 130
                                        while idx < 2:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 294] = this.address
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 326] = block.timestamp + 3600
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 3600, 2, mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 390 len 64]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 194 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 194
                                        require return_data.size >= 32
                                        _4936 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28]
                                        require mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                        require ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 225 < ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + return_data.size + 194
                                        _5012 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]
                                        if mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194] > test266151307():
                                            revert with 0, 65
                                        if ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]) + 1 < 0 or ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]) + 195 > test266151307():
                                            revert with 0, 65
                                        mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]) + 195
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 194] = _5012
                                        require return_data.size >= _4936 + (32 * _5012) + 32
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 226 len 32 * _5012] = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + _4936 + 226 len 32 * _5012]
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(stor4)
                                        staticcall stor4.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7920 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if mem[_7920] < (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1:
                                            revert with 0, 17
                                        require ext_code.size(stor4)
                                        call stor4.0x2e1a7d4d with:
                                             gas gas_remaining wei
                                            args (mem[_7920] + -(1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) - 1)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        call tx.origin with:
                                           value eth.balance(this.address) wei
                                             gas 2300 * is_zero(value) wei
                                        if not cd[(arg4 + 196)]:
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            require ext_code.size(address(cd[(arg4 + 132)]))
                                            call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8816 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_8816] == bool(mem[_8816])
                                        else:
                                            require ext_code.size(stor4)
                                            call stor4.deposit() with:
                                               value (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1 wei
                                                 gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            require ext_code.size(address(cd[(arg4 + 132)]))
                                            call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9040 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_9040] == bool(mem[_9040])
                                    else:
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 98] = 3
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 130] = sub_3fd82e21Address
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 162] = sub_e36c61f1Address
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 194] = stor4
                                        if 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 226] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 230] = ext_call.return_data[0]
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 262] = 0
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 294] = 160
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 390] = 3
                                        idx = 0
                                        s = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 422
                                        t = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 130
                                        while idx < 3:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 326] = this.address
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 358] = block.timestamp + 3600
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 3600, 3, mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 422 len 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 226 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 226
                                        require return_data.size >= 32
                                        _4937 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28]
                                        require mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                        require ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 257 < ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + return_data.size + 226
                                        _5013 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]
                                        if mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226] > test266151307():
                                            revert with 0, 65
                                        if ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 1 < 0 or ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 227 > test266151307():
                                            revert with 0, 65
                                        mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 227
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 226] = _5013
                                        require return_data.size >= _4937 + (32 * _5013) + 32
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 258 len 32 * _5013] = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + _4937 + 258 len 32 * _5013]
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(stor4)
                                        staticcall stor4.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7921 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if mem[_7921] < (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1:
                                            revert with 0, 17
                                        require ext_code.size(stor4)
                                        call stor4.0x2e1a7d4d with:
                                             gas gas_remaining wei
                                            args (mem[_7921] + -(1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) - 1)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        call tx.origin with:
                                           value eth.balance(this.address) wei
                                             gas 2300 * is_zero(value) wei
                                        if not cd[(arg4 + 196)]:
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            require ext_code.size(address(cd[(arg4 + 132)]))
                                            call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8817 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_8817] == bool(mem[_8817])
                                        else:
                                            require ext_code.size(stor4)
                                            call stor4.deposit() with:
                                               value (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1 wei
                                                 gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            require ext_code.size(address(cd[(arg4 + 132)]))
                                            call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9041 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_9041] == bool(mem[_9041])
                        else:
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (2 * ceil32(return_data.size)) + 102] = account
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (2 * ceil32(return_data.size)) + 134] = cd[(arg4 + 100)]
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (2 * ceil32(return_data.size)) + 166] = sub_3c8a5d8dAddress
                            require ext_code.size(sub_1c1d3e8dAddress)
                            call sub_1c1d3e8dAddress.liquidateBorrow(address arg1, uint256 arg2, address arg3) with:
                                 gas gas_remaining wei
                                args account, cd[(arg4 + 100)], sub_3c8a5d8dAddress
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (2 * ceil32(return_data.size)) + 98] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 102] = this.address
                            require ext_code.size(sub_3c8a5d8dAddress)
                            staticcall sub_3c8a5d8dAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 98] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 102] = ext_call.return_data[0]
                            require ext_code.size(sub_3c8a5d8dAddress)
                            call sub_3c8a5d8dAddress.redeem(uint256 arg1) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0]
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 98] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if not sub_3fd82e21Address:
                                require ext_code.size(stor4)
                                call stor4.deposit() with:
                                   value (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1 wei
                                     gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                call tx.origin with:
                                   value eth.balance(this.address) wei
                                     gas 2300 * is_zero(value) wei
                                if cd[(arg4 + 196)]:
                                    require ext_code.size(stor4)
                                    call stor4.deposit() with:
                                       value (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1 wei
                                         gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(address(cd[(arg4 + 132)]))
                                call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                            else:
                                mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 102] = this.address
                                require ext_code.size(sub_3fd82e21Address)
                                staticcall sub_3fd82e21Address.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 98] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if stor4 == sub_3fd82e21Address:
                                    require ext_code.size(stor4)
                                    staticcall stor4.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if ext_call.return_data[0] < (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1:
                                        revert with 0, 17
                                    require ext_code.size(stor4)
                                    call stor4.0x2e1a7d4d with:
                                         gas gas_remaining wei
                                        args (ext_call.return_data[0] + -(1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) - 1)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    call tx.origin with:
                                       value eth.balance(this.address) wei
                                         gas 2300 * is_zero(value) wei
                                    if cd[(arg4 + 196)]:
                                        require ext_code.size(stor4)
                                        call stor4.deposit() with:
                                           value (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1 wei
                                             gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(address(cd[(arg4 + 132)]))
                                    call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                else:
                                    if sub_ccccbcf7Address != sub_3fd82e21Address:
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 98] = 2
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 130] = sub_3fd82e21Address
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 162] = stor4
                                        if 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 194] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 198] = ext_call.return_data[0]
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 230] = 0
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 262] = 160
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 358] = 2
                                        idx = 0
                                        s = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 390
                                        t = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 130
                                        while idx < 2:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 294] = this.address
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 326] = block.timestamp + 3600
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 3600, 2, mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 390 len 64]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 194 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (10 * ceil32(return_data.size)) + 194
                                        require return_data.size >= 32
                                        _4934 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28]
                                        require mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                        require ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 225 < ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + return_data.size + 194
                                        _5010 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]
                                        if mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194] > test266151307():
                                            revert with 0, 65
                                        if ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]) + 1 < 0 or ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (10 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]) + 195 > test266151307():
                                            revert with 0, 65
                                        mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (10 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]) + 195
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (10 * ceil32(return_data.size)) + 194] = _5010
                                        require return_data.size >= _4934 + (32 * _5010) + 32
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (10 * ceil32(return_data.size)) + 226 len 32 * _5010] = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + _4934 + 226 len 32 * _5010]
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(stor4)
                                        staticcall stor4.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7918 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if mem[_7918] < (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1:
                                            revert with 0, 17
                                        require ext_code.size(stor4)
                                        call stor4.0x2e1a7d4d with:
                                             gas gas_remaining wei
                                            args (mem[_7918] + -(1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) - 1)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        call tx.origin with:
                                           value eth.balance(this.address) wei
                                             gas 2300 * is_zero(value) wei
                                        if not cd[(arg4 + 196)]:
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            require ext_code.size(address(cd[(arg4 + 132)]))
                                            call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8814 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_8814] == bool(mem[_8814])
                                        else:
                                            require ext_code.size(stor4)
                                            call stor4.deposit() with:
                                               value (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1 wei
                                                 gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            require ext_code.size(address(cd[(arg4 + 132)]))
                                            call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9038 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_9038] == bool(mem[_9038])
                                    else:
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 98] = 3
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 130] = sub_3fd82e21Address
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 162] = sub_e36c61f1Address
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 194] = stor4
                                        if 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 226] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 230] = ext_call.return_data[0]
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 262] = 0
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 294] = 160
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 390] = 3
                                        idx = 0
                                        s = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 422
                                        t = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 130
                                        while idx < 3:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 326] = this.address
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 358] = block.timestamp + 3600
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 3600, 3, mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 422 len 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 226 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (10 * ceil32(return_data.size)) + 226
                                        require return_data.size >= 32
                                        _4935 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28]
                                        require mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                        require ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 257 < ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + return_data.size + 226
                                        _5011 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]
                                        if mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226] > test266151307():
                                            revert with 0, 65
                                        if ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 1 < 0 or ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (10 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 227 > test266151307():
                                            revert with 0, 65
                                        mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (10 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 227
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (10 * ceil32(return_data.size)) + 226] = _5011
                                        require return_data.size >= _4935 + (32 * _5011) + 32
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (10 * ceil32(return_data.size)) + 258 len 32 * _5011] = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + _4935 + 258 len 32 * _5011]
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(stor4)
                                        staticcall stor4.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7919 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if mem[_7919] < (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1:
                                            revert with 0, 17
                                        require ext_code.size(stor4)
                                        call stor4.0x2e1a7d4d with:
                                             gas gas_remaining wei
                                            args (mem[_7919] + -(1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) - 1)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        call tx.origin with:
                                           value eth.balance(this.address) wei
                                             gas 2300 * is_zero(value) wei
                                        if not cd[(arg4 + 196)]:
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            require ext_code.size(address(cd[(arg4 + 132)]))
                                            call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8815 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_8815] == bool(mem[_8815])
                                        else:
                                            require ext_code.size(stor4)
                                            call stor4.deposit() with:
                                               value (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1 wei
                                                 gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            require ext_code.size(address(cd[(arg4 + 132)]))
                                            call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9039 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_9039] == bool(mem[_9039])
                else:
                    if cd[(arg4 + 196)]:
                        if not sub_ccccbcf7Address:
                            require ext_code.size(stor4)
                            call stor4.0x2e1a7d4d with:
                                 gas gas_remaining wei
                                args cd[(arg4 + 100)]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (2 * ceil32(return_data.size)) + 134] = sub_3c8a5d8dAddress
                            require ext_code.size(sub_1c1d3e8dAddress)
                            call sub_1c1d3e8dAddress.liquidateBorrow(address arg1, address arg2) with:
                               value cd[(arg4 + 100)] wei
                                 gas gas_remaining wei
                                args account, sub_3c8a5d8dAddress
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (2 * ceil32(return_data.size)) + 102] = this.address
                            require ext_code.size(sub_3c8a5d8dAddress)
                            staticcall sub_3c8a5d8dAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (2 * ceil32(return_data.size)) + 98] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 102] = ext_call.return_data[0]
                            require ext_code.size(sub_3c8a5d8dAddress)
                            call sub_3c8a5d8dAddress.redeem(uint256 arg1) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0]
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 98] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if not sub_3fd82e21Address:
                                require ext_code.size(stor4)
                                call stor4.deposit() with:
                                   value (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1 wei
                                     gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                call tx.origin with:
                                   value eth.balance(this.address) wei
                                     gas 2300 * is_zero(value) wei
                                if cd[(arg4 + 196)]:
                                    require ext_code.size(stor4)
                                    call stor4.deposit() with:
                                       value (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1 wei
                                         gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(address(cd[(arg4 + 132)]))
                                call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                            else:
                                mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 102] = this.address
                                require ext_code.size(sub_3fd82e21Address)
                                staticcall sub_3fd82e21Address.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 98] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if stor4 == sub_3fd82e21Address:
                                    require ext_code.size(stor4)
                                    staticcall stor4.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if ext_call.return_data[0] < (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1:
                                        revert with 0, 17
                                    require ext_code.size(stor4)
                                    call stor4.0x2e1a7d4d with:
                                         gas gas_remaining wei
                                        args (ext_call.return_data[0] + -(1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) - 1)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    call tx.origin with:
                                       value eth.balance(this.address) wei
                                         gas 2300 * is_zero(value) wei
                                    if cd[(arg4 + 196)]:
                                        require ext_code.size(stor4)
                                        call stor4.deposit() with:
                                           value (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1 wei
                                             gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(address(cd[(arg4 + 132)]))
                                    call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                else:
                                    if sub_ccccbcf7Address != sub_3fd82e21Address:
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 98] = 2
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 130] = sub_3fd82e21Address
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 162] = stor4
                                        if 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 194] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 198] = ext_call.return_data[0]
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 230] = 0
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 262] = 160
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 358] = 2
                                        idx = 0
                                        s = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 390
                                        t = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 130
                                        while idx < 2:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 294] = this.address
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 326] = block.timestamp + 3600
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 3600, 2, mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 390 len 64]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 194 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 194
                                        require return_data.size >= 32
                                        _4940 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28]
                                        require mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                        require ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 225 < ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + return_data.size + 194
                                        _5016 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]
                                        if mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194] > test266151307():
                                            revert with 0, 65
                                        if ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]) + 1 < 0 or ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]) + 195 > test266151307():
                                            revert with 0, 65
                                        mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]) + 195
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 194] = _5016
                                        require return_data.size >= _4940 + (32 * _5016) + 32
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 226 len 32 * _5016] = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + _4940 + 226 len 32 * _5016]
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(stor4)
                                        staticcall stor4.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7924 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if mem[_7924] < (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1:
                                            revert with 0, 17
                                        require ext_code.size(stor4)
                                        call stor4.0x2e1a7d4d with:
                                             gas gas_remaining wei
                                            args (mem[_7924] + -(1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) - 1)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        call tx.origin with:
                                           value eth.balance(this.address) wei
                                             gas 2300 * is_zero(value) wei
                                        if not cd[(arg4 + 196)]:
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            require ext_code.size(address(cd[(arg4 + 132)]))
                                            call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8820 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_8820] == bool(mem[_8820])
                                        else:
                                            require ext_code.size(stor4)
                                            call stor4.deposit() with:
                                               value (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1 wei
                                                 gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            require ext_code.size(address(cd[(arg4 + 132)]))
                                            call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9044 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_9044] == bool(mem[_9044])
                                    else:
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 98] = 3
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 130] = sub_3fd82e21Address
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 162] = sub_e36c61f1Address
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 194] = stor4
                                        if 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 226] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 230] = ext_call.return_data[0]
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 262] = 0
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 294] = 160
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 390] = 3
                                        idx = 0
                                        s = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 422
                                        t = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 130
                                        while idx < 3:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 326] = this.address
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 358] = block.timestamp + 3600
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 3600, 3, mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 422 len 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 226 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 226
                                        require return_data.size >= 32
                                        _4941 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28]
                                        require mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                        require ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 257 < ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + return_data.size + 226
                                        _5017 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]
                                        if mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226] > test266151307():
                                            revert with 0, 65
                                        if ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 1 < 0 or ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 227 > test266151307():
                                            revert with 0, 65
                                        mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 227
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 226] = _5017
                                        require return_data.size >= _4941 + (32 * _5017) + 32
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 258 len 32 * _5017] = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + _4941 + 258 len 32 * _5017]
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(stor4)
                                        staticcall stor4.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7925 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if mem[_7925] < (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1:
                                            revert with 0, 17
                                        require ext_code.size(stor4)
                                        call stor4.0x2e1a7d4d with:
                                             gas gas_remaining wei
                                            args (mem[_7925] + -(1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) - 1)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        call tx.origin with:
                                           value eth.balance(this.address) wei
                                             gas 2300 * is_zero(value) wei
                                        if not cd[(arg4 + 196)]:
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            require ext_code.size(address(cd[(arg4 + 132)]))
                                            call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8821 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_8821] == bool(mem[_8821])
                                        else:
                                            require ext_code.size(stor4)
                                            call stor4.deposit() with:
                                               value (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1 wei
                                                 gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            require ext_code.size(address(cd[(arg4 + 132)]))
                                            call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9045 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_9045] == bool(mem[_9045])
                        else:
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (2 * ceil32(return_data.size)) + 102] = account
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (2 * ceil32(return_data.size)) + 134] = cd[(arg4 + 100)]
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (2 * ceil32(return_data.size)) + 166] = sub_3c8a5d8dAddress
                            require ext_code.size(sub_1c1d3e8dAddress)
                            call sub_1c1d3e8dAddress.liquidateBorrow(address arg1, uint256 arg2, address arg3) with:
                                 gas gas_remaining wei
                                args account, cd[(arg4 + 100)], sub_3c8a5d8dAddress
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (2 * ceil32(return_data.size)) + 98] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 102] = this.address
                            require ext_code.size(sub_3c8a5d8dAddress)
                            staticcall sub_3c8a5d8dAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 98] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 102] = ext_call.return_data[0]
                            require ext_code.size(sub_3c8a5d8dAddress)
                            call sub_3c8a5d8dAddress.redeem(uint256 arg1) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0]
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 98] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if not sub_3fd82e21Address:
                                require ext_code.size(stor4)
                                call stor4.deposit() with:
                                   value (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1 wei
                                     gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                call tx.origin with:
                                   value eth.balance(this.address) wei
                                     gas 2300 * is_zero(value) wei
                                if cd[(arg4 + 196)]:
                                    require ext_code.size(stor4)
                                    call stor4.deposit() with:
                                       value (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1 wei
                                         gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(address(cd[(arg4 + 132)]))
                                call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                            else:
                                mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 102] = this.address
                                require ext_code.size(sub_3fd82e21Address)
                                staticcall sub_3fd82e21Address.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 98] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if stor4 == sub_3fd82e21Address:
                                    require ext_code.size(stor4)
                                    staticcall stor4.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if ext_call.return_data[0] < (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1:
                                        revert with 0, 17
                                    require ext_code.size(stor4)
                                    call stor4.0x2e1a7d4d with:
                                         gas gas_remaining wei
                                        args (ext_call.return_data[0] + -(1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) - 1)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    call tx.origin with:
                                       value eth.balance(this.address) wei
                                         gas 2300 * is_zero(value) wei
                                    if cd[(arg4 + 196)]:
                                        require ext_code.size(stor4)
                                        call stor4.deposit() with:
                                           value (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1 wei
                                             gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(address(cd[(arg4 + 132)]))
                                    call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                else:
                                    if sub_ccccbcf7Address != sub_3fd82e21Address:
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 98] = 2
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 130] = sub_3fd82e21Address
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 162] = stor4
                                        if 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 194] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 198] = ext_call.return_data[0]
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 230] = 0
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 262] = 160
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 358] = 2
                                        idx = 0
                                        s = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 390
                                        t = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 130
                                        while idx < 2:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 294] = this.address
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 326] = block.timestamp + 3600
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 3600, 2, mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 390 len 64]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 194 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (10 * ceil32(return_data.size)) + 194
                                        require return_data.size >= 32
                                        _4938 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28]
                                        require mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                        require ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 225 < ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + return_data.size + 194
                                        _5014 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]
                                        if mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194] > test266151307():
                                            revert with 0, 65
                                        if ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]) + 1 < 0 or ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (10 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]) + 195 > test266151307():
                                            revert with 0, 65
                                        mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (10 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]) + 195
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (10 * ceil32(return_data.size)) + 194] = _5014
                                        require return_data.size >= _4938 + (32 * _5014) + 32
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (10 * ceil32(return_data.size)) + 226 len 32 * _5014] = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + _4938 + 226 len 32 * _5014]
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(stor4)
                                        staticcall stor4.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7922 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if mem[_7922] < (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1:
                                            revert with 0, 17
                                        require ext_code.size(stor4)
                                        call stor4.0x2e1a7d4d with:
                                             gas gas_remaining wei
                                            args (mem[_7922] + -(1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) - 1)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        call tx.origin with:
                                           value eth.balance(this.address) wei
                                             gas 2300 * is_zero(value) wei
                                        if not cd[(arg4 + 196)]:
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            require ext_code.size(address(cd[(arg4 + 132)]))
                                            call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8818 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_8818] == bool(mem[_8818])
                                        else:
                                            require ext_code.size(stor4)
                                            call stor4.deposit() with:
                                               value (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1 wei
                                                 gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            require ext_code.size(address(cd[(arg4 + 132)]))
                                            call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9042 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_9042] == bool(mem[_9042])
                                    else:
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 98] = 3
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 130] = sub_3fd82e21Address
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 162] = sub_e36c61f1Address
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 194] = stor4
                                        if 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 226] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 230] = ext_call.return_data[0]
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 262] = 0
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 294] = 160
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 390] = 3
                                        idx = 0
                                        s = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 422
                                        t = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 130
                                        while idx < 3:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 326] = this.address
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 358] = block.timestamp + 3600
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 3600, 3, mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 422 len 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 226 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (10 * ceil32(return_data.size)) + 226
                                        require return_data.size >= 32
                                        _4939 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28]
                                        require mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                        require ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 257 < ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + return_data.size + 226
                                        _5015 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]
                                        if mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226] > test266151307():
                                            revert with 0, 65
                                        if ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 1 < 0 or ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (10 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 227 > test266151307():
                                            revert with 0, 65
                                        mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (10 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 227
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (10 * ceil32(return_data.size)) + 226] = _5015
                                        require return_data.size >= _4939 + (32 * _5015) + 32
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (10 * ceil32(return_data.size)) + 258 len 32 * _5015] = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + _4939 + 258 len 32 * _5015]
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(stor4)
                                        staticcall stor4.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7923 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if mem[_7923] < (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1:
                                            revert with 0, 17
                                        require ext_code.size(stor4)
                                        call stor4.0x2e1a7d4d with:
                                             gas gas_remaining wei
                                            args (mem[_7923] + -(1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) - 1)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        call tx.origin with:
                                           value eth.balance(this.address) wei
                                             gas 2300 * is_zero(value) wei
                                        if not cd[(arg4 + 196)]:
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            require ext_code.size(address(cd[(arg4 + 132)]))
                                            call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8819 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_8819] == bool(mem[_8819])
                                        else:
                                            require ext_code.size(stor4)
                                            call stor4.deposit() with:
                                               value (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1 wei
                                                 gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            require ext_code.size(address(cd[(arg4 + 132)]))
                                            call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9043 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_9043] == bool(mem[_9043])
                    else:
                        if not sub_ccccbcf7Address:
                            require ext_code.size(stor4)
                            call stor4.0x2e1a7d4d with:
                                 gas gas_remaining wei
                                args cd[(arg4 + 100)]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (2 * ceil32(return_data.size)) + 134] = sub_3c8a5d8dAddress
                            require ext_code.size(sub_1c1d3e8dAddress)
                            call sub_1c1d3e8dAddress.liquidateBorrow(address arg1, address arg2) with:
                               value cd[(arg4 + 100)] wei
                                 gas gas_remaining wei
                                args account, sub_3c8a5d8dAddress
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (2 * ceil32(return_data.size)) + 102] = this.address
                            require ext_code.size(sub_3c8a5d8dAddress)
                            staticcall sub_3c8a5d8dAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (2 * ceil32(return_data.size)) + 98] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 102] = ext_call.return_data[0]
                            require ext_code.size(sub_3c8a5d8dAddress)
                            call sub_3c8a5d8dAddress.redeem(uint256 arg1) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0]
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 98] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if not sub_3fd82e21Address:
                                require ext_code.size(stor4)
                                call stor4.deposit() with:
                                   value (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1 wei
                                     gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                call tx.origin with:
                                   value eth.balance(this.address) wei
                                     gas 2300 * is_zero(value) wei
                                if cd[(arg4 + 196)]:
                                    require ext_code.size(stor4)
                                    call stor4.deposit() with:
                                       value (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1 wei
                                         gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(address(cd[(arg4 + 132)]))
                                call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                            else:
                                mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 102] = this.address
                                require ext_code.size(sub_3fd82e21Address)
                                staticcall sub_3fd82e21Address.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 98] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if stor4 == sub_3fd82e21Address:
                                    require ext_code.size(stor4)
                                    staticcall stor4.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if ext_call.return_data[0] < (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1:
                                        revert with 0, 17
                                    require ext_code.size(stor4)
                                    call stor4.0x2e1a7d4d with:
                                         gas gas_remaining wei
                                        args (ext_call.return_data[0] + -(1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) - 1)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    call tx.origin with:
                                       value eth.balance(this.address) wei
                                         gas 2300 * is_zero(value) wei
                                    if cd[(arg4 + 196)]:
                                        require ext_code.size(stor4)
                                        call stor4.deposit() with:
                                           value (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1 wei
                                             gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(address(cd[(arg4 + 132)]))
                                    call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                else:
                                    if sub_ccccbcf7Address != sub_3fd82e21Address:
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 98] = 2
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 130] = sub_3fd82e21Address
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 162] = stor4
                                        if 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 194] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 198] = ext_call.return_data[0]
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 230] = 0
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 262] = 160
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 358] = 2
                                        idx = 0
                                        s = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 390
                                        t = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 130
                                        while idx < 2:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 294] = this.address
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 326] = block.timestamp + 3600
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 3600, 2, mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 390 len 64]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 194 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 194
                                        require return_data.size >= 32
                                        _4944 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28]
                                        require mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                        require ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 225 < ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + return_data.size + 194
                                        _5020 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]
                                        if mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194] > test266151307():
                                            revert with 0, 65
                                        if ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]) + 1 < 0 or ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]) + 195 > test266151307():
                                            revert with 0, 65
                                        mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]) + 195
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 194] = _5020
                                        require return_data.size >= _4944 + (32 * _5020) + 32
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 226 len 32 * _5020] = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + _4944 + 226 len 32 * _5020]
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(stor4)
                                        staticcall stor4.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7928 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if mem[_7928] < (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1:
                                            revert with 0, 17
                                        require ext_code.size(stor4)
                                        call stor4.0x2e1a7d4d with:
                                             gas gas_remaining wei
                                            args (mem[_7928] + -(1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) - 1)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        call tx.origin with:
                                           value eth.balance(this.address) wei
                                             gas 2300 * is_zero(value) wei
                                        if not cd[(arg4 + 196)]:
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            require ext_code.size(address(cd[(arg4 + 132)]))
                                            call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8824 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_8824] == bool(mem[_8824])
                                        else:
                                            require ext_code.size(stor4)
                                            call stor4.deposit() with:
                                               value (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1 wei
                                                 gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            require ext_code.size(address(cd[(arg4 + 132)]))
                                            call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9048 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_9048] == bool(mem[_9048])
                                    else:
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 98] = 3
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 130] = sub_3fd82e21Address
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 162] = sub_e36c61f1Address
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 194] = stor4
                                        if 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 226] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 230] = ext_call.return_data[0]
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 262] = 0
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 294] = 160
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 390] = 3
                                        idx = 0
                                        s = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 422
                                        t = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 130
                                        while idx < 3:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 326] = this.address
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 358] = block.timestamp + 3600
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 3600, 3, mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 422 len 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 226 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 226
                                        require return_data.size >= 32
                                        _4945 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28]
                                        require mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                        require ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 257 < ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + return_data.size + 226
                                        _5021 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]
                                        if mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226] > test266151307():
                                            revert with 0, 65
                                        if ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 1 < 0 or ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 227 > test266151307():
                                            revert with 0, 65
                                        mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 227
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 226] = _5021
                                        require return_data.size >= _4945 + (32 * _5021) + 32
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 258 len 32 * _5021] = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + _4945 + 258 len 32 * _5021]
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(stor4)
                                        staticcall stor4.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7929 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if mem[_7929] < (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1:
                                            revert with 0, 17
                                        require ext_code.size(stor4)
                                        call stor4.0x2e1a7d4d with:
                                             gas gas_remaining wei
                                            args (mem[_7929] + -(1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) - 1)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        call tx.origin with:
                                           value eth.balance(this.address) wei
                                             gas 2300 * is_zero(value) wei
                                        if not cd[(arg4 + 196)]:
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            require ext_code.size(address(cd[(arg4 + 132)]))
                                            call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8825 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_8825] == bool(mem[_8825])
                                        else:
                                            require ext_code.size(stor4)
                                            call stor4.deposit() with:
                                               value (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1 wei
                                                 gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            require ext_code.size(address(cd[(arg4 + 132)]))
                                            call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9049 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_9049] == bool(mem[_9049])
                        else:
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (2 * ceil32(return_data.size)) + 102] = account
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (2 * ceil32(return_data.size)) + 134] = cd[(arg4 + 100)]
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (2 * ceil32(return_data.size)) + 166] = sub_3c8a5d8dAddress
                            require ext_code.size(sub_1c1d3e8dAddress)
                            call sub_1c1d3e8dAddress.liquidateBorrow(address arg1, uint256 arg2, address arg3) with:
                                 gas gas_remaining wei
                                args account, cd[(arg4 + 100)], sub_3c8a5d8dAddress
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (2 * ceil32(return_data.size)) + 98] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 102] = this.address
                            require ext_code.size(sub_3c8a5d8dAddress)
                            staticcall sub_3c8a5d8dAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 98] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 102] = ext_call.return_data[0]
                            require ext_code.size(sub_3c8a5d8dAddress)
                            call sub_3c8a5d8dAddress.redeem(uint256 arg1) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0]
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 98] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if not sub_3fd82e21Address:
                                require ext_code.size(stor4)
                                call stor4.deposit() with:
                                   value (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1 wei
                                     gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                call tx.origin with:
                                   value eth.balance(this.address) wei
                                     gas 2300 * is_zero(value) wei
                                if cd[(arg4 + 196)]:
                                    require ext_code.size(stor4)
                                    call stor4.deposit() with:
                                       value (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1 wei
                                         gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(address(cd[(arg4 + 132)]))
                                call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                            else:
                                mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 102] = this.address
                                require ext_code.size(sub_3fd82e21Address)
                                staticcall sub_3fd82e21Address.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 98] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if stor4 == sub_3fd82e21Address:
                                    require ext_code.size(stor4)
                                    staticcall stor4.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if ext_call.return_data[0] < (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1:
                                        revert with 0, 17
                                    require ext_code.size(stor4)
                                    call stor4.0x2e1a7d4d with:
                                         gas gas_remaining wei
                                        args (ext_call.return_data[0] + -(1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) - 1)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    call tx.origin with:
                                       value eth.balance(this.address) wei
                                         gas 2300 * is_zero(value) wei
                                    if cd[(arg4 + 196)]:
                                        require ext_code.size(stor4)
                                        call stor4.deposit() with:
                                           value (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1 wei
                                             gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(address(cd[(arg4 + 132)]))
                                    call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                else:
                                    if sub_ccccbcf7Address != sub_3fd82e21Address:
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 98] = 2
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 130] = sub_3fd82e21Address
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 162] = stor4
                                        if 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 194] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 198] = ext_call.return_data[0]
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 230] = 0
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 262] = 160
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 358] = 2
                                        idx = 0
                                        s = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 390
                                        t = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 130
                                        while idx < 2:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 294] = this.address
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 326] = block.timestamp + 3600
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 3600, 2, mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 390 len 64]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 194 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (10 * ceil32(return_data.size)) + 194
                                        require return_data.size >= 32
                                        _4942 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28]
                                        require mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                        require ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 225 < ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + return_data.size + 194
                                        _5018 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]
                                        if mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194] > test266151307():
                                            revert with 0, 65
                                        if ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]) + 1 < 0 or ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (10 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]) + 195 > test266151307():
                                            revert with 0, 65
                                        mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (10 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]) + 195
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (10 * ceil32(return_data.size)) + 194] = _5018
                                        require return_data.size >= _4942 + (32 * _5018) + 32
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (10 * ceil32(return_data.size)) + 226 len 32 * _5018] = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + _4942 + 226 len 32 * _5018]
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(stor4)
                                        staticcall stor4.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7926 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if mem[_7926] < (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1:
                                            revert with 0, 17
                                        require ext_code.size(stor4)
                                        call stor4.0x2e1a7d4d with:
                                             gas gas_remaining wei
                                            args (mem[_7926] + -(1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) - 1)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        call tx.origin with:
                                           value eth.balance(this.address) wei
                                             gas 2300 * is_zero(value) wei
                                        if not cd[(arg4 + 196)]:
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            require ext_code.size(address(cd[(arg4 + 132)]))
                                            call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8822 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_8822] == bool(mem[_8822])
                                        else:
                                            require ext_code.size(stor4)
                                            call stor4.deposit() with:
                                               value (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1 wei
                                                 gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            require ext_code.size(address(cd[(arg4 + 132)]))
                                            call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9046 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_9046] == bool(mem[_9046])
                                    else:
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 98] = 3
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 130] = sub_3fd82e21Address
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 162] = sub_e36c61f1Address
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 194] = stor4
                                        if 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 226] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 230] = ext_call.return_data[0]
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 262] = 0
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 294] = 160
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 390] = 3
                                        idx = 0
                                        s = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 422
                                        t = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 130
                                        while idx < 3:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 326] = this.address
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 358] = block.timestamp + 3600
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 3600, 3, mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 422 len 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 226 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (10 * ceil32(return_data.size)) + 226
                                        require return_data.size >= 32
                                        _4943 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28]
                                        require mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                        require ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 257 < ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + return_data.size + 226
                                        _5019 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]
                                        if mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226] > test266151307():
                                            revert with 0, 65
                                        if ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 1 < 0 or ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (10 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 227 > test266151307():
                                            revert with 0, 65
                                        mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (10 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 227
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (10 * ceil32(return_data.size)) + 226] = _5019
                                        require return_data.size >= _4943 + (32 * _5019) + 32
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (10 * ceil32(return_data.size)) + 258 len 32 * _5019] = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + _4943 + 258 len 32 * _5019]
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(stor4)
                                        staticcall stor4.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7927 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if mem[_7927] < (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1:
                                            revert with 0, 17
                                        require ext_code.size(stor4)
                                        call stor4.0x2e1a7d4d with:
                                             gas gas_remaining wei
                                            args (mem[_7927] + -(1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) - 1)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        call tx.origin with:
                                           value eth.balance(this.address) wei
                                             gas 2300 * is_zero(value) wei
                                        if not cd[(arg4 + 196)]:
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            require ext_code.size(address(cd[(arg4 + 132)]))
                                            call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8823 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_8823] == bool(mem[_8823])
                                        else:
                                            require ext_code.size(stor4)
                                            call stor4.deposit() with:
                                               value (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1 wei
                                                 gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            require ext_code.size(address(cd[(arg4 + 132)]))
                                            call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9047 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_9047] == bool(mem[_9047])
            else:
                require ext_code.size(stor4)
                call stor4.0x2e1a7d4d with:
                     gas gas_remaining wei
                    args cd[(arg4 + 100)]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + 102] = stor3
                require ext_code.size(address(cd[(arg4 + 68)]))
                staticcall address(cd[(arg4 + 68)]).0x70a08231 with:
                        gas gas_remaining wei
                       args stor3
                mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + 98] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + ceil32(return_data.size) + 102] = stor3
                require ext_code.size(address(cd[(arg4 + 132)]))
                staticcall address(cd[(arg4 + 132)]).0x70a08231 with:
                        gas gas_remaining wei
                       args stor3
                mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + ceil32(return_data.size) + 98] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if ext_call.return_data[0] > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                    revert with 0, 17
                if ext_call.return_data[0] > 0x4189374bc6a7ef9db22d0e5604189374bc6a7ef9db22d0e5604189374bc6a7:
                    revert with 0, 17
                if 1000 * ext_call.return_data[0] and cd[(arg4 + 100)] > -1 / 1000 * ext_call.return_data[0]:
                    revert with 0, 17
                if not 997 * ext_call.return_data[0]:
                    revert with 0, 18
                if 1 > !(1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]):
                    revert with 0, 17
                if cd[(arg4 + 164)]:
                    if cd[(arg4 + 196)]:
                        if not sub_ccccbcf7Address:
                            require ext_code.size(stor4)
                            call stor4.0x2e1a7d4d with:
                                 gas gas_remaining wei
                                args cd[(arg4 + 100)]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (2 * ceil32(return_data.size)) + 134] = sub_3c8a5d8dAddress
                            require ext_code.size(sub_1c1d3e8dAddress)
                            call sub_1c1d3e8dAddress.liquidateBorrow(address arg1, address arg2) with:
                               value cd[(arg4 + 100)] wei
                                 gas gas_remaining wei
                                args account, sub_3c8a5d8dAddress
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (2 * ceil32(return_data.size)) + 102] = this.address
                            require ext_code.size(sub_3c8a5d8dAddress)
                            staticcall sub_3c8a5d8dAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (2 * ceil32(return_data.size)) + 98] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 102] = ext_call.return_data[0]
                            require ext_code.size(sub_3c8a5d8dAddress)
                            call sub_3c8a5d8dAddress.redeem(uint256 arg1) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0]
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 98] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if not sub_3fd82e21Address:
                                require ext_code.size(stor4)
                                call stor4.deposit() with:
                                   value (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1 wei
                                     gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                call tx.origin with:
                                   value eth.balance(this.address) wei
                                     gas 2300 * is_zero(value) wei
                                if cd[(arg4 + 196)]:
                                    require ext_code.size(stor4)
                                    call stor4.deposit() with:
                                       value (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1 wei
                                         gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(address(cd[(arg4 + 132)]))
                                call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                            else:
                                mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 102] = this.address
                                require ext_code.size(sub_3fd82e21Address)
                                staticcall sub_3fd82e21Address.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 98] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if stor4 == sub_3fd82e21Address:
                                    require ext_code.size(stor4)
                                    staticcall stor4.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if ext_call.return_data[0] < (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1:
                                        revert with 0, 17
                                    require ext_code.size(stor4)
                                    call stor4.0x2e1a7d4d with:
                                         gas gas_remaining wei
                                        args (ext_call.return_data[0] + -(1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) - 1)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    call tx.origin with:
                                       value eth.balance(this.address) wei
                                         gas 2300 * is_zero(value) wei
                                    if cd[(arg4 + 196)]:
                                        require ext_code.size(stor4)
                                        call stor4.deposit() with:
                                           value (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1 wei
                                             gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(address(cd[(arg4 + 132)]))
                                    call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                else:
                                    if sub_ccccbcf7Address != sub_3fd82e21Address:
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 98] = 2
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 130] = sub_3fd82e21Address
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 162] = stor4
                                        if 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 194] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 198] = ext_call.return_data[0]
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 230] = 0
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 262] = 160
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 358] = 2
                                        idx = 0
                                        s = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 390
                                        t = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 130
                                        while idx < 2:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 294] = this.address
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 326] = block.timestamp + 3600
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 3600, 2, mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 390 len 64]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 194 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 194
                                        require return_data.size >= 32
                                        _4948 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28]
                                        require mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                        require ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 225 < ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + return_data.size + 194
                                        _5024 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]
                                        if mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194] > test266151307():
                                            revert with 0, 65
                                        if ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]) + 1 < 0 or ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]) + 195 > test266151307():
                                            revert with 0, 65
                                        mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]) + 195
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 194] = _5024
                                        require return_data.size >= _4948 + (32 * _5024) + 32
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 226 len 32 * _5024] = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + _4948 + 226 len 32 * _5024]
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(stor4)
                                        staticcall stor4.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7932 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if mem[_7932] < (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1:
                                            revert with 0, 17
                                        require ext_code.size(stor4)
                                        call stor4.0x2e1a7d4d with:
                                             gas gas_remaining wei
                                            args (mem[_7932] + -(1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) - 1)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        call tx.origin with:
                                           value eth.balance(this.address) wei
                                             gas 2300 * is_zero(value) wei
                                        if not cd[(arg4 + 196)]:
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            require ext_code.size(address(cd[(arg4 + 132)]))
                                            call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8828 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_8828] == bool(mem[_8828])
                                        else:
                                            require ext_code.size(stor4)
                                            call stor4.deposit() with:
                                               value (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1 wei
                                                 gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            require ext_code.size(address(cd[(arg4 + 132)]))
                                            call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9052 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_9052] == bool(mem[_9052])
                                    else:
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 98] = 3
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 130] = sub_3fd82e21Address
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 162] = sub_e36c61f1Address
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 194] = stor4
                                        if 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 226] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 230] = ext_call.return_data[0]
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 262] = 0
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 294] = 160
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 390] = 3
                                        idx = 0
                                        s = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 422
                                        t = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 130
                                        while idx < 3:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 326] = this.address
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 358] = block.timestamp + 3600
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 3600, 3, mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 422 len 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 226 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 226
                                        require return_data.size >= 32
                                        _4949 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28]
                                        require mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                        require ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 257 < ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + return_data.size + 226
                                        _5025 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]
                                        if mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226] > test266151307():
                                            revert with 0, 65
                                        if ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 1 < 0 or ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 227 > test266151307():
                                            revert with 0, 65
                                        mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 227
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 226] = _5025
                                        require return_data.size >= _4949 + (32 * _5025) + 32
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 258 len 32 * _5025] = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + _4949 + 258 len 32 * _5025]
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(stor4)
                                        staticcall stor4.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7933 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if mem[_7933] < (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1:
                                            revert with 0, 17
                                        require ext_code.size(stor4)
                                        call stor4.0x2e1a7d4d with:
                                             gas gas_remaining wei
                                            args (mem[_7933] + -(1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) - 1)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        call tx.origin with:
                                           value eth.balance(this.address) wei
                                             gas 2300 * is_zero(value) wei
                                        if not cd[(arg4 + 196)]:
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            require ext_code.size(address(cd[(arg4 + 132)]))
                                            call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8829 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_8829] == bool(mem[_8829])
                                        else:
                                            require ext_code.size(stor4)
                                            call stor4.deposit() with:
                                               value (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1 wei
                                                 gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            require ext_code.size(address(cd[(arg4 + 132)]))
                                            call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9053 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_9053] == bool(mem[_9053])
                        else:
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (2 * ceil32(return_data.size)) + 102] = account
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (2 * ceil32(return_data.size)) + 134] = cd[(arg4 + 100)]
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (2 * ceil32(return_data.size)) + 166] = sub_3c8a5d8dAddress
                            require ext_code.size(sub_1c1d3e8dAddress)
                            call sub_1c1d3e8dAddress.liquidateBorrow(address arg1, uint256 arg2, address arg3) with:
                                 gas gas_remaining wei
                                args account, cd[(arg4 + 100)], sub_3c8a5d8dAddress
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (2 * ceil32(return_data.size)) + 98] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 102] = this.address
                            require ext_code.size(sub_3c8a5d8dAddress)
                            staticcall sub_3c8a5d8dAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 98] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 102] = ext_call.return_data[0]
                            require ext_code.size(sub_3c8a5d8dAddress)
                            call sub_3c8a5d8dAddress.redeem(uint256 arg1) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0]
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 98] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if not sub_3fd82e21Address:
                                require ext_code.size(stor4)
                                call stor4.deposit() with:
                                   value (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1 wei
                                     gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                call tx.origin with:
                                   value eth.balance(this.address) wei
                                     gas 2300 * is_zero(value) wei
                                if cd[(arg4 + 196)]:
                                    require ext_code.size(stor4)
                                    call stor4.deposit() with:
                                       value (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1 wei
                                         gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(address(cd[(arg4 + 132)]))
                                call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                            else:
                                mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 102] = this.address
                                require ext_code.size(sub_3fd82e21Address)
                                staticcall sub_3fd82e21Address.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 98] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if stor4 == sub_3fd82e21Address:
                                    require ext_code.size(stor4)
                                    staticcall stor4.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if ext_call.return_data[0] < (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1:
                                        revert with 0, 17
                                    require ext_code.size(stor4)
                                    call stor4.0x2e1a7d4d with:
                                         gas gas_remaining wei
                                        args (ext_call.return_data[0] + -(1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) - 1)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    call tx.origin with:
                                       value eth.balance(this.address) wei
                                         gas 2300 * is_zero(value) wei
                                    if cd[(arg4 + 196)]:
                                        require ext_code.size(stor4)
                                        call stor4.deposit() with:
                                           value (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1 wei
                                             gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(address(cd[(arg4 + 132)]))
                                    call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                else:
                                    if sub_ccccbcf7Address != sub_3fd82e21Address:
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 98] = 2
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 130] = sub_3fd82e21Address
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 162] = stor4
                                        if 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 194] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 198] = ext_call.return_data[0]
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 230] = 0
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 262] = 160
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 358] = 2
                                        idx = 0
                                        s = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 390
                                        t = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 130
                                        while idx < 2:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 294] = this.address
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 326] = block.timestamp + 3600
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 3600, 2, mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 390 len 64]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 194 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (10 * ceil32(return_data.size)) + 194
                                        require return_data.size >= 32
                                        _4946 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28]
                                        require mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                        require ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 225 < ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + return_data.size + 194
                                        _5022 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]
                                        if mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194] > test266151307():
                                            revert with 0, 65
                                        if ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]) + 1 < 0 or ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (10 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]) + 195 > test266151307():
                                            revert with 0, 65
                                        mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (10 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]) + 195
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (10 * ceil32(return_data.size)) + 194] = _5022
                                        require return_data.size >= _4946 + (32 * _5022) + 32
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (10 * ceil32(return_data.size)) + 226 len 32 * _5022] = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + _4946 + 226 len 32 * _5022]
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(stor4)
                                        staticcall stor4.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7930 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if mem[_7930] < (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1:
                                            revert with 0, 17
                                        require ext_code.size(stor4)
                                        call stor4.0x2e1a7d4d with:
                                             gas gas_remaining wei
                                            args (mem[_7930] + -(1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) - 1)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        call tx.origin with:
                                           value eth.balance(this.address) wei
                                             gas 2300 * is_zero(value) wei
                                        if not cd[(arg4 + 196)]:
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            require ext_code.size(address(cd[(arg4 + 132)]))
                                            call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8826 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_8826] == bool(mem[_8826])
                                        else:
                                            require ext_code.size(stor4)
                                            call stor4.deposit() with:
                                               value (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1 wei
                                                 gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            require ext_code.size(address(cd[(arg4 + 132)]))
                                            call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9050 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_9050] == bool(mem[_9050])
                                    else:
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 98] = 3
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 130] = sub_3fd82e21Address
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 162] = sub_e36c61f1Address
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 194] = stor4
                                        if 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 226] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 230] = ext_call.return_data[0]
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 262] = 0
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 294] = 160
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 390] = 3
                                        idx = 0
                                        s = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 422
                                        t = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 130
                                        while idx < 3:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 326] = this.address
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 358] = block.timestamp + 3600
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 3600, 3, mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 422 len 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 226 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (10 * ceil32(return_data.size)) + 226
                                        require return_data.size >= 32
                                        _4947 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28]
                                        require mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                        require ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 257 < ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + return_data.size + 226
                                        _5023 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]
                                        if mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226] > test266151307():
                                            revert with 0, 65
                                        if ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 1 < 0 or ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (10 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 227 > test266151307():
                                            revert with 0, 65
                                        mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (10 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 227
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (10 * ceil32(return_data.size)) + 226] = _5023
                                        require return_data.size >= _4947 + (32 * _5023) + 32
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (10 * ceil32(return_data.size)) + 258 len 32 * _5023] = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + _4947 + 258 len 32 * _5023]
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(stor4)
                                        staticcall stor4.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7931 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if mem[_7931] < (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1:
                                            revert with 0, 17
                                        require ext_code.size(stor4)
                                        call stor4.0x2e1a7d4d with:
                                             gas gas_remaining wei
                                            args (mem[_7931] + -(1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) - 1)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        call tx.origin with:
                                           value eth.balance(this.address) wei
                                             gas 2300 * is_zero(value) wei
                                        if not cd[(arg4 + 196)]:
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            require ext_code.size(address(cd[(arg4 + 132)]))
                                            call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8827 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_8827] == bool(mem[_8827])
                                        else:
                                            require ext_code.size(stor4)
                                            call stor4.deposit() with:
                                               value (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1 wei
                                                 gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            require ext_code.size(address(cd[(arg4 + 132)]))
                                            call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9051 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_9051] == bool(mem[_9051])
                    else:
                        if not sub_ccccbcf7Address:
                            require ext_code.size(stor4)
                            call stor4.0x2e1a7d4d with:
                                 gas gas_remaining wei
                                args cd[(arg4 + 100)]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (2 * ceil32(return_data.size)) + 134] = sub_3c8a5d8dAddress
                            require ext_code.size(sub_1c1d3e8dAddress)
                            call sub_1c1d3e8dAddress.liquidateBorrow(address arg1, address arg2) with:
                               value cd[(arg4 + 100)] wei
                                 gas gas_remaining wei
                                args account, sub_3c8a5d8dAddress
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (2 * ceil32(return_data.size)) + 102] = this.address
                            require ext_code.size(sub_3c8a5d8dAddress)
                            staticcall sub_3c8a5d8dAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (2 * ceil32(return_data.size)) + 98] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 102] = ext_call.return_data[0]
                            require ext_code.size(sub_3c8a5d8dAddress)
                            call sub_3c8a5d8dAddress.redeem(uint256 arg1) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0]
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 98] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if not sub_3fd82e21Address:
                                require ext_code.size(stor4)
                                call stor4.deposit() with:
                                   value (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1 wei
                                     gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                call tx.origin with:
                                   value eth.balance(this.address) wei
                                     gas 2300 * is_zero(value) wei
                                if cd[(arg4 + 196)]:
                                    require ext_code.size(stor4)
                                    call stor4.deposit() with:
                                       value (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1 wei
                                         gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(address(cd[(arg4 + 132)]))
                                call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                            else:
                                mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 102] = this.address
                                require ext_code.size(sub_3fd82e21Address)
                                staticcall sub_3fd82e21Address.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 98] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if stor4 == sub_3fd82e21Address:
                                    require ext_code.size(stor4)
                                    staticcall stor4.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if ext_call.return_data[0] < (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1:
                                        revert with 0, 17
                                    require ext_code.size(stor4)
                                    call stor4.0x2e1a7d4d with:
                                         gas gas_remaining wei
                                        args (ext_call.return_data[0] + -(1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) - 1)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    call tx.origin with:
                                       value eth.balance(this.address) wei
                                         gas 2300 * is_zero(value) wei
                                    if cd[(arg4 + 196)]:
                                        require ext_code.size(stor4)
                                        call stor4.deposit() with:
                                           value (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1 wei
                                             gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(address(cd[(arg4 + 132)]))
                                    call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                else:
                                    if sub_ccccbcf7Address != sub_3fd82e21Address:
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 98] = 2
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 130] = sub_3fd82e21Address
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 162] = stor4
                                        if 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 194] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 198] = ext_call.return_data[0]
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 230] = 0
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 262] = 160
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 358] = 2
                                        idx = 0
                                        s = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 390
                                        t = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 130
                                        while idx < 2:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 294] = this.address
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 326] = block.timestamp + 3600
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 3600, 2, mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 390 len 64]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 194 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 194
                                        require return_data.size >= 32
                                        _4952 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28]
                                        require mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                        require ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 225 < ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + return_data.size + 194
                                        _5028 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]
                                        if mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194] > test266151307():
                                            revert with 0, 65
                                        if ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]) + 1 < 0 or ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]) + 195 > test266151307():
                                            revert with 0, 65
                                        mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]) + 195
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 194] = _5028
                                        require return_data.size >= _4952 + (32 * _5028) + 32
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 226 len 32 * _5028] = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + _4952 + 226 len 32 * _5028]
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(stor4)
                                        staticcall stor4.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7936 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if mem[_7936] < (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1:
                                            revert with 0, 17
                                        require ext_code.size(stor4)
                                        call stor4.0x2e1a7d4d with:
                                             gas gas_remaining wei
                                            args (mem[_7936] + -(1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) - 1)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        call tx.origin with:
                                           value eth.balance(this.address) wei
                                             gas 2300 * is_zero(value) wei
                                        if not cd[(arg4 + 196)]:
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            require ext_code.size(address(cd[(arg4 + 132)]))
                                            call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8832 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_8832] == bool(mem[_8832])
                                        else:
                                            require ext_code.size(stor4)
                                            call stor4.deposit() with:
                                               value (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1 wei
                                                 gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            require ext_code.size(address(cd[(arg4 + 132)]))
                                            call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9056 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_9056] == bool(mem[_9056])
                                    else:
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 98] = 3
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 130] = sub_3fd82e21Address
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 162] = sub_e36c61f1Address
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 194] = stor4
                                        if 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 226] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 230] = ext_call.return_data[0]
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 262] = 0
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 294] = 160
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 390] = 3
                                        idx = 0
                                        s = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 422
                                        t = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 130
                                        while idx < 3:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 326] = this.address
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 358] = block.timestamp + 3600
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 3600, 3, mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 422 len 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 226 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 226
                                        require return_data.size >= 32
                                        _4953 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28]
                                        require mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                        require ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 257 < ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + return_data.size + 226
                                        _5029 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]
                                        if mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226] > test266151307():
                                            revert with 0, 65
                                        if ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 1 < 0 or ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 227 > test266151307():
                                            revert with 0, 65
                                        mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 227
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 226] = _5029
                                        require return_data.size >= _4953 + (32 * _5029) + 32
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 258 len 32 * _5029] = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + _4953 + 258 len 32 * _5029]
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(stor4)
                                        staticcall stor4.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7937 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if mem[_7937] < (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1:
                                            revert with 0, 17
                                        require ext_code.size(stor4)
                                        call stor4.0x2e1a7d4d with:
                                             gas gas_remaining wei
                                            args (mem[_7937] + -(1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) - 1)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        call tx.origin with:
                                           value eth.balance(this.address) wei
                                             gas 2300 * is_zero(value) wei
                                        if not cd[(arg4 + 196)]:
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            require ext_code.size(address(cd[(arg4 + 132)]))
                                            call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8833 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_8833] == bool(mem[_8833])
                                        else:
                                            require ext_code.size(stor4)
                                            call stor4.deposit() with:
                                               value (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1 wei
                                                 gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            require ext_code.size(address(cd[(arg4 + 132)]))
                                            call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9057 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_9057] == bool(mem[_9057])
                        else:
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (2 * ceil32(return_data.size)) + 102] = account
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (2 * ceil32(return_data.size)) + 134] = cd[(arg4 + 100)]
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (2 * ceil32(return_data.size)) + 166] = sub_3c8a5d8dAddress
                            require ext_code.size(sub_1c1d3e8dAddress)
                            call sub_1c1d3e8dAddress.liquidateBorrow(address arg1, uint256 arg2, address arg3) with:
                                 gas gas_remaining wei
                                args account, cd[(arg4 + 100)], sub_3c8a5d8dAddress
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (2 * ceil32(return_data.size)) + 98] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 102] = this.address
                            require ext_code.size(sub_3c8a5d8dAddress)
                            staticcall sub_3c8a5d8dAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 98] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 102] = ext_call.return_data[0]
                            require ext_code.size(sub_3c8a5d8dAddress)
                            call sub_3c8a5d8dAddress.redeem(uint256 arg1) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0]
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 98] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if not sub_3fd82e21Address:
                                require ext_code.size(stor4)
                                call stor4.deposit() with:
                                   value (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1 wei
                                     gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                call tx.origin with:
                                   value eth.balance(this.address) wei
                                     gas 2300 * is_zero(value) wei
                                if cd[(arg4 + 196)]:
                                    require ext_code.size(stor4)
                                    call stor4.deposit() with:
                                       value (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1 wei
                                         gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(address(cd[(arg4 + 132)]))
                                call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                            else:
                                mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 102] = this.address
                                require ext_code.size(sub_3fd82e21Address)
                                staticcall sub_3fd82e21Address.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 98] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if stor4 == sub_3fd82e21Address:
                                    require ext_code.size(stor4)
                                    staticcall stor4.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if ext_call.return_data[0] < (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1:
                                        revert with 0, 17
                                    require ext_code.size(stor4)
                                    call stor4.0x2e1a7d4d with:
                                         gas gas_remaining wei
                                        args (ext_call.return_data[0] + -(1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) - 1)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    call tx.origin with:
                                       value eth.balance(this.address) wei
                                         gas 2300 * is_zero(value) wei
                                    if cd[(arg4 + 196)]:
                                        require ext_code.size(stor4)
                                        call stor4.deposit() with:
                                           value (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1 wei
                                             gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(address(cd[(arg4 + 132)]))
                                    call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                else:
                                    if sub_ccccbcf7Address != sub_3fd82e21Address:
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 98] = 2
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 130] = sub_3fd82e21Address
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 162] = stor4
                                        if 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 194] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 198] = ext_call.return_data[0]
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 230] = 0
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 262] = 160
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 358] = 2
                                        idx = 0
                                        s = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 390
                                        t = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 130
                                        while idx < 2:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 294] = this.address
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 326] = block.timestamp + 3600
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 3600, 2, mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 390 len 64]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 194 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (10 * ceil32(return_data.size)) + 194
                                        require return_data.size >= 32
                                        _4950 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28]
                                        require mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                        require ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 225 < ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + return_data.size + 194
                                        _5026 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]
                                        if mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194] > test266151307():
                                            revert with 0, 65
                                        if ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]) + 1 < 0 or ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (10 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]) + 195 > test266151307():
                                            revert with 0, 65
                                        mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (10 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]) + 195
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (10 * ceil32(return_data.size)) + 194] = _5026
                                        require return_data.size >= _4950 + (32 * _5026) + 32
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (10 * ceil32(return_data.size)) + 226 len 32 * _5026] = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + _4950 + 226 len 32 * _5026]
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(stor4)
                                        staticcall stor4.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7934 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if mem[_7934] < (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1:
                                            revert with 0, 17
                                        require ext_code.size(stor4)
                                        call stor4.0x2e1a7d4d with:
                                             gas gas_remaining wei
                                            args (mem[_7934] + -(1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) - 1)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        call tx.origin with:
                                           value eth.balance(this.address) wei
                                             gas 2300 * is_zero(value) wei
                                        if not cd[(arg4 + 196)]:
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            require ext_code.size(address(cd[(arg4 + 132)]))
                                            call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8830 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_8830] == bool(mem[_8830])
                                        else:
                                            require ext_code.size(stor4)
                                            call stor4.deposit() with:
                                               value (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1 wei
                                                 gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            require ext_code.size(address(cd[(arg4 + 132)]))
                                            call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9054 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_9054] == bool(mem[_9054])
                                    else:
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 98] = 3
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 130] = sub_3fd82e21Address
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 162] = sub_e36c61f1Address
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 194] = stor4
                                        if 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 226] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 230] = ext_call.return_data[0]
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 262] = 0
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 294] = 160
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 390] = 3
                                        idx = 0
                                        s = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 422
                                        t = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 130
                                        while idx < 3:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 326] = this.address
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 358] = block.timestamp + 3600
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 3600, 3, mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 422 len 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 226 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (10 * ceil32(return_data.size)) + 226
                                        require return_data.size >= 32
                                        _4951 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28]
                                        require mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                        require ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 257 < ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + return_data.size + 226
                                        _5027 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]
                                        if mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226] > test266151307():
                                            revert with 0, 65
                                        if ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 1 < 0 or ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (10 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 227 > test266151307():
                                            revert with 0, 65
                                        mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (10 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 227
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (10 * ceil32(return_data.size)) + 226] = _5027
                                        require return_data.size >= _4951 + (32 * _5027) + 32
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (10 * ceil32(return_data.size)) + 258 len 32 * _5027] = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + _4951 + 258 len 32 * _5027]
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(stor4)
                                        staticcall stor4.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7935 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if mem[_7935] < (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1:
                                            revert with 0, 17
                                        require ext_code.size(stor4)
                                        call stor4.0x2e1a7d4d with:
                                             gas gas_remaining wei
                                            args (mem[_7935] + -(1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) - 1)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        call tx.origin with:
                                           value eth.balance(this.address) wei
                                             gas 2300 * is_zero(value) wei
                                        if not cd[(arg4 + 196)]:
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            require ext_code.size(address(cd[(arg4 + 132)]))
                                            call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8831 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_8831] == bool(mem[_8831])
                                        else:
                                            require ext_code.size(stor4)
                                            call stor4.deposit() with:
                                               value (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1 wei
                                                 gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            require ext_code.size(address(cd[(arg4 + 132)]))
                                            call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9055 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_9055] == bool(mem[_9055])
                else:
                    if cd[(arg4 + 196)]:
                        if not sub_ccccbcf7Address:
                            require ext_code.size(stor4)
                            call stor4.0x2e1a7d4d with:
                                 gas gas_remaining wei
                                args cd[(arg4 + 100)]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (2 * ceil32(return_data.size)) + 134] = sub_3c8a5d8dAddress
                            require ext_code.size(sub_1c1d3e8dAddress)
                            call sub_1c1d3e8dAddress.liquidateBorrow(address arg1, address arg2) with:
                               value cd[(arg4 + 100)] wei
                                 gas gas_remaining wei
                                args account, sub_3c8a5d8dAddress
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (2 * ceil32(return_data.size)) + 102] = this.address
                            require ext_code.size(sub_3c8a5d8dAddress)
                            staticcall sub_3c8a5d8dAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (2 * ceil32(return_data.size)) + 98] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 102] = ext_call.return_data[0]
                            require ext_code.size(sub_3c8a5d8dAddress)
                            call sub_3c8a5d8dAddress.redeem(uint256 arg1) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0]
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 98] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if not sub_3fd82e21Address:
                                require ext_code.size(stor4)
                                call stor4.deposit() with:
                                   value (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1 wei
                                     gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                call tx.origin with:
                                   value eth.balance(this.address) wei
                                     gas 2300 * is_zero(value) wei
                                if cd[(arg4 + 196)]:
                                    require ext_code.size(stor4)
                                    call stor4.deposit() with:
                                       value (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1 wei
                                         gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(address(cd[(arg4 + 132)]))
                                call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                            else:
                                mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 102] = this.address
                                require ext_code.size(sub_3fd82e21Address)
                                staticcall sub_3fd82e21Address.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 98] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if stor4 == sub_3fd82e21Address:
                                    require ext_code.size(stor4)
                                    staticcall stor4.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if ext_call.return_data[0] < (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1:
                                        revert with 0, 17
                                    require ext_code.size(stor4)
                                    call stor4.0x2e1a7d4d with:
                                         gas gas_remaining wei
                                        args (ext_call.return_data[0] + -(1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) - 1)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    call tx.origin with:
                                       value eth.balance(this.address) wei
                                         gas 2300 * is_zero(value) wei
                                    if cd[(arg4 + 196)]:
                                        require ext_code.size(stor4)
                                        call stor4.deposit() with:
                                           value (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1 wei
                                             gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(address(cd[(arg4 + 132)]))
                                    call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                else:
                                    if sub_ccccbcf7Address != sub_3fd82e21Address:
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 98] = 2
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 130] = sub_3fd82e21Address
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 162] = stor4
                                        if 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 194] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 198] = ext_call.return_data[0]
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 230] = 0
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 262] = 160
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 358] = 2
                                        idx = 0
                                        s = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 390
                                        t = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 130
                                        while idx < 2:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 294] = this.address
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 326] = block.timestamp + 3600
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 3600, 2, mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 390 len 64]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 194 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 194
                                        require return_data.size >= 32
                                        _4956 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28]
                                        require mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                        require ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 225 < ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + return_data.size + 194
                                        _5032 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]
                                        if mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194] > test266151307():
                                            revert with 0, 65
                                        if ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]) + 1 < 0 or ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]) + 195 > test266151307():
                                            revert with 0, 65
                                        mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]) + 195
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 194] = _5032
                                        require return_data.size >= _4956 + (32 * _5032) + 32
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 226 len 32 * _5032] = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + _4956 + 226 len 32 * _5032]
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(stor4)
                                        staticcall stor4.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7940 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if mem[_7940] < (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1:
                                            revert with 0, 17
                                        require ext_code.size(stor4)
                                        call stor4.0x2e1a7d4d with:
                                             gas gas_remaining wei
                                            args (mem[_7940] + -(1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) - 1)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        call tx.origin with:
                                           value eth.balance(this.address) wei
                                             gas 2300 * is_zero(value) wei
                                        if not cd[(arg4 + 196)]:
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            require ext_code.size(address(cd[(arg4 + 132)]))
                                            call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8836 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_8836] == bool(mem[_8836])
                                        else:
                                            require ext_code.size(stor4)
                                            call stor4.deposit() with:
                                               value (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1 wei
                                                 gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            require ext_code.size(address(cd[(arg4 + 132)]))
                                            call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9060 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_9060] == bool(mem[_9060])
                                    else:
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 98] = 3
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 130] = sub_3fd82e21Address
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 162] = sub_e36c61f1Address
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 194] = stor4
                                        if 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 226] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 230] = ext_call.return_data[0]
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 262] = 0
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 294] = 160
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 390] = 3
                                        idx = 0
                                        s = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 422
                                        t = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 130
                                        while idx < 3:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 326] = this.address
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 358] = block.timestamp + 3600
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 3600, 3, mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 422 len 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 226 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 226
                                        require return_data.size >= 32
                                        _4957 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28]
                                        require mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                        require ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 257 < ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + return_data.size + 226
                                        _5033 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]
                                        if mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226] > test266151307():
                                            revert with 0, 65
                                        if ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 1 < 0 or ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 227 > test266151307():
                                            revert with 0, 65
                                        mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 227
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 226] = _5033
                                        require return_data.size >= _4957 + (32 * _5033) + 32
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 258 len 32 * _5033] = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + _4957 + 258 len 32 * _5033]
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(stor4)
                                        staticcall stor4.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7941 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if mem[_7941] < (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1:
                                            revert with 0, 17
                                        require ext_code.size(stor4)
                                        call stor4.0x2e1a7d4d with:
                                             gas gas_remaining wei
                                            args (mem[_7941] + -(1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) - 1)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        call tx.origin with:
                                           value eth.balance(this.address) wei
                                             gas 2300 * is_zero(value) wei
                                        if not cd[(arg4 + 196)]:
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            require ext_code.size(address(cd[(arg4 + 132)]))
                                            call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8837 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_8837] == bool(mem[_8837])
                                        else:
                                            require ext_code.size(stor4)
                                            call stor4.deposit() with:
                                               value (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1 wei
                                                 gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            require ext_code.size(address(cd[(arg4 + 132)]))
                                            call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9061 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_9061] == bool(mem[_9061])
                        else:
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (2 * ceil32(return_data.size)) + 102] = account
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (2 * ceil32(return_data.size)) + 134] = cd[(arg4 + 100)]
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (2 * ceil32(return_data.size)) + 166] = sub_3c8a5d8dAddress
                            require ext_code.size(sub_1c1d3e8dAddress)
                            call sub_1c1d3e8dAddress.liquidateBorrow(address arg1, uint256 arg2, address arg3) with:
                                 gas gas_remaining wei
                                args account, cd[(arg4 + 100)], sub_3c8a5d8dAddress
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (2 * ceil32(return_data.size)) + 98] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 102] = this.address
                            require ext_code.size(sub_3c8a5d8dAddress)
                            staticcall sub_3c8a5d8dAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 98] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 102] = ext_call.return_data[0]
                            require ext_code.size(sub_3c8a5d8dAddress)
                            call sub_3c8a5d8dAddress.redeem(uint256 arg1) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0]
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 98] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if not sub_3fd82e21Address:
                                require ext_code.size(stor4)
                                call stor4.deposit() with:
                                   value (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1 wei
                                     gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                call tx.origin with:
                                   value eth.balance(this.address) wei
                                     gas 2300 * is_zero(value) wei
                                if cd[(arg4 + 196)]:
                                    require ext_code.size(stor4)
                                    call stor4.deposit() with:
                                       value (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1 wei
                                         gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(address(cd[(arg4 + 132)]))
                                call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                            else:
                                mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 102] = this.address
                                require ext_code.size(sub_3fd82e21Address)
                                staticcall sub_3fd82e21Address.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 98] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if stor4 == sub_3fd82e21Address:
                                    require ext_code.size(stor4)
                                    staticcall stor4.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if ext_call.return_data[0] < (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1:
                                        revert with 0, 17
                                    require ext_code.size(stor4)
                                    call stor4.0x2e1a7d4d with:
                                         gas gas_remaining wei
                                        args (ext_call.return_data[0] + -(1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) - 1)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    call tx.origin with:
                                       value eth.balance(this.address) wei
                                         gas 2300 * is_zero(value) wei
                                    if cd[(arg4 + 196)]:
                                        require ext_code.size(stor4)
                                        call stor4.deposit() with:
                                           value (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1 wei
                                             gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(address(cd[(arg4 + 132)]))
                                    call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                else:
                                    if sub_ccccbcf7Address != sub_3fd82e21Address:
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 98] = 2
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 130] = sub_3fd82e21Address
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 162] = stor4
                                        if 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 194] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 198] = ext_call.return_data[0]
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 230] = 0
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 262] = 160
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 358] = 2
                                        idx = 0
                                        s = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 390
                                        t = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 130
                                        while idx < 2:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 294] = this.address
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 326] = block.timestamp + 3600
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 3600, 2, mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 390 len 64]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 194 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (10 * ceil32(return_data.size)) + 194
                                        require return_data.size >= 32
                                        _4954 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28]
                                        require mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                        require ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 225 < ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + return_data.size + 194
                                        _5030 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]
                                        if mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194] > test266151307():
                                            revert with 0, 65
                                        if ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]) + 1 < 0 or ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (10 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]) + 195 > test266151307():
                                            revert with 0, 65
                                        mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (10 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]) + 195
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (10 * ceil32(return_data.size)) + 194] = _5030
                                        require return_data.size >= _4954 + (32 * _5030) + 32
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (10 * ceil32(return_data.size)) + 226 len 32 * _5030] = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + _4954 + 226 len 32 * _5030]
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(stor4)
                                        staticcall stor4.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7938 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if mem[_7938] < (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1:
                                            revert with 0, 17
                                        require ext_code.size(stor4)
                                        call stor4.0x2e1a7d4d with:
                                             gas gas_remaining wei
                                            args (mem[_7938] + -(1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) - 1)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        call tx.origin with:
                                           value eth.balance(this.address) wei
                                             gas 2300 * is_zero(value) wei
                                        if not cd[(arg4 + 196)]:
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            require ext_code.size(address(cd[(arg4 + 132)]))
                                            call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8834 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_8834] == bool(mem[_8834])
                                        else:
                                            require ext_code.size(stor4)
                                            call stor4.deposit() with:
                                               value (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1 wei
                                                 gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            require ext_code.size(address(cd[(arg4 + 132)]))
                                            call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9058 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_9058] == bool(mem[_9058])
                                    else:
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 98] = 3
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 130] = sub_3fd82e21Address
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 162] = sub_e36c61f1Address
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 194] = stor4
                                        if 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 226] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 230] = ext_call.return_data[0]
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 262] = 0
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 294] = 160
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 390] = 3
                                        idx = 0
                                        s = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 422
                                        t = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 130
                                        while idx < 3:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 326] = this.address
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 358] = block.timestamp + 3600
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 3600, 3, mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 422 len 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 226 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (10 * ceil32(return_data.size)) + 226
                                        require return_data.size >= 32
                                        _4955 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28]
                                        require mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                        require ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 257 < ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + return_data.size + 226
                                        _5031 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]
                                        if mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226] > test266151307():
                                            revert with 0, 65
                                        if ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 1 < 0 or ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (10 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 227 > test266151307():
                                            revert with 0, 65
                                        mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (10 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 227
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (10 * ceil32(return_data.size)) + 226] = _5031
                                        require return_data.size >= _4955 + (32 * _5031) + 32
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (10 * ceil32(return_data.size)) + 258 len 32 * _5031] = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + _4955 + 258 len 32 * _5031]
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(stor4)
                                        staticcall stor4.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7939 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if mem[_7939] < (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1:
                                            revert with 0, 17
                                        require ext_code.size(stor4)
                                        call stor4.0x2e1a7d4d with:
                                             gas gas_remaining wei
                                            args (mem[_7939] + -(1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) - 1)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        call tx.origin with:
                                           value eth.balance(this.address) wei
                                             gas 2300 * is_zero(value) wei
                                        if not cd[(arg4 + 196)]:
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            require ext_code.size(address(cd[(arg4 + 132)]))
                                            call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8835 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_8835] == bool(mem[_8835])
                                        else:
                                            require ext_code.size(stor4)
                                            call stor4.deposit() with:
                                               value (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1 wei
                                                 gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            require ext_code.size(address(cd[(arg4 + 132)]))
                                            call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9059 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_9059] == bool(mem[_9059])
                    else:
                        if not sub_ccccbcf7Address:
                            require ext_code.size(stor4)
                            call stor4.0x2e1a7d4d with:
                                 gas gas_remaining wei
                                args cd[(arg4 + 100)]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (2 * ceil32(return_data.size)) + 134] = sub_3c8a5d8dAddress
                            require ext_code.size(sub_1c1d3e8dAddress)
                            call sub_1c1d3e8dAddress.liquidateBorrow(address arg1, address arg2) with:
                               value cd[(arg4 + 100)] wei
                                 gas gas_remaining wei
                                args account, sub_3c8a5d8dAddress
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (2 * ceil32(return_data.size)) + 102] = this.address
                            require ext_code.size(sub_3c8a5d8dAddress)
                            staticcall sub_3c8a5d8dAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (2 * ceil32(return_data.size)) + 98] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 102] = ext_call.return_data[0]
                            require ext_code.size(sub_3c8a5d8dAddress)
                            call sub_3c8a5d8dAddress.redeem(uint256 arg1) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0]
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 98] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if not sub_3fd82e21Address:
                                require ext_code.size(stor4)
                                call stor4.deposit() with:
                                   value (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1 wei
                                     gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                call tx.origin with:
                                   value eth.balance(this.address) wei
                                     gas 2300 * is_zero(value) wei
                                if cd[(arg4 + 196)]:
                                    require ext_code.size(stor4)
                                    call stor4.deposit() with:
                                       value (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1 wei
                                         gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(address(cd[(arg4 + 132)]))
                                call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                            else:
                                mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 102] = this.address
                                require ext_code.size(sub_3fd82e21Address)
                                staticcall sub_3fd82e21Address.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 98] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if stor4 == sub_3fd82e21Address:
                                    require ext_code.size(stor4)
                                    staticcall stor4.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if ext_call.return_data[0] < (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1:
                                        revert with 0, 17
                                    require ext_code.size(stor4)
                                    call stor4.0x2e1a7d4d with:
                                         gas gas_remaining wei
                                        args (ext_call.return_data[0] + -(1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) - 1)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    call tx.origin with:
                                       value eth.balance(this.address) wei
                                         gas 2300 * is_zero(value) wei
                                    if cd[(arg4 + 196)]:
                                        require ext_code.size(stor4)
                                        call stor4.deposit() with:
                                           value (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1 wei
                                             gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(address(cd[(arg4 + 132)]))
                                    call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                else:
                                    if sub_ccccbcf7Address != sub_3fd82e21Address:
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 98] = 2
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 130] = sub_3fd82e21Address
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 162] = stor4
                                        if 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 194] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 198] = ext_call.return_data[0]
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 230] = 0
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 262] = 160
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 358] = 2
                                        idx = 0
                                        s = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 390
                                        t = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 130
                                        while idx < 2:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 294] = this.address
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 326] = block.timestamp + 3600
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 3600, 2, mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 390 len 64]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 194 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 194
                                        require return_data.size >= 32
                                        _4960 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28]
                                        require mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                        require ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 225 < ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + return_data.size + 194
                                        _5036 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]
                                        if mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194] > test266151307():
                                            revert with 0, 65
                                        if ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]) + 1 < 0 or ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]) + 195 > test266151307():
                                            revert with 0, 65
                                        mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]) + 195
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 194] = _5036
                                        require return_data.size >= _4960 + (32 * _5036) + 32
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 226 len 32 * _5036] = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + _4960 + 226 len 32 * _5036]
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(stor4)
                                        staticcall stor4.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7944 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if mem[_7944] < (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1:
                                            revert with 0, 17
                                        require ext_code.size(stor4)
                                        call stor4.0x2e1a7d4d with:
                                             gas gas_remaining wei
                                            args (mem[_7944] + -(1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) - 1)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        call tx.origin with:
                                           value eth.balance(this.address) wei
                                             gas 2300 * is_zero(value) wei
                                        if not cd[(arg4 + 196)]:
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            require ext_code.size(address(cd[(arg4 + 132)]))
                                            call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8840 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_8840] == bool(mem[_8840])
                                        else:
                                            require ext_code.size(stor4)
                                            call stor4.deposit() with:
                                               value (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1 wei
                                                 gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            require ext_code.size(address(cd[(arg4 + 132)]))
                                            call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9064 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_9064] == bool(mem[_9064])
                                    else:
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 98] = 3
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 130] = sub_3fd82e21Address
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 162] = sub_e36c61f1Address
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 194] = stor4
                                        if 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 226] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 230] = ext_call.return_data[0]
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 262] = 0
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 294] = 160
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 390] = 3
                                        idx = 0
                                        s = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 422
                                        t = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 130
                                        while idx < 3:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 326] = this.address
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 358] = block.timestamp + 3600
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 3600, 3, mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 422 len 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 226 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 226
                                        require return_data.size >= 32
                                        _4961 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28]
                                        require mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                        require ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 257 < ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + return_data.size + 226
                                        _5037 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]
                                        if mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226] > test266151307():
                                            revert with 0, 65
                                        if ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 1 < 0 or ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 227 > test266151307():
                                            revert with 0, 65
                                        mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 227
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 226] = _5037
                                        require return_data.size >= _4961 + (32 * _5037) + 32
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 258 len 32 * _5037] = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + _4961 + 258 len 32 * _5037]
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(stor4)
                                        staticcall stor4.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7945 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if mem[_7945] < (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1:
                                            revert with 0, 17
                                        require ext_code.size(stor4)
                                        call stor4.0x2e1a7d4d with:
                                             gas gas_remaining wei
                                            args (mem[_7945] + -(1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) - 1)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        call tx.origin with:
                                           value eth.balance(this.address) wei
                                             gas 2300 * is_zero(value) wei
                                        if not cd[(arg4 + 196)]:
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            require ext_code.size(address(cd[(arg4 + 132)]))
                                            call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8841 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_8841] == bool(mem[_8841])
                                        else:
                                            require ext_code.size(stor4)
                                            call stor4.deposit() with:
                                               value (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1 wei
                                                 gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            require ext_code.size(address(cd[(arg4 + 132)]))
                                            call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9065 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_9065] == bool(mem[_9065])
                        else:
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (2 * ceil32(return_data.size)) + 102] = account
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (2 * ceil32(return_data.size)) + 134] = cd[(arg4 + 100)]
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (2 * ceil32(return_data.size)) + 166] = sub_3c8a5d8dAddress
                            require ext_code.size(sub_1c1d3e8dAddress)
                            call sub_1c1d3e8dAddress.liquidateBorrow(address arg1, uint256 arg2, address arg3) with:
                                 gas gas_remaining wei
                                args account, cd[(arg4 + 100)], sub_3c8a5d8dAddress
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (2 * ceil32(return_data.size)) + 98] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 102] = this.address
                            require ext_code.size(sub_3c8a5d8dAddress)
                            staticcall sub_3c8a5d8dAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 98] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 102] = ext_call.return_data[0]
                            require ext_code.size(sub_3c8a5d8dAddress)
                            call sub_3c8a5d8dAddress.redeem(uint256 arg1) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0]
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 98] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if not sub_3fd82e21Address:
                                require ext_code.size(stor4)
                                call stor4.deposit() with:
                                   value (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1 wei
                                     gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                call tx.origin with:
                                   value eth.balance(this.address) wei
                                     gas 2300 * is_zero(value) wei
                                if cd[(arg4 + 196)]:
                                    require ext_code.size(stor4)
                                    call stor4.deposit() with:
                                       value (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1 wei
                                         gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(address(cd[(arg4 + 132)]))
                                call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                            else:
                                mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 102] = this.address
                                require ext_code.size(sub_3fd82e21Address)
                                staticcall sub_3fd82e21Address.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 98] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if stor4 == sub_3fd82e21Address:
                                    require ext_code.size(stor4)
                                    staticcall stor4.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if ext_call.return_data[0] < (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1:
                                        revert with 0, 17
                                    require ext_code.size(stor4)
                                    call stor4.0x2e1a7d4d with:
                                         gas gas_remaining wei
                                        args (ext_call.return_data[0] + -(1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) - 1)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    call tx.origin with:
                                       value eth.balance(this.address) wei
                                         gas 2300 * is_zero(value) wei
                                    if cd[(arg4 + 196)]:
                                        require ext_code.size(stor4)
                                        call stor4.deposit() with:
                                           value (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1 wei
                                             gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(address(cd[(arg4 + 132)]))
                                    call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                else:
                                    if sub_ccccbcf7Address != sub_3fd82e21Address:
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 98] = 2
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 130] = sub_3fd82e21Address
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 162] = stor4
                                        if 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 194] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 198] = ext_call.return_data[0]
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 230] = 0
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 262] = 160
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 358] = 2
                                        idx = 0
                                        s = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 390
                                        t = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 130
                                        while idx < 2:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 294] = this.address
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 326] = block.timestamp + 3600
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 3600, 2, mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 390 len 64]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 194 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (10 * ceil32(return_data.size)) + 194
                                        require return_data.size >= 32
                                        _4958 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28]
                                        require mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                        require ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 225 < ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + return_data.size + 194
                                        _5034 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]
                                        if mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194] > test266151307():
                                            revert with 0, 65
                                        if ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]) + 1 < 0 or ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (10 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]) + 195 > test266151307():
                                            revert with 0, 65
                                        mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (10 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 194 len 4], ext_call.return_data[0 len 28] + 194]) + 195
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (10 * ceil32(return_data.size)) + 194] = _5034
                                        require return_data.size >= _4958 + (32 * _5034) + 32
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (10 * ceil32(return_data.size)) + 226 len 32 * _5034] = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + _4958 + 226 len 32 * _5034]
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(stor4)
                                        staticcall stor4.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7942 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if mem[_7942] < (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1:
                                            revert with 0, 17
                                        require ext_code.size(stor4)
                                        call stor4.0x2e1a7d4d with:
                                             gas gas_remaining wei
                                            args (mem[_7942] + -(1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) - 1)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        call tx.origin with:
                                           value eth.balance(this.address) wei
                                             gas 2300 * is_zero(value) wei
                                        if not cd[(arg4 + 196)]:
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            require ext_code.size(address(cd[(arg4 + 132)]))
                                            call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8838 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_8838] == bool(mem[_8838])
                                        else:
                                            require ext_code.size(stor4)
                                            call stor4.deposit() with:
                                               value (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1 wei
                                                 gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            require ext_code.size(address(cd[(arg4 + 132)]))
                                            call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9062 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_9062] == bool(mem[_9062])
                                    else:
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 98] = 3
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 130] = sub_3fd82e21Address
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 162] = sub_e36c61f1Address
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 194] = stor4
                                        if 3600 > !block.timestamp:
                                            revert with 0, 17
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 226] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 230] = ext_call.return_data[0]
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 262] = 0
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 294] = 160
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 390] = 3
                                        idx = 0
                                        s = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 422
                                        t = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 130
                                        while idx < 3:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 326] = this.address
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 358] = block.timestamp + 3600
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 3600, 3, mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 422 len 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 226 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (10 * ceil32(return_data.size)) + 226
                                        require return_data.size >= 32
                                        _4959 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28]
                                        require mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                        require ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 257 < ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + return_data.size + 226
                                        _5035 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]
                                        if mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226] > test266151307():
                                            revert with 0, 65
                                        if ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 1 < 0 or ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (10 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 227 > test266151307():
                                            revert with 0, 65
                                        mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (10 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 227
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (10 * ceil32(return_data.size)) + 226] = _5035
                                        require return_data.size >= _4959 + (32 * _5035) + 32
                                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (10 * ceil32(return_data.size)) + 258 len 32 * _5035] = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + _4959 + 258 len 32 * _5035]
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(stor4)
                                        staticcall stor4.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7943 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if mem[_7943] < (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1:
                                            revert with 0, 17
                                        require ext_code.size(stor4)
                                        call stor4.0x2e1a7d4d with:
                                             gas gas_remaining wei
                                            args (mem[_7943] + -(1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) - 1)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        call tx.origin with:
                                           value eth.balance(this.address) wei
                                             gas 2300 * is_zero(value) wei
                                        if not cd[(arg4 + 196)]:
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            require ext_code.size(address(cd[(arg4 + 132)]))
                                            call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _8839 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_8839] == bool(mem[_8839])
                                        else:
                                            require ext_code.size(stor4)
                                            call stor4.deposit() with:
                                               value (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1 wei
                                                 gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            require ext_code.size(address(cd[(arg4 + 132)]))
                                            call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, (1000 * ext_call.return_data[0] * cd[(arg4 + 100)] / 997 * ext_call.return_data[0]) + 1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _9063 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_9063] == bool(mem[_9063])
        else:
            require cd[(arg4 + cd[(arg4 + 228)] + 36)] >= 64
            _14 = mem[128]
            require mem[128] == mem[140 len 20]
            _18 = mem[160]
            require ext_code.size(mem[140 len 20])
            staticcall mem[140 len 20].token0() with:
                    gas gas_remaining wei
            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + 98] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
            require ext_code.size(address(_14))
            staticcall address(_14).token1() with:
                    gas gas_remaining wei
            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + ceil32(return_data.size) + 98] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (2 * ceil32(return_data.size)) + 102] = address(_14)
            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (2 * ceil32(return_data.size)) + 134] = _18
            require ext_code.size(stor4)
            call stor4.0xa9059cbb with:
                 gas gas_remaining wei
                args address(_14), _18
            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (2 * ceil32(return_data.size)) + 98] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == bool(ext_call.return_data[0])
            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 98] = 0
            if address(cd[(arg4 + 68)]) == address(ext_call.return_data[0]):
                if address(cd[(arg4 + 68)]) == ext_call.return_data[12 len 20]:
                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 166] = cd[(arg4 + 100)]
                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 198] = this.address
                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 230] = 128
                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 262] = 0
                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 294 len 0] = None
                    require ext_code.size(address(_14))
                    call address(_14).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                         gas gas_remaining wei
                        args cd[(arg4 + 100)], cd[(arg4 + 100)], address(this.address), 128, 0
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 134] = stor3
                    require ext_code.size(stor4)
                    staticcall stor4.0x70a08231 with:
                            gas gas_remaining wei
                           args stor3
                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 130] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 134] = stor3
                    require ext_code.size(address(cd[(arg4 + 132)]))
                    staticcall address(cd[(arg4 + 132)]).0x70a08231 with:
                            gas gas_remaining wei
                           args stor3
                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 130] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if ext_call.return_data[0] > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                        revert with 0, 17
                    if ext_call.return_data[0] > 0x4189374bc6a7ef9db22d0e5604189374bc6a7ef9db22d0e5604189374bc6a7:
                        revert with 0, 17
                    if 1000 * ext_call.return_data[0] and _18 > -1 / 1000 * ext_call.return_data[0]:
                        revert with 0, 17
                    if not 997 * ext_call.return_data[0]:
                        revert with 0, 18
                    if 1 > !(1000 * ext_call.return_data[0] * _18 / 997 * ext_call.return_data[0]):
                        revert with 0, 17
                    if not sub_ccccbcf7Address:
                        require ext_code.size(stor4)
                        call stor4.0x2e1a7d4d with:
                             gas gas_remaining wei
                            args cd[(arg4 + 100)]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 166] = sub_3c8a5d8dAddress
                        require ext_code.size(sub_1c1d3e8dAddress)
                        call sub_1c1d3e8dAddress.liquidateBorrow(address arg1, address arg2) with:
                           value cd[(arg4 + 100)] wei
                             gas gas_remaining wei
                            args account, sub_3c8a5d8dAddress
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 134] = this.address
                        require ext_code.size(sub_3c8a5d8dAddress)
                        staticcall sub_3c8a5d8dAddress.0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 130] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 134] = ext_call.return_data[0]
                        require ext_code.size(sub_3c8a5d8dAddress)
                        call sub_3c8a5d8dAddress.redeem(uint256 arg1) with:
                             gas gas_remaining wei
                            args ext_call.return_data[0]
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 130] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if not sub_3fd82e21Address:
                            require ext_code.size(stor4)
                            call stor4.deposit() with:
                               value (1000 * ext_call.return_data[0] * _18 / 997 * ext_call.return_data[0]) + 1 wei
                                 gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            call tx.origin with:
                               value eth.balance(this.address) wei
                                 gas 2300 * is_zero(value) wei
                            require ext_code.size(address(cd[(arg4 + 132)]))
                            call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                 gas gas_remaining wei
                                args stor3, (1000 * ext_call.return_data[0] * _18 / 997 * ext_call.return_data[0]) + 1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                        else:
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (10 * ceil32(return_data.size)) + 134] = this.address
                            require ext_code.size(sub_3fd82e21Address)
                            staticcall sub_3fd82e21Address.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (10 * ceil32(return_data.size)) + 130] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if stor4 == sub_3fd82e21Address:
                                require ext_code.size(stor4)
                                staticcall stor4.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if ext_call.return_data[0] < (1000 * ext_call.return_data[0] * _18 / 997 * ext_call.return_data[0]) + 1:
                                    revert with 0, 17
                                require ext_code.size(stor4)
                                call stor4.0x2e1a7d4d with:
                                     gas gas_remaining wei
                                    args (ext_call.return_data[0] + -(1000 * ext_call.return_data[0] * _18 / 997 * ext_call.return_data[0]) - 1)
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                call tx.origin with:
                                   value eth.balance(this.address) wei
                                     gas 2300 * is_zero(value) wei
                                require ext_code.size(address(cd[(arg4 + 132)]))
                                call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                     gas gas_remaining wei
                                    args stor3, (1000 * ext_call.return_data[0] * _18 / 997 * ext_call.return_data[0]) + 1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                            else:
                                if sub_ccccbcf7Address != sub_3fd82e21Address:
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 130] = 2
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 162] = sub_3fd82e21Address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 194] = stor4
                                    if 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 226] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 230] = ext_call.return_data[0]
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 262] = 0
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 294] = 160
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 390] = 2
                                    idx = 0
                                    s = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 422
                                    t = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 162
                                    while idx < 2:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 326] = this.address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 358] = block.timestamp + 3600
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 3600, 2, mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 422 len 64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 226 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 226
                                    require return_data.size >= 32
                                    _7980 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28]
                                    require mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 257 < ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + return_data.size + 226
                                    _8076 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]
                                    if mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226] > test266151307():
                                        revert with 0, 65
                                    if ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 1 < 0 or ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 227 > test266151307():
                                        revert with 0, 65
                                    mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 227
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 226] = _8076
                                    require return_data.size >= _7980 + (32 * _8076) + 32
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 258 len 32 * _8076] = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + _7980 + 258 len 32 * _8076]
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(stor4)
                                    staticcall stor4.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9452 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if mem[_9452] < (1000 * ext_call.return_data[0] * _18 / 997 * ext_call.return_data[0]) + 1:
                                        revert with 0, 17
                                    require ext_code.size(stor4)
                                    call stor4.0x2e1a7d4d with:
                                         gas gas_remaining wei
                                        args (mem[_9452] + -(1000 * ext_call.return_data[0] * _18 / 997 * ext_call.return_data[0]) - 1)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    call tx.origin with:
                                       value eth.balance(this.address) wei
                                         gas 2300 * is_zero(value) wei
                                    mem[mem[64] + 4] = stor3
                                    mem[mem[64] + 36] = (1000 * ext_call.return_data[0] * _18 / 997 * ext_call.return_data[0]) + 1
                                    require ext_code.size(address(cd[(arg4 + 132)]))
                                    call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                         gas gas_remaining wei
                                        args stor3, (1000 * ext_call.return_data[0] * _18 / 997 * ext_call.return_data[0]) + 1
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9676 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_9676] == bool(mem[_9676])
                                else:
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 130] = 3
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 162] = sub_3fd82e21Address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 194] = sub_e36c61f1Address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 226] = stor4
                                    if 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 258] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 262] = ext_call.return_data[0]
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 294] = 0
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 326] = 160
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 422] = 3
                                    idx = 0
                                    s = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 454
                                    t = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 162
                                    while idx < 3:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 358] = this.address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 390] = block.timestamp + 3600
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 3600, 3, mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 454 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 258 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 258
                                    require return_data.size >= 32
                                    _7981 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 258 len 4], ext_call.return_data[0 len 28]
                                    require mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 258 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 258 len 4], ext_call.return_data[0 len 28] + 289 < ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + return_data.size + 258
                                    _8077 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 258 len 4], ext_call.return_data[0 len 28] + 258]
                                    if mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 258 len 4], ext_call.return_data[0 len 28] + 258] > test266151307():
                                        revert with 0, 65
                                    if ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 258 len 4], ext_call.return_data[0 len 28] + 258]) + 1 < 0 or ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 258 len 4], ext_call.return_data[0 len 28] + 258]) + 259 > test266151307():
                                        revert with 0, 65
                                    mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 258 len 4], ext_call.return_data[0 len 28] + 258]) + 259
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 258] = _8077
                                    require return_data.size >= _7981 + (32 * _8077) + 32
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 290 len 32 * _8077] = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + _7981 + 290 len 32 * _8077]
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(stor4)
                                    staticcall stor4.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9453 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if mem[_9453] < (1000 * ext_call.return_data[0] * _18 / 997 * ext_call.return_data[0]) + 1:
                                        revert with 0, 17
                                    require ext_code.size(stor4)
                                    call stor4.0x2e1a7d4d with:
                                         gas gas_remaining wei
                                        args (mem[_9453] + -(1000 * ext_call.return_data[0] * _18 / 997 * ext_call.return_data[0]) - 1)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    call tx.origin with:
                                       value eth.balance(this.address) wei
                                         gas 2300 * is_zero(value) wei
                                    mem[mem[64] + 4] = stor3
                                    mem[mem[64] + 36] = (1000 * ext_call.return_data[0] * _18 / 997 * ext_call.return_data[0]) + 1
                                    require ext_code.size(address(cd[(arg4 + 132)]))
                                    call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                         gas gas_remaining wei
                                        args stor3, (1000 * ext_call.return_data[0] * _18 / 997 * ext_call.return_data[0]) + 1
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9677 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_9677] == bool(mem[_9677])
                    else:
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 134] = account
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 166] = cd[(arg4 + 100)]
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 198] = sub_3c8a5d8dAddress
                        require ext_code.size(sub_1c1d3e8dAddress)
                        call sub_1c1d3e8dAddress.liquidateBorrow(address arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args account, cd[(arg4 + 100)], sub_3c8a5d8dAddress
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 130] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 134] = this.address
                        require ext_code.size(sub_3c8a5d8dAddress)
                        staticcall sub_3c8a5d8dAddress.0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 130] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (10 * ceil32(return_data.size)) + 134] = ext_call.return_data[0]
                        require ext_code.size(sub_3c8a5d8dAddress)
                        call sub_3c8a5d8dAddress.redeem(uint256 arg1) with:
                             gas gas_remaining wei
                            args ext_call.return_data[0]
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (10 * ceil32(return_data.size)) + 130] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if not sub_3fd82e21Address:
                            require ext_code.size(stor4)
                            call stor4.deposit() with:
                               value (1000 * ext_call.return_data[0] * _18 / 997 * ext_call.return_data[0]) + 1 wei
                                 gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            call tx.origin with:
                               value eth.balance(this.address) wei
                                 gas 2300 * is_zero(value) wei
                            require ext_code.size(address(cd[(arg4 + 132)]))
                            call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                 gas gas_remaining wei
                                args stor3, (1000 * ext_call.return_data[0] * _18 / 997 * ext_call.return_data[0]) + 1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                        else:
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 134] = this.address
                            require ext_code.size(sub_3fd82e21Address)
                            staticcall sub_3fd82e21Address.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 130] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if stor4 == sub_3fd82e21Address:
                                require ext_code.size(stor4)
                                staticcall stor4.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if ext_call.return_data[0] < (1000 * ext_call.return_data[0] * _18 / 997 * ext_call.return_data[0]) + 1:
                                    revert with 0, 17
                                require ext_code.size(stor4)
                                call stor4.0x2e1a7d4d with:
                                     gas gas_remaining wei
                                    args (ext_call.return_data[0] + -(1000 * ext_call.return_data[0] * _18 / 997 * ext_call.return_data[0]) - 1)
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                call tx.origin with:
                                   value eth.balance(this.address) wei
                                     gas 2300 * is_zero(value) wei
                                require ext_code.size(address(cd[(arg4 + 132)]))
                                call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                     gas gas_remaining wei
                                    args stor3, (1000 * ext_call.return_data[0] * _18 / 997 * ext_call.return_data[0]) + 1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                            else:
                                if sub_ccccbcf7Address != sub_3fd82e21Address:
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 130] = 2
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 162] = sub_3fd82e21Address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 194] = stor4
                                    if 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 226] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 230] = ext_call.return_data[0]
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 262] = 0
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 294] = 160
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 390] = 2
                                    idx = 0
                                    s = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 422
                                    t = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 162
                                    while idx < 2:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 326] = this.address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 358] = block.timestamp + 3600
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 3600, 2, mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 422 len 64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 226 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (13 * ceil32(return_data.size)) + 226
                                    require return_data.size >= 32
                                    _7978 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28]
                                    require mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 257 < ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + return_data.size + 226
                                    _8074 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]
                                    if mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226] > test266151307():
                                        revert with 0, 65
                                    if ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 1 < 0 or ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (13 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 227 > test266151307():
                                        revert with 0, 65
                                    mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (13 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 227
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (13 * ceil32(return_data.size)) + 226] = _8074
                                    require return_data.size >= _7978 + (32 * _8074) + 32
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (13 * ceil32(return_data.size)) + 258 len 32 * _8074] = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + _7978 + 258 len 32 * _8074]
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(stor4)
                                    staticcall stor4.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9450 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if mem[_9450] < (1000 * ext_call.return_data[0] * _18 / 997 * ext_call.return_data[0]) + 1:
                                        revert with 0, 17
                                    require ext_code.size(stor4)
                                    call stor4.0x2e1a7d4d with:
                                         gas gas_remaining wei
                                        args (mem[_9450] + -(1000 * ext_call.return_data[0] * _18 / 997 * ext_call.return_data[0]) - 1)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    call tx.origin with:
                                       value eth.balance(this.address) wei
                                         gas 2300 * is_zero(value) wei
                                    mem[mem[64] + 4] = stor3
                                    mem[mem[64] + 36] = (1000 * ext_call.return_data[0] * _18 / 997 * ext_call.return_data[0]) + 1
                                    require ext_code.size(address(cd[(arg4 + 132)]))
                                    call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                         gas gas_remaining wei
                                        args stor3, (1000 * ext_call.return_data[0] * _18 / 997 * ext_call.return_data[0]) + 1
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9674 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_9674] == bool(mem[_9674])
                                else:
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 130] = 3
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 162] = sub_3fd82e21Address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 194] = sub_e36c61f1Address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 226] = stor4
                                    if 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 258] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 262] = ext_call.return_data[0]
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 294] = 0
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 326] = 160
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 422] = 3
                                    idx = 0
                                    s = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 454
                                    t = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 162
                                    while idx < 3:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 358] = this.address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 390] = block.timestamp + 3600
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 3600, 3, mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 454 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 258 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (13 * ceil32(return_data.size)) + 258
                                    require return_data.size >= 32
                                    _7979 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 258 len 4], ext_call.return_data[0 len 28]
                                    require mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 258 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 258 len 4], ext_call.return_data[0 len 28] + 289 < ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + return_data.size + 258
                                    _8075 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 258 len 4], ext_call.return_data[0 len 28] + 258]
                                    if mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 258 len 4], ext_call.return_data[0 len 28] + 258] > test266151307():
                                        revert with 0, 65
                                    if ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 258 len 4], ext_call.return_data[0 len 28] + 258]) + 1 < 0 or ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (13 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 258 len 4], ext_call.return_data[0 len 28] + 258]) + 259 > test266151307():
                                        revert with 0, 65
                                    mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (13 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 258 len 4], ext_call.return_data[0 len 28] + 258]) + 259
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (13 * ceil32(return_data.size)) + 258] = _8075
                                    require return_data.size >= _7979 + (32 * _8075) + 32
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (13 * ceil32(return_data.size)) + 290 len 32 * _8075] = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + _7979 + 290 len 32 * _8075]
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(stor4)
                                    staticcall stor4.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9451 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if mem[_9451] < (1000 * ext_call.return_data[0] * _18 / 997 * ext_call.return_data[0]) + 1:
                                        revert with 0, 17
                                    require ext_code.size(stor4)
                                    call stor4.0x2e1a7d4d with:
                                         gas gas_remaining wei
                                        args (mem[_9451] + -(1000 * ext_call.return_data[0] * _18 / 997 * ext_call.return_data[0]) - 1)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    call tx.origin with:
                                       value eth.balance(this.address) wei
                                         gas 2300 * is_zero(value) wei
                                    mem[mem[64] + 4] = stor3
                                    mem[mem[64] + 36] = (1000 * ext_call.return_data[0] * _18 / 997 * ext_call.return_data[0]) + 1
                                    require ext_code.size(address(cd[(arg4 + 132)]))
                                    call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                         gas gas_remaining wei
                                        args stor3, (1000 * ext_call.return_data[0] * _18 / 997 * ext_call.return_data[0]) + 1
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9675 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_9675] == bool(mem[_9675])
                else:
                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 166] = 0
                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 198] = this.address
                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 230] = 128
                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 262] = 0
                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 294 len 0] = None
                    require ext_code.size(address(_14))
                    call address(_14).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                         gas gas_remaining wei
                        args cd[(arg4 + 100)], 0, address(this.address), 128, 0
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 134] = stor3
                    require ext_code.size(stor4)
                    staticcall stor4.0x70a08231 with:
                            gas gas_remaining wei
                           args stor3
                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 130] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 134] = stor3
                    require ext_code.size(address(cd[(arg4 + 132)]))
                    staticcall address(cd[(arg4 + 132)]).0x70a08231 with:
                            gas gas_remaining wei
                           args stor3
                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 130] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if ext_call.return_data[0] > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                        revert with 0, 17
                    if ext_call.return_data[0] > 0x4189374bc6a7ef9db22d0e5604189374bc6a7ef9db22d0e5604189374bc6a7:
                        revert with 0, 17
                    if 1000 * ext_call.return_data[0] and _18 > -1 / 1000 * ext_call.return_data[0]:
                        revert with 0, 17
                    if not 997 * ext_call.return_data[0]:
                        revert with 0, 18
                    if 1 > !(1000 * ext_call.return_data[0] * _18 / 997 * ext_call.return_data[0]):
                        revert with 0, 17
                    if not sub_ccccbcf7Address:
                        require ext_code.size(stor4)
                        call stor4.0x2e1a7d4d with:
                             gas gas_remaining wei
                            args cd[(arg4 + 100)]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 166] = sub_3c8a5d8dAddress
                        require ext_code.size(sub_1c1d3e8dAddress)
                        call sub_1c1d3e8dAddress.liquidateBorrow(address arg1, address arg2) with:
                           value cd[(arg4 + 100)] wei
                             gas gas_remaining wei
                            args account, sub_3c8a5d8dAddress
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 134] = this.address
                        require ext_code.size(sub_3c8a5d8dAddress)
                        staticcall sub_3c8a5d8dAddress.0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 130] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 134] = ext_call.return_data[0]
                        require ext_code.size(sub_3c8a5d8dAddress)
                        call sub_3c8a5d8dAddress.redeem(uint256 arg1) with:
                             gas gas_remaining wei
                            args ext_call.return_data[0]
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 130] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if not sub_3fd82e21Address:
                            require ext_code.size(stor4)
                            call stor4.deposit() with:
                               value (1000 * ext_call.return_data[0] * _18 / 997 * ext_call.return_data[0]) + 1 wei
                                 gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            call tx.origin with:
                               value eth.balance(this.address) wei
                                 gas 2300 * is_zero(value) wei
                            require ext_code.size(address(cd[(arg4 + 132)]))
                            call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                 gas gas_remaining wei
                                args stor3, (1000 * ext_call.return_data[0] * _18 / 997 * ext_call.return_data[0]) + 1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                        else:
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (10 * ceil32(return_data.size)) + 134] = this.address
                            require ext_code.size(sub_3fd82e21Address)
                            staticcall sub_3fd82e21Address.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (10 * ceil32(return_data.size)) + 130] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if stor4 == sub_3fd82e21Address:
                                require ext_code.size(stor4)
                                staticcall stor4.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if ext_call.return_data[0] < (1000 * ext_call.return_data[0] * _18 / 997 * ext_call.return_data[0]) + 1:
                                    revert with 0, 17
                                require ext_code.size(stor4)
                                call stor4.0x2e1a7d4d with:
                                     gas gas_remaining wei
                                    args (ext_call.return_data[0] + -(1000 * ext_call.return_data[0] * _18 / 997 * ext_call.return_data[0]) - 1)
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                call tx.origin with:
                                   value eth.balance(this.address) wei
                                     gas 2300 * is_zero(value) wei
                                require ext_code.size(address(cd[(arg4 + 132)]))
                                call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                     gas gas_remaining wei
                                    args stor3, (1000 * ext_call.return_data[0] * _18 / 997 * ext_call.return_data[0]) + 1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                            else:
                                if sub_ccccbcf7Address != sub_3fd82e21Address:
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 130] = 2
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 162] = sub_3fd82e21Address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 194] = stor4
                                    if 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 226] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 230] = ext_call.return_data[0]
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 262] = 0
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 294] = 160
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 390] = 2
                                    idx = 0
                                    s = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 422
                                    t = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 162
                                    while idx < 2:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 326] = this.address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 358] = block.timestamp + 3600
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 3600, 2, mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 422 len 64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 226 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 226
                                    require return_data.size >= 32
                                    _7988 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28]
                                    require mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 257 < ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + return_data.size + 226
                                    _8084 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]
                                    if mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226] > test266151307():
                                        revert with 0, 65
                                    if ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 1 < 0 or ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 227 > test266151307():
                                        revert with 0, 65
                                    mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 227
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 226] = _8084
                                    require return_data.size >= _7988 + (32 * _8084) + 32
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 258 len 32 * _8084] = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + _7988 + 258 len 32 * _8084]
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(stor4)
                                    staticcall stor4.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9460 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if mem[_9460] < (1000 * ext_call.return_data[0] * _18 / 997 * ext_call.return_data[0]) + 1:
                                        revert with 0, 17
                                    require ext_code.size(stor4)
                                    call stor4.0x2e1a7d4d with:
                                         gas gas_remaining wei
                                        args (mem[_9460] + -(1000 * ext_call.return_data[0] * _18 / 997 * ext_call.return_data[0]) - 1)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    call tx.origin with:
                                       value eth.balance(this.address) wei
                                         gas 2300 * is_zero(value) wei
                                    mem[mem[64] + 4] = stor3
                                    mem[mem[64] + 36] = (1000 * ext_call.return_data[0] * _18 / 997 * ext_call.return_data[0]) + 1
                                    require ext_code.size(address(cd[(arg4 + 132)]))
                                    call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                         gas gas_remaining wei
                                        args stor3, (1000 * ext_call.return_data[0] * _18 / 997 * ext_call.return_data[0]) + 1
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9684 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_9684] == bool(mem[_9684])
                                else:
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 130] = 3
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 162] = sub_3fd82e21Address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 194] = sub_e36c61f1Address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 226] = stor4
                                    if 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 258] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 262] = ext_call.return_data[0]
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 294] = 0
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 326] = 160
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 422] = 3
                                    idx = 0
                                    s = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 454
                                    t = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 162
                                    while idx < 3:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 358] = this.address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 390] = block.timestamp + 3600
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 3600, 3, mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 454 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 258 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 258
                                    require return_data.size >= 32
                                    _7989 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 258 len 4], ext_call.return_data[0 len 28]
                                    require mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 258 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 258 len 4], ext_call.return_data[0 len 28] + 289 < ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + return_data.size + 258
                                    _8085 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 258 len 4], ext_call.return_data[0 len 28] + 258]
                                    if mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 258 len 4], ext_call.return_data[0 len 28] + 258] > test266151307():
                                        revert with 0, 65
                                    if ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 258 len 4], ext_call.return_data[0 len 28] + 258]) + 1 < 0 or ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 258 len 4], ext_call.return_data[0 len 28] + 258]) + 259 > test266151307():
                                        revert with 0, 65
                                    mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 258 len 4], ext_call.return_data[0 len 28] + 258]) + 259
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 258] = _8085
                                    require return_data.size >= _7989 + (32 * _8085) + 32
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 290 len 32 * _8085] = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + _7989 + 290 len 32 * _8085]
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(stor4)
                                    staticcall stor4.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9461 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if mem[_9461] < (1000 * ext_call.return_data[0] * _18 / 997 * ext_call.return_data[0]) + 1:
                                        revert with 0, 17
                                    require ext_code.size(stor4)
                                    call stor4.0x2e1a7d4d with:
                                         gas gas_remaining wei
                                        args (mem[_9461] + -(1000 * ext_call.return_data[0] * _18 / 997 * ext_call.return_data[0]) - 1)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    call tx.origin with:
                                       value eth.balance(this.address) wei
                                         gas 2300 * is_zero(value) wei
                                    mem[mem[64] + 4] = stor3
                                    mem[mem[64] + 36] = (1000 * ext_call.return_data[0] * _18 / 997 * ext_call.return_data[0]) + 1
                                    require ext_code.size(address(cd[(arg4 + 132)]))
                                    call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                         gas gas_remaining wei
                                        args stor3, (1000 * ext_call.return_data[0] * _18 / 997 * ext_call.return_data[0]) + 1
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9685 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_9685] == bool(mem[_9685])
                    else:
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 134] = account
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 166] = cd[(arg4 + 100)]
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 198] = sub_3c8a5d8dAddress
                        require ext_code.size(sub_1c1d3e8dAddress)
                        call sub_1c1d3e8dAddress.liquidateBorrow(address arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args account, cd[(arg4 + 100)], sub_3c8a5d8dAddress
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 130] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 134] = this.address
                        require ext_code.size(sub_3c8a5d8dAddress)
                        staticcall sub_3c8a5d8dAddress.0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 130] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (10 * ceil32(return_data.size)) + 134] = ext_call.return_data[0]
                        require ext_code.size(sub_3c8a5d8dAddress)
                        call sub_3c8a5d8dAddress.redeem(uint256 arg1) with:
                             gas gas_remaining wei
                            args ext_call.return_data[0]
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (10 * ceil32(return_data.size)) + 130] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if not sub_3fd82e21Address:
                            require ext_code.size(stor4)
                            call stor4.deposit() with:
                               value (1000 * ext_call.return_data[0] * _18 / 997 * ext_call.return_data[0]) + 1 wei
                                 gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            call tx.origin with:
                               value eth.balance(this.address) wei
                                 gas 2300 * is_zero(value) wei
                            require ext_code.size(address(cd[(arg4 + 132)]))
                            call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                 gas gas_remaining wei
                                args stor3, (1000 * ext_call.return_data[0] * _18 / 997 * ext_call.return_data[0]) + 1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                        else:
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 134] = this.address
                            require ext_code.size(sub_3fd82e21Address)
                            staticcall sub_3fd82e21Address.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 130] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if stor4 == sub_3fd82e21Address:
                                require ext_code.size(stor4)
                                staticcall stor4.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if ext_call.return_data[0] < (1000 * ext_call.return_data[0] * _18 / 997 * ext_call.return_data[0]) + 1:
                                    revert with 0, 17
                                require ext_code.size(stor4)
                                call stor4.0x2e1a7d4d with:
                                     gas gas_remaining wei
                                    args (ext_call.return_data[0] + -(1000 * ext_call.return_data[0] * _18 / 997 * ext_call.return_data[0]) - 1)
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                call tx.origin with:
                                   value eth.balance(this.address) wei
                                     gas 2300 * is_zero(value) wei
                                require ext_code.size(address(cd[(arg4 + 132)]))
                                call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                     gas gas_remaining wei
                                    args stor3, (1000 * ext_call.return_data[0] * _18 / 997 * ext_call.return_data[0]) + 1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                            else:
                                if sub_ccccbcf7Address != sub_3fd82e21Address:
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 130] = 2
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 162] = sub_3fd82e21Address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 194] = stor4
                                    if 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 226] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 230] = ext_call.return_data[0]
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 262] = 0
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 294] = 160
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 390] = 2
                                    idx = 0
                                    s = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 422
                                    t = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 162
                                    while idx < 2:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 326] = this.address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 358] = block.timestamp + 3600
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 3600, 2, mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 422 len 64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 226 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (13 * ceil32(return_data.size)) + 226
                                    require return_data.size >= 32
                                    _7986 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28]
                                    require mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 257 < ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + return_data.size + 226
                                    _8082 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]
                                    if mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226] > test266151307():
                                        revert with 0, 65
                                    if ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 1 < 0 or ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (13 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 227 > test266151307():
                                        revert with 0, 65
                                    mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (13 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 227
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (13 * ceil32(return_data.size)) + 226] = _8082
                                    require return_data.size >= _7986 + (32 * _8082) + 32
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (13 * ceil32(return_data.size)) + 258 len 32 * _8082] = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + _7986 + 258 len 32 * _8082]
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(stor4)
                                    staticcall stor4.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9458 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if mem[_9458] < (1000 * ext_call.return_data[0] * _18 / 997 * ext_call.return_data[0]) + 1:
                                        revert with 0, 17
                                    require ext_code.size(stor4)
                                    call stor4.0x2e1a7d4d with:
                                         gas gas_remaining wei
                                        args (mem[_9458] + -(1000 * ext_call.return_data[0] * _18 / 997 * ext_call.return_data[0]) - 1)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    call tx.origin with:
                                       value eth.balance(this.address) wei
                                         gas 2300 * is_zero(value) wei
                                    mem[mem[64] + 4] = stor3
                                    mem[mem[64] + 36] = (1000 * ext_call.return_data[0] * _18 / 997 * ext_call.return_data[0]) + 1
                                    require ext_code.size(address(cd[(arg4 + 132)]))
                                    call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                         gas gas_remaining wei
                                        args stor3, (1000 * ext_call.return_data[0] * _18 / 997 * ext_call.return_data[0]) + 1
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9682 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_9682] == bool(mem[_9682])
                                else:
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 130] = 3
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 162] = sub_3fd82e21Address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 194] = sub_e36c61f1Address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 226] = stor4
                                    if 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 258] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 262] = ext_call.return_data[0]
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 294] = 0
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 326] = 160
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 422] = 3
                                    idx = 0
                                    s = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 454
                                    t = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 162
                                    while idx < 3:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 358] = this.address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 390] = block.timestamp + 3600
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 3600, 3, mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 454 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 258 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (13 * ceil32(return_data.size)) + 258
                                    require return_data.size >= 32
                                    _7987 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 258 len 4], ext_call.return_data[0 len 28]
                                    require mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 258 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 258 len 4], ext_call.return_data[0 len 28] + 289 < ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + return_data.size + 258
                                    _8083 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 258 len 4], ext_call.return_data[0 len 28] + 258]
                                    if mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 258 len 4], ext_call.return_data[0 len 28] + 258] > test266151307():
                                        revert with 0, 65
                                    if ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 258 len 4], ext_call.return_data[0 len 28] + 258]) + 1 < 0 or ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (13 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 258 len 4], ext_call.return_data[0 len 28] + 258]) + 259 > test266151307():
                                        revert with 0, 65
                                    mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (13 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 258 len 4], ext_call.return_data[0 len 28] + 258]) + 259
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (13 * ceil32(return_data.size)) + 258] = _8083
                                    require return_data.size >= _7987 + (32 * _8083) + 32
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (13 * ceil32(return_data.size)) + 290 len 32 * _8083] = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + _7987 + 290 len 32 * _8083]
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(stor4)
                                    staticcall stor4.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9459 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if mem[_9459] < (1000 * ext_call.return_data[0] * _18 / 997 * ext_call.return_data[0]) + 1:
                                        revert with 0, 17
                                    require ext_code.size(stor4)
                                    call stor4.0x2e1a7d4d with:
                                         gas gas_remaining wei
                                        args (mem[_9459] + -(1000 * ext_call.return_data[0] * _18 / 997 * ext_call.return_data[0]) - 1)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    call tx.origin with:
                                       value eth.balance(this.address) wei
                                         gas 2300 * is_zero(value) wei
                                    mem[mem[64] + 4] = stor3
                                    mem[mem[64] + 36] = (1000 * ext_call.return_data[0] * _18 / 997 * ext_call.return_data[0]) + 1
                                    require ext_code.size(address(cd[(arg4 + 132)]))
                                    call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                         gas gas_remaining wei
                                        args stor3, (1000 * ext_call.return_data[0] * _18 / 997 * ext_call.return_data[0]) + 1
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9683 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_9683] == bool(mem[_9683])
            else:
                if address(cd[(arg4 + 68)]) == ext_call.return_data[12 len 20]:
                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 166] = cd[(arg4 + 100)]
                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 198] = this.address
                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 230] = 128
                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 262] = 0
                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 294 len 0] = None
                    require ext_code.size(address(_14))
                    call address(_14).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                         gas gas_remaining wei
                        args 0, cd[(arg4 + 100)], address(this.address), 128, 0
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 134] = stor3
                    require ext_code.size(stor4)
                    staticcall stor4.0x70a08231 with:
                            gas gas_remaining wei
                           args stor3
                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 130] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 134] = stor3
                    require ext_code.size(address(cd[(arg4 + 132)]))
                    staticcall address(cd[(arg4 + 132)]).0x70a08231 with:
                            gas gas_remaining wei
                           args stor3
                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 130] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if ext_call.return_data[0] > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                        revert with 0, 17
                    if ext_call.return_data[0] > 0x4189374bc6a7ef9db22d0e5604189374bc6a7ef9db22d0e5604189374bc6a7:
                        revert with 0, 17
                    if 1000 * ext_call.return_data[0] and _18 > -1 / 1000 * ext_call.return_data[0]:
                        revert with 0, 17
                    if not 997 * ext_call.return_data[0]:
                        revert with 0, 18
                    if 1 > !(1000 * ext_call.return_data[0] * _18 / 997 * ext_call.return_data[0]):
                        revert with 0, 17
                    if not sub_ccccbcf7Address:
                        require ext_code.size(stor4)
                        call stor4.0x2e1a7d4d with:
                             gas gas_remaining wei
                            args cd[(arg4 + 100)]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 166] = sub_3c8a5d8dAddress
                        require ext_code.size(sub_1c1d3e8dAddress)
                        call sub_1c1d3e8dAddress.liquidateBorrow(address arg1, address arg2) with:
                           value cd[(arg4 + 100)] wei
                             gas gas_remaining wei
                            args account, sub_3c8a5d8dAddress
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 134] = this.address
                        require ext_code.size(sub_3c8a5d8dAddress)
                        staticcall sub_3c8a5d8dAddress.0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 130] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 134] = ext_call.return_data[0]
                        require ext_code.size(sub_3c8a5d8dAddress)
                        call sub_3c8a5d8dAddress.redeem(uint256 arg1) with:
                             gas gas_remaining wei
                            args ext_call.return_data[0]
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 130] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if not sub_3fd82e21Address:
                            require ext_code.size(stor4)
                            call stor4.deposit() with:
                               value (1000 * ext_call.return_data[0] * _18 / 997 * ext_call.return_data[0]) + 1 wei
                                 gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            call tx.origin with:
                               value eth.balance(this.address) wei
                                 gas 2300 * is_zero(value) wei
                            require ext_code.size(address(cd[(arg4 + 132)]))
                            call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                 gas gas_remaining wei
                                args stor3, (1000 * ext_call.return_data[0] * _18 / 997 * ext_call.return_data[0]) + 1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                        else:
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (10 * ceil32(return_data.size)) + 134] = this.address
                            require ext_code.size(sub_3fd82e21Address)
                            staticcall sub_3fd82e21Address.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (10 * ceil32(return_data.size)) + 130] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if stor4 == sub_3fd82e21Address:
                                require ext_code.size(stor4)
                                staticcall stor4.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if ext_call.return_data[0] < (1000 * ext_call.return_data[0] * _18 / 997 * ext_call.return_data[0]) + 1:
                                    revert with 0, 17
                                require ext_code.size(stor4)
                                call stor4.0x2e1a7d4d with:
                                     gas gas_remaining wei
                                    args (ext_call.return_data[0] + -(1000 * ext_call.return_data[0] * _18 / 997 * ext_call.return_data[0]) - 1)
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                call tx.origin with:
                                   value eth.balance(this.address) wei
                                     gas 2300 * is_zero(value) wei
                                require ext_code.size(address(cd[(arg4 + 132)]))
                                call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                     gas gas_remaining wei
                                    args stor3, (1000 * ext_call.return_data[0] * _18 / 997 * ext_call.return_data[0]) + 1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                            else:
                                if sub_ccccbcf7Address != sub_3fd82e21Address:
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 130] = 2
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 162] = sub_3fd82e21Address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 194] = stor4
                                    if 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 226] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 230] = ext_call.return_data[0]
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 262] = 0
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 294] = 160
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 390] = 2
                                    idx = 0
                                    s = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 422
                                    t = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 162
                                    while idx < 2:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 326] = this.address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 358] = block.timestamp + 3600
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 3600, 2, mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 422 len 64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 226 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 226
                                    require return_data.size >= 32
                                    _7996 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28]
                                    require mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 257 < ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + return_data.size + 226
                                    _8092 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]
                                    if mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226] > test266151307():
                                        revert with 0, 65
                                    if ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 1 < 0 or ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 227 > test266151307():
                                        revert with 0, 65
                                    mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 227
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 226] = _8092
                                    require return_data.size >= _7996 + (32 * _8092) + 32
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 258 len 32 * _8092] = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + _7996 + 258 len 32 * _8092]
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(stor4)
                                    staticcall stor4.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9468 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if mem[_9468] < (1000 * ext_call.return_data[0] * _18 / 997 * ext_call.return_data[0]) + 1:
                                        revert with 0, 17
                                    require ext_code.size(stor4)
                                    call stor4.0x2e1a7d4d with:
                                         gas gas_remaining wei
                                        args (mem[_9468] + -(1000 * ext_call.return_data[0] * _18 / 997 * ext_call.return_data[0]) - 1)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    call tx.origin with:
                                       value eth.balance(this.address) wei
                                         gas 2300 * is_zero(value) wei
                                    mem[mem[64] + 4] = stor3
                                    mem[mem[64] + 36] = (1000 * ext_call.return_data[0] * _18 / 997 * ext_call.return_data[0]) + 1
                                    require ext_code.size(address(cd[(arg4 + 132)]))
                                    call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                         gas gas_remaining wei
                                        args stor3, (1000 * ext_call.return_data[0] * _18 / 997 * ext_call.return_data[0]) + 1
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9692 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_9692] == bool(mem[_9692])
                                else:
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 130] = 3
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 162] = sub_3fd82e21Address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 194] = sub_e36c61f1Address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 226] = stor4
                                    if 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 258] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 262] = ext_call.return_data[0]
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 294] = 0
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 326] = 160
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 422] = 3
                                    idx = 0
                                    s = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 454
                                    t = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 162
                                    while idx < 3:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 358] = this.address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 390] = block.timestamp + 3600
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 3600, 3, mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 454 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 258 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 258
                                    require return_data.size >= 32
                                    _7997 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 258 len 4], ext_call.return_data[0 len 28]
                                    require mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 258 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 258 len 4], ext_call.return_data[0 len 28] + 289 < ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + return_data.size + 258
                                    _8093 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 258 len 4], ext_call.return_data[0 len 28] + 258]
                                    if mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 258 len 4], ext_call.return_data[0 len 28] + 258] > test266151307():
                                        revert with 0, 65
                                    if ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 258 len 4], ext_call.return_data[0 len 28] + 258]) + 1 < 0 or ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 258 len 4], ext_call.return_data[0 len 28] + 258]) + 259 > test266151307():
                                        revert with 0, 65
                                    mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 258 len 4], ext_call.return_data[0 len 28] + 258]) + 259
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 258] = _8093
                                    require return_data.size >= _7997 + (32 * _8093) + 32
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 290 len 32 * _8093] = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + _7997 + 290 len 32 * _8093]
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(stor4)
                                    staticcall stor4.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9469 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if mem[_9469] < (1000 * ext_call.return_data[0] * _18 / 997 * ext_call.return_data[0]) + 1:
                                        revert with 0, 17
                                    require ext_code.size(stor4)
                                    call stor4.0x2e1a7d4d with:
                                         gas gas_remaining wei
                                        args (mem[_9469] + -(1000 * ext_call.return_data[0] * _18 / 997 * ext_call.return_data[0]) - 1)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    call tx.origin with:
                                       value eth.balance(this.address) wei
                                         gas 2300 * is_zero(value) wei
                                    mem[mem[64] + 4] = stor3
                                    mem[mem[64] + 36] = (1000 * ext_call.return_data[0] * _18 / 997 * ext_call.return_data[0]) + 1
                                    require ext_code.size(address(cd[(arg4 + 132)]))
                                    call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                         gas gas_remaining wei
                                        args stor3, (1000 * ext_call.return_data[0] * _18 / 997 * ext_call.return_data[0]) + 1
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9693 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_9693] == bool(mem[_9693])
                    else:
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 134] = account
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 166] = cd[(arg4 + 100)]
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 198] = sub_3c8a5d8dAddress
                        require ext_code.size(sub_1c1d3e8dAddress)
                        call sub_1c1d3e8dAddress.liquidateBorrow(address arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args account, cd[(arg4 + 100)], sub_3c8a5d8dAddress
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 130] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 134] = this.address
                        require ext_code.size(sub_3c8a5d8dAddress)
                        staticcall sub_3c8a5d8dAddress.0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 130] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (10 * ceil32(return_data.size)) + 134] = ext_call.return_data[0]
                        require ext_code.size(sub_3c8a5d8dAddress)
                        call sub_3c8a5d8dAddress.redeem(uint256 arg1) with:
                             gas gas_remaining wei
                            args ext_call.return_data[0]
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (10 * ceil32(return_data.size)) + 130] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if not sub_3fd82e21Address:
                            require ext_code.size(stor4)
                            call stor4.deposit() with:
                               value (1000 * ext_call.return_data[0] * _18 / 997 * ext_call.return_data[0]) + 1 wei
                                 gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            call tx.origin with:
                               value eth.balance(this.address) wei
                                 gas 2300 * is_zero(value) wei
                            require ext_code.size(address(cd[(arg4 + 132)]))
                            call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                 gas gas_remaining wei
                                args stor3, (1000 * ext_call.return_data[0] * _18 / 997 * ext_call.return_data[0]) + 1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                        else:
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 134] = this.address
                            require ext_code.size(sub_3fd82e21Address)
                            staticcall sub_3fd82e21Address.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 130] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if stor4 == sub_3fd82e21Address:
                                require ext_code.size(stor4)
                                staticcall stor4.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if ext_call.return_data[0] < (1000 * ext_call.return_data[0] * _18 / 997 * ext_call.return_data[0]) + 1:
                                    revert with 0, 17
                                require ext_code.size(stor4)
                                call stor4.0x2e1a7d4d with:
                                     gas gas_remaining wei
                                    args (ext_call.return_data[0] + -(1000 * ext_call.return_data[0] * _18 / 997 * ext_call.return_data[0]) - 1)
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                call tx.origin with:
                                   value eth.balance(this.address) wei
                                     gas 2300 * is_zero(value) wei
                                require ext_code.size(address(cd[(arg4 + 132)]))
                                call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                     gas gas_remaining wei
                                    args stor3, (1000 * ext_call.return_data[0] * _18 / 997 * ext_call.return_data[0]) + 1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                            else:
                                if sub_ccccbcf7Address != sub_3fd82e21Address:
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 130] = 2
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 162] = sub_3fd82e21Address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 194] = stor4
                                    if 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 226] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 230] = ext_call.return_data[0]
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 262] = 0
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 294] = 160
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 390] = 2
                                    idx = 0
                                    s = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 422
                                    t = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 162
                                    while idx < 2:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 326] = this.address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 358] = block.timestamp + 3600
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 3600, 2, mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 422 len 64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 226 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (13 * ceil32(return_data.size)) + 226
                                    require return_data.size >= 32
                                    _7994 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28]
                                    require mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 257 < ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + return_data.size + 226
                                    _8090 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]
                                    if mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226] > test266151307():
                                        revert with 0, 65
                                    if ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 1 < 0 or ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (13 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 227 > test266151307():
                                        revert with 0, 65
                                    mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (13 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 227
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (13 * ceil32(return_data.size)) + 226] = _8090
                                    require return_data.size >= _7994 + (32 * _8090) + 32
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (13 * ceil32(return_data.size)) + 258 len 32 * _8090] = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + _7994 + 258 len 32 * _8090]
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(stor4)
                                    staticcall stor4.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9466 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if mem[_9466] < (1000 * ext_call.return_data[0] * _18 / 997 * ext_call.return_data[0]) + 1:
                                        revert with 0, 17
                                    require ext_code.size(stor4)
                                    call stor4.0x2e1a7d4d with:
                                         gas gas_remaining wei
                                        args (mem[_9466] + -(1000 * ext_call.return_data[0] * _18 / 997 * ext_call.return_data[0]) - 1)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    call tx.origin with:
                                       value eth.balance(this.address) wei
                                         gas 2300 * is_zero(value) wei
                                    mem[mem[64] + 4] = stor3
                                    mem[mem[64] + 36] = (1000 * ext_call.return_data[0] * _18 / 997 * ext_call.return_data[0]) + 1
                                    require ext_code.size(address(cd[(arg4 + 132)]))
                                    call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                         gas gas_remaining wei
                                        args stor3, (1000 * ext_call.return_data[0] * _18 / 997 * ext_call.return_data[0]) + 1
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9690 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_9690] == bool(mem[_9690])
                                else:
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 130] = 3
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 162] = sub_3fd82e21Address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 194] = sub_e36c61f1Address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 226] = stor4
                                    if 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 258] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 262] = ext_call.return_data[0]
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 294] = 0
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 326] = 160
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 422] = 3
                                    idx = 0
                                    s = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 454
                                    t = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 162
                                    while idx < 3:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 358] = this.address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 390] = block.timestamp + 3600
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 3600, 3, mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 454 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 258 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (13 * ceil32(return_data.size)) + 258
                                    require return_data.size >= 32
                                    _7995 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 258 len 4], ext_call.return_data[0 len 28]
                                    require mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 258 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 258 len 4], ext_call.return_data[0 len 28] + 289 < ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + return_data.size + 258
                                    _8091 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 258 len 4], ext_call.return_data[0 len 28] + 258]
                                    if mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 258 len 4], ext_call.return_data[0 len 28] + 258] > test266151307():
                                        revert with 0, 65
                                    if ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 258 len 4], ext_call.return_data[0 len 28] + 258]) + 1 < 0 or ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (13 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 258 len 4], ext_call.return_data[0 len 28] + 258]) + 259 > test266151307():
                                        revert with 0, 65
                                    mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (13 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 258 len 4], ext_call.return_data[0 len 28] + 258]) + 259
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (13 * ceil32(return_data.size)) + 258] = _8091
                                    require return_data.size >= _7995 + (32 * _8091) + 32
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (13 * ceil32(return_data.size)) + 290 len 32 * _8091] = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + _7995 + 290 len 32 * _8091]
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(stor4)
                                    staticcall stor4.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9467 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if mem[_9467] < (1000 * ext_call.return_data[0] * _18 / 997 * ext_call.return_data[0]) + 1:
                                        revert with 0, 17
                                    require ext_code.size(stor4)
                                    call stor4.0x2e1a7d4d with:
                                         gas gas_remaining wei
                                        args (mem[_9467] + -(1000 * ext_call.return_data[0] * _18 / 997 * ext_call.return_data[0]) - 1)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    call tx.origin with:
                                       value eth.balance(this.address) wei
                                         gas 2300 * is_zero(value) wei
                                    mem[mem[64] + 4] = stor3
                                    mem[mem[64] + 36] = (1000 * ext_call.return_data[0] * _18 / 997 * ext_call.return_data[0]) + 1
                                    require ext_code.size(address(cd[(arg4 + 132)]))
                                    call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                         gas gas_remaining wei
                                        args stor3, (1000 * ext_call.return_data[0] * _18 / 997 * ext_call.return_data[0]) + 1
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9691 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_9691] == bool(mem[_9691])
                else:
                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 166] = 0
                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 198] = this.address
                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 230] = 128
                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 262] = 0
                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 294 len 0] = None
                    require ext_code.size(address(_14))
                    call address(_14).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                         gas gas_remaining wei
                        args 0, 0, address(this.address), 128, 0
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 134] = stor3
                    require ext_code.size(stor4)
                    staticcall stor4.0x70a08231 with:
                            gas gas_remaining wei
                           args stor3
                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (4 * ceil32(return_data.size)) + 130] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 134] = stor3
                    require ext_code.size(address(cd[(arg4 + 132)]))
                    staticcall address(cd[(arg4 + 132)]).0x70a08231 with:
                            gas gas_remaining wei
                           args stor3
                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (6 * ceil32(return_data.size)) + 130] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if ext_call.return_data[0] > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                        revert with 0, 17
                    if ext_call.return_data[0] > 0x4189374bc6a7ef9db22d0e5604189374bc6a7ef9db22d0e5604189374bc6a7:
                        revert with 0, 17
                    if 1000 * ext_call.return_data[0] and _18 > -1 / 1000 * ext_call.return_data[0]:
                        revert with 0, 17
                    if not 997 * ext_call.return_data[0]:
                        revert with 0, 18
                    if 1 > !(1000 * ext_call.return_data[0] * _18 / 997 * ext_call.return_data[0]):
                        revert with 0, 17
                    if not sub_ccccbcf7Address:
                        require ext_code.size(stor4)
                        call stor4.0x2e1a7d4d with:
                             gas gas_remaining wei
                            args cd[(arg4 + 100)]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 166] = sub_3c8a5d8dAddress
                        require ext_code.size(sub_1c1d3e8dAddress)
                        call sub_1c1d3e8dAddress.liquidateBorrow(address arg1, address arg2) with:
                           value cd[(arg4 + 100)] wei
                             gas gas_remaining wei
                            args account, sub_3c8a5d8dAddress
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 134] = this.address
                        require ext_code.size(sub_3c8a5d8dAddress)
                        staticcall sub_3c8a5d8dAddress.0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 130] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 134] = ext_call.return_data[0]
                        require ext_code.size(sub_3c8a5d8dAddress)
                        call sub_3c8a5d8dAddress.redeem(uint256 arg1) with:
                             gas gas_remaining wei
                            args ext_call.return_data[0]
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 130] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if not sub_3fd82e21Address:
                            require ext_code.size(stor4)
                            call stor4.deposit() with:
                               value (1000 * ext_call.return_data[0] * _18 / 997 * ext_call.return_data[0]) + 1 wei
                                 gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            call tx.origin with:
                               value eth.balance(this.address) wei
                                 gas 2300 * is_zero(value) wei
                            require ext_code.size(address(cd[(arg4 + 132)]))
                            call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                 gas gas_remaining wei
                                args stor3, (1000 * ext_call.return_data[0] * _18 / 997 * ext_call.return_data[0]) + 1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                        else:
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (10 * ceil32(return_data.size)) + 134] = this.address
                            require ext_code.size(sub_3fd82e21Address)
                            staticcall sub_3fd82e21Address.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (10 * ceil32(return_data.size)) + 130] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if stor4 == sub_3fd82e21Address:
                                require ext_code.size(stor4)
                                staticcall stor4.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if ext_call.return_data[0] < (1000 * ext_call.return_data[0] * _18 / 997 * ext_call.return_data[0]) + 1:
                                    revert with 0, 17
                                require ext_code.size(stor4)
                                call stor4.0x2e1a7d4d with:
                                     gas gas_remaining wei
                                    args (ext_call.return_data[0] + -(1000 * ext_call.return_data[0] * _18 / 997 * ext_call.return_data[0]) - 1)
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                call tx.origin with:
                                   value eth.balance(this.address) wei
                                     gas 2300 * is_zero(value) wei
                                require ext_code.size(address(cd[(arg4 + 132)]))
                                call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                     gas gas_remaining wei
                                    args stor3, (1000 * ext_call.return_data[0] * _18 / 997 * ext_call.return_data[0]) + 1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                            else:
                                if sub_ccccbcf7Address != sub_3fd82e21Address:
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 130] = 2
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 162] = sub_3fd82e21Address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 194] = stor4
                                    if 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 226] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 230] = ext_call.return_data[0]
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 262] = 0
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 294] = 160
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 390] = 2
                                    idx = 0
                                    s = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 422
                                    t = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 162
                                    while idx < 2:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 326] = this.address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 358] = block.timestamp + 3600
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 3600, 2, mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 422 len 64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 226 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 226
                                    require return_data.size >= 32
                                    _8004 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28]
                                    require mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 257 < ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + return_data.size + 226
                                    _8100 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]
                                    if mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226] > test266151307():
                                        revert with 0, 65
                                    if ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 1 < 0 or ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 227 > test266151307():
                                        revert with 0, 65
                                    mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 227
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 226] = _8100
                                    require return_data.size >= _8004 + (32 * _8100) + 32
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 258 len 32 * _8100] = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + _8004 + 258 len 32 * _8100]
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(stor4)
                                    staticcall stor4.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9476 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if mem[_9476] < (1000 * ext_call.return_data[0] * _18 / 997 * ext_call.return_data[0]) + 1:
                                        revert with 0, 17
                                    require ext_code.size(stor4)
                                    call stor4.0x2e1a7d4d with:
                                         gas gas_remaining wei
                                        args (mem[_9476] + -(1000 * ext_call.return_data[0] * _18 / 997 * ext_call.return_data[0]) - 1)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    call tx.origin with:
                                       value eth.balance(this.address) wei
                                         gas 2300 * is_zero(value) wei
                                    mem[mem[64] + 4] = stor3
                                    mem[mem[64] + 36] = (1000 * ext_call.return_data[0] * _18 / 997 * ext_call.return_data[0]) + 1
                                    require ext_code.size(address(cd[(arg4 + 132)]))
                                    call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                         gas gas_remaining wei
                                        args stor3, (1000 * ext_call.return_data[0] * _18 / 997 * ext_call.return_data[0]) + 1
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9700 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_9700] == bool(mem[_9700])
                                else:
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 130] = 3
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 162] = sub_3fd82e21Address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 194] = sub_e36c61f1Address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 226] = stor4
                                    if 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 258] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 262] = ext_call.return_data[0]
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 294] = 0
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 326] = 160
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 422] = 3
                                    idx = 0
                                    s = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 454
                                    t = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 162
                                    while idx < 3:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 358] = this.address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 390] = block.timestamp + 3600
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 3600, 3, mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 454 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 258 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 258
                                    require return_data.size >= 32
                                    _8005 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 258 len 4], ext_call.return_data[0 len 28]
                                    require mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 258 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 258 len 4], ext_call.return_data[0 len 28] + 289 < ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + return_data.size + 258
                                    _8101 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 258 len 4], ext_call.return_data[0 len 28] + 258]
                                    if mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 258 len 4], ext_call.return_data[0 len 28] + 258] > test266151307():
                                        revert with 0, 65
                                    if ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 258 len 4], ext_call.return_data[0 len 28] + 258]) + 1 < 0 or ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 258 len 4], ext_call.return_data[0 len 28] + 258]) + 259 > test266151307():
                                        revert with 0, 65
                                    mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 258 len 4], ext_call.return_data[0 len 28] + 258]) + 259
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 258] = _8101
                                    require return_data.size >= _8005 + (32 * _8101) + 32
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 290 len 32 * _8101] = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + _8005 + 290 len 32 * _8101]
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(stor4)
                                    staticcall stor4.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9477 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if mem[_9477] < (1000 * ext_call.return_data[0] * _18 / 997 * ext_call.return_data[0]) + 1:
                                        revert with 0, 17
                                    require ext_code.size(stor4)
                                    call stor4.0x2e1a7d4d with:
                                         gas gas_remaining wei
                                        args (mem[_9477] + -(1000 * ext_call.return_data[0] * _18 / 997 * ext_call.return_data[0]) - 1)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    call tx.origin with:
                                       value eth.balance(this.address) wei
                                         gas 2300 * is_zero(value) wei
                                    mem[mem[64] + 4] = stor3
                                    mem[mem[64] + 36] = (1000 * ext_call.return_data[0] * _18 / 997 * ext_call.return_data[0]) + 1
                                    require ext_code.size(address(cd[(arg4 + 132)]))
                                    call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                         gas gas_remaining wei
                                        args stor3, (1000 * ext_call.return_data[0] * _18 / 997 * ext_call.return_data[0]) + 1
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9701 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_9701] == bool(mem[_9701])
                    else:
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 134] = account
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 166] = cd[(arg4 + 100)]
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 198] = sub_3c8a5d8dAddress
                        require ext_code.size(sub_1c1d3e8dAddress)
                        call sub_1c1d3e8dAddress.liquidateBorrow(address arg1, uint256 arg2, address arg3) with:
                             gas gas_remaining wei
                            args account, cd[(arg4 + 100)], sub_3c8a5d8dAddress
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (7 * ceil32(return_data.size)) + 130] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 134] = this.address
                        require ext_code.size(sub_3c8a5d8dAddress)
                        staticcall sub_3c8a5d8dAddress.0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (8 * ceil32(return_data.size)) + 130] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (10 * ceil32(return_data.size)) + 134] = ext_call.return_data[0]
                        require ext_code.size(sub_3c8a5d8dAddress)
                        call sub_3c8a5d8dAddress.redeem(uint256 arg1) with:
                             gas gas_remaining wei
                            args ext_call.return_data[0]
                        mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (10 * ceil32(return_data.size)) + 130] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if not sub_3fd82e21Address:
                            require ext_code.size(stor4)
                            call stor4.deposit() with:
                               value (1000 * ext_call.return_data[0] * _18 / 997 * ext_call.return_data[0]) + 1 wei
                                 gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            call tx.origin with:
                               value eth.balance(this.address) wei
                                 gas 2300 * is_zero(value) wei
                            require ext_code.size(address(cd[(arg4 + 132)]))
                            call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                 gas gas_remaining wei
                                args stor3, (1000 * ext_call.return_data[0] * _18 / 997 * ext_call.return_data[0]) + 1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                        else:
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 134] = this.address
                            require ext_code.size(sub_3fd82e21Address)
                            staticcall sub_3fd82e21Address.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (11 * ceil32(return_data.size)) + 130] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if stor4 == sub_3fd82e21Address:
                                require ext_code.size(stor4)
                                staticcall stor4.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if ext_call.return_data[0] < (1000 * ext_call.return_data[0] * _18 / 997 * ext_call.return_data[0]) + 1:
                                    revert with 0, 17
                                require ext_code.size(stor4)
                                call stor4.0x2e1a7d4d with:
                                     gas gas_remaining wei
                                    args (ext_call.return_data[0] + -(1000 * ext_call.return_data[0] * _18 / 997 * ext_call.return_data[0]) - 1)
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                call tx.origin with:
                                   value eth.balance(this.address) wei
                                     gas 2300 * is_zero(value) wei
                                require ext_code.size(address(cd[(arg4 + 132)]))
                                call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                     gas gas_remaining wei
                                    args stor3, (1000 * ext_call.return_data[0] * _18 / 997 * ext_call.return_data[0]) + 1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                            else:
                                if sub_ccccbcf7Address != sub_3fd82e21Address:
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 130] = 2
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 162] = sub_3fd82e21Address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 194] = stor4
                                    if 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 226] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 230] = ext_call.return_data[0]
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 262] = 0
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 294] = 160
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 390] = 2
                                    idx = 0
                                    s = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 422
                                    t = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 162
                                    while idx < 2:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 326] = this.address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 358] = block.timestamp + 3600
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 3600, 2, mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 422 len 64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 226 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (13 * ceil32(return_data.size)) + 226
                                    require return_data.size >= 32
                                    _8002 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28]
                                    require mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 257 < ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + return_data.size + 226
                                    _8098 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]
                                    if mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226] > test266151307():
                                        revert with 0, 65
                                    if ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 1 < 0 or ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (13 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 227 > test266151307():
                                        revert with 0, 65
                                    mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (13 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 226 len 4], ext_call.return_data[0 len 28] + 226]) + 227
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (13 * ceil32(return_data.size)) + 226] = _8098
                                    require return_data.size >= _8002 + (32 * _8098) + 32
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (13 * ceil32(return_data.size)) + 258 len 32 * _8098] = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + _8002 + 258 len 32 * _8098]
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(stor4)
                                    staticcall stor4.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9474 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if mem[_9474] < (1000 * ext_call.return_data[0] * _18 / 997 * ext_call.return_data[0]) + 1:
                                        revert with 0, 17
                                    require ext_code.size(stor4)
                                    call stor4.0x2e1a7d4d with:
                                         gas gas_remaining wei
                                        args (mem[_9474] + -(1000 * ext_call.return_data[0] * _18 / 997 * ext_call.return_data[0]) - 1)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    call tx.origin with:
                                       value eth.balance(this.address) wei
                                         gas 2300 * is_zero(value) wei
                                    mem[mem[64] + 4] = stor3
                                    mem[mem[64] + 36] = (1000 * ext_call.return_data[0] * _18 / 997 * ext_call.return_data[0]) + 1
                                    require ext_code.size(address(cd[(arg4 + 132)]))
                                    call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                         gas gas_remaining wei
                                        args stor3, (1000 * ext_call.return_data[0] * _18 / 997 * ext_call.return_data[0]) + 1
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9698 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_9698] == bool(mem[_9698])
                                else:
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 130] = 3
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 162] = sub_3fd82e21Address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 194] = sub_e36c61f1Address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 226] = stor4
                                    if 3600 > !block.timestamp:
                                        revert with 0, 17
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 258] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 262] = ext_call.return_data[0]
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 294] = 0
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 326] = 160
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 422] = 3
                                    idx = 0
                                    s = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 454
                                    t = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 162
                                    while idx < 3:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 358] = this.address
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 390] = block.timestamp + 3600
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 3600, 3, mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 454 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 258 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (13 * ceil32(return_data.size)) + 258
                                    require return_data.size >= 32
                                    _8003 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 258 len 4], ext_call.return_data[0 len 28]
                                    require mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 258 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 258 len 4], ext_call.return_data[0 len 28] + 289 < ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + return_data.size + 258
                                    _8099 = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 258 len 4], ext_call.return_data[0 len 28] + 258]
                                    if mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 258 len 4], ext_call.return_data[0 len 28] + 258] > test266151307():
                                        revert with 0, 65
                                    if ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 258 len 4], ext_call.return_data[0 len 28] + 258]) + 1 < 0 or ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (13 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 258 len 4], ext_call.return_data[0 len 28] + 258]) + 259 > test266151307():
                                        revert with 0, 65
                                    mem[64] = ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (13 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + 258 len 4], ext_call.return_data[0 len 28] + 258]) + 259
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (13 * ceil32(return_data.size)) + 258] = _8099
                                    require return_data.size >= _8003 + (32 * _8099) + 32
                                    mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (13 * ceil32(return_data.size)) + 290 len 32 * _8099] = mem[ceil32(ceil32(cd[(arg4 + cd[(arg4 + 228)] + 36)])) + ceil32(ceil32(cd[(arg4 + cd[(arg4 + 260)] + 36)])) + (12 * ceil32(return_data.size)) + _8003 + 290 len 32 * _8099]
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(stor4)
                                    staticcall stor4.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9475 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if mem[_9475] < (1000 * ext_call.return_data[0] * _18 / 997 * ext_call.return_data[0]) + 1:
                                        revert with 0, 17
                                    require ext_code.size(stor4)
                                    call stor4.0x2e1a7d4d with:
                                         gas gas_remaining wei
                                        args (mem[_9475] + -(1000 * ext_call.return_data[0] * _18 / 997 * ext_call.return_data[0]) - 1)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    call tx.origin with:
                                       value eth.balance(this.address) wei
                                         gas 2300 * is_zero(value) wei
                                    mem[mem[64] + 4] = stor3
                                    mem[mem[64] + 36] = (1000 * ext_call.return_data[0] * _18 / 997 * ext_call.return_data[0]) + 1
                                    require ext_code.size(address(cd[(arg4 + 132)]))
                                    call address(cd[(arg4 + 132)]).0xa9059cbb with:
                                         gas gas_remaining wei
                                        args stor3, (1000 * ext_call.return_data[0] * _18 / 997 * ext_call.return_data[0]) + 1
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _9699 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_9699] == bool(mem[_9699])
}



}

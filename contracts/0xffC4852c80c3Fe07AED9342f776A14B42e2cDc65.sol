contract main {




// =====================  Runtime code  =====================


function _fallback() payable {
    revert
}

function sub_edf0bfad(?) payable {
    mem[64] = 96
    require calldata.size - 4 >= 128
    require arg3 == address(arg3)
    require arg4 <= test266151307()
    require arg4 + 35 < calldata.size
    require arg4.length <= test266151307()
    require arg4 + arg4.length + 36 <= calldata.size
    idx = 1000000000000000000 * 10^18
    while 1 < idx:
        if 1 > !idx:
            revert with 0, 17
        if 1 > !(idx + 1):
            revert with 0, 17
        mem[mem[64] + 4] = 64
        mem[mem[64] + 68] = arg4.length
        mem[mem[64] + 100 len arg4.length] = arg4[all]
        mem[mem[64] + arg4.length + 100] = 0
        mem[mem[64] + 36] = idx + 2 / 2
        require ext_code.size(address(arg3))
        call address(arg3).quoteExactInput(bytes arg1, uint256 arg2) with:
             gas gas_remaining wei
            args Array(len=arg4.length, data=arg4[all]), idx + 2 / 2
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _9 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        if mem[_9] > !arg1:
            revert with 0, 17
        if mem[_9] + arg1 and arg2 > -1 / mem[_9] + arg1:
            revert with 0, 17
        if idx + 2 / 2 > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
            revert with 0, 17
        if 10^18 * idx + 2 / 2 <= (mem[_9] * arg2) + (arg1 * arg2):
            idx = idx
            continue 
        if idx + 2 / 2 < 1:
            revert with 0, 17
        idx = (idx + 2 / 2) - 1
        continue 
    return 1
}

function sub_2218a3f2(?) payable {
    mem[64] = 96
    require calldata.size - 4 >= 128
    require cd[68] == address(cd[68])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + (32 * ('cd', 100).length) + 36 <= calldata.size
    idx = 1000000000000000000 * 10^18
    while 1 < idx:
        if 1 > !idx:
            revert with 0, 17
        if 1 > !(idx + 1):
            revert with 0, 17
        mem[mem[64]] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = idx + 2 / 2
        mem[mem[64] + 36] = 64
        mem[mem[64] + 68] = ('cd', 100).length
        s = 0
        t = mem[64] + 100
        u = cd[100] + 36
        while s < ('cd', 100).length:
            require cd[u] == address(cd[u])
            mem[t] = address(cd[u])
            s = s + 1
            t = t + 32
            u = u + 32
            continue 
        require ext_code.size(address(cd[68]))
        staticcall address(cd[68]).getAmountsOut(uint256 arg1, address[] arg2) with:
                gas gas_remaining wei
               args Mask(255, 1, idx + 2), Array(len=('cd', 100).length, data=mem[mem[64] + 100 len 32 * ('cd', 100).length])
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _24 = mem[64]
        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _25 = mem[_24]
        require mem[_24] <= test266151307()
        require _24 + return_data.size > _24 + mem[_24] + 31
        _26 = mem[_24 + mem[_24]]
        if mem[_24 + mem[_24]] > test266151307():
            revert with 0, 65
        if ceil32(32 * mem[_24 + mem[_24]]) + 1 < 0 or _24 + ceil32(return_data.size) + ceil32(32 * mem[_24 + mem[_24]]) + 1 > test266151307():
            revert with 0, 65
        mem[64] = _24 + ceil32(return_data.size) + ceil32(32 * mem[_24 + mem[_24]]) + 1
        mem[_24 + ceil32(return_data.size)] = _26
        require _25 + (32 * _26) + 32 <= return_data.size
        t = _24 + _25 + 32
        u = _24 + ceil32(return_data.size) + 32
        s = 0
        while s < _26:
            mem[u] = mem[t]
            t = t + 32
            u = u + 32
            s = s + 1
            continue 
        if _26 < 1:
            revert with 0, 17
        if _26 - 1 >= _26:
            revert with 0, 50
        if mem[(32 * _26 - 1) + _24 + ceil32(return_data.size) + 32] > !cd[4]:
            revert with 0, 17
        if mem[(32 * _26 - 1) + _24 + ceil32(return_data.size) + 32] + cd[4] and cd[36] > -1 / mem[(32 * _26 - 1) + _24 + ceil32(return_data.size) + 32] + cd[4]:
            revert with 0, 17
        if idx + 2 / 2 > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
            revert with 0, 17
        if 10^18 * idx + 2 / 2 <= (mem[(32 * _26 - 1) + _24 + ceil32(return_data.size) + 32] * cd[36]) + (cd[4] * cd[36]):
            idx = idx
            continue 
        if idx + 2 / 2 < 1:
            revert with 0, 17
        idx = (idx + 2 / 2) - 1
        continue 
    return 1
}

function sub_a01bac49(?) payable {
    mem[64] = 96
    require calldata.size - 4 >= 128
    require arg3 == address(arg3)
    require arg4 <= test266151307()
    require arg4 + 35 < calldata.size
    require arg4.length <= test266151307()
    require arg4 + arg4.length + 36 <= calldata.size
    idx = 1000000000000000000 * 10^18
    while 1 < idx:
        if 1 > !idx:
            revert with 0, 17
        if 1 > !(idx + 1):
            revert with 0, 17
        mem[mem[64]] = 0xcdca175300000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = 64
        mem[mem[64] + 68] = arg4.length
        mem[mem[64] + 100 len arg4.length] = arg4[all]
        mem[mem[64] + arg4.length + 100] = 0
        mem[mem[64] + 36] = idx + 2 / 2
        require ext_code.size(address(arg3))
        call address(arg3).quoteExactInput(bytes arg1, uint256 arg2) with:
             gas gas_remaining wei
            args Array(len=arg4.length, data=arg4[all]), idx + 2 / 2
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _18 = mem[64]
        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 128
        _19 = mem[_18]
        _20 = mem[_18 + 32]
        require mem[_18 + 32] <= test266151307()
        require _18 + mem[_18 + 32] + 31 < _18 + return_data.size
        _21 = mem[_18 + mem[_18 + 32]]
        if mem[_18 + mem[_18 + 32]] > test266151307():
            revert with 0, 65
        if ceil32(32 * mem[_18 + mem[_18 + 32]]) + 1 < 0 or _18 + ceil32(return_data.size) + ceil32(32 * mem[_18 + mem[_18 + 32]]) + 1 > test266151307():
            revert with 0, 65
        mem[64] = _18 + ceil32(return_data.size) + ceil32(32 * mem[_18 + mem[_18 + 32]]) + 1
        mem[_18 + ceil32(return_data.size)] = _21
        require _20 + (32 * _21) + 32 <= return_data.size
        t = _18 + _20 + 32
        u = _18 + ceil32(return_data.size) + 32
        s = 0
        while s < _21:
            require mem[t] == mem[t + 12 len 20]
            mem[u] = mem[t]
            t = t + 32
            u = u + 32
            s = s + 1
            continue 
        _29 = mem[_18 + 64]
        require mem[_18 + 64] <= test266151307()
        require _18 + mem[_18 + 64] + 31 < _18 + return_data.size
        _31 = mem[_18 + mem[_18 + 64]]
        if mem[_18 + mem[_18 + 64]] > test266151307():
            revert with 0, 65
        _32 = mem[64]
        if mem[64] + ceil32(32 * mem[_18 + mem[_18 + 64]]) + 1 < mem[64] or mem[64] + ceil32(32 * mem[_18 + mem[_18 + 64]]) + 1 > test266151307():
            revert with 0, 65
        mem[64] = mem[64] + ceil32(32 * mem[_18 + mem[_18 + 64]]) + 1
        mem[_32] = _31
        require _29 + (32 * _31) + 32 <= return_data.size
        s = 0
        t = _18 + _29 + 32
        u = _32 + 32
        while s < _31:
            require mem[t] == mem[t + 28 len 4]
            mem[u] = mem[t]
            s = s + 1
            t = t + 32
            u = u + 32
            continue 
        if _19 > !arg1:
            revert with 0, 17
        if _19 + arg1 and arg2 > -1 / _19 + arg1:
            revert with 0, 17
        if idx + 2 / 2 > 0x12725dd1d243aba0e75fe645cc4873f9e65afe688c928e1f21:
            revert with 0, 17
        if 10^18 * idx + 2 / 2 <= (_19 * arg2) + (arg1 * arg2):
            idx = idx
            continue 
        if idx + 2 / 2 < 1:
            revert with 0, 17
        idx = (idx + 2 / 2) - 1
        continue 
    return 1
}



}

contract main {




// =====================  Runtime code  =====================


#
#  - deposit(uint256 arg1, uint256 arg2, uint256 arg3)
#  - pendingSushi(uint256 arg1, address arg2)
#  - withdrawNFT(uint256 arg1, uint256 arg2)
#  - withdraw(uint256 arg1, uint256 arg2)
#  - sub_9ca2cb1a(?)
#
address owner;
address WETHAddress;
address sushiAddress;
address devaddr;
uint256 bonusEndBlock;
uint256 sushiPerBlock;
uint32 stor6;
address migratorAddress;
uint256 stor6;
array of struct poolInfo;
mapping of struct userInfo;
uint256 totalAllocPoint;
uint256 sub_9e98edc6;
uint256 sub_e600038d;
uint256 sub_a054b70a;
uint256 BLOCKS_PER_YEAR;
uint256 startBlock;
address sub_ae46f614Address;

function poolLength() {
    return poolInfo.length
}

function sushi() {
    return sushiAddress
}

function poolInfo(uint256 arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    require arg1 < poolInfo.length
    return poolInfo[arg1].field_0, 
           poolInfo[arg1].field_256,
           poolInfo[arg1].field_512,
           bool(poolInfo[arg1].field_768),
           poolInfo[arg1].field_1024,
           poolInfo[arg1].field_1280,
           poolInfo[arg1].field_1536
}

function totalAllocPoint() {
    return totalAllocPoint
}

function bonusEndBlock() {
    return bonusEndBlock
}

function startBlock() {
    return startBlock
}

function migrator() {
    return address(migratorAddress)
}

function owner() {
    return owner
}

function userInfo(uint256 arg1, address arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require arg2 == arg2
    return userInfo[arg1][arg2].field_0, 
           userInfo[arg1][arg2].field_256,
           userInfo[arg1][arg2].field_512,
           userInfo[arg1][arg2].field_768
}

function sub_9e98edc6(?) {
    return sub_9e98edc6
}

function sub_a054b70a(?) {
    return sub_a054b70a
}

function WETH() {
    return WETHAddress
}

function sub_ae46f614(?) {
    return sub_ae46f614Address
}

function sushiPerBlock() {
    return sushiPerBlock
}

function BLOCKS_PER_YEAR() {
    return BLOCKS_PER_YEAR
}

function devaddr() {
    return devaddr
}

function sub_e600038d(?) {
    return sub_e600038d
}

function _fallback() payable {
    revert
}

function renounceOwnership() {
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    emit OwnershipTransferred(owner, 0);
    owner = 0
}

function dev(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if devaddr != msg.sender:
        revert with 0, 'dev: wut?'
    devaddr = arg1
}

function _setMigrator(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        if devaddr != msg.sender:
            revert with 0, '!dev addr'
    address(migratorAddress) = arg1
}

function getTimeMultiplex(uint256 arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if not arg1:
        return 100
    if arg1 <= 168 * 24 * 3600:
        return 120
    if arg1 <= 336 * 24 * 3600:
        return 140
    if arg1 > 720 * 24 * 3600:
        return 200
    return 160
}

function formatDuration(uint256 arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if not arg1:
        return 0
    if arg1 <= 168 * 24 * 3600:
        return (168 * 24 * 3600)
    if arg1 <= 336 * 24 * 3600:
        return (336 * 24 * 3600)
    if arg1 > 720 * 24 * 3600:
        return (4320 * 24 * 3600)
    return (720 * 24 * 3600)
}

function transferOwnership(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Ownable: new owner is the zero address'
    emit OwnershipTransferred(owner, arg1);
    owner = arg1
}

function onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg2 == arg2
    require arg3 == arg3
    require arg4 <= test266151307()
    require arg4 + 35 < calldata.size
    require arg4.length <= test266151307()
    require arg4 + arg4.length + 36 <= calldata.size
    return 0x150b7a0200000000000000000000000000000000000000000000000000000000
}

function initialize(address arg1, address arg2, address arg3, uint256 arg4, uint256 arg5, uint256 arg6) {
    require calldata.size - 4 >= 192
    require arg1 == arg1
    require arg2 == arg2
    require arg3 == arg3
    require arg4 == arg4
    require arg5 == arg5
    require arg6 == arg6
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    sushiAddress = arg1
    devaddr = arg2
    WETHAddress = arg3
    sushiPerBlock = arg4
    startBlock = arg5
    bonusEndBlock = arg6
    create contract with 0 wei
                    code: code.data[21410 len 1116]
    if not create.new_address:
        revert with ext_call.return_data[0 len return_data.size]
    sub_ae46f614Address = address(create.new_address)
}

function _migrate(uint256 arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if not address(migratorAddress):
        revert with 0, 'migrate: no migrator'
    if arg1 >= poolInfo.length:
        revert with 'NH{q', 50
    mem[100] = this.address
    require ext_code.size(poolInfo[arg1].field_0)
    staticcall poolInfo[arg1].field_0.0x70a08231 with:
            gas gas_remaining wei
           args this.address
    mem[96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[0]
    mem[ceil32(return_data.size) + 96] = 68
    mem[ceil32(return_data.size) + 132 len 28] = Mask(224, 0, stor6)
    mem[ceil32(return_data.size) + 128 len 4] = approve(address arg1, uint256 arg2)
    if ext_call.return_data[0] <= 0:
        mem[ceil32(return_data.size) + 196 len 96] = approve(address arg1, uint256 arg2), Mask(224, 0, stor6), uint32(stor6), ext_call.return_data[0], mem[ceil32(return_data.size) + 196 len 28]
        call poolInfo[arg1].field_0.mem[ceil32(return_data.size) + 196 len 4] with:
             gas gas_remaining wei
            args mem[ceil32(return_data.size) + 200 len 64]
        if not return_data.size:
            if not ext_call.success:
                revert with 0, '!TransferHelper: APPROVE_FAILED'
            if ext_call.return_data[0]:
                require ext_call.return_data[0] >= 32
                require 0, mem[132 len 28] == bool(0, mem[132 len 28])
                if not 0, mem[132 len 28]:
                    revert with 0, '!TransferHelper: APPROVE_FAILED'
        else:
            mem[ceil32(return_data.size) + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not ext_call.success:
                revert with 0, '!TransferHelper: APPROVE_FAILED'
            if return_data.size:
                require return_data.size >= 32
                require mem[ceil32(return_data.size) + 228] == bool(mem[ceil32(return_data.size) + 228])
                if not mem[ceil32(return_data.size) + 228]:
                    revert with 0, '!TransferHelper: APPROVE_FAILED'
    else:
        mem[ceil32(return_data.size) + 196 len 96] = approve(address arg1, uint256 arg2), Mask(224, 0, stor6), uint32(stor6), 0, mem[ceil32(return_data.size) + 196 len 28]
        call poolInfo[arg1].field_0.mem[ceil32(return_data.size) + 196 len 4] with:
             gas gas_remaining wei
            args mem[ceil32(return_data.size) + 200 len 64]
        if not return_data.size:
            if not ext_call.success:
                revert with 0, '!TransferHelper: APPROVE_FAILED'
            if ext_call.return_data[0]:
                require ext_call.return_data[0] >= 32
                require 0, mem[132 len 28] == bool(0, mem[132 len 28])
                if not 0, mem[132 len 28]:
                    revert with 0, '!TransferHelper: APPROVE_FAILED'
            mem[ceil32(return_data.size) + 296 len 96] = 0, address(migratorAddress), ext_call.return_data[0], mem[ceil32(return_data.size) + 296 len 28]
            call poolInfo[arg1].field_0.mem[ceil32(return_data.size) + 296 len 4] with:
                 gas gas_remaining wei
                args mem[ceil32(return_data.size) + 300 len 64]
            if not return_data.size:
                if not ext_call.success:
                    revert with 0, '!TransferHelper: APPROVE_FAILED'
                if ext_call.return_data[0]:
                    require ext_call.return_data[0] >= 32
                    require 0, mem[132 len 28] == bool(0, mem[132 len 28])
                    if not 0, mem[132 len 28]:
                        revert with 0, '!TransferHelper: APPROVE_FAILED'
            else:
                mem[ceil32(return_data.size) + 328 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not ext_call.success:
                    revert with 0, '!TransferHelper: APPROVE_FAILED'
                if return_data.size:
                    require return_data.size >= 32
                    require mem[ceil32(return_data.size) + 328] == bool(mem[ceil32(return_data.size) + 328])
                    if not mem[ceil32(return_data.size) + 328]:
                        revert with 0, '!TransferHelper: APPROVE_FAILED'
        else:
            mem[ceil32(return_data.size) + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not ext_call.success:
                revert with 0, '!TransferHelper: APPROVE_FAILED'
            if return_data.size:
                require return_data.size >= 32
                require mem[ceil32(return_data.size) + 228] == bool(mem[ceil32(return_data.size) + 228])
                if not mem[ceil32(return_data.size) + 228]:
                    revert with 0, '!TransferHelper: APPROVE_FAILED'
            mem[ceil32(return_data.size) + ceil32(return_data.size) + 297 len 96] = 0, address(migratorAddress), ext_call.return_data[0], mem[ceil32(return_data.size) + ceil32(return_data.size) + 297 len 28]
            call poolInfo[arg1].field_0.mem[ceil32(return_data.size) + ceil32(return_data.size) + 297 len 4] with:
                 gas gas_remaining wei
                args mem[ceil32(return_data.size) + ceil32(return_data.size) + 301 len 64]
            if not return_data.size:
                if not ext_call.success:
                    revert with 0, '!TransferHelper: APPROVE_FAILED'
                if ext_call.return_data[0]:
                    require ext_call.return_data[0] >= 32
                    require 0, mem[132 len 28] == bool(0, mem[132 len 28])
                    if not 0, mem[132 len 28]:
                        revert with 0, '!TransferHelper: APPROVE_FAILED'
            else:
                mem[ceil32(return_data.size) + ceil32(return_data.size) + 329 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not ext_call.success:
                    revert with 0, '!TransferHelper: APPROVE_FAILED'
                if return_data.size:
                    require return_data.size >= 32
                    require mem[ceil32(return_data.size) + ceil32(return_data.size) + 329] == bool(mem[ceil32(return_data.size) + ceil32(return_data.size) + 329])
                    if not mem[ceil32(return_data.size) + ceil32(return_data.size) + 329]:
                        revert with 0, '!TransferHelper: APPROVE_FAILED'
    require ext_code.size(address(migratorAddress))
    call address(migratorAddress).migrate(address arg1) with:
         gas gas_remaining wei
        args poolInfo[arg1].field_0
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    require ext_code.size(address(ext_call.return_data[0]))
    staticcall address(ext_call.return_data[0]).0x70a08231 with:
            gas gas_remaining wei
           args this.address
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[0]
    if ext_call.return_data[0] != ext_call.return_data[0]:
        revert with 0, 'migrate: bad'
    poolInfo[arg1].field_0 = address(ext_call.return_data[0])
}

function sub_0805d884(?) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if arg1 >= poolInfo.length:
        revert with 'NH{q', 50
    if not sushiPerBlock:
        if poolInfo[arg1].field_768:
            if block.number <= bonusEndBlock:
                if 100 < sub_e600038d:
                    revert with 'NH{q', 17
                if sub_9e98edc6 <= 0:
                    revert with 0, 'SafeMath: division by zero', 0
                if not sub_9e98edc6:
                    revert with 'NH{q', 18
                return (0 / sub_9e98edc6)
            if poolInfo[arg1].field_768:
                if block.number > bonusEndBlock:
                    if 100 < sub_a054b70a:
                        revert with 'NH{q', 17
                    if sub_9e98edc6 <= 0:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not sub_9e98edc6:
                        revert with 'NH{q', 18
                    return (0 / sub_9e98edc6)
                if poolInfo[arg1].field_768:
                    return 0
        if block.number > bonusEndBlock:
            if poolInfo[arg1].field_768:
                return 0
            if block.number <= bonusEndBlock:
                return 0
        if totalAllocPoint <= 0:
            revert with 0, 'SafeMath: division by zero', 0
        if not totalAllocPoint:
            revert with 'NH{q', 18
        return (0 / totalAllocPoint)
    if sushiPerBlock and BLOCKS_PER_YEAR > -1 / sushiPerBlock:
        revert with 'NH{q', 17
    if not sushiPerBlock:
        revert with 'NH{q', 18
    if sushiPerBlock * BLOCKS_PER_YEAR / sushiPerBlock != BLOCKS_PER_YEAR:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
    if not sushiPerBlock * BLOCKS_PER_YEAR:
        if poolInfo[arg1].field_768:
            if block.number <= bonusEndBlock:
                if 100 < sub_e600038d:
                    revert with 'NH{q', 17
                if sub_9e98edc6 <= 0:
                    revert with 0, 'SafeMath: division by zero', 0
                if not sub_9e98edc6:
                    revert with 'NH{q', 18
                return (0 / sub_9e98edc6)
            if poolInfo[arg1].field_768:
                if block.number > bonusEndBlock:
                    if 100 < sub_a054b70a:
                        revert with 'NH{q', 17
                    if sub_9e98edc6 <= 0:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not sub_9e98edc6:
                        revert with 'NH{q', 18
                    return (0 / sub_9e98edc6)
                if poolInfo[arg1].field_768:
                    return 0
        if block.number > bonusEndBlock:
            if poolInfo[arg1].field_768:
                return 0
            if block.number <= bonusEndBlock:
                return 0
        if totalAllocPoint <= 0:
            revert with 0, 'SafeMath: division by zero', 0
        if not totalAllocPoint:
            revert with 'NH{q', 18
        return (0 / totalAllocPoint)
    if sushiPerBlock * BLOCKS_PER_YEAR and poolInfo[arg1].field_256 > -1 / sushiPerBlock * BLOCKS_PER_YEAR:
        revert with 'NH{q', 17
    if not sushiPerBlock * BLOCKS_PER_YEAR:
        revert with 'NH{q', 18
    if sushiPerBlock * BLOCKS_PER_YEAR * poolInfo[arg1].field_256 / sushiPerBlock * BLOCKS_PER_YEAR != poolInfo[arg1].field_256:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
    if poolInfo[arg1].field_768:
        if block.number <= bonusEndBlock:
            if 100 < sub_e600038d:
                revert with 'NH{q', 17
            if not sushiPerBlock * BLOCKS_PER_YEAR * poolInfo[arg1].field_256 / 100:
                if sub_9e98edc6 <= 0:
                    revert with 0, 'SafeMath: division by zero', 0
                if not sub_9e98edc6:
                    revert with 'NH{q', 18
                return (0 / sub_9e98edc6)
            if sushiPerBlock * BLOCKS_PER_YEAR * poolInfo[arg1].field_256 / 100 and -sub_e600038d + 100 > -1 / sushiPerBlock * BLOCKS_PER_YEAR * poolInfo[arg1].field_256 / 100:
                revert with 'NH{q', 17
            if not sushiPerBlock * BLOCKS_PER_YEAR * poolInfo[arg1].field_256 / 100:
                revert with 'NH{q', 18
            if (100 * sushiPerBlock * BLOCKS_PER_YEAR * poolInfo[arg1].field_256 / 100) - (sub_e600038d * sushiPerBlock * BLOCKS_PER_YEAR * poolInfo[arg1].field_256 / 100) / sushiPerBlock * BLOCKS_PER_YEAR * poolInfo[arg1].field_256 / 100 != -sub_e600038d + 100:
                revert with 0, 'SafeMath: multiplication overflow'
            if sub_9e98edc6 <= 0:
                revert with 0, 'SafeMath: division by zero', 0
            if not sub_9e98edc6:
                revert with 'NH{q', 18
            return ((100 * sushiPerBlock * BLOCKS_PER_YEAR * poolInfo[arg1].field_256 / 100) - (sub_e600038d * sushiPerBlock * BLOCKS_PER_YEAR * poolInfo[arg1].field_256 / 100) / sub_9e98edc6)
        if poolInfo[arg1].field_768:
            if block.number > bonusEndBlock:
                if 100 < sub_a054b70a:
                    revert with 'NH{q', 17
                if not sushiPerBlock * BLOCKS_PER_YEAR * poolInfo[arg1].field_256 / 100:
                    if sub_9e98edc6 <= 0:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not sub_9e98edc6:
                        revert with 'NH{q', 18
                    return (0 / sub_9e98edc6)
                if sushiPerBlock * BLOCKS_PER_YEAR * poolInfo[arg1].field_256 / 100 and -sub_a054b70a + 100 > -1 / sushiPerBlock * BLOCKS_PER_YEAR * poolInfo[arg1].field_256 / 100:
                    revert with 'NH{q', 17
                if not sushiPerBlock * BLOCKS_PER_YEAR * poolInfo[arg1].field_256 / 100:
                    revert with 'NH{q', 18
                if (100 * sushiPerBlock * BLOCKS_PER_YEAR * poolInfo[arg1].field_256 / 100) - (sub_a054b70a * sushiPerBlock * BLOCKS_PER_YEAR * poolInfo[arg1].field_256 / 100) / sushiPerBlock * BLOCKS_PER_YEAR * poolInfo[arg1].field_256 / 100 != -sub_a054b70a + 100:
                    revert with 0, 'SafeMath: multiplication overflow'
                if sub_9e98edc6 <= 0:
                    revert with 0, 'SafeMath: division by zero', 0
                if not sub_9e98edc6:
                    revert with 'NH{q', 18
                return ((100 * sushiPerBlock * BLOCKS_PER_YEAR * poolInfo[arg1].field_256 / 100) - (sub_a054b70a * sushiPerBlock * BLOCKS_PER_YEAR * poolInfo[arg1].field_256 / 100) / sub_9e98edc6)
            if poolInfo[arg1].field_768:
                return 0
    if block.number <= bonusEndBlock:
        if not sushiPerBlock * BLOCKS_PER_YEAR * poolInfo[arg1].field_256 / 100:
            if totalAllocPoint <= 0:
                revert with 0, 'SafeMath: division by zero', 0
            if not totalAllocPoint:
                revert with 'NH{q', 18
            return (0 / totalAllocPoint)
        if sushiPerBlock * BLOCKS_PER_YEAR * poolInfo[arg1].field_256 / 100 and sub_e600038d > -1 / sushiPerBlock * BLOCKS_PER_YEAR * poolInfo[arg1].field_256 / 100:
            revert with 'NH{q', 17
        if not sushiPerBlock * BLOCKS_PER_YEAR * poolInfo[arg1].field_256 / 100:
            revert with 'NH{q', 18
        if sushiPerBlock * BLOCKS_PER_YEAR * poolInfo[arg1].field_256 / 100 * sub_e600038d / sushiPerBlock * BLOCKS_PER_YEAR * poolInfo[arg1].field_256 / 100 != sub_e600038d:
            revert with 0, 'SafeMath: multiplication overflow'
        if totalAllocPoint <= 0:
            revert with 0, 'SafeMath: division by zero', 0
        if not totalAllocPoint:
            revert with 'NH{q', 18
        return (sushiPerBlock * BLOCKS_PER_YEAR * poolInfo[arg1].field_256 / 100 * sub_e600038d / totalAllocPoint)
    if poolInfo[arg1].field_768:
        return 0
    if block.number <= bonusEndBlock:
        return 0
    if not sushiPerBlock * BLOCKS_PER_YEAR * poolInfo[arg1].field_256 / 100:
        if totalAllocPoint <= 0:
            revert with 0, 'SafeMath: division by zero', 0
        if not totalAllocPoint:
            revert with 'NH{q', 18
        return (0 / totalAllocPoint)
    if sushiPerBlock * BLOCKS_PER_YEAR * poolInfo[arg1].field_256 / 100 and sub_a054b70a > -1 / sushiPerBlock * BLOCKS_PER_YEAR * poolInfo[arg1].field_256 / 100:
        revert with 'NH{q', 17
    if not sushiPerBlock * BLOCKS_PER_YEAR * poolInfo[arg1].field_256 / 100:
        revert with 'NH{q', 18
    if sushiPerBlock * BLOCKS_PER_YEAR * poolInfo[arg1].field_256 / 100 * sub_a054b70a / sushiPerBlock * BLOCKS_PER_YEAR * poolInfo[arg1].field_256 / 100 != sub_a054b70a:
        revert with 0, 'SafeMath: multiplication overflow'
    if totalAllocPoint <= 0:
        revert with 0, 'SafeMath: division by zero', 0
    if not totalAllocPoint:
        revert with 'NH{q', 18
    return (sushiPerBlock * BLOCKS_PER_YEAR * poolInfo[arg1].field_256 / 100 * sub_a054b70a / totalAllocPoint)
}

function sub_b1c1dc60(?) {
    require calldata.size - 4 >= 96
    require arg1 == arg1
    require arg2 == arg2
    require arg3 == bool(arg3)
    if arg2 <= bonusEndBlock:
        if not arg3:
            if arg1 > arg2:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg2 < arg1:
                revert with 'NH{q', 17
            if not arg2 - arg1:
                return 0
            if arg2 - arg1 and sub_e600038d > -1 / arg2 - arg1:
                revert with 'NH{q', 17
            if not arg2 - arg1:
                revert with 'NH{q', 18
            if (arg2 * sub_e600038d) - (arg1 * sub_e600038d) / arg2 - arg1 != sub_e600038d:
                revert with 0, 'SafeMath: multiplication overflow'
            return ((arg2 * sub_e600038d) - (arg1 * sub_e600038d) / 100)
        if 100 < sub_e600038d:
            revert with 'NH{q', 17
        if arg1 > arg2:
            revert with 0, 'SafeMath: subtraction overflow', 0
        if arg2 < arg1:
            revert with 'NH{q', 17
        if not arg2 - arg1:
            return 0
        if arg2 - arg1 and -sub_e600038d + 100 > -1 / arg2 - arg1:
            revert with 'NH{q', 17
        if not arg2 - arg1:
            revert with 'NH{q', 18
        if (100 * arg2) - (sub_e600038d * arg2) - (100 * arg1) + (sub_e600038d * arg1) / arg2 - arg1 != -sub_e600038d + 100:
            revert with 0, 'SafeMath: multiplication overflow'
        return ((100 * arg2) - (sub_e600038d * arg2) - (100 * arg1) + (sub_e600038d * arg1) / 100)
    if arg1 >= bonusEndBlock:
        if not arg3:
            if arg1 > arg2:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg2 < arg1:
                revert with 'NH{q', 17
            if not arg2 - arg1:
                return 0
            if arg2 - arg1 and sub_a054b70a > -1 / arg2 - arg1:
                revert with 'NH{q', 17
            if not arg2 - arg1:
                revert with 'NH{q', 18
            if (arg2 * sub_a054b70a) - (arg1 * sub_a054b70a) / arg2 - arg1 != sub_a054b70a:
                revert with 0, 'SafeMath: multiplication overflow'
            return ((arg2 * sub_a054b70a) - (arg1 * sub_a054b70a) / 100)
        if 100 < sub_a054b70a:
            revert with 'NH{q', 17
        if arg1 > arg2:
            revert with 0, 'SafeMath: subtraction overflow', 0
        if arg2 < arg1:
            revert with 'NH{q', 17
        if not arg2 - arg1:
            return 0
        if arg2 - arg1 and -sub_a054b70a + 100 > -1 / arg2 - arg1:
            revert with 'NH{q', 17
        if not arg2 - arg1:
            revert with 'NH{q', 18
        if (100 * arg2) - (sub_a054b70a * arg2) - (100 * arg1) + (sub_a054b70a * arg1) / arg2 - arg1 != -sub_a054b70a + 100:
            revert with 0, 'SafeMath: multiplication overflow'
        return ((100 * arg2) - (sub_a054b70a * arg2) - (100 * arg1) + (sub_a054b70a * arg1) / 100)
    if not arg3:
        if bonusEndBlock > arg2:
            revert with 0, 'SafeMath: subtraction overflow', 0
        if arg2 < bonusEndBlock:
            revert with 'NH{q', 17
        if not arg2 - bonusEndBlock:
            if arg1 > bonusEndBlock:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if bonusEndBlock < arg1:
                revert with 'NH{q', 17
            if not bonusEndBlock - arg1:
                return 0
            if bonusEndBlock - arg1 and sub_e600038d > -1 / bonusEndBlock - arg1:
                revert with 'NH{q', 17
            if not bonusEndBlock - arg1:
                revert with 'NH{q', 18
            if (bonusEndBlock * sub_e600038d) - (arg1 * sub_e600038d) / bonusEndBlock - arg1 != sub_e600038d:
                revert with 0, 'SafeMath: multiplication overflow'
            if (bonusEndBlock * sub_e600038d) - (arg1 * sub_e600038d) / 100 > -1:
                revert with 'NH{q', 17
            if (bonusEndBlock * sub_e600038d) - (arg1 * sub_e600038d) / 100 < (bonusEndBlock * sub_e600038d) - (arg1 * sub_e600038d) / 100:
                revert with 0, 'SafeMath: addition overflow'
            return ((bonusEndBlock * sub_e600038d) - (arg1 * sub_e600038d) / 100)
        if arg2 - bonusEndBlock and sub_a054b70a > -1 / arg2 - bonusEndBlock:
            revert with 'NH{q', 17
        if not arg2 - bonusEndBlock:
            revert with 'NH{q', 18
        if (arg2 * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / arg2 - bonusEndBlock != sub_a054b70a:
            revert with 0, 'SafeMath: multiplication overflow'
        if arg1 > bonusEndBlock:
            revert with 0, 'SafeMath: subtraction overflow', 0
        if bonusEndBlock < arg1:
            revert with 'NH{q', 17
        if not bonusEndBlock - arg1:
            if 0 > -((arg2 * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100) - 1:
                revert with 'NH{q', 17
            if (arg2 * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 < 0:
                revert with 0, 'SafeMath: addition overflow'
            return ((arg2 * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100)
        if bonusEndBlock - arg1 and sub_e600038d > -1 / bonusEndBlock - arg1:
            revert with 'NH{q', 17
        if not bonusEndBlock - arg1:
            revert with 'NH{q', 18
        if (bonusEndBlock * sub_e600038d) - (arg1 * sub_e600038d) / bonusEndBlock - arg1 != sub_e600038d:
            revert with 0, 'SafeMath: multiplication overflow'
        if (bonusEndBlock * sub_e600038d) - (arg1 * sub_e600038d) / 100 > -((arg2 * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100) - 1:
            revert with 'NH{q', 17
        if ((bonusEndBlock * sub_e600038d) - (arg1 * sub_e600038d) / 100) + ((arg2 * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100) < (bonusEndBlock * sub_e600038d) - (arg1 * sub_e600038d) / 100:
            revert with 0, 'SafeMath: addition overflow'
        return (((bonusEndBlock * sub_e600038d) - (arg1 * sub_e600038d) / 100) + ((arg2 * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100))
    if 100 < sub_a054b70a:
        revert with 'NH{q', 17
    if bonusEndBlock > arg2:
        revert with 0, 'SafeMath: subtraction overflow', 0
    if arg2 < bonusEndBlock:
        revert with 'NH{q', 17
    if not arg2 - bonusEndBlock:
        if 100 < sub_e600038d:
            revert with 'NH{q', 17
        if arg1 > bonusEndBlock:
            revert with 0, 'SafeMath: subtraction overflow', 0
        if bonusEndBlock < arg1:
            revert with 'NH{q', 17
        if not bonusEndBlock - arg1:
            return 0
        if bonusEndBlock - arg1 and -sub_e600038d + 100 > -1 / bonusEndBlock - arg1:
            revert with 'NH{q', 17
        if not bonusEndBlock - arg1:
            revert with 'NH{q', 18
        if (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * arg1) + (sub_e600038d * arg1) / bonusEndBlock - arg1 != -sub_e600038d + 100:
            revert with 0, 'SafeMath: multiplication overflow'
        if (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * arg1) + (sub_e600038d * arg1) / 100 > -1:
            revert with 'NH{q', 17
        if (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * arg1) + (sub_e600038d * arg1) / 100 < (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * arg1) + (sub_e600038d * arg1) / 100:
            revert with 0, 'SafeMath: addition overflow'
        return ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * arg1) + (sub_e600038d * arg1) / 100)
    if arg2 - bonusEndBlock and -sub_a054b70a + 100 > -1 / arg2 - bonusEndBlock:
        revert with 'NH{q', 17
    if not arg2 - bonusEndBlock:
        revert with 'NH{q', 18
    if (100 * arg2) - (sub_a054b70a * arg2) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / arg2 - bonusEndBlock != -sub_a054b70a + 100:
        revert with 0, 'SafeMath: multiplication overflow'
    if 100 < sub_e600038d:
        revert with 'NH{q', 17
    if arg1 > bonusEndBlock:
        revert with 0, 'SafeMath: subtraction overflow', 0
    if bonusEndBlock < arg1:
        revert with 'NH{q', 17
    if not bonusEndBlock - arg1:
        if 0 > -((100 * arg2) - (sub_a054b70a * arg2) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100) - 1:
            revert with 'NH{q', 17
        if (100 * arg2) - (sub_a054b70a * arg2) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 < 0:
            revert with 0, 'SafeMath: addition overflow'
        return ((100 * arg2) - (sub_a054b70a * arg2) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100)
    if bonusEndBlock - arg1 and -sub_e600038d + 100 > -1 / bonusEndBlock - arg1:
        revert with 'NH{q', 17
    if not bonusEndBlock - arg1:
        revert with 'NH{q', 18
    if (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * arg1) + (sub_e600038d * arg1) / bonusEndBlock - arg1 != -sub_e600038d + 100:
        revert with 0, 'SafeMath: multiplication overflow'
    if (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * arg1) + (sub_e600038d * arg1) / 100 > -((100 * arg2) - (sub_a054b70a * arg2) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100) - 1:
        revert with 'NH{q', 17
    if ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * arg1) + (sub_e600038d * arg1) / 100) + ((100 * arg2) - (sub_a054b70a * arg2) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100) < (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * arg1) + (sub_e600038d * arg1) / 100:
        revert with 0, 'SafeMath: addition overflow'
    return (((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * arg1) + (sub_e600038d * arg1) / 100) + ((100 * arg2) - (sub_a054b70a * arg2) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100))
}

function updatePool(uint256 arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if arg1 >= poolInfo.length:
        revert with 'NH{q', 50
    if block.number > poolInfo[arg1].field_1280:
        if poolInfo[arg1].field_512:
            if block.number <= bonusEndBlock:
                if not poolInfo[arg1].field_768:
                    if poolInfo[arg1].field_1280 > block.number:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if block.number < poolInfo[arg1].field_1280:
                        revert with 'NH{q', 17
                    if not block.number - poolInfo[arg1].field_1280:
                        if totalAllocPoint <= 0:
                            revert with 0, 'SafeMath: division by zero', 0
                        if not totalAllocPoint:
                            revert with 'NH{q', 18
                        if not 0 / totalAllocPoint:
                            emit Mint(0, this.address);
                            if poolInfo[arg1].field_512 <= 0:
                                revert with 0, 'SafeMath: division by zero', 0
                            if not poolInfo[arg1].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                        else:
                            require ext_code.size(sushiAddress)
                            call sushiAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args address(this.address), 0 / totalAllocPoint
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            emit Mint((0 / totalAllocPoint), this.address);
                            if not 0 / totalAllocPoint:
                                if poolInfo[arg1].field_512 <= 0:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not poolInfo[arg1].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                            else:
                                if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                                    revert with 'NH{q', 17
                                if not 0 / totalAllocPoint:
                                    revert with 'NH{q', 18
                                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if poolInfo[arg1].field_512 <= 0:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not poolInfo[arg1].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[arg1].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[arg1].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[arg1].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512
                    else:
                        if block.number - poolInfo[arg1].field_1280 and sub_e600038d > -1 / block.number - poolInfo[arg1].field_1280:
                            revert with 'NH{q', 17
                        if not block.number - poolInfo[arg1].field_1280:
                            revert with 'NH{q', 18
                        if (block.number * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / block.number - poolInfo[arg1].field_1280 != sub_e600038d:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not (block.number * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100:
                            if totalAllocPoint <= 0:
                                revert with 0, 'SafeMath: division by zero', 0
                            if not totalAllocPoint:
                                revert with 'NH{q', 18
                            if not 0 / totalAllocPoint:
                                emit Mint(0, this.address);
                                if poolInfo[arg1].field_512 <= 0:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not poolInfo[arg1].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                            else:
                                require ext_code.size(sushiAddress)
                                call sushiAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args address(this.address), 0 / totalAllocPoint
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                emit Mint((0 / totalAllocPoint), this.address);
                                if not 0 / totalAllocPoint:
                                    if poolInfo[arg1].field_512 <= 0:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if not poolInfo[arg1].field_512:
                                        revert with 'NH{q', 18
                                    if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                        revert with 'NH{q', 17
                                    if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                else:
                                    if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                                        revert with 'NH{q', 17
                                    if not 0 / totalAllocPoint:
                                        revert with 'NH{q', 18
                                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if poolInfo[arg1].field_512 <= 0:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if not poolInfo[arg1].field_512:
                                        revert with 'NH{q', 18
                                    if poolInfo[arg1].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512) - 1:
                                        revert with 'NH{q', 17
                                    if poolInfo[arg1].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512
                        else:
                            if (block.number * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 and sushiPerBlock > -1 / (block.number * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100:
                                revert with 'NH{q', 17
                            if not (block.number * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100:
                                revert with 'NH{q', 18
                            if (block.number * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock / (block.number * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 != sushiPerBlock:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not (block.number * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock:
                                if totalAllocPoint <= 0:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not totalAllocPoint:
                                    revert with 'NH{q', 18
                                if not 0 / totalAllocPoint:
                                    emit Mint(0, this.address);
                                    if poolInfo[arg1].field_512 <= 0:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if not poolInfo[arg1].field_512:
                                        revert with 'NH{q', 18
                                    if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                        revert with 'NH{q', 17
                                    if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                else:
                                    require ext_code.size(sushiAddress)
                                    call sushiAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args address(this.address), 0 / totalAllocPoint
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    emit Mint((0 / totalAllocPoint), this.address);
                                    if not 0 / totalAllocPoint:
                                        if poolInfo[arg1].field_512 <= 0:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        if not poolInfo[arg1].field_512:
                                            revert with 'NH{q', 18
                                        if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                            revert with 'NH{q', 17
                                        if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                    else:
                                        if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                                            revert with 'NH{q', 17
                                        if not 0 / totalAllocPoint:
                                            revert with 'NH{q', 18
                                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if poolInfo[arg1].field_512 <= 0:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        if not poolInfo[arg1].field_512:
                                            revert with 'NH{q', 18
                                        if poolInfo[arg1].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512) - 1:
                                            revert with 'NH{q', 17
                                        if poolInfo[arg1].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512
                            else:
                                if (block.number * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock and poolInfo[arg1].field_256 > -1 / (block.number * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock:
                                    revert with 'NH{q', 17
                                if not (block.number * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock:
                                    revert with 'NH{q', 18
                                if (block.number * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / (block.number * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock != poolInfo[arg1].field_256:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if totalAllocPoint <= 0:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not totalAllocPoint:
                                    revert with 'NH{q', 18
                                if not (block.number * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint:
                                    emit Mint(0, this.address);
                                    if poolInfo[arg1].field_512 <= 0:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if not poolInfo[arg1].field_512:
                                        revert with 'NH{q', 18
                                    if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                        revert with 'NH{q', 17
                                    if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                else:
                                    require ext_code.size(sushiAddress)
                                    call sushiAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args address(this.address), (block.number * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    emit Mint(((block.number * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint), this.address);
                                    if not (block.number * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint:
                                        if poolInfo[arg1].field_512 <= 0:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        if not poolInfo[arg1].field_512:
                                            revert with 'NH{q', 18
                                        if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                            revert with 'NH{q', 17
                                        if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                    else:
                                        if (block.number * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint and 10^12 > -1 / (block.number * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint:
                                            revert with 'NH{q', 17
                                        if not (block.number * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint:
                                            revert with 'NH{q', 18
                                        if 10^12 * (block.number * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint / (block.number * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint != 10^12:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if poolInfo[arg1].field_512 <= 0:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        if not poolInfo[arg1].field_512:
                                            revert with 'NH{q', 18
                                        if poolInfo[arg1].field_1536 > -(10^12 * (block.number * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint / poolInfo[arg1].field_512) - 1:
                                            revert with 'NH{q', 17
                                        if poolInfo[arg1].field_1536 + (10^12 * (block.number * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_1536 += 10^12 * (block.number * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint / poolInfo[arg1].field_512
                else:
                    if 100 < sub_e600038d:
                        revert with 'NH{q', 17
                    if poolInfo[arg1].field_1280 > block.number:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if block.number < poolInfo[arg1].field_1280:
                        revert with 'NH{q', 17
                    if not block.number - poolInfo[arg1].field_1280:
                        if totalAllocPoint <= 0:
                            revert with 0, 'SafeMath: division by zero', 0
                        if not totalAllocPoint:
                            revert with 'NH{q', 18
                        if not 0 / totalAllocPoint:
                            emit Mint(0, this.address);
                            if poolInfo[arg1].field_512 <= 0:
                                revert with 0, 'SafeMath: division by zero', 0
                            if not poolInfo[arg1].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                        else:
                            require ext_code.size(sushiAddress)
                            call sushiAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args address(this.address), 0 / totalAllocPoint
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            emit Mint((0 / totalAllocPoint), this.address);
                            if not 0 / totalAllocPoint:
                                if poolInfo[arg1].field_512 <= 0:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not poolInfo[arg1].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                            else:
                                if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                                    revert with 'NH{q', 17
                                if not 0 / totalAllocPoint:
                                    revert with 'NH{q', 18
                                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if poolInfo[arg1].field_512 <= 0:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not poolInfo[arg1].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[arg1].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[arg1].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[arg1].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512
                    else:
                        if block.number - poolInfo[arg1].field_1280 and -sub_e600038d + 100 > -1 / block.number - poolInfo[arg1].field_1280:
                            revert with 'NH{q', 17
                        if not block.number - poolInfo[arg1].field_1280:
                            revert with 'NH{q', 18
                        if (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / block.number - poolInfo[arg1].field_1280 != -sub_e600038d + 100:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100:
                            if totalAllocPoint <= 0:
                                revert with 0, 'SafeMath: division by zero', 0
                            if not totalAllocPoint:
                                revert with 'NH{q', 18
                            if not 0 / totalAllocPoint:
                                emit Mint(0, this.address);
                                if poolInfo[arg1].field_512 <= 0:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not poolInfo[arg1].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                            else:
                                require ext_code.size(sushiAddress)
                                call sushiAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args address(this.address), 0 / totalAllocPoint
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                emit Mint((0 / totalAllocPoint), this.address);
                                if not 0 / totalAllocPoint:
                                    if poolInfo[arg1].field_512 <= 0:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if not poolInfo[arg1].field_512:
                                        revert with 'NH{q', 18
                                    if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                        revert with 'NH{q', 17
                                    if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                else:
                                    if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                                        revert with 'NH{q', 17
                                    if not 0 / totalAllocPoint:
                                        revert with 'NH{q', 18
                                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if poolInfo[arg1].field_512 <= 0:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if not poolInfo[arg1].field_512:
                                        revert with 'NH{q', 18
                                    if poolInfo[arg1].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512) - 1:
                                        revert with 'NH{q', 17
                                    if poolInfo[arg1].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512
                        else:
                            if (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 and sushiPerBlock > -1 / (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100:
                                revert with 'NH{q', 17
                            if not (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100:
                                revert with 'NH{q', 18
                            if (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock / (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 != sushiPerBlock:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock:
                                if totalAllocPoint <= 0:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not totalAllocPoint:
                                    revert with 'NH{q', 18
                                if not 0 / totalAllocPoint:
                                    emit Mint(0, this.address);
                                    if poolInfo[arg1].field_512 <= 0:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if not poolInfo[arg1].field_512:
                                        revert with 'NH{q', 18
                                    if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                        revert with 'NH{q', 17
                                    if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                else:
                                    require ext_code.size(sushiAddress)
                                    call sushiAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args address(this.address), 0 / totalAllocPoint
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    emit Mint((0 / totalAllocPoint), this.address);
                                    if not 0 / totalAllocPoint:
                                        if poolInfo[arg1].field_512 <= 0:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        if not poolInfo[arg1].field_512:
                                            revert with 'NH{q', 18
                                        if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                            revert with 'NH{q', 17
                                        if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                    else:
                                        if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                                            revert with 'NH{q', 17
                                        if not 0 / totalAllocPoint:
                                            revert with 'NH{q', 18
                                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if poolInfo[arg1].field_512 <= 0:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        if not poolInfo[arg1].field_512:
                                            revert with 'NH{q', 18
                                        if poolInfo[arg1].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512) - 1:
                                            revert with 'NH{q', 17
                                        if poolInfo[arg1].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512
                            else:
                                if (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock and poolInfo[arg1].field_256 > -1 / (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock:
                                    revert with 'NH{q', 17
                                if not (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock:
                                    revert with 'NH{q', 18
                                if (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock != poolInfo[arg1].field_256:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if totalAllocPoint <= 0:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not totalAllocPoint:
                                    revert with 'NH{q', 18
                                if not (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint:
                                    emit Mint(0, this.address);
                                    if poolInfo[arg1].field_512 <= 0:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if not poolInfo[arg1].field_512:
                                        revert with 'NH{q', 18
                                    if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                        revert with 'NH{q', 17
                                    if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                else:
                                    require ext_code.size(sushiAddress)
                                    call sushiAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args address(this.address), (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    emit Mint(((100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint), this.address);
                                    if not (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint:
                                        if poolInfo[arg1].field_512 <= 0:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        if not poolInfo[arg1].field_512:
                                            revert with 'NH{q', 18
                                        if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                            revert with 'NH{q', 17
                                        if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                    else:
                                        if (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint and 10^12 > -1 / (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint:
                                            revert with 'NH{q', 17
                                        if not (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint:
                                            revert with 'NH{q', 18
                                        if 10^12 * (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint / (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint != 10^12:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if poolInfo[arg1].field_512 <= 0:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        if not poolInfo[arg1].field_512:
                                            revert with 'NH{q', 18
                                        if poolInfo[arg1].field_1536 > -(10^12 * (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint / poolInfo[arg1].field_512) - 1:
                                            revert with 'NH{q', 17
                                        if poolInfo[arg1].field_1536 + (10^12 * (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_1536 += 10^12 * (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint / poolInfo[arg1].field_512
            else:
                if poolInfo[arg1].field_1280 >= bonusEndBlock:
                    if not poolInfo[arg1].field_768:
                        if poolInfo[arg1].field_1280 > block.number:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if block.number < poolInfo[arg1].field_1280:
                            revert with 'NH{q', 17
                        if not block.number - poolInfo[arg1].field_1280:
                            if totalAllocPoint <= 0:
                                revert with 0, 'SafeMath: division by zero', 0
                            if not totalAllocPoint:
                                revert with 'NH{q', 18
                            if not 0 / totalAllocPoint:
                                emit Mint(0, this.address);
                                if poolInfo[arg1].field_512 <= 0:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not poolInfo[arg1].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                            else:
                                require ext_code.size(sushiAddress)
                                call sushiAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args address(this.address), 0 / totalAllocPoint
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                emit Mint((0 / totalAllocPoint), this.address);
                                if not 0 / totalAllocPoint:
                                    if poolInfo[arg1].field_512 <= 0:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if not poolInfo[arg1].field_512:
                                        revert with 'NH{q', 18
                                    if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                        revert with 'NH{q', 17
                                    if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                else:
                                    if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                                        revert with 'NH{q', 17
                                    if not 0 / totalAllocPoint:
                                        revert with 'NH{q', 18
                                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if poolInfo[arg1].field_512 <= 0:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if not poolInfo[arg1].field_512:
                                        revert with 'NH{q', 18
                                    if poolInfo[arg1].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512) - 1:
                                        revert with 'NH{q', 17
                                    if poolInfo[arg1].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512
                        else:
                            if block.number - poolInfo[arg1].field_1280 and sub_a054b70a > -1 / block.number - poolInfo[arg1].field_1280:
                                revert with 'NH{q', 17
                            if not block.number - poolInfo[arg1].field_1280:
                                revert with 'NH{q', 18
                            if (block.number * sub_a054b70a) - (poolInfo[arg1].field_1280 * sub_a054b70a) / block.number - poolInfo[arg1].field_1280 != sub_a054b70a:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not (block.number * sub_a054b70a) - (poolInfo[arg1].field_1280 * sub_a054b70a) / 100:
                                if totalAllocPoint <= 0:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not totalAllocPoint:
                                    revert with 'NH{q', 18
                                if not 0 / totalAllocPoint:
                                    emit Mint(0, this.address);
                                    if poolInfo[arg1].field_512 <= 0:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if not poolInfo[arg1].field_512:
                                        revert with 'NH{q', 18
                                    if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                        revert with 'NH{q', 17
                                    if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                else:
                                    require ext_code.size(sushiAddress)
                                    call sushiAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args address(this.address), 0 / totalAllocPoint
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    emit Mint((0 / totalAllocPoint), this.address);
                                    if not 0 / totalAllocPoint:
                                        if poolInfo[arg1].field_512 <= 0:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        if not poolInfo[arg1].field_512:
                                            revert with 'NH{q', 18
                                        if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                            revert with 'NH{q', 17
                                        if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                    else:
                                        if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                                            revert with 'NH{q', 17
                                        if not 0 / totalAllocPoint:
                                            revert with 'NH{q', 18
                                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if poolInfo[arg1].field_512 <= 0:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        if not poolInfo[arg1].field_512:
                                            revert with 'NH{q', 18
                                        if poolInfo[arg1].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512) - 1:
                                            revert with 'NH{q', 17
                                        if poolInfo[arg1].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512
                            else:
                                if (block.number * sub_a054b70a) - (poolInfo[arg1].field_1280 * sub_a054b70a) / 100 and sushiPerBlock > -1 / (block.number * sub_a054b70a) - (poolInfo[arg1].field_1280 * sub_a054b70a) / 100:
                                    revert with 'NH{q', 17
                                if not (block.number * sub_a054b70a) - (poolInfo[arg1].field_1280 * sub_a054b70a) / 100:
                                    revert with 'NH{q', 18
                                if (block.number * sub_a054b70a) - (poolInfo[arg1].field_1280 * sub_a054b70a) / 100 * sushiPerBlock / (block.number * sub_a054b70a) - (poolInfo[arg1].field_1280 * sub_a054b70a) / 100 != sushiPerBlock:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not (block.number * sub_a054b70a) - (poolInfo[arg1].field_1280 * sub_a054b70a) / 100 * sushiPerBlock:
                                    if totalAllocPoint <= 0:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if not totalAllocPoint:
                                        revert with 'NH{q', 18
                                    if not 0 / totalAllocPoint:
                                        emit Mint(0, this.address);
                                        if poolInfo[arg1].field_512 <= 0:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        if not poolInfo[arg1].field_512:
                                            revert with 'NH{q', 18
                                        if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                            revert with 'NH{q', 17
                                        if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                    else:
                                        require ext_code.size(sushiAddress)
                                        call sushiAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args address(this.address), 0 / totalAllocPoint
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        emit Mint((0 / totalAllocPoint), this.address);
                                        if not 0 / totalAllocPoint:
                                            if poolInfo[arg1].field_512 <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if not poolInfo[arg1].field_512:
                                                revert with 'NH{q', 18
                                            if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                revert with 'NH{q', 17
                                            if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                        else:
                                            if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                                                revert with 'NH{q', 17
                                            if not 0 / totalAllocPoint:
                                                revert with 'NH{q', 18
                                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if poolInfo[arg1].field_512 <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if not poolInfo[arg1].field_512:
                                                revert with 'NH{q', 18
                                            if poolInfo[arg1].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512) - 1:
                                                revert with 'NH{q', 17
                                            if poolInfo[arg1].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512
                                else:
                                    if (block.number * sub_a054b70a) - (poolInfo[arg1].field_1280 * sub_a054b70a) / 100 * sushiPerBlock and poolInfo[arg1].field_256 > -1 / (block.number * sub_a054b70a) - (poolInfo[arg1].field_1280 * sub_a054b70a) / 100 * sushiPerBlock:
                                        revert with 'NH{q', 17
                                    if not (block.number * sub_a054b70a) - (poolInfo[arg1].field_1280 * sub_a054b70a) / 100 * sushiPerBlock:
                                        revert with 'NH{q', 18
                                    if (block.number * sub_a054b70a) - (poolInfo[arg1].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / (block.number * sub_a054b70a) - (poolInfo[arg1].field_1280 * sub_a054b70a) / 100 * sushiPerBlock != poolInfo[arg1].field_256:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if totalAllocPoint <= 0:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if not totalAllocPoint:
                                        revert with 'NH{q', 18
                                    if not (block.number * sub_a054b70a) - (poolInfo[arg1].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint:
                                        emit Mint(0, this.address);
                                        if poolInfo[arg1].field_512 <= 0:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        if not poolInfo[arg1].field_512:
                                            revert with 'NH{q', 18
                                        if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                            revert with 'NH{q', 17
                                        if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                    else:
                                        require ext_code.size(sushiAddress)
                                        call sushiAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args address(this.address), (block.number * sub_a054b70a) - (poolInfo[arg1].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        emit Mint(((block.number * sub_a054b70a) - (poolInfo[arg1].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint), this.address);
                                        if not (block.number * sub_a054b70a) - (poolInfo[arg1].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint:
                                            if poolInfo[arg1].field_512 <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if not poolInfo[arg1].field_512:
                                                revert with 'NH{q', 18
                                            if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                revert with 'NH{q', 17
                                            if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                        else:
                                            if (block.number * sub_a054b70a) - (poolInfo[arg1].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint and 10^12 > -1 / (block.number * sub_a054b70a) - (poolInfo[arg1].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint:
                                                revert with 'NH{q', 17
                                            if not (block.number * sub_a054b70a) - (poolInfo[arg1].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint:
                                                revert with 'NH{q', 18
                                            if 10^12 * (block.number * sub_a054b70a) - (poolInfo[arg1].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint / (block.number * sub_a054b70a) - (poolInfo[arg1].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint != 10^12:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if poolInfo[arg1].field_512 <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if not poolInfo[arg1].field_512:
                                                revert with 'NH{q', 18
                                            if poolInfo[arg1].field_1536 > -(10^12 * (block.number * sub_a054b70a) - (poolInfo[arg1].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint / poolInfo[arg1].field_512) - 1:
                                                revert with 'NH{q', 17
                                            if poolInfo[arg1].field_1536 + (10^12 * (block.number * sub_a054b70a) - (poolInfo[arg1].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_1536 += 10^12 * (block.number * sub_a054b70a) - (poolInfo[arg1].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint / poolInfo[arg1].field_512
                    else:
                        if 100 < sub_a054b70a:
                            revert with 'NH{q', 17
                        if poolInfo[arg1].field_1280 > block.number:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if block.number < poolInfo[arg1].field_1280:
                            revert with 'NH{q', 17
                        if not block.number - poolInfo[arg1].field_1280:
                            if totalAllocPoint <= 0:
                                revert with 0, 'SafeMath: division by zero', 0
                            if not totalAllocPoint:
                                revert with 'NH{q', 18
                            if not 0 / totalAllocPoint:
                                emit Mint(0, this.address);
                                if poolInfo[arg1].field_512 <= 0:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not poolInfo[arg1].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                            else:
                                require ext_code.size(sushiAddress)
                                call sushiAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args address(this.address), 0 / totalAllocPoint
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                emit Mint((0 / totalAllocPoint), this.address);
                                if not 0 / totalAllocPoint:
                                    if poolInfo[arg1].field_512 <= 0:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if not poolInfo[arg1].field_512:
                                        revert with 'NH{q', 18
                                    if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                        revert with 'NH{q', 17
                                    if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                else:
                                    if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                                        revert with 'NH{q', 17
                                    if not 0 / totalAllocPoint:
                                        revert with 'NH{q', 18
                                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if poolInfo[arg1].field_512 <= 0:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if not poolInfo[arg1].field_512:
                                        revert with 'NH{q', 18
                                    if poolInfo[arg1].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512) - 1:
                                        revert with 'NH{q', 17
                                    if poolInfo[arg1].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512
                        else:
                            if block.number - poolInfo[arg1].field_1280 and -sub_a054b70a + 100 > -1 / block.number - poolInfo[arg1].field_1280:
                                revert with 'NH{q', 17
                            if not block.number - poolInfo[arg1].field_1280:
                                revert with 'NH{q', 18
                            if (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_a054b70a * poolInfo[arg1].field_1280) / block.number - poolInfo[arg1].field_1280 != -sub_a054b70a + 100:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_a054b70a * poolInfo[arg1].field_1280) / 100:
                                if totalAllocPoint <= 0:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not totalAllocPoint:
                                    revert with 'NH{q', 18
                                if not 0 / totalAllocPoint:
                                    emit Mint(0, this.address);
                                    if poolInfo[arg1].field_512 <= 0:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if not poolInfo[arg1].field_512:
                                        revert with 'NH{q', 18
                                    if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                        revert with 'NH{q', 17
                                    if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                else:
                                    require ext_code.size(sushiAddress)
                                    call sushiAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args address(this.address), 0 / totalAllocPoint
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    emit Mint((0 / totalAllocPoint), this.address);
                                    if not 0 / totalAllocPoint:
                                        if poolInfo[arg1].field_512 <= 0:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        if not poolInfo[arg1].field_512:
                                            revert with 'NH{q', 18
                                        if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                            revert with 'NH{q', 17
                                        if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                    else:
                                        if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                                            revert with 'NH{q', 17
                                        if not 0 / totalAllocPoint:
                                            revert with 'NH{q', 18
                                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if poolInfo[arg1].field_512 <= 0:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        if not poolInfo[arg1].field_512:
                                            revert with 'NH{q', 18
                                        if poolInfo[arg1].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512) - 1:
                                            revert with 'NH{q', 17
                                        if poolInfo[arg1].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512
                            else:
                                if (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_a054b70a * poolInfo[arg1].field_1280) / 100 and sushiPerBlock > -1 / (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_a054b70a * poolInfo[arg1].field_1280) / 100:
                                    revert with 'NH{q', 17
                                if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_a054b70a * poolInfo[arg1].field_1280) / 100:
                                    revert with 'NH{q', 18
                                if (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_a054b70a * poolInfo[arg1].field_1280) / 100 * sushiPerBlock / (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_a054b70a * poolInfo[arg1].field_1280) / 100 != sushiPerBlock:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_a054b70a * poolInfo[arg1].field_1280) / 100 * sushiPerBlock:
                                    if totalAllocPoint <= 0:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if not totalAllocPoint:
                                        revert with 'NH{q', 18
                                    if not 0 / totalAllocPoint:
                                        emit Mint(0, this.address);
                                        if poolInfo[arg1].field_512 <= 0:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        if not poolInfo[arg1].field_512:
                                            revert with 'NH{q', 18
                                        if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                            revert with 'NH{q', 17
                                        if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                    else:
                                        require ext_code.size(sushiAddress)
                                        call sushiAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args address(this.address), 0 / totalAllocPoint
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        emit Mint((0 / totalAllocPoint), this.address);
                                        if not 0 / totalAllocPoint:
                                            if poolInfo[arg1].field_512 <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if not poolInfo[arg1].field_512:
                                                revert with 'NH{q', 18
                                            if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                revert with 'NH{q', 17
                                            if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                        else:
                                            if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                                                revert with 'NH{q', 17
                                            if not 0 / totalAllocPoint:
                                                revert with 'NH{q', 18
                                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if poolInfo[arg1].field_512 <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if not poolInfo[arg1].field_512:
                                                revert with 'NH{q', 18
                                            if poolInfo[arg1].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512) - 1:
                                                revert with 'NH{q', 17
                                            if poolInfo[arg1].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512
                                else:
                                    if (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_a054b70a * poolInfo[arg1].field_1280) / 100 * sushiPerBlock and poolInfo[arg1].field_256 > -1 / (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_a054b70a * poolInfo[arg1].field_1280) / 100 * sushiPerBlock:
                                        revert with 'NH{q', 17
                                    if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_a054b70a * poolInfo[arg1].field_1280) / 100 * sushiPerBlock:
                                        revert with 'NH{q', 18
                                    if (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_a054b70a * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_a054b70a * poolInfo[arg1].field_1280) / 100 * sushiPerBlock != poolInfo[arg1].field_256:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if totalAllocPoint <= 0:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if not totalAllocPoint:
                                        revert with 'NH{q', 18
                                    if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_a054b70a * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint:
                                        emit Mint(0, this.address);
                                        if poolInfo[arg1].field_512 <= 0:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        if not poolInfo[arg1].field_512:
                                            revert with 'NH{q', 18
                                        if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                            revert with 'NH{q', 17
                                        if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                    else:
                                        require ext_code.size(sushiAddress)
                                        call sushiAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args address(this.address), (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_a054b70a * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        emit Mint(((100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_a054b70a * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint), this.address);
                                        if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_a054b70a * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint:
                                            if poolInfo[arg1].field_512 <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if not poolInfo[arg1].field_512:
                                                revert with 'NH{q', 18
                                            if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                revert with 'NH{q', 17
                                            if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                        else:
                                            if (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_a054b70a * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint and 10^12 > -1 / (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_a054b70a * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint:
                                                revert with 'NH{q', 17
                                            if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_a054b70a * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint:
                                                revert with 'NH{q', 18
                                            if 10^12 * (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_a054b70a * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint / (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_a054b70a * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint != 10^12:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if poolInfo[arg1].field_512 <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if not poolInfo[arg1].field_512:
                                                revert with 'NH{q', 18
                                            if poolInfo[arg1].field_1536 > -(10^12 * (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_a054b70a * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint / poolInfo[arg1].field_512) - 1:
                                                revert with 'NH{q', 17
                                            if poolInfo[arg1].field_1536 + (10^12 * (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_a054b70a * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_1536 += 10^12 * (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[arg1].field_1280) + (sub_a054b70a * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint / poolInfo[arg1].field_512
                else:
                    if not poolInfo[arg1].field_768:
                        if bonusEndBlock > block.number:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if block.number < bonusEndBlock:
                            revert with 'NH{q', 17
                        if not block.number - bonusEndBlock:
                            if poolInfo[arg1].field_1280 > bonusEndBlock:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if bonusEndBlock < poolInfo[arg1].field_1280:
                                revert with 'NH{q', 17
                            if not bonusEndBlock - poolInfo[arg1].field_1280:
                                if totalAllocPoint <= 0:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not totalAllocPoint:
                                    revert with 'NH{q', 18
                                if not 0 / totalAllocPoint:
                                    emit Mint(0, this.address);
                                    if poolInfo[arg1].field_512 <= 0:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if not poolInfo[arg1].field_512:
                                        revert with 'NH{q', 18
                                    if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                        revert with 'NH{q', 17
                                    if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                else:
                                    require ext_code.size(sushiAddress)
                                    call sushiAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args address(this.address), 0 / totalAllocPoint
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    emit Mint((0 / totalAllocPoint), this.address);
                                    if not 0 / totalAllocPoint:
                                        if poolInfo[arg1].field_512 <= 0:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        if not poolInfo[arg1].field_512:
                                            revert with 'NH{q', 18
                                        if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                            revert with 'NH{q', 17
                                        if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                    else:
                                        if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                                            revert with 'NH{q', 17
                                        if not 0 / totalAllocPoint:
                                            revert with 'NH{q', 18
                                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if poolInfo[arg1].field_512 <= 0:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        if not poolInfo[arg1].field_512:
                                            revert with 'NH{q', 18
                                        if poolInfo[arg1].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512) - 1:
                                            revert with 'NH{q', 17
                                        if poolInfo[arg1].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512
                            else:
                                if bonusEndBlock - poolInfo[arg1].field_1280 and sub_e600038d > -1 / bonusEndBlock - poolInfo[arg1].field_1280:
                                    revert with 'NH{q', 17
                                if not bonusEndBlock - poolInfo[arg1].field_1280:
                                    revert with 'NH{q', 18
                                if (bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / bonusEndBlock - poolInfo[arg1].field_1280 != sub_e600038d:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if (bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 > -1:
                                    revert with 'NH{q', 17
                                if (bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 < (bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not (bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100:
                                    if totalAllocPoint <= 0:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if not totalAllocPoint:
                                        revert with 'NH{q', 18
                                    if not 0 / totalAllocPoint:
                                        emit Mint(0, this.address);
                                        if poolInfo[arg1].field_512 <= 0:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        if not poolInfo[arg1].field_512:
                                            revert with 'NH{q', 18
                                        if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                            revert with 'NH{q', 17
                                        if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                    else:
                                        require ext_code.size(sushiAddress)
                                        call sushiAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args address(this.address), 0 / totalAllocPoint
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        emit Mint((0 / totalAllocPoint), this.address);
                                        if not 0 / totalAllocPoint:
                                            if poolInfo[arg1].field_512 <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if not poolInfo[arg1].field_512:
                                                revert with 'NH{q', 18
                                            if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                revert with 'NH{q', 17
                                            if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                        else:
                                            if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                                                revert with 'NH{q', 17
                                            if not 0 / totalAllocPoint:
                                                revert with 'NH{q', 18
                                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if poolInfo[arg1].field_512 <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if not poolInfo[arg1].field_512:
                                                revert with 'NH{q', 18
                                            if poolInfo[arg1].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512) - 1:
                                                revert with 'NH{q', 17
                                            if poolInfo[arg1].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512
                                else:
                                    if (bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 and sushiPerBlock > -1 / (bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100:
                                        revert with 'NH{q', 17
                                    if not (bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100:
                                        revert with 'NH{q', 18
                                    if (bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock / (bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 != sushiPerBlock:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not (bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock:
                                        if totalAllocPoint <= 0:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        if not totalAllocPoint:
                                            revert with 'NH{q', 18
                                        if not 0 / totalAllocPoint:
                                            emit Mint(0, this.address);
                                            if poolInfo[arg1].field_512 <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if not poolInfo[arg1].field_512:
                                                revert with 'NH{q', 18
                                            if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                revert with 'NH{q', 17
                                            if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                        else:
                                            require ext_code.size(sushiAddress)
                                            call sushiAddress.0x40c10f19 with:
                                                 gas gas_remaining wei
                                                args address(this.address), 0 / totalAllocPoint
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            emit Mint((0 / totalAllocPoint), this.address);
                                            if not 0 / totalAllocPoint:
                                                if poolInfo[arg1].field_512 <= 0:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                if not poolInfo[arg1].field_512:
                                                    revert with 'NH{q', 18
                                                if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                    revert with 'NH{q', 17
                                                if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                            else:
                                                if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                                                    revert with 'NH{q', 17
                                                if not 0 / totalAllocPoint:
                                                    revert with 'NH{q', 18
                                                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if poolInfo[arg1].field_512 <= 0:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                if not poolInfo[arg1].field_512:
                                                    revert with 'NH{q', 18
                                                if poolInfo[arg1].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512) - 1:
                                                    revert with 'NH{q', 17
                                                if poolInfo[arg1].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512
                                    else:
                                        if (bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock and poolInfo[arg1].field_256 > -1 / (bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock:
                                            revert with 'NH{q', 17
                                        if not (bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock:
                                            revert with 'NH{q', 18
                                        if (bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / (bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock != poolInfo[arg1].field_256:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if totalAllocPoint <= 0:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        if not totalAllocPoint:
                                            revert with 'NH{q', 18
                                        if not (bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint:
                                            emit Mint(0, this.address);
                                            if poolInfo[arg1].field_512 <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if not poolInfo[arg1].field_512:
                                                revert with 'NH{q', 18
                                            if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                revert with 'NH{q', 17
                                            if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                        else:
                                            require ext_code.size(sushiAddress)
                                            call sushiAddress.0x40c10f19 with:
                                                 gas gas_remaining wei
                                                args address(this.address), (bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            emit Mint(((bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint), this.address);
                                            if not (bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint:
                                                if poolInfo[arg1].field_512 <= 0:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                if not poolInfo[arg1].field_512:
                                                    revert with 'NH{q', 18
                                                if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                    revert with 'NH{q', 17
                                                if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                            else:
                                                if (bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint and 10^12 > -1 / (bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint:
                                                    revert with 'NH{q', 17
                                                if not (bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint:
                                                    revert with 'NH{q', 18
                                                if 10^12 * (bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint / (bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint != 10^12:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if poolInfo[arg1].field_512 <= 0:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                if not poolInfo[arg1].field_512:
                                                    revert with 'NH{q', 18
                                                if poolInfo[arg1].field_1536 > -(10^12 * (bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint / poolInfo[arg1].field_512) - 1:
                                                    revert with 'NH{q', 17
                                                if poolInfo[arg1].field_1536 + (10^12 * (bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_1536 += 10^12 * (bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint / poolInfo[arg1].field_512
                        else:
                            if block.number - bonusEndBlock and sub_a054b70a > -1 / block.number - bonusEndBlock:
                                revert with 'NH{q', 17
                            if not block.number - bonusEndBlock:
                                revert with 'NH{q', 18
                            if (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / block.number - bonusEndBlock != sub_a054b70a:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if poolInfo[arg1].field_1280 > bonusEndBlock:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if bonusEndBlock < poolInfo[arg1].field_1280:
                                revert with 'NH{q', 17
                            if not bonusEndBlock - poolInfo[arg1].field_1280:
                                if 0 > -((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100) - 1:
                                    revert with 'NH{q', 17
                                if (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100:
                                    if totalAllocPoint <= 0:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if not totalAllocPoint:
                                        revert with 'NH{q', 18
                                    if not 0 / totalAllocPoint:
                                        emit Mint(0, this.address);
                                        if poolInfo[arg1].field_512 <= 0:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        if not poolInfo[arg1].field_512:
                                            revert with 'NH{q', 18
                                        if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                            revert with 'NH{q', 17
                                        if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                    else:
                                        require ext_code.size(sushiAddress)
                                        call sushiAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args address(this.address), 0 / totalAllocPoint
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        emit Mint((0 / totalAllocPoint), this.address);
                                        if not 0 / totalAllocPoint:
                                            if poolInfo[arg1].field_512 <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if not poolInfo[arg1].field_512:
                                                revert with 'NH{q', 18
                                            if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                revert with 'NH{q', 17
                                            if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                        else:
                                            if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                                                revert with 'NH{q', 17
                                            if not 0 / totalAllocPoint:
                                                revert with 'NH{q', 18
                                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if poolInfo[arg1].field_512 <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if not poolInfo[arg1].field_512:
                                                revert with 'NH{q', 18
                                            if poolInfo[arg1].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512) - 1:
                                                revert with 'NH{q', 17
                                            if poolInfo[arg1].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512
                                else:
                                    if (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 and sushiPerBlock > -1 / (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100:
                                        revert with 'NH{q', 17
                                    if not (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100:
                                        revert with 'NH{q', 18
                                    if (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock / (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 != sushiPerBlock:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock:
                                        if totalAllocPoint <= 0:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        if not totalAllocPoint:
                                            revert with 'NH{q', 18
                                        if not 0 / totalAllocPoint:
                                            emit Mint(0, this.address);
                                            if poolInfo[arg1].field_512 <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if not poolInfo[arg1].field_512:
                                                revert with 'NH{q', 18
                                            if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                revert with 'NH{q', 17
                                            if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                        else:
                                            require ext_code.size(sushiAddress)
                                            call sushiAddress.0x40c10f19 with:
                                                 gas gas_remaining wei
                                                args address(this.address), 0 / totalAllocPoint
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            emit Mint((0 / totalAllocPoint), this.address);
                                            if not 0 / totalAllocPoint:
                                                if poolInfo[arg1].field_512 <= 0:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                if not poolInfo[arg1].field_512:
                                                    revert with 'NH{q', 18
                                                if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                    revert with 'NH{q', 17
                                                if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                            else:
                                                if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                                                    revert with 'NH{q', 17
                                                if not 0 / totalAllocPoint:
                                                    revert with 'NH{q', 18
                                                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if poolInfo[arg1].field_512 <= 0:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                if not poolInfo[arg1].field_512:
                                                    revert with 'NH{q', 18
                                                if poolInfo[arg1].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512) - 1:
                                                    revert with 'NH{q', 17
                                                if poolInfo[arg1].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512
                                    else:
                                        if (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock and poolInfo[arg1].field_256 > -1 / (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock:
                                            revert with 'NH{q', 17
                                        if not (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock:
                                            revert with 'NH{q', 18
                                        if (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock != poolInfo[arg1].field_256:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if totalAllocPoint <= 0:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        if not totalAllocPoint:
                                            revert with 'NH{q', 18
                                        if not (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint:
                                            emit Mint(0, this.address);
                                            if poolInfo[arg1].field_512 <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if not poolInfo[arg1].field_512:
                                                revert with 'NH{q', 18
                                            if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                revert with 'NH{q', 17
                                            if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                        else:
                                            require ext_code.size(sushiAddress)
                                            call sushiAddress.0x40c10f19 with:
                                                 gas gas_remaining wei
                                                args address(this.address), (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            emit Mint(((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint), this.address);
                                            if not (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint:
                                                if poolInfo[arg1].field_512 <= 0:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                if not poolInfo[arg1].field_512:
                                                    revert with 'NH{q', 18
                                                if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                    revert with 'NH{q', 17
                                                if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                            else:
                                                if (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint and 10^12 > -1 / (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint:
                                                    revert with 'NH{q', 17
                                                if not (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint:
                                                    revert with 'NH{q', 18
                                                if 10^12 * (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint / (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint != 10^12:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if poolInfo[arg1].field_512 <= 0:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                if not poolInfo[arg1].field_512:
                                                    revert with 'NH{q', 18
                                                if poolInfo[arg1].field_1536 > -(10^12 * (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint / poolInfo[arg1].field_512) - 1:
                                                    revert with 'NH{q', 17
                                                if poolInfo[arg1].field_1536 + (10^12 * (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_1536 += 10^12 * (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint / poolInfo[arg1].field_512
                            else:
                                if bonusEndBlock - poolInfo[arg1].field_1280 and sub_e600038d > -1 / bonusEndBlock - poolInfo[arg1].field_1280:
                                    revert with 'NH{q', 17
                                if not bonusEndBlock - poolInfo[arg1].field_1280:
                                    revert with 'NH{q', 18
                                if (bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / bonusEndBlock - poolInfo[arg1].field_1280 != sub_e600038d:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if (bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 > -((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100) - 1:
                                    revert with 'NH{q', 17
                                if ((bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100) < (bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not ((bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100):
                                    if totalAllocPoint <= 0:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if not totalAllocPoint:
                                        revert with 'NH{q', 18
                                    if not 0 / totalAllocPoint:
                                        emit Mint(0, this.address);
                                        if poolInfo[arg1].field_512 <= 0:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        if not poolInfo[arg1].field_512:
                                            revert with 'NH{q', 18
                                        if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                            revert with 'NH{q', 17
                                        if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                    else:
                                        require ext_code.size(sushiAddress)
                                        call sushiAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args address(this.address), 0 / totalAllocPoint
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        emit Mint((0 / totalAllocPoint), this.address);
                                        if not 0 / totalAllocPoint:
                                            if poolInfo[arg1].field_512 <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if not poolInfo[arg1].field_512:
                                                revert with 'NH{q', 18
                                            if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                revert with 'NH{q', 17
                                            if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                        else:
                                            if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                                                revert with 'NH{q', 17
                                            if not 0 / totalAllocPoint:
                                                revert with 'NH{q', 18
                                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if poolInfo[arg1].field_512 <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if not poolInfo[arg1].field_512:
                                                revert with 'NH{q', 18
                                            if poolInfo[arg1].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512) - 1:
                                                revert with 'NH{q', 17
                                            if poolInfo[arg1].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512
                                else:
                                    if ((bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100) and sushiPerBlock > -1 / ((bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100):
                                        revert with 'NH{q', 17
                                    if not ((bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100):
                                        revert with 'NH{q', 18
                                    if ((bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock) / ((bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100) != sushiPerBlock:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not ((bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock):
                                        if totalAllocPoint <= 0:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        if not totalAllocPoint:
                                            revert with 'NH{q', 18
                                        if not 0 / totalAllocPoint:
                                            emit Mint(0, this.address);
                                            if poolInfo[arg1].field_512 <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if not poolInfo[arg1].field_512:
                                                revert with 'NH{q', 18
                                            if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                revert with 'NH{q', 17
                                            if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                        else:
                                            require ext_code.size(sushiAddress)
                                            call sushiAddress.0x40c10f19 with:
                                                 gas gas_remaining wei
                                                args address(this.address), 0 / totalAllocPoint
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            emit Mint((0 / totalAllocPoint), this.address);
                                            if not 0 / totalAllocPoint:
                                                if poolInfo[arg1].field_512 <= 0:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                if not poolInfo[arg1].field_512:
                                                    revert with 'NH{q', 18
                                                if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                    revert with 'NH{q', 17
                                                if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                            else:
                                                if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                                                    revert with 'NH{q', 17
                                                if not 0 / totalAllocPoint:
                                                    revert with 'NH{q', 18
                                                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if poolInfo[arg1].field_512 <= 0:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                if not poolInfo[arg1].field_512:
                                                    revert with 'NH{q', 18
                                                if poolInfo[arg1].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512) - 1:
                                                    revert with 'NH{q', 17
                                                if poolInfo[arg1].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512
                                    else:
                                        if ((bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock) and poolInfo[arg1].field_256 > -1 / ((bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock):
                                            revert with 'NH{q', 17
                                        if not ((bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock):
                                            revert with 'NH{q', 18
                                        if ((bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[arg1].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[arg1].field_256) / ((bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock) != poolInfo[arg1].field_256:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if totalAllocPoint <= 0:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        if not totalAllocPoint:
                                            revert with 'NH{q', 18
                                        if not ((bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[arg1].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[arg1].field_256) / totalAllocPoint:
                                            emit Mint(0, this.address);
                                            if poolInfo[arg1].field_512 <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if not poolInfo[arg1].field_512:
                                                revert with 'NH{q', 18
                                            if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                revert with 'NH{q', 17
                                            if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                        else:
                                            require ext_code.size(sushiAddress)
                                            call sushiAddress.0x40c10f19 with:
                                                 gas gas_remaining wei
                                                args address(this.address), ((bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[arg1].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[arg1].field_256) / totalAllocPoint
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            emit Mint((((bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[arg1].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[arg1].field_256) / totalAllocPoint), this.address);
                                            if not ((bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[arg1].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[arg1].field_256) / totalAllocPoint:
                                                if poolInfo[arg1].field_512 <= 0:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                if not poolInfo[arg1].field_512:
                                                    revert with 'NH{q', 18
                                                if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                    revert with 'NH{q', 17
                                                if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                            else:
                                                if ((bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[arg1].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[arg1].field_256) / totalAllocPoint and 10^12 > -1 / ((bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[arg1].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[arg1].field_256) / totalAllocPoint:
                                                    revert with 'NH{q', 17
                                                if not ((bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[arg1].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[arg1].field_256) / totalAllocPoint:
                                                    revert with 'NH{q', 18
                                                if 10^12 * ((bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[arg1].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / ((bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[arg1].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if poolInfo[arg1].field_512 <= 0:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                if not poolInfo[arg1].field_512:
                                                    revert with 'NH{q', 18
                                                if poolInfo[arg1].field_1536 > -(10^12 * ((bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[arg1].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_512) - 1:
                                                    revert with 'NH{q', 17
                                                if poolInfo[arg1].field_1536 + (10^12 * ((bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[arg1].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_1536 += 10^12 * ((bonusEndBlock * sub_e600038d) - (poolInfo[arg1].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[arg1].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_512
                    else:
                        if 100 < sub_a054b70a:
                            revert with 'NH{q', 17
                        if bonusEndBlock > block.number:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if block.number < bonusEndBlock:
                            revert with 'NH{q', 17
                        if not block.number - bonusEndBlock:
                            if 100 < sub_e600038d:
                                revert with 'NH{q', 17
                            if poolInfo[arg1].field_1280 > bonusEndBlock:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if bonusEndBlock < poolInfo[arg1].field_1280:
                                revert with 'NH{q', 17
                            if not bonusEndBlock - poolInfo[arg1].field_1280:
                                if totalAllocPoint <= 0:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not totalAllocPoint:
                                    revert with 'NH{q', 18
                                if not 0 / totalAllocPoint:
                                    emit Mint(0, this.address);
                                    if poolInfo[arg1].field_512 <= 0:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if not poolInfo[arg1].field_512:
                                        revert with 'NH{q', 18
                                    if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                        revert with 'NH{q', 17
                                    if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                else:
                                    require ext_code.size(sushiAddress)
                                    call sushiAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args address(this.address), 0 / totalAllocPoint
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    emit Mint((0 / totalAllocPoint), this.address);
                                    if not 0 / totalAllocPoint:
                                        if poolInfo[arg1].field_512 <= 0:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        if not poolInfo[arg1].field_512:
                                            revert with 'NH{q', 18
                                        if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                            revert with 'NH{q', 17
                                        if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                    else:
                                        if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                                            revert with 'NH{q', 17
                                        if not 0 / totalAllocPoint:
                                            revert with 'NH{q', 18
                                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if poolInfo[arg1].field_512 <= 0:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        if not poolInfo[arg1].field_512:
                                            revert with 'NH{q', 18
                                        if poolInfo[arg1].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512) - 1:
                                            revert with 'NH{q', 17
                                        if poolInfo[arg1].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512
                            else:
                                if bonusEndBlock - poolInfo[arg1].field_1280 and -sub_e600038d + 100 > -1 / bonusEndBlock - poolInfo[arg1].field_1280:
                                    revert with 'NH{q', 17
                                if not bonusEndBlock - poolInfo[arg1].field_1280:
                                    revert with 'NH{q', 18
                                if (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / bonusEndBlock - poolInfo[arg1].field_1280 != -sub_e600038d + 100:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 > -1:
                                    revert with 'NH{q', 17
                                if (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 < (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100:
                                    if totalAllocPoint <= 0:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if not totalAllocPoint:
                                        revert with 'NH{q', 18
                                    if not 0 / totalAllocPoint:
                                        emit Mint(0, this.address);
                                        if poolInfo[arg1].field_512 <= 0:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        if not poolInfo[arg1].field_512:
                                            revert with 'NH{q', 18
                                        if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                            revert with 'NH{q', 17
                                        if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                    else:
                                        require ext_code.size(sushiAddress)
                                        call sushiAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args address(this.address), 0 / totalAllocPoint
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        emit Mint((0 / totalAllocPoint), this.address);
                                        if not 0 / totalAllocPoint:
                                            if poolInfo[arg1].field_512 <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if not poolInfo[arg1].field_512:
                                                revert with 'NH{q', 18
                                            if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                revert with 'NH{q', 17
                                            if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                        else:
                                            if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                                                revert with 'NH{q', 17
                                            if not 0 / totalAllocPoint:
                                                revert with 'NH{q', 18
                                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if poolInfo[arg1].field_512 <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if not poolInfo[arg1].field_512:
                                                revert with 'NH{q', 18
                                            if poolInfo[arg1].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512) - 1:
                                                revert with 'NH{q', 17
                                            if poolInfo[arg1].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512
                                else:
                                    if (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 and sushiPerBlock > -1 / (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100:
                                        revert with 'NH{q', 17
                                    if not (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100:
                                        revert with 'NH{q', 18
                                    if (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock / (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 != sushiPerBlock:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock:
                                        if totalAllocPoint <= 0:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        if not totalAllocPoint:
                                            revert with 'NH{q', 18
                                        if not 0 / totalAllocPoint:
                                            emit Mint(0, this.address);
                                            if poolInfo[arg1].field_512 <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if not poolInfo[arg1].field_512:
                                                revert with 'NH{q', 18
                                            if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                revert with 'NH{q', 17
                                            if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                        else:
                                            require ext_code.size(sushiAddress)
                                            call sushiAddress.0x40c10f19 with:
                                                 gas gas_remaining wei
                                                args address(this.address), 0 / totalAllocPoint
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            emit Mint((0 / totalAllocPoint), this.address);
                                            if not 0 / totalAllocPoint:
                                                if poolInfo[arg1].field_512 <= 0:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                if not poolInfo[arg1].field_512:
                                                    revert with 'NH{q', 18
                                                if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                    revert with 'NH{q', 17
                                                if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                            else:
                                                if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                                                    revert with 'NH{q', 17
                                                if not 0 / totalAllocPoint:
                                                    revert with 'NH{q', 18
                                                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if poolInfo[arg1].field_512 <= 0:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                if not poolInfo[arg1].field_512:
                                                    revert with 'NH{q', 18
                                                if poolInfo[arg1].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512) - 1:
                                                    revert with 'NH{q', 17
                                                if poolInfo[arg1].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512
                                    else:
                                        if (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock and poolInfo[arg1].field_256 > -1 / (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock:
                                            revert with 'NH{q', 17
                                        if not (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock:
                                            revert with 'NH{q', 18
                                        if (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock != poolInfo[arg1].field_256:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if totalAllocPoint <= 0:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        if not totalAllocPoint:
                                            revert with 'NH{q', 18
                                        if not (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint:
                                            emit Mint(0, this.address);
                                            if poolInfo[arg1].field_512 <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if not poolInfo[arg1].field_512:
                                                revert with 'NH{q', 18
                                            if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                revert with 'NH{q', 17
                                            if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                        else:
                                            require ext_code.size(sushiAddress)
                                            call sushiAddress.0x40c10f19 with:
                                                 gas gas_remaining wei
                                                args address(this.address), (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            emit Mint(((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint), this.address);
                                            if not (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint:
                                                if poolInfo[arg1].field_512 <= 0:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                if not poolInfo[arg1].field_512:
                                                    revert with 'NH{q', 18
                                                if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                    revert with 'NH{q', 17
                                                if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                            else:
                                                if (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint and 10^12 > -1 / (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint:
                                                    revert with 'NH{q', 17
                                                if not (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint:
                                                    revert with 'NH{q', 18
                                                if 10^12 * (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint / (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint != 10^12:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if poolInfo[arg1].field_512 <= 0:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                if not poolInfo[arg1].field_512:
                                                    revert with 'NH{q', 18
                                                if poolInfo[arg1].field_1536 > -(10^12 * (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint / poolInfo[arg1].field_512) - 1:
                                                    revert with 'NH{q', 17
                                                if poolInfo[arg1].field_1536 + (10^12 * (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_1536 += 10^12 * (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint / poolInfo[arg1].field_512
                        else:
                            if block.number - bonusEndBlock and -sub_a054b70a + 100 > -1 / block.number - bonusEndBlock:
                                revert with 'NH{q', 17
                            if not block.number - bonusEndBlock:
                                revert with 'NH{q', 18
                            if (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / block.number - bonusEndBlock != -sub_a054b70a + 100:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 100 < sub_e600038d:
                                revert with 'NH{q', 17
                            if poolInfo[arg1].field_1280 > bonusEndBlock:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if bonusEndBlock < poolInfo[arg1].field_1280:
                                revert with 'NH{q', 17
                            if not bonusEndBlock - poolInfo[arg1].field_1280:
                                if 0 > -((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100) - 1:
                                    revert with 'NH{q', 17
                                if (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100:
                                    if totalAllocPoint <= 0:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if not totalAllocPoint:
                                        revert with 'NH{q', 18
                                    if not 0 / totalAllocPoint:
                                        emit Mint(0, this.address);
                                        if poolInfo[arg1].field_512 <= 0:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        if not poolInfo[arg1].field_512:
                                            revert with 'NH{q', 18
                                        if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                            revert with 'NH{q', 17
                                        if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                    else:
                                        require ext_code.size(sushiAddress)
                                        call sushiAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args address(this.address), 0 / totalAllocPoint
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        emit Mint((0 / totalAllocPoint), this.address);
                                        if not 0 / totalAllocPoint:
                                            if poolInfo[arg1].field_512 <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if not poolInfo[arg1].field_512:
                                                revert with 'NH{q', 18
                                            if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                revert with 'NH{q', 17
                                            if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                        else:
                                            if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                                                revert with 'NH{q', 17
                                            if not 0 / totalAllocPoint:
                                                revert with 'NH{q', 18
                                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if poolInfo[arg1].field_512 <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if not poolInfo[arg1].field_512:
                                                revert with 'NH{q', 18
                                            if poolInfo[arg1].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512) - 1:
                                                revert with 'NH{q', 17
                                            if poolInfo[arg1].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512
                                else:
                                    if (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 and sushiPerBlock > -1 / (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100:
                                        revert with 'NH{q', 17
                                    if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100:
                                        revert with 'NH{q', 18
                                    if (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock / (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 != sushiPerBlock:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock:
                                        if totalAllocPoint <= 0:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        if not totalAllocPoint:
                                            revert with 'NH{q', 18
                                        if not 0 / totalAllocPoint:
                                            emit Mint(0, this.address);
                                            if poolInfo[arg1].field_512 <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if not poolInfo[arg1].field_512:
                                                revert with 'NH{q', 18
                                            if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                revert with 'NH{q', 17
                                            if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                        else:
                                            require ext_code.size(sushiAddress)
                                            call sushiAddress.0x40c10f19 with:
                                                 gas gas_remaining wei
                                                args address(this.address), 0 / totalAllocPoint
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            emit Mint((0 / totalAllocPoint), this.address);
                                            if not 0 / totalAllocPoint:
                                                if poolInfo[arg1].field_512 <= 0:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                if not poolInfo[arg1].field_512:
                                                    revert with 'NH{q', 18
                                                if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                    revert with 'NH{q', 17
                                                if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                            else:
                                                if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                                                    revert with 'NH{q', 17
                                                if not 0 / totalAllocPoint:
                                                    revert with 'NH{q', 18
                                                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if poolInfo[arg1].field_512 <= 0:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                if not poolInfo[arg1].field_512:
                                                    revert with 'NH{q', 18
                                                if poolInfo[arg1].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512) - 1:
                                                    revert with 'NH{q', 17
                                                if poolInfo[arg1].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512
                                    else:
                                        if (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock and poolInfo[arg1].field_256 > -1 / (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock:
                                            revert with 'NH{q', 17
                                        if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock:
                                            revert with 'NH{q', 18
                                        if (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock != poolInfo[arg1].field_256:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if totalAllocPoint <= 0:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        if not totalAllocPoint:
                                            revert with 'NH{q', 18
                                        if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint:
                                            emit Mint(0, this.address);
                                            if poolInfo[arg1].field_512 <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if not poolInfo[arg1].field_512:
                                                revert with 'NH{q', 18
                                            if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                revert with 'NH{q', 17
                                            if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                        else:
                                            require ext_code.size(sushiAddress)
                                            call sushiAddress.0x40c10f19 with:
                                                 gas gas_remaining wei
                                                args address(this.address), (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            emit Mint(((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint), this.address);
                                            if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint:
                                                if poolInfo[arg1].field_512 <= 0:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                if not poolInfo[arg1].field_512:
                                                    revert with 'NH{q', 18
                                                if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                    revert with 'NH{q', 17
                                                if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                            else:
                                                if (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint and 10^12 > -1 / (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint:
                                                    revert with 'NH{q', 17
                                                if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint:
                                                    revert with 'NH{q', 18
                                                if 10^12 * (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint / (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint != 10^12:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if poolInfo[arg1].field_512 <= 0:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                if not poolInfo[arg1].field_512:
                                                    revert with 'NH{q', 18
                                                if poolInfo[arg1].field_1536 > -(10^12 * (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint / poolInfo[arg1].field_512) - 1:
                                                    revert with 'NH{q', 17
                                                if poolInfo[arg1].field_1536 + (10^12 * (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_1536 += 10^12 * (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[arg1].field_256 / totalAllocPoint / poolInfo[arg1].field_512
                            else:
                                if bonusEndBlock - poolInfo[arg1].field_1280 and -sub_e600038d + 100 > -1 / bonusEndBlock - poolInfo[arg1].field_1280:
                                    revert with 'NH{q', 17
                                if not bonusEndBlock - poolInfo[arg1].field_1280:
                                    revert with 'NH{q', 18
                                if (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / bonusEndBlock - poolInfo[arg1].field_1280 != -sub_e600038d + 100:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 > -((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100) - 1:
                                    revert with 'NH{q', 17
                                if ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100) < (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100):
                                    if totalAllocPoint <= 0:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if not totalAllocPoint:
                                        revert with 'NH{q', 18
                                    if not 0 / totalAllocPoint:
                                        emit Mint(0, this.address);
                                        if poolInfo[arg1].field_512 <= 0:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        if not poolInfo[arg1].field_512:
                                            revert with 'NH{q', 18
                                        if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                            revert with 'NH{q', 17
                                        if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                    else:
                                        require ext_code.size(sushiAddress)
                                        call sushiAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args address(this.address), 0 / totalAllocPoint
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        emit Mint((0 / totalAllocPoint), this.address);
                                        if not 0 / totalAllocPoint:
                                            if poolInfo[arg1].field_512 <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if not poolInfo[arg1].field_512:
                                                revert with 'NH{q', 18
                                            if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                revert with 'NH{q', 17
                                            if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                        else:
                                            if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                                                revert with 'NH{q', 17
                                            if not 0 / totalAllocPoint:
                                                revert with 'NH{q', 18
                                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if poolInfo[arg1].field_512 <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if not poolInfo[arg1].field_512:
                                                revert with 'NH{q', 18
                                            if poolInfo[arg1].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512) - 1:
                                                revert with 'NH{q', 17
                                            if poolInfo[arg1].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512
                                else:
                                    if ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100) and sushiPerBlock > -1 / ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100):
                                        revert with 'NH{q', 17
                                    if not ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100):
                                        revert with 'NH{q', 18
                                    if ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock) / ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100) != sushiPerBlock:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock):
                                        if totalAllocPoint <= 0:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        if not totalAllocPoint:
                                            revert with 'NH{q', 18
                                        if not 0 / totalAllocPoint:
                                            emit Mint(0, this.address);
                                            if poolInfo[arg1].field_512 <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if not poolInfo[arg1].field_512:
                                                revert with 'NH{q', 18
                                            if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                revert with 'NH{q', 17
                                            if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                        else:
                                            require ext_code.size(sushiAddress)
                                            call sushiAddress.0x40c10f19 with:
                                                 gas gas_remaining wei
                                                args address(this.address), 0 / totalAllocPoint
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            emit Mint((0 / totalAllocPoint), this.address);
                                            if not 0 / totalAllocPoint:
                                                if poolInfo[arg1].field_512 <= 0:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                if not poolInfo[arg1].field_512:
                                                    revert with 'NH{q', 18
                                                if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                    revert with 'NH{q', 17
                                                if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                            else:
                                                if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                                                    revert with 'NH{q', 17
                                                if not 0 / totalAllocPoint:
                                                    revert with 'NH{q', 18
                                                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if poolInfo[arg1].field_512 <= 0:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                if not poolInfo[arg1].field_512:
                                                    revert with 'NH{q', 18
                                                if poolInfo[arg1].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512) - 1:
                                                    revert with 'NH{q', 17
                                                if poolInfo[arg1].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_512
                                    else:
                                        if ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock) and poolInfo[arg1].field_256 > -1 / ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock):
                                            revert with 'NH{q', 17
                                        if not ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock):
                                            revert with 'NH{q', 18
                                        if ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[arg1].field_256) / ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock) != poolInfo[arg1].field_256:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if totalAllocPoint <= 0:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        if not totalAllocPoint:
                                            revert with 'NH{q', 18
                                        if not ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[arg1].field_256) / totalAllocPoint:
                                            emit Mint(0, this.address);
                                            if poolInfo[arg1].field_512 <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            if not poolInfo[arg1].field_512:
                                                revert with 'NH{q', 18
                                            if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                revert with 'NH{q', 17
                                            if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                        else:
                                            require ext_code.size(sushiAddress)
                                            call sushiAddress.0x40c10f19 with:
                                                 gas gas_remaining wei
                                                args address(this.address), ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[arg1].field_256) / totalAllocPoint
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            emit Mint((((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[arg1].field_256) / totalAllocPoint), this.address);
                                            if not ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[arg1].field_256) / totalAllocPoint:
                                                if poolInfo[arg1].field_512 <= 0:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                if not poolInfo[arg1].field_512:
                                                    revert with 'NH{q', 18
                                                if poolInfo[arg1].field_1536 > -(0 / poolInfo[arg1].field_512) - 1:
                                                    revert with 'NH{q', 17
                                                if poolInfo[arg1].field_1536 + (0 / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_1536 += 0 / poolInfo[arg1].field_512
                                            else:
                                                if ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[arg1].field_256) / totalAllocPoint and 10^12 > -1 / ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[arg1].field_256) / totalAllocPoint:
                                                    revert with 'NH{q', 17
                                                if not ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[arg1].field_256) / totalAllocPoint:
                                                    revert with 'NH{q', 18
                                                if 10^12 * ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if poolInfo[arg1].field_512 <= 0:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                if not poolInfo[arg1].field_512:
                                                    revert with 'NH{q', 18
                                                if poolInfo[arg1].field_1536 > -(10^12 * ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_512) - 1:
                                                    revert with 'NH{q', 17
                                                if poolInfo[arg1].field_1536 + (10^12 * ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_512) < poolInfo[arg1].field_1536:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_1536 += 10^12 * ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[arg1].field_1280) + (sub_e600038d * poolInfo[arg1].field_1280) / 100 * sushiPerBlock * poolInfo[arg1].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_512
        poolInfo[arg1].field_1280 = block.number
}

function massUpdatePools() payable {
    mem[64] = 96
    require not msg.value
    idx = 0
    while idx < poolInfo.length:
        mem[0] = 7
        if block.number <= poolInfo[idx].field_1280:
            if idx == -1:
                revert with 'NH{q', 17
            idx = idx + 1
            continue 
        if not poolInfo[idx].field_512:
            poolInfo[idx].field_1280 = block.number
            if idx == -1:
                revert with 'NH{q', 17
            idx = idx + 1
            continue 
        if block.number <= bonusEndBlock:
            if not poolInfo[idx].field_768:
                _1406 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1406] = 30
                mem[_1406 + 32] = 'SafeMath: subtraction overflow'
                if poolInfo[idx].field_1280 > block.number:
                    _1409 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_1409 + idx + 68] = mem[_1406 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1409 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _1409 + -mem[64] + 100
                if block.number < poolInfo[idx].field_1280:
                    revert with 'NH{q', 17
                if not block.number - poolInfo[idx].field_1280:
                    _1427 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1427] = 26
                    mem[_1427 + 32] = 'SafeMath: division by zero'
                    _1463 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1463] = 26
                    mem[_1463 + 32] = 'SafeMath: division by zero'
                    if totalAllocPoint <= 0:
                        _1469 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1469 + idx + 68] = mem[_1463 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1469 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1469 + -mem[64] + 100
                    if not totalAllocPoint:
                        revert with 'NH{q', 18
                    if not 0 / totalAllocPoint:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _1549 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1549] = 26
                        mem[_1549 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _1558 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1558 + idx + 68] = mem[_1549 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1558 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1558 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sushiAddress)
                    call sushiAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args address(this.address), 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0 / totalAllocPoint
                    emit Mint((0 / totalAllocPoint), this.address);
                    if not 0 / totalAllocPoint:
                        _1613 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1613] = 26
                        mem[_1613 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _1629 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1629 + idx + 68] = mem[_1613 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1629 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1629 + -mem[64] + 100
                    if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                        revert with 'NH{q', 17
                    if not 0 / totalAllocPoint:
                        revert with 'NH{q', 18
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _1728 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1728] = 26
                    mem[_1728 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _1753 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_1753 + idx + 68] = mem[_1728 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1753 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _1753 + -mem[64] + 100
                if block.number - poolInfo[idx].field_1280 and sub_e600038d > -1 / block.number - poolInfo[idx].field_1280:
                    revert with 'NH{q', 17
                if not block.number - poolInfo[idx].field_1280:
                    revert with 'NH{q', 18
                if (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / block.number - poolInfo[idx].field_1280 != sub_e600038d:
                    revert with 0, 'SafeMath: multiplication overflow'
                _1453 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1453] = 26
                mem[_1453 + 32] = 'SafeMath: division by zero'
                if not (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100:
                    _1497 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1497] = 26
                    mem[_1497 + 32] = 'SafeMath: division by zero'
                    if totalAllocPoint <= 0:
                        _1501 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1501 + idx + 68] = mem[_1497 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1501 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1501 + -mem[64] + 100
                    if not totalAllocPoint:
                        revert with 'NH{q', 18
                    if not 0 / totalAllocPoint:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _1637 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1637] = 26
                        mem[_1637 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _1645 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1645 + idx + 68] = mem[_1637 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1645 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1645 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sushiAddress)
                    call sushiAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args address(this.address), 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0 / totalAllocPoint
                    emit Mint((0 / totalAllocPoint), this.address);
                    if not 0 / totalAllocPoint:
                        _1727 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1727] = 26
                        mem[_1727 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _1752 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1752 + idx + 68] = mem[_1727 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1752 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1752 + -mem[64] + 100
                    if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                        revert with 'NH{q', 17
                    if not 0 / totalAllocPoint:
                        revert with 'NH{q', 18
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _1891 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1891] = 26
                    mem[_1891 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _1916 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_1916 + idx + 68] = mem[_1891 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1916 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _1916 + -mem[64] + 100
                if (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 and sushiPerBlock > -1 / (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100:
                    revert with 'NH{q', 17
                if not (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100:
                    revert with 'NH{q', 18
                if (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock / (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 != sushiPerBlock:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock:
                    _1557 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1557] = 26
                    mem[_1557 + 32] = 'SafeMath: division by zero'
                    if totalAllocPoint <= 0:
                        _1564 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1564 + idx + 68] = mem[_1557 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1564 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1564 + -mem[64] + 100
                    if not totalAllocPoint:
                        revert with 'NH{q', 18
                    if not 0 / totalAllocPoint:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _1764 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1764] = 26
                        mem[_1764 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _1781 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1781 + idx + 68] = mem[_1764 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1781 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1781 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sushiAddress)
                    call sushiAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args address(this.address), 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0 / totalAllocPoint
                    emit Mint((0 / totalAllocPoint), this.address);
                    if not 0 / totalAllocPoint:
                        _1890 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1890] = 26
                        mem[_1890 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _1915 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1915 + idx + 68] = mem[_1890 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1915 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1915 + -mem[64] + 100
                    if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                        revert with 'NH{q', 17
                    if not 0 / totalAllocPoint:
                        revert with 'NH{q', 18
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _2080 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2080] = 26
                    mem[_2080 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _2110 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2110 + idx + 68] = mem[_2080 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2110 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _2110 + -mem[64] + 100
                if (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock and poolInfo[idx].field_256 > -1 / (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock:
                    revert with 'NH{q', 17
                if not (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock:
                    revert with 'NH{q', 18
                if (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock != poolInfo[idx].field_256:
                    revert with 0, 'SafeMath: multiplication overflow'
                _1644 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1644] = 26
                mem[_1644 + 32] = 'SafeMath: division by zero'
                if totalAllocPoint <= 0:
                    _1656 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_1656 + idx + 68] = mem[_1644 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1656 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _1656 + -mem[64] + 100
                if not totalAllocPoint:
                    revert with 'NH{q', 18
                if not (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                    mem[mem[64]] = 0
                    emit Mint(0, this.address);
                    _1926 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1926] = 26
                    mem[_1926 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _1950 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_1950 + idx + 68] = mem[_1926 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1950 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _1950 + -mem[64] + 100
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                require ext_code.size(sushiAddress)
                call sushiAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args address(this.address), (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                emit Mint(((block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint), this.address);
                if not (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                    _2079 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2079] = 26
                    mem[_2079 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _2109 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2109 + idx + 68] = mem[_2079 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2109 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _2109 + -mem[64] + 100
                if (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint and 10^12 > -1 / (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                    revert with 'NH{q', 17
                if not (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                    revert with 'NH{q', 18
                if 10^12 * (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                _2285 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2285] = 26
                mem[_2285 + 32] = 'SafeMath: division by zero'
                if poolInfo[idx].field_512 > 0:
                    if not poolInfo[idx].field_512:
                        revert with 'NH{q', 18
                    if poolInfo[idx].field_1536 > -(10^12 * (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                        revert with 'NH{q', 17
                    if poolInfo[idx].field_1536 + (10^12 * (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_1536 += 10^12 * (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512
                    poolInfo[idx].field_1280 = block.number
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                _2315 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_2315 + idx + 68] = mem[_2285 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_2315 + 94] = 0
                revert with memory
                  from mem[64]
                   len _2315 + -mem[64] + 100
            if 100 < sub_e600038d:
                revert with 'NH{q', 17
            _1415 = mem[64]
            mem[64] = mem[64] + 64
            mem[_1415] = 30
            mem[_1415 + 32] = 'SafeMath: subtraction overflow'
            if poolInfo[idx].field_1280 > block.number:
                _1418 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_1418 + idx + 68] = mem[_1415 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_1418 + 98] = 0
                revert with memory
                  from mem[64]
                   len _1418 + -mem[64] + 100
            if block.number < poolInfo[idx].field_1280:
                revert with 'NH{q', 17
            if not block.number - poolInfo[idx].field_1280:
                _1439 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1439] = 26
                mem[_1439 + 32] = 'SafeMath: division by zero'
                _1480 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1480] = 26
                mem[_1480 + 32] = 'SafeMath: division by zero'
                if totalAllocPoint <= 0:
                    _1485 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_1485 + idx + 68] = mem[_1480 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1485 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _1485 + -mem[64] + 100
                if not totalAllocPoint:
                    revert with 'NH{q', 18
                if not 0 / totalAllocPoint:
                    mem[mem[64]] = 0
                    emit Mint(0, this.address);
                    _1585 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1585] = 26
                    mem[_1585 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _1599 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_1599 + idx + 68] = mem[_1585 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1599 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _1599 + -mem[64] + 100
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = 0 / totalAllocPoint
                require ext_code.size(sushiAddress)
                call sushiAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args address(this.address), 0 / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 0 / totalAllocPoint
                emit Mint((0 / totalAllocPoint), this.address);
                if not 0 / totalAllocPoint:
                    _1659 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1659] = 26
                    mem[_1659 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _1681 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_1681 + idx + 68] = mem[_1659 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1681 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _1681 + -mem[64] + 100
                if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                    revert with 'NH{q', 17
                if not 0 / totalAllocPoint:
                    revert with 'NH{q', 18
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                _1804 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1804] = 26
                mem[_1804 + 32] = 'SafeMath: division by zero'
                if poolInfo[idx].field_512 > 0:
                    if not poolInfo[idx].field_512:
                        revert with 'NH{q', 18
                    if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                        revert with 'NH{q', 17
                    if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                    poolInfo[idx].field_1280 = block.number
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                _1824 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_1824 + idx + 68] = mem[_1804 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_1824 + 94] = 0
                revert with memory
                  from mem[64]
                   len _1824 + -mem[64] + 100
            if block.number - poolInfo[idx].field_1280 and -sub_e600038d + 100 > -1 / block.number - poolInfo[idx].field_1280:
                revert with 'NH{q', 17
            if not block.number - poolInfo[idx].field_1280:
                revert with 'NH{q', 18
            if (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / block.number - poolInfo[idx].field_1280 != -sub_e600038d + 100:
                revert with 0, 'SafeMath: multiplication overflow'
            _1464 = mem[64]
            mem[64] = mem[64] + 64
            mem[_1464] = 26
            mem[_1464 + 32] = 'SafeMath: division by zero'
            if not (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100:
                _1524 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1524] = 26
                mem[_1524 + 32] = 'SafeMath: division by zero'
                if totalAllocPoint <= 0:
                    _1531 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_1531 + idx + 68] = mem[_1524 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1531 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _1531 + -mem[64] + 100
                if not totalAllocPoint:
                    revert with 'NH{q', 18
                if not 0 / totalAllocPoint:
                    mem[mem[64]] = 0
                    emit Mint(0, this.address);
                    _1689 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1689] = 26
                    mem[_1689 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _1703 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_1703 + idx + 68] = mem[_1689 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1703 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _1703 + -mem[64] + 100
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = 0 / totalAllocPoint
                require ext_code.size(sushiAddress)
                call sushiAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args address(this.address), 0 / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 0 / totalAllocPoint
                emit Mint((0 / totalAllocPoint), this.address);
                if not 0 / totalAllocPoint:
                    _1803 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1803] = 26
                    mem[_1803 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _1823 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_1823 + idx + 68] = mem[_1803 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1823 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _1823 + -mem[64] + 100
                if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                    revert with 'NH{q', 17
                if not 0 / totalAllocPoint:
                    revert with 'NH{q', 18
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                _1974 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1974] = 26
                mem[_1974 + 32] = 'SafeMath: division by zero'
                if poolInfo[idx].field_512 > 0:
                    if not poolInfo[idx].field_512:
                        revert with 'NH{q', 18
                    if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                        revert with 'NH{q', 17
                    if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                    poolInfo[idx].field_1280 = block.number
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                _1993 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_1993 + idx + 68] = mem[_1974 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_1993 + 94] = 0
                revert with memory
                  from mem[64]
                   len _1993 + -mem[64] + 100
            if (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 and sushiPerBlock > -1 / (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100:
                revert with 'NH{q', 17
            if not (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100:
                revert with 'NH{q', 18
            if (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock / (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 != sushiPerBlock:
                revert with 0, 'SafeMath: multiplication overflow'
            if not (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock:
                _1598 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1598] = 26
                mem[_1598 + 32] = 'SafeMath: division by zero'
                if totalAllocPoint <= 0:
                    _1606 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_1606 + idx + 68] = mem[_1598 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1606 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _1606 + -mem[64] + 100
                if not totalAllocPoint:
                    revert with 'NH{q', 18
                if not 0 / totalAllocPoint:
                    mem[mem[64]] = 0
                    emit Mint(0, this.address);
                    _1834 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1834] = 26
                    mem[_1834 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _1859 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_1859 + idx + 68] = mem[_1834 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1859 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _1859 + -mem[64] + 100
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = 0 / totalAllocPoint
                require ext_code.size(sushiAddress)
                call sushiAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args address(this.address), 0 / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 0 / totalAllocPoint
                emit Mint((0 / totalAllocPoint), this.address);
                if not 0 / totalAllocPoint:
                    _1973 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1973] = 26
                    mem[_1973 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _1992 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_1992 + idx + 68] = mem[_1973 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1992 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _1992 + -mem[64] + 100
                if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                    revert with 'NH{q', 17
                if not 0 / totalAllocPoint:
                    revert with 'NH{q', 18
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                _2165 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2165] = 26
                mem[_2165 + 32] = 'SafeMath: division by zero'
                if poolInfo[idx].field_512 > 0:
                    if not poolInfo[idx].field_512:
                        revert with 'NH{q', 18
                    if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                        revert with 'NH{q', 17
                    if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                    poolInfo[idx].field_1280 = block.number
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                _2186 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_2186 + idx + 68] = mem[_2165 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_2186 + 94] = 0
                revert with memory
                  from mem[64]
                   len _2186 + -mem[64] + 100
            if (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock and poolInfo[idx].field_256 > -1 / (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock:
                revert with 'NH{q', 17
            if not (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock:
                revert with 'NH{q', 18
            if (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock != poolInfo[idx].field_256:
                revert with 0, 'SafeMath: multiplication overflow'
            _1702 = mem[64]
            mem[64] = mem[64] + 64
            mem[_1702] = 26
            mem[_1702 + 32] = 'SafeMath: division by zero'
            if totalAllocPoint <= 0:
                _1719 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_1719 + idx + 68] = mem[_1702 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_1719 + 94] = 0
                revert with memory
                  from mem[64]
                   len _1719 + -mem[64] + 100
            if not totalAllocPoint:
                revert with 'NH{q', 18
            if not (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                mem[mem[64]] = 0
                emit Mint(0, this.address);
                _2005 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2005] = 26
                mem[_2005 + 32] = 'SafeMath: division by zero'
                if poolInfo[idx].field_512 > 0:
                    if not poolInfo[idx].field_512:
                        revert with 'NH{q', 18
                    if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                        revert with 'NH{q', 17
                    if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                    poolInfo[idx].field_1280 = block.number
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                _2042 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_2042 + idx + 68] = mem[_2005 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_2042 + 94] = 0
                revert with memory
                  from mem[64]
                   len _2042 + -mem[64] + 100
            mem[mem[64] + 4] = this.address
            mem[mem[64] + 36] = (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
            require ext_code.size(sushiAddress)
            call sushiAddress.0x40c10f19 with:
                 gas gas_remaining wei
                args address(this.address), (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[mem[64]] = (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
            emit Mint(((100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint), this.address);
            if not (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                _2164 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2164] = 26
                mem[_2164 + 32] = 'SafeMath: division by zero'
                if poolInfo[idx].field_512 > 0:
                    if not poolInfo[idx].field_512:
                        revert with 'NH{q', 18
                    if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                        revert with 'NH{q', 17
                    if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                    poolInfo[idx].field_1280 = block.number
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                _2185 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_2185 + idx + 68] = mem[_2164 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_2185 + 94] = 0
                revert with memory
                  from mem[64]
                   len _2185 + -mem[64] + 100
            if (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint and 10^12 > -1 / (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                revert with 'NH{q', 17
            if not (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                revert with 'NH{q', 18
            if 10^12 * (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint != 10^12:
                revert with 0, 'SafeMath: multiplication overflow'
            _2366 = mem[64]
            mem[64] = mem[64] + 64
            mem[_2366] = 26
            mem[_2366 + 32] = 'SafeMath: division by zero'
            if poolInfo[idx].field_512 > 0:
                if not poolInfo[idx].field_512:
                    revert with 'NH{q', 18
                if poolInfo[idx].field_1536 > -(10^12 * (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                    revert with 'NH{q', 17
                if poolInfo[idx].field_1536 + (10^12 * (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                    revert with 0, 'SafeMath: addition overflow'
                poolInfo[idx].field_1536 += 10^12 * (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512
                poolInfo[idx].field_1280 = block.number
                if idx == -1:
                    revert with 'NH{q', 17
                idx = idx + 1
                continue 
            _2390 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[_2390 + idx + 68] = mem[_2366 + idx + 32]
                idx = idx + 32
                continue 
            mem[_2390 + 94] = 0
            revert with memory
              from mem[64]
               len _2390 + -mem[64] + 100
        if poolInfo[idx].field_1280 >= bonusEndBlock:
            if not poolInfo[idx].field_768:
                _1408 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1408] = 30
                mem[_1408 + 32] = 'SafeMath: subtraction overflow'
                if poolInfo[idx].field_1280 > block.number:
                    _1411 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_1411 + idx + 68] = mem[_1408 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1411 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _1411 + -mem[64] + 100
                if block.number < poolInfo[idx].field_1280:
                    revert with 'NH{q', 17
                if not block.number - poolInfo[idx].field_1280:
                    _1429 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1429] = 26
                    mem[_1429 + 32] = 'SafeMath: division by zero'
                    _1466 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1466] = 26
                    mem[_1466 + 32] = 'SafeMath: division by zero'
                    if totalAllocPoint <= 0:
                        _1470 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1470 + idx + 68] = mem[_1466 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1470 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1470 + -mem[64] + 100
                    if not totalAllocPoint:
                        revert with 'NH{q', 18
                    if not 0 / totalAllocPoint:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _1553 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1553] = 26
                        mem[_1553 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _1562 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1562 + idx + 68] = mem[_1553 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1562 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1562 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sushiAddress)
                    call sushiAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args address(this.address), 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0 / totalAllocPoint
                    emit Mint((0 / totalAllocPoint), this.address);
                    if not 0 / totalAllocPoint:
                        _1619 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1619] = 26
                        mem[_1619 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _1633 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1633 + idx + 68] = mem[_1619 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1633 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1633 + -mem[64] + 100
                    if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                        revert with 'NH{q', 17
                    if not 0 / totalAllocPoint:
                        revert with 'NH{q', 18
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _1741 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1741] = 26
                    mem[_1741 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _1759 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_1759 + idx + 68] = mem[_1741 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1759 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _1759 + -mem[64] + 100
                if block.number - poolInfo[idx].field_1280 and sub_a054b70a > -1 / block.number - poolInfo[idx].field_1280:
                    revert with 'NH{q', 17
                if not block.number - poolInfo[idx].field_1280:
                    revert with 'NH{q', 18
                if (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / block.number - poolInfo[idx].field_1280 != sub_a054b70a:
                    revert with 0, 'SafeMath: multiplication overflow'
                _1455 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1455] = 26
                mem[_1455 + 32] = 'SafeMath: division by zero'
                if not (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100:
                    _1499 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1499] = 26
                    mem[_1499 + 32] = 'SafeMath: division by zero'
                    if totalAllocPoint <= 0:
                        _1503 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1503 + idx + 68] = mem[_1499 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1503 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1503 + -mem[64] + 100
                    if not totalAllocPoint:
                        revert with 'NH{q', 18
                    if not 0 / totalAllocPoint:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _1642 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1642] = 26
                        mem[_1642 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _1649 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1649 + idx + 68] = mem[_1642 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1649 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1649 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sushiAddress)
                    call sushiAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args address(this.address), 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0 / totalAllocPoint
                    emit Mint((0 / totalAllocPoint), this.address);
                    if not 0 / totalAllocPoint:
                        _1740 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1740] = 26
                        mem[_1740 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _1758 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1758 + idx + 68] = mem[_1740 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1758 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1758 + -mem[64] + 100
                    if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                        revert with 'NH{q', 17
                    if not 0 / totalAllocPoint:
                        revert with 'NH{q', 18
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _1905 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1905] = 26
                    mem[_1905 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _1923 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_1923 + idx + 68] = mem[_1905 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1923 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _1923 + -mem[64] + 100
                if (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 and sushiPerBlock > -1 / (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100:
                    revert with 'NH{q', 17
                if not (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100:
                    revert with 'NH{q', 18
                if (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock / (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 != sushiPerBlock:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock:
                    _1561 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1561] = 26
                    mem[_1561 + 32] = 'SafeMath: division by zero'
                    if totalAllocPoint <= 0:
                        _1568 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1568 + idx + 68] = mem[_1561 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1568 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1568 + -mem[64] + 100
                    if not totalAllocPoint:
                        revert with 'NH{q', 18
                    if not 0 / totalAllocPoint:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _1773 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1773] = 26
                        mem[_1773 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _1786 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1786 + idx + 68] = mem[_1773 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1786 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1786 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sushiAddress)
                    call sushiAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args address(this.address), 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0 / totalAllocPoint
                    emit Mint((0 / totalAllocPoint), this.address);
                    if not 0 / totalAllocPoint:
                        _1904 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1904] = 26
                        mem[_1904 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _1922 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1922 + idx + 68] = mem[_1904 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1922 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1922 + -mem[64] + 100
                    if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                        revert with 'NH{q', 17
                    if not 0 / totalAllocPoint:
                        revert with 'NH{q', 18
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _2095 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2095] = 26
                    mem[_2095 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _2117 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2117 + idx + 68] = mem[_2095 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2117 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _2117 + -mem[64] + 100
                if (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock and poolInfo[idx].field_256 > -1 / (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock:
                    revert with 'NH{q', 17
                if not (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock:
                    revert with 'NH{q', 18
                if (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock != poolInfo[idx].field_256:
                    revert with 0, 'SafeMath: multiplication overflow'
                _1648 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1648] = 26
                mem[_1648 + 32] = 'SafeMath: division by zero'
                if totalAllocPoint <= 0:
                    _1663 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_1663 + idx + 68] = mem[_1648 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1663 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _1663 + -mem[64] + 100
                if not totalAllocPoint:
                    revert with 'NH{q', 18
                if not (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                    mem[mem[64]] = 0
                    emit Mint(0, this.address);
                    _1938 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1938] = 26
                    mem[_1938 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _1958 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_1958 + idx + 68] = mem[_1938 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1958 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _1958 + -mem[64] + 100
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                require ext_code.size(sushiAddress)
                call sushiAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args address(this.address), (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                emit Mint(((block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint), this.address);
                if not (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                    _2094 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2094] = 26
                    mem[_2094 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _2116 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2116 + idx + 68] = mem[_2094 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2116 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _2116 + -mem[64] + 100
                if (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint and 10^12 > -1 / (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                    revert with 'NH{q', 17
                if not (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                    revert with 'NH{q', 18
                if 10^12 * (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                _2301 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2301] = 26
                mem[_2301 + 32] = 'SafeMath: division by zero'
                if poolInfo[idx].field_512 > 0:
                    if not poolInfo[idx].field_512:
                        revert with 'NH{q', 18
                    if poolInfo[idx].field_1536 > -(10^12 * (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                        revert with 'NH{q', 17
                    if poolInfo[idx].field_1536 + (10^12 * (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_1536 += 10^12 * (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512
                    poolInfo[idx].field_1280 = block.number
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                _2321 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_2321 + idx + 68] = mem[_2301 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_2321 + 94] = 0
                revert with memory
                  from mem[64]
                   len _2321 + -mem[64] + 100
            if 100 < sub_a054b70a:
                revert with 'NH{q', 17
            _1417 = mem[64]
            mem[64] = mem[64] + 64
            mem[_1417] = 30
            mem[_1417 + 32] = 'SafeMath: subtraction overflow'
            if poolInfo[idx].field_1280 > block.number:
                _1420 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_1420 + idx + 68] = mem[_1417 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_1420 + 98] = 0
                revert with memory
                  from mem[64]
                   len _1420 + -mem[64] + 100
            if block.number < poolInfo[idx].field_1280:
                revert with 'NH{q', 17
            if not block.number - poolInfo[idx].field_1280:
                _1441 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1441] = 26
                mem[_1441 + 32] = 'SafeMath: division by zero'
                _1483 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1483] = 26
                mem[_1483 + 32] = 'SafeMath: division by zero'
                if totalAllocPoint <= 0:
                    _1487 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_1487 + idx + 68] = mem[_1483 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1487 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _1487 + -mem[64] + 100
                if not totalAllocPoint:
                    revert with 'NH{q', 18
                if not 0 / totalAllocPoint:
                    mem[mem[64]] = 0
                    emit Mint(0, this.address);
                    _1591 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1591] = 26
                    mem[_1591 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _1602 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_1602 + idx + 68] = mem[_1591 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1602 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _1602 + -mem[64] + 100
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = 0 / totalAllocPoint
                require ext_code.size(sushiAddress)
                call sushiAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args address(this.address), 0 / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 0 / totalAllocPoint
                emit Mint((0 / totalAllocPoint), this.address);
                if not 0 / totalAllocPoint:
                    _1666 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1666] = 26
                    mem[_1666 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _1685 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_1685 + idx + 68] = mem[_1666 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1685 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _1685 + -mem[64] + 100
                if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                    revert with 'NH{q', 17
                if not 0 / totalAllocPoint:
                    revert with 'NH{q', 18
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                _1809 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1809] = 26
                mem[_1809 + 32] = 'SafeMath: division by zero'
                if poolInfo[idx].field_512 > 0:
                    if not poolInfo[idx].field_512:
                        revert with 'NH{q', 18
                    if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                        revert with 'NH{q', 17
                    if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                    poolInfo[idx].field_1280 = block.number
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                _1830 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_1830 + idx + 68] = mem[_1809 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_1830 + 94] = 0
                revert with memory
                  from mem[64]
                   len _1830 + -mem[64] + 100
            if block.number - poolInfo[idx].field_1280 and -sub_a054b70a + 100 > -1 / block.number - poolInfo[idx].field_1280:
                revert with 'NH{q', 17
            if not block.number - poolInfo[idx].field_1280:
                revert with 'NH{q', 18
            if (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / block.number - poolInfo[idx].field_1280 != -sub_a054b70a + 100:
                revert with 0, 'SafeMath: multiplication overflow'
            _1467 = mem[64]
            mem[64] = mem[64] + 64
            mem[_1467] = 26
            mem[_1467 + 32] = 'SafeMath: division by zero'
            if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100:
                _1527 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1527] = 26
                mem[_1527 + 32] = 'SafeMath: division by zero'
                if totalAllocPoint <= 0:
                    _1535 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_1535 + idx + 68] = mem[_1527 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1535 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _1535 + -mem[64] + 100
                if not totalAllocPoint:
                    revert with 'NH{q', 18
                if not 0 / totalAllocPoint:
                    mem[mem[64]] = 0
                    emit Mint(0, this.address);
                    _1694 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1694] = 26
                    mem[_1694 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _1709 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_1709 + idx + 68] = mem[_1694 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1709 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _1709 + -mem[64] + 100
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = 0 / totalAllocPoint
                require ext_code.size(sushiAddress)
                call sushiAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args address(this.address), 0 / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 0 / totalAllocPoint
                emit Mint((0 / totalAllocPoint), this.address);
                if not 0 / totalAllocPoint:
                    _1808 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1808] = 26
                    mem[_1808 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _1829 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_1829 + idx + 68] = mem[_1808 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1829 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _1829 + -mem[64] + 100
                if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                    revert with 'NH{q', 17
                if not 0 / totalAllocPoint:
                    revert with 'NH{q', 18
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                _1979 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1979] = 26
                mem[_1979 + 32] = 'SafeMath: division by zero'
                if poolInfo[idx].field_512 > 0:
                    if not poolInfo[idx].field_512:
                        revert with 'NH{q', 18
                    if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                        revert with 'NH{q', 17
                    if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                    poolInfo[idx].field_1280 = block.number
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                _2002 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_2002 + idx + 68] = mem[_1979 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_2002 + 94] = 0
                revert with memory
                  from mem[64]
                   len _2002 + -mem[64] + 100
            if (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 and sushiPerBlock > -1 / (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100:
                revert with 'NH{q', 17
            if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100:
                revert with 'NH{q', 18
            if (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock / (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 != sushiPerBlock:
                revert with 0, 'SafeMath: multiplication overflow'
            if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock:
                _1601 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1601] = 26
                mem[_1601 + 32] = 'SafeMath: division by zero'
                if totalAllocPoint <= 0:
                    _1610 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_1610 + idx + 68] = mem[_1601 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1610 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _1610 + -mem[64] + 100
                if not totalAllocPoint:
                    revert with 'NH{q', 18
                if not 0 / totalAllocPoint:
                    mem[mem[64]] = 0
                    emit Mint(0, this.address);
                    _1842 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1842] = 26
                    mem[_1842 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _1869 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_1869 + idx + 68] = mem[_1842 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1869 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _1869 + -mem[64] + 100
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = 0 / totalAllocPoint
                require ext_code.size(sushiAddress)
                call sushiAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args address(this.address), 0 / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 0 / totalAllocPoint
                emit Mint((0 / totalAllocPoint), this.address);
                if not 0 / totalAllocPoint:
                    _1978 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1978] = 26
                    mem[_1978 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _2001 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2001 + idx + 68] = mem[_1978 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2001 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _2001 + -mem[64] + 100
                if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                    revert with 'NH{q', 17
                if not 0 / totalAllocPoint:
                    revert with 'NH{q', 18
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                _2173 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2173] = 26
                mem[_2173 + 32] = 'SafeMath: division by zero'
                if poolInfo[idx].field_512 > 0:
                    if not poolInfo[idx].field_512:
                        revert with 'NH{q', 18
                    if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                        revert with 'NH{q', 17
                    if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                    poolInfo[idx].field_1280 = block.number
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                _2198 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_2198 + idx + 68] = mem[_2173 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_2198 + 94] = 0
                revert with memory
                  from mem[64]
                   len _2198 + -mem[64] + 100
            if (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock and poolInfo[idx].field_256 > -1 / (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock:
                revert with 'NH{q', 17
            if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock:
                revert with 'NH{q', 18
            if (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock != poolInfo[idx].field_256:
                revert with 0, 'SafeMath: multiplication overflow'
            _1708 = mem[64]
            mem[64] = mem[64] + 64
            mem[_1708] = 26
            mem[_1708 + 32] = 'SafeMath: division by zero'
            if totalAllocPoint <= 0:
                _1724 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_1724 + idx + 68] = mem[_1708 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_1724 + 94] = 0
                revert with memory
                  from mem[64]
                   len _1724 + -mem[64] + 100
            if not totalAllocPoint:
                revert with 'NH{q', 18
            if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                mem[mem[64]] = 0
                emit Mint(0, this.address);
                _2019 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2019] = 26
                mem[_2019 + 32] = 'SafeMath: division by zero'
                if poolInfo[idx].field_512 > 0:
                    if not poolInfo[idx].field_512:
                        revert with 'NH{q', 18
                    if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                        revert with 'NH{q', 17
                    if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                    poolInfo[idx].field_1280 = block.number
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                _2054 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_2054 + idx + 68] = mem[_2019 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_2054 + 94] = 0
                revert with memory
                  from mem[64]
                   len _2054 + -mem[64] + 100
            mem[mem[64] + 4] = this.address
            mem[mem[64] + 36] = (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
            require ext_code.size(sushiAddress)
            call sushiAddress.0x40c10f19 with:
                 gas gas_remaining wei
                args address(this.address), (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[mem[64]] = (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
            emit Mint(((100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint), this.address);
            if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                _2172 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2172] = 26
                mem[_2172 + 32] = 'SafeMath: division by zero'
                if poolInfo[idx].field_512 > 0:
                    if not poolInfo[idx].field_512:
                        revert with 'NH{q', 18
                    if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                        revert with 'NH{q', 17
                    if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                    poolInfo[idx].field_1280 = block.number
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                _2197 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_2197 + idx + 68] = mem[_2172 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_2197 + 94] = 0
                revert with memory
                  from mem[64]
                   len _2197 + -mem[64] + 100
            if (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint and 10^12 > -1 / (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                revert with 'NH{q', 17
            if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                revert with 'NH{q', 18
            if 10^12 * (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint != 10^12:
                revert with 0, 'SafeMath: multiplication overflow'
            _2378 = mem[64]
            mem[64] = mem[64] + 64
            mem[_2378] = 26
            mem[_2378 + 32] = 'SafeMath: division by zero'
            if poolInfo[idx].field_512 > 0:
                if not poolInfo[idx].field_512:
                    revert with 'NH{q', 18
                if poolInfo[idx].field_1536 > -(10^12 * (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                    revert with 'NH{q', 17
                if poolInfo[idx].field_1536 + (10^12 * (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                    revert with 0, 'SafeMath: addition overflow'
                poolInfo[idx].field_1536 += 10^12 * (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512
                poolInfo[idx].field_1280 = block.number
                if idx == -1:
                    revert with 'NH{q', 17
                idx = idx + 1
                continue 
            _2402 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[_2402 + idx + 68] = mem[_2378 + idx + 32]
                idx = idx + 32
                continue 
            mem[_2402 + 94] = 0
            revert with memory
              from mem[64]
               len _2402 + -mem[64] + 100
        if not poolInfo[idx].field_768:
            _1407 = mem[64]
            mem[64] = mem[64] + 64
            mem[_1407] = 30
            mem[_1407 + 32] = 'SafeMath: subtraction overflow'
            if bonusEndBlock > block.number:
                _1410 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_1410 + idx + 68] = mem[_1407 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_1410 + 98] = 0
                revert with memory
                  from mem[64]
                   len _1410 + -mem[64] + 100
            if block.number < bonusEndBlock:
                revert with 'NH{q', 17
            if not block.number - bonusEndBlock:
                _1428 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1428] = 26
                mem[_1428 + 32] = 'SafeMath: division by zero'
                _1450 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1450] = 30
                mem[_1450 + 32] = 'SafeMath: subtraction overflow'
                if poolInfo[idx].field_1280 > bonusEndBlock:
                    _1452 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_1452 + idx + 68] = mem[_1450 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1452 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _1452 + -mem[64] + 100
                if bonusEndBlock < poolInfo[idx].field_1280:
                    revert with 'NH{q', 17
                if not bonusEndBlock - poolInfo[idx].field_1280:
                    _1478 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1478] = 26
                    mem[_1478 + 32] = 'SafeMath: division by zero'
                    _1603 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1603] = 26
                    mem[_1603 + 32] = 'SafeMath: division by zero'
                    if totalAllocPoint <= 0:
                        _1617 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1617 + idx + 68] = mem[_1603 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1617 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1617 + -mem[64] + 100
                    if not totalAllocPoint:
                        revert with 'NH{q', 18
                    if not 0 / totalAllocPoint:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _1853 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1853] = 26
                        mem[_1853 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _1878 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1878 + idx + 68] = mem[_1853 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1878 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1878 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sushiAddress)
                    call sushiAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args address(this.address), 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0 / totalAllocPoint
                    emit Mint((0 / totalAllocPoint), this.address);
                    if not 0 / totalAllocPoint:
                        _1985 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1985] = 26
                        mem[_1985 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _2013 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2013 + idx + 68] = mem[_1985 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2013 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2013 + -mem[64] + 100
                    if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                        revert with 'NH{q', 17
                    if not 0 / totalAllocPoint:
                        revert with 'NH{q', 18
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _2180 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2180] = 26
                    mem[_2180 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _2210 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2210 + idx + 68] = mem[_2180 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2210 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _2210 + -mem[64] + 100
                if bonusEndBlock - poolInfo[idx].field_1280 and sub_e600038d > -1 / bonusEndBlock - poolInfo[idx].field_1280:
                    revert with 'NH{q', 17
                if not bonusEndBlock - poolInfo[idx].field_1280:
                    revert with 'NH{q', 18
                if (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / bonusEndBlock - poolInfo[idx].field_1280 != sub_e600038d:
                    revert with 0, 'SafeMath: multiplication overflow'
                _1520 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1520] = 26
                mem[_1520 + 32] = 'SafeMath: division by zero'
                if (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 > -1:
                    revert with 'NH{q', 17
                if (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 < (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100:
                    revert with 0, 'SafeMath: addition overflow'
                if not (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100:
                    _1714 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1714] = 26
                    mem[_1714 + 32] = 'SafeMath: division by zero'
                    if totalAllocPoint <= 0:
                        _1735 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1735 + idx + 68] = mem[_1714 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1735 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1735 + -mem[64] + 100
                    if not totalAllocPoint:
                        revert with 'NH{q', 18
                    if not 0 / totalAllocPoint:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _2034 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2034] = 26
                        mem[_2034 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _2065 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2065 + idx + 68] = mem[_2034 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2065 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2065 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sushiAddress)
                    call sushiAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args address(this.address), 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0 / totalAllocPoint
                    emit Mint((0 / totalAllocPoint), this.address);
                    if not 0 / totalAllocPoint:
                        _2179 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2179] = 26
                        mem[_2179 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _2209 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2209 + idx + 68] = mem[_2179 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2209 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2209 + -mem[64] + 100
                    if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                        revert with 'NH{q', 17
                    if not 0 / totalAllocPoint:
                        revert with 'NH{q', 18
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _2386 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2386] = 26
                    mem[_2386 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _2416 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2416 + idx + 68] = mem[_2386 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2416 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _2416 + -mem[64] + 100
                if (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 and sushiPerBlock > -1 / (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100:
                    revert with 'NH{q', 17
                if not (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100:
                    revert with 'NH{q', 18
                if (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock / (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 != sushiPerBlock:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock:
                    _1877 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1877] = 26
                    mem[_1877 + 32] = 'SafeMath: division by zero'
                    if totalAllocPoint <= 0:
                        _1899 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1899 + idx + 68] = mem[_1877 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1899 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1899 + -mem[64] + 100
                    if not totalAllocPoint:
                        revert with 'NH{q', 18
                    if not 0 / totalAllocPoint:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _2235 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2235] = 26
                        mem[_2235 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _2268 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2268 + idx + 68] = mem[_2235 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2268 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2268 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sushiAddress)
                    call sushiAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args address(this.address), 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0 / totalAllocPoint
                    emit Mint((0 / totalAllocPoint), this.address);
                    if not 0 / totalAllocPoint:
                        _2385 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2385] = 26
                        mem[_2385 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _2415 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2415 + idx + 68] = mem[_2385 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2415 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2415 + -mem[64] + 100
                    if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                        revert with 'NH{q', 17
                    if not 0 / totalAllocPoint:
                        revert with 'NH{q', 18
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _2570 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2570] = 26
                    mem[_2570 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _2595 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2595 + idx + 68] = mem[_2570 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2595 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _2595 + -mem[64] + 100
                if (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock and poolInfo[idx].field_256 > -1 / (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock:
                    revert with 'NH{q', 17
                if not (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock:
                    revert with 'NH{q', 18
                if (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock != poolInfo[idx].field_256:
                    revert with 0, 'SafeMath: multiplication overflow'
                _2064 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2064] = 26
                mem[_2064 + 32] = 'SafeMath: division by zero'
                if totalAllocPoint <= 0:
                    _2088 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2088 + idx + 68] = mem[_2064 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2088 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _2088 + -mem[64] + 100
                if not totalAllocPoint:
                    revert with 'NH{q', 18
                if not (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                    mem[mem[64]] = 0
                    emit Mint(0, this.address);
                    _2442 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2442] = 26
                    mem[_2442 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _2473 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2473 + idx + 68] = mem[_2442 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2473 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _2473 + -mem[64] + 100
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                require ext_code.size(sushiAddress)
                call sushiAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args address(this.address), (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                emit Mint(((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint), this.address);
                if not (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                    _2569 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2569] = 26
                    mem[_2569 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _2594 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2594 + idx + 68] = mem[_2569 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2594 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _2594 + -mem[64] + 100
                if (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint and 10^12 > -1 / (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                    revert with 'NH{q', 17
                if not (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                    revert with 'NH{q', 18
                if 10^12 * (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                _2721 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2721] = 26
                mem[_2721 + 32] = 'SafeMath: division by zero'
                if poolInfo[idx].field_512 > 0:
                    if not poolInfo[idx].field_512:
                        revert with 'NH{q', 18
                    if poolInfo[idx].field_1536 > -(10^12 * (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                        revert with 'NH{q', 17
                    if poolInfo[idx].field_1536 + (10^12 * (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_1536 += 10^12 * (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512
                    poolInfo[idx].field_1280 = block.number
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                _2741 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_2741 + idx + 68] = mem[_2721 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_2741 + 94] = 0
                revert with memory
                  from mem[64]
                   len _2741 + -mem[64] + 100
            if block.number - bonusEndBlock and sub_a054b70a > -1 / block.number - bonusEndBlock:
                revert with 'NH{q', 17
            if not block.number - bonusEndBlock:
                revert with 'NH{q', 18
            if (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / block.number - bonusEndBlock != sub_a054b70a:
                revert with 0, 'SafeMath: multiplication overflow'
            _1454 = mem[64]
            mem[64] = mem[64] + 64
            mem[_1454] = 26
            mem[_1454 + 32] = 'SafeMath: division by zero'
            _1476 = mem[64]
            mem[64] = mem[64] + 64
            mem[_1476] = 30
            mem[_1476 + 32] = 'SafeMath: subtraction overflow'
            if poolInfo[idx].field_1280 > bonusEndBlock:
                _1481 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_1481 + idx + 68] = mem[_1476 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_1481 + 98] = 0
                revert with memory
                  from mem[64]
                   len _1481 + -mem[64] + 100
            if bonusEndBlock < poolInfo[idx].field_1280:
                revert with 'NH{q', 17
            if not bonusEndBlock - poolInfo[idx].field_1280:
                _1519 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1519] = 26
                mem[_1519 + 32] = 'SafeMath: division by zero'
                if 0 > -((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100) - 1:
                    revert with 'NH{q', 17
                if (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 < 0:
                    revert with 0, 'SafeMath: addition overflow'
                if not (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100:
                    _1713 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1713] = 26
                    mem[_1713 + 32] = 'SafeMath: division by zero'
                    if totalAllocPoint <= 0:
                        _1734 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1734 + idx + 68] = mem[_1713 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1734 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1734 + -mem[64] + 100
                    if not totalAllocPoint:
                        revert with 'NH{q', 18
                    if not 0 / totalAllocPoint:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _2031 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2031] = 26
                        mem[_2031 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _2063 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2063 + idx + 68] = mem[_2031 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2063 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2063 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sushiAddress)
                    call sushiAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args address(this.address), 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0 / totalAllocPoint
                    emit Mint((0 / totalAllocPoint), this.address);
                    if not 0 / totalAllocPoint:
                        _2177 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2177] = 26
                        mem[_2177 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _2207 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2207 + idx + 68] = mem[_2177 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2207 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2207 + -mem[64] + 100
                    if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                        revert with 'NH{q', 17
                    if not 0 / totalAllocPoint:
                        revert with 'NH{q', 18
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _2383 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2383] = 26
                    mem[_2383 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _2412 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2412 + idx + 68] = mem[_2383 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2412 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _2412 + -mem[64] + 100
                if (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 and sushiPerBlock > -1 / (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100:
                    revert with 'NH{q', 17
                if not (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100:
                    revert with 'NH{q', 18
                if (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock / (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 != sushiPerBlock:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock:
                    _1876 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1876] = 26
                    mem[_1876 + 32] = 'SafeMath: division by zero'
                    if totalAllocPoint <= 0:
                        _1897 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1897 + idx + 68] = mem[_1876 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1897 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1897 + -mem[64] + 100
                    if not totalAllocPoint:
                        revert with 'NH{q', 18
                    if not 0 / totalAllocPoint:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _2232 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2232] = 26
                        mem[_2232 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _2265 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2265 + idx + 68] = mem[_2232 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2265 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2265 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sushiAddress)
                    call sushiAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args address(this.address), 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0 / totalAllocPoint
                    emit Mint((0 / totalAllocPoint), this.address);
                    if not 0 / totalAllocPoint:
                        _2382 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2382] = 26
                        mem[_2382 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _2411 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2411 + idx + 68] = mem[_2382 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2411 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2411 + -mem[64] + 100
                    if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                        revert with 'NH{q', 17
                    if not 0 / totalAllocPoint:
                        revert with 'NH{q', 18
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _2568 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2568] = 26
                    mem[_2568 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _2591 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2591 + idx + 68] = mem[_2568 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2591 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _2591 + -mem[64] + 100
                if (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock and poolInfo[idx].field_256 > -1 / (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock:
                    revert with 'NH{q', 17
                if not (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock:
                    revert with 'NH{q', 18
                if (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock != poolInfo[idx].field_256:
                    revert with 0, 'SafeMath: multiplication overflow'
                _2062 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2062] = 26
                mem[_2062 + 32] = 'SafeMath: division by zero'
                if totalAllocPoint <= 0:
                    _2086 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2086 + idx + 68] = mem[_2062 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2086 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _2086 + -mem[64] + 100
                if not totalAllocPoint:
                    revert with 'NH{q', 18
                if not (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                    mem[mem[64]] = 0
                    emit Mint(0, this.address);
                    _2439 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2439] = 26
                    mem[_2439 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _2468 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2468 + idx + 68] = mem[_2439 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2468 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _2468 + -mem[64] + 100
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                require ext_code.size(sushiAddress)
                call sushiAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args address(this.address), (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                emit Mint(((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint), this.address);
                if not (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                    _2567 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2567] = 26
                    mem[_2567 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _2590 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2590 + idx + 68] = mem[_2567 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2590 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _2590 + -mem[64] + 100
                if (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint and 10^12 > -1 / (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                    revert with 'NH{q', 17
                if not (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                    revert with 'NH{q', 18
                if 10^12 * (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                _2720 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2720] = 26
                mem[_2720 + 32] = 'SafeMath: division by zero'
                if poolInfo[idx].field_512 > 0:
                    if not poolInfo[idx].field_512:
                        revert with 'NH{q', 18
                    if poolInfo[idx].field_1536 > -(10^12 * (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                        revert with 'NH{q', 17
                    if poolInfo[idx].field_1536 + (10^12 * (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_1536 += 10^12 * (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512
                    poolInfo[idx].field_1280 = block.number
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                _2738 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_2738 + idx + 68] = mem[_2720 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_2738 + 94] = 0
                revert with memory
                  from mem[64]
                   len _2738 + -mem[64] + 100
            if bonusEndBlock - poolInfo[idx].field_1280 and sub_e600038d > -1 / bonusEndBlock - poolInfo[idx].field_1280:
                revert with 'NH{q', 17
            if not bonusEndBlock - poolInfo[idx].field_1280:
                revert with 'NH{q', 18
            if (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / bonusEndBlock - poolInfo[idx].field_1280 != sub_e600038d:
                revert with 0, 'SafeMath: multiplication overflow'
            _1594 = mem[64]
            mem[64] = mem[64] + 64
            mem[_1594] = 26
            mem[_1594 + 32] = 'SafeMath: division by zero'
            if (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 > -((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100) - 1:
                revert with 'NH{q', 17
            if ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100) < (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100:
                revert with 0, 'SafeMath: addition overflow'
            if not ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100):
                _1875 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1875] = 26
                mem[_1875 + 32] = 'SafeMath: division by zero'
                if totalAllocPoint <= 0:
                    _1896 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_1896 + idx + 68] = mem[_1875 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1896 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _1896 + -mem[64] + 100
                if not totalAllocPoint:
                    revert with 'NH{q', 18
                if not 0 / totalAllocPoint:
                    mem[mem[64]] = 0
                    emit Mint(0, this.address);
                    _2229 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2229] = 26
                    mem[_2229 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _2264 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2264 + idx + 68] = mem[_2229 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2264 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _2264 + -mem[64] + 100
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = 0 / totalAllocPoint
                require ext_code.size(sushiAddress)
                call sushiAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args address(this.address), 0 / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 0 / totalAllocPoint
                emit Mint((0 / totalAllocPoint), this.address);
                if not 0 / totalAllocPoint:
                    _2380 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2380] = 26
                    mem[_2380 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _2409 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2409 + idx + 68] = mem[_2380 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2409 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _2409 + -mem[64] + 100
                if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                    revert with 'NH{q', 17
                if not 0 / totalAllocPoint:
                    revert with 'NH{q', 18
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                _2566 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2566] = 26
                mem[_2566 + 32] = 'SafeMath: division by zero'
                if poolInfo[idx].field_512 > 0:
                    if not poolInfo[idx].field_512:
                        revert with 'NH{q', 18
                    if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                        revert with 'NH{q', 17
                    if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                    poolInfo[idx].field_1280 = block.number
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                _2588 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_2588 + idx + 68] = mem[_2566 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_2588 + 94] = 0
                revert with memory
                  from mem[64]
                   len _2588 + -mem[64] + 100
            if ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100) and sushiPerBlock > -1 / ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100):
                revert with 'NH{q', 17
            if not ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100):
                revert with 'NH{q', 18
            if ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock) / ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100) != sushiPerBlock:
                revert with 0, 'SafeMath: multiplication overflow'
            if not ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock):
                _2061 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2061] = 26
                mem[_2061 + 32] = 'SafeMath: division by zero'
                if totalAllocPoint <= 0:
                    _2084 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2084 + idx + 68] = mem[_2061 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2084 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _2084 + -mem[64] + 100
                if not totalAllocPoint:
                    revert with 'NH{q', 18
                if not 0 / totalAllocPoint:
                    mem[mem[64]] = 0
                    emit Mint(0, this.address);
                    _2438 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2438] = 26
                    mem[_2438 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _2465 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2465 + idx + 68] = mem[_2438 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2465 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _2465 + -mem[64] + 100
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = 0 / totalAllocPoint
                require ext_code.size(sushiAddress)
                call sushiAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args address(this.address), 0 / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 0 / totalAllocPoint
                emit Mint((0 / totalAllocPoint), this.address);
                if not 0 / totalAllocPoint:
                    _2565 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2565] = 26
                    mem[_2565 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _2587 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2587 + idx + 68] = mem[_2565 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2587 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _2587 + -mem[64] + 100
                if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                    revert with 'NH{q', 17
                if not 0 / totalAllocPoint:
                    revert with 'NH{q', 18
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                _2719 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2719] = 26
                mem[_2719 + 32] = 'SafeMath: division by zero'
                if poolInfo[idx].field_512 > 0:
                    if not poolInfo[idx].field_512:
                        revert with 'NH{q', 18
                    if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                        revert with 'NH{q', 17
                    if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                    poolInfo[idx].field_1280 = block.number
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                _2735 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_2735 + idx + 68] = mem[_2719 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_2735 + 94] = 0
                revert with memory
                  from mem[64]
                   len _2735 + -mem[64] + 100
            if ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock) and poolInfo[idx].field_256 > -1 / ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock):
                revert with 'NH{q', 17
            if not ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock):
                revert with 'NH{q', 18
            if ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock) != poolInfo[idx].field_256:
                revert with 0, 'SafeMath: multiplication overflow'
            _2263 = mem[64]
            mem[64] = mem[64] + 64
            mem[_2263] = 26
            mem[_2263 + 32] = 'SafeMath: division by zero'
            if totalAllocPoint <= 0:
                _2287 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_2287 + idx + 68] = mem[_2263 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_2287 + 94] = 0
                revert with memory
                  from mem[64]
                   len _2287 + -mem[64] + 100
            if not totalAllocPoint:
                revert with 'NH{q', 18
            if not ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                mem[mem[64]] = 0
                emit Mint(0, this.address);
                _2610 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2610] = 26
                mem[_2610 + 32] = 'SafeMath: division by zero'
                if poolInfo[idx].field_512 > 0:
                    if not poolInfo[idx].field_512:
                        revert with 'NH{q', 18
                    if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                        revert with 'NH{q', 17
                    if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                    poolInfo[idx].field_1280 = block.number
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                _2636 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_2636 + idx + 68] = mem[_2610 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_2636 + 94] = 0
                revert with memory
                  from mem[64]
                   len _2636 + -mem[64] + 100
            mem[mem[64] + 4] = this.address
            mem[mem[64] + 36] = ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint
            require ext_code.size(sushiAddress)
            call sushiAddress.0x40c10f19 with:
                 gas gas_remaining wei
                args address(this.address), ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[mem[64]] = ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint
            emit Mint((((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint), this.address);
            if not ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                _2718 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2718] = 26
                mem[_2718 + 32] = 'SafeMath: division by zero'
                if poolInfo[idx].field_512 > 0:
                    if not poolInfo[idx].field_512:
                        revert with 'NH{q', 18
                    if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                        revert with 'NH{q', 17
                    if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                    poolInfo[idx].field_1280 = block.number
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                _2734 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_2734 + idx + 68] = mem[_2718 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_2734 + 94] = 0
                revert with memory
                  from mem[64]
                   len _2734 + -mem[64] + 100
            if ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint and 10^12 > -1 / ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                revert with 'NH{q', 17
            if not ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                revert with 'NH{q', 18
            if 10^12 * ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint / ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                revert with 0, 'SafeMath: multiplication overflow'
            _2832 = mem[64]
            mem[64] = mem[64] + 64
            mem[_2832] = 26
            mem[_2832 + 32] = 'SafeMath: division by zero'
            if poolInfo[idx].field_512 > 0:
                if not poolInfo[idx].field_512:
                    revert with 'NH{q', 18
                if poolInfo[idx].field_1536 > -(10^12 * ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_512) - 1:
                    revert with 'NH{q', 17
                if poolInfo[idx].field_1536 + (10^12 * ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                    revert with 0, 'SafeMath: addition overflow'
                poolInfo[idx].field_1536 += 10^12 * ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_512
                poolInfo[idx].field_1280 = block.number
                if idx == -1:
                    revert with 'NH{q', 17
                idx = idx + 1
                continue 
            _2985 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[_2985 + idx + 68] = mem[_2832 + idx + 32]
                idx = idx + 32
                continue 
            mem[_2985 + 94] = 0
            revert with memory
              from mem[64]
               len _2985 + -mem[64] + 100
        if 100 < sub_a054b70a:
            revert with 'NH{q', 17
        _1416 = mem[64]
        mem[64] = mem[64] + 64
        mem[_1416] = 30
        mem[_1416 + 32] = 'SafeMath: subtraction overflow'
        if bonusEndBlock > block.number:
            _1419 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[_1419 + idx + 68] = mem[_1416 + idx + 32]
                idx = idx + 32
                continue 
            mem[_1419 + 98] = 0
            revert with memory
              from mem[64]
               len _1419 + -mem[64] + 100
        if block.number < bonusEndBlock:
            revert with 'NH{q', 17
        if not block.number - bonusEndBlock:
            _1440 = mem[64]
            mem[64] = mem[64] + 64
            mem[_1440] = 26
            mem[_1440 + 32] = 'SafeMath: division by zero'
            if 100 < sub_e600038d:
                revert with 'NH{q', 17
            _1474 = mem[64]
            mem[64] = mem[64] + 64
            mem[_1474] = 30
            mem[_1474 + 32] = 'SafeMath: subtraction overflow'
            if poolInfo[idx].field_1280 > bonusEndBlock:
                _1479 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_1479 + idx + 68] = mem[_1474 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_1479 + 98] = 0
                revert with memory
                  from mem[64]
                   len _1479 + -mem[64] + 100
            if bonusEndBlock < poolInfo[idx].field_1280:
                revert with 'NH{q', 17
            if not bonusEndBlock - poolInfo[idx].field_1280:
                _1514 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1514] = 26
                mem[_1514 + 32] = 'SafeMath: division by zero'
                _1706 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1706] = 26
                mem[_1706 + 32] = 'SafeMath: division by zero'
                if totalAllocPoint <= 0:
                    _1721 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_1721 + idx + 68] = mem[_1706 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1721 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _1721 + -mem[64] + 100
                if not totalAllocPoint:
                    revert with 'NH{q', 18
                if not 0 / totalAllocPoint:
                    mem[mem[64]] = 0
                    emit Mint(0, this.address);
                    _2018 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2018] = 26
                    mem[_2018 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _2052 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2052 + idx + 68] = mem[_2018 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2052 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _2052 + -mem[64] + 100
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = 0 / totalAllocPoint
                require ext_code.size(sushiAddress)
                call sushiAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args address(this.address), 0 / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 0 / totalAllocPoint
                emit Mint((0 / totalAllocPoint), this.address);
                if not 0 / totalAllocPoint:
                    _2171 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2171] = 26
                    mem[_2171 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _2196 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2196 + idx + 68] = mem[_2171 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2196 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _2196 + -mem[64] + 100
                if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                    revert with 'NH{q', 17
                if not 0 / totalAllocPoint:
                    revert with 'NH{q', 18
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                _2377 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2377] = 26
                mem[_2377 + 32] = 'SafeMath: division by zero'
                if poolInfo[idx].field_512 > 0:
                    if not poolInfo[idx].field_512:
                        revert with 'NH{q', 18
                    if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                        revert with 'NH{q', 17
                    if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                    poolInfo[idx].field_1280 = block.number
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                _2400 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_2400 + idx + 68] = mem[_2377 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_2400 + 94] = 0
                revert with memory
                  from mem[64]
                   len _2400 + -mem[64] + 100
            if bonusEndBlock - poolInfo[idx].field_1280 and -sub_e600038d + 100 > -1 / bonusEndBlock - poolInfo[idx].field_1280:
                revert with 'NH{q', 17
            if not bonusEndBlock - poolInfo[idx].field_1280:
                revert with 'NH{q', 18
            if (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / bonusEndBlock - poolInfo[idx].field_1280 != -sub_e600038d + 100:
                revert with 0, 'SafeMath: multiplication overflow'
            _1587 = mem[64]
            mem[64] = mem[64] + 64
            mem[_1587] = 26
            mem[_1587 + 32] = 'SafeMath: division by zero'
            if (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 > -1:
                revert with 'NH{q', 17
            if (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 < (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100:
                revert with 0, 'SafeMath: addition overflow'
            if not (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100:
                _1867 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1867] = 26
                mem[_1867 + 32] = 'SafeMath: division by zero'
                if totalAllocPoint <= 0:
                    _1884 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_1884 + idx + 68] = mem[_1867 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1884 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _1884 + -mem[64] + 100
                if not totalAllocPoint:
                    revert with 'NH{q', 18
                if not 0 / totalAllocPoint:
                    mem[mem[64]] = 0
                    emit Mint(0, this.address);
                    _2219 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2219] = 26
                    mem[_2219 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _2253 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2253 + idx + 68] = mem[_2219 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2253 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _2253 + -mem[64] + 100
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = 0 / totalAllocPoint
                require ext_code.size(sushiAddress)
                call sushiAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args address(this.address), 0 / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 0 / totalAllocPoint
                emit Mint((0 / totalAllocPoint), this.address);
                if not 0 / totalAllocPoint:
                    _2376 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2376] = 26
                    mem[_2376 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _2399 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2399 + idx + 68] = mem[_2376 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2399 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _2399 + -mem[64] + 100
                if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                    revert with 'NH{q', 17
                if not 0 / totalAllocPoint:
                    revert with 'NH{q', 18
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                _2563 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2563] = 26
                mem[_2563 + 32] = 'SafeMath: division by zero'
                if poolInfo[idx].field_512 > 0:
                    if not poolInfo[idx].field_512:
                        revert with 'NH{q', 18
                    if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                        revert with 'NH{q', 17
                    if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                    poolInfo[idx].field_1280 = block.number
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                _2581 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_2581 + idx + 68] = mem[_2563 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_2581 + 94] = 0
                revert with memory
                  from mem[64]
                   len _2581 + -mem[64] + 100
            if (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 and sushiPerBlock > -1 / (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100:
                revert with 'NH{q', 17
            if not (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100:
                revert with 'NH{q', 18
            if (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock / (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 != sushiPerBlock:
                revert with 0, 'SafeMath: multiplication overflow'
            if not (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock:
                _2051 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2051] = 26
                mem[_2051 + 32] = 'SafeMath: division by zero'
                if totalAllocPoint <= 0:
                    _2075 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2075 + idx + 68] = mem[_2051 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2075 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _2075 + -mem[64] + 100
                if not totalAllocPoint:
                    revert with 'NH{q', 18
                if not 0 / totalAllocPoint:
                    mem[mem[64]] = 0
                    emit Mint(0, this.address);
                    _2427 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2427] = 26
                    mem[_2427 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _2457 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2457 + idx + 68] = mem[_2427 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2457 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _2457 + -mem[64] + 100
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = 0 / totalAllocPoint
                require ext_code.size(sushiAddress)
                call sushiAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args address(this.address), 0 / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 0 / totalAllocPoint
                emit Mint((0 / totalAllocPoint), this.address);
                if not 0 / totalAllocPoint:
                    _2562 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2562] = 26
                    mem[_2562 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _2580 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2580 + idx + 68] = mem[_2562 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2580 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _2580 + -mem[64] + 100
                if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                    revert with 'NH{q', 17
                if not 0 / totalAllocPoint:
                    revert with 'NH{q', 18
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                _2717 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2717] = 26
                mem[_2717 + 32] = 'SafeMath: division by zero'
                if poolInfo[idx].field_512 > 0:
                    if not poolInfo[idx].field_512:
                        revert with 'NH{q', 18
                    if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                        revert with 'NH{q', 17
                    if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                    poolInfo[idx].field_1280 = block.number
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                _2731 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_2731 + idx + 68] = mem[_2717 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_2731 + 94] = 0
                revert with memory
                  from mem[64]
                   len _2731 + -mem[64] + 100
            if (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock and poolInfo[idx].field_256 > -1 / (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock:
                revert with 'NH{q', 17
            if not (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock:
                revert with 'NH{q', 18
            if (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock != poolInfo[idx].field_256:
                revert with 0, 'SafeMath: multiplication overflow'
            _2252 = mem[64]
            mem[64] = mem[64] + 64
            mem[_2252] = 26
            mem[_2252 + 32] = 'SafeMath: division by zero'
            if totalAllocPoint <= 0:
                _2282 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_2282 + idx + 68] = mem[_2252 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_2282 + 94] = 0
                revert with memory
                  from mem[64]
                   len _2282 + -mem[64] + 100
            if not totalAllocPoint:
                revert with 'NH{q', 18
            if not (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                mem[mem[64]] = 0
                emit Mint(0, this.address);
                _2604 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2604] = 26
                mem[_2604 + 32] = 'SafeMath: division by zero'
                if poolInfo[idx].field_512 > 0:
                    if not poolInfo[idx].field_512:
                        revert with 'NH{q', 18
                    if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                        revert with 'NH{q', 17
                    if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                    poolInfo[idx].field_1280 = block.number
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                _2629 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_2629 + idx + 68] = mem[_2604 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_2629 + 94] = 0
                revert with memory
                  from mem[64]
                   len _2629 + -mem[64] + 100
            mem[mem[64] + 4] = this.address
            mem[mem[64] + 36] = (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
            require ext_code.size(sushiAddress)
            call sushiAddress.0x40c10f19 with:
                 gas gas_remaining wei
                args address(this.address), (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[mem[64]] = (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
            emit Mint(((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint), this.address);
            if not (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                _2716 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2716] = 26
                mem[_2716 + 32] = 'SafeMath: division by zero'
                if poolInfo[idx].field_512 > 0:
                    if not poolInfo[idx].field_512:
                        revert with 'NH{q', 18
                    if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                        revert with 'NH{q', 17
                    if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                    poolInfo[idx].field_1280 = block.number
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                _2730 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_2730 + idx + 68] = mem[_2716 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_2730 + 94] = 0
                revert with memory
                  from mem[64]
                   len _2730 + -mem[64] + 100
            if (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint and 10^12 > -1 / (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                revert with 'NH{q', 17
            if not (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                revert with 'NH{q', 18
            if 10^12 * (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint != 10^12:
                revert with 0, 'SafeMath: multiplication overflow'
            _2831 = mem[64]
            mem[64] = mem[64] + 64
            mem[_2831] = 26
            mem[_2831 + 32] = 'SafeMath: division by zero'
            if poolInfo[idx].field_512 > 0:
                if not poolInfo[idx].field_512:
                    revert with 'NH{q', 18
                if poolInfo[idx].field_1536 > -(10^12 * (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                    revert with 'NH{q', 17
                if poolInfo[idx].field_1536 + (10^12 * (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                    revert with 0, 'SafeMath: addition overflow'
                poolInfo[idx].field_1536 += 10^12 * (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512
                poolInfo[idx].field_1280 = block.number
                if idx == -1:
                    revert with 'NH{q', 17
                idx = idx + 1
                continue 
            _2984 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[_2984 + idx + 68] = mem[_2831 + idx + 32]
                idx = idx + 32
                continue 
            mem[_2984 + 94] = 0
            revert with memory
              from mem[64]
               len _2984 + -mem[64] + 100
        if block.number - bonusEndBlock and -sub_a054b70a + 100 > -1 / block.number - bonusEndBlock:
            revert with 'NH{q', 17
        if not block.number - bonusEndBlock:
            revert with 'NH{q', 18
        if (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / block.number - bonusEndBlock != -sub_a054b70a + 100:
            revert with 0, 'SafeMath: multiplication overflow'
        _1465 = mem[64]
        mem[64] = mem[64] + 64
        mem[_1465] = 26
        mem[_1465 + 32] = 'SafeMath: division by zero'
        if 100 < sub_e600038d:
            revert with 'NH{q', 17
        _1510 = mem[64]
        mem[64] = mem[64] + 64
        mem[_1510] = 30
        mem[_1510 + 32] = 'SafeMath: subtraction overflow'
        if poolInfo[idx].field_1280 > bonusEndBlock:
            _1521 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[_1521 + idx + 68] = mem[_1510 + idx + 32]
                idx = idx + 32
                continue 
            mem[_1521 + 98] = 0
            revert with memory
              from mem[64]
               len _1521 + -mem[64] + 100
        if bonusEndBlock < poolInfo[idx].field_1280:
            revert with 'NH{q', 17
        if not bonusEndBlock - poolInfo[idx].field_1280:
            _1586 = mem[64]
            mem[64] = mem[64] + 64
            mem[_1586] = 26
            mem[_1586 + 32] = 'SafeMath: division by zero'
            if 0 > -((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100) - 1:
                revert with 'NH{q', 17
            if (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 < 0:
                revert with 0, 'SafeMath: addition overflow'
            if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100:
                _1866 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1866] = 26
                mem[_1866 + 32] = 'SafeMath: division by zero'
                if totalAllocPoint <= 0:
                    _1883 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_1883 + idx + 68] = mem[_1866 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1883 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _1883 + -mem[64] + 100
                if not totalAllocPoint:
                    revert with 'NH{q', 18
                if not 0 / totalAllocPoint:
                    mem[mem[64]] = 0
                    emit Mint(0, this.address);
                    _2216 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2216] = 26
                    mem[_2216 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _2251 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2251 + idx + 68] = mem[_2216 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2251 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _2251 + -mem[64] + 100
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = 0 / totalAllocPoint
                require ext_code.size(sushiAddress)
                call sushiAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args address(this.address), 0 / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 0 / totalAllocPoint
                emit Mint((0 / totalAllocPoint), this.address);
                if not 0 / totalAllocPoint:
                    _2374 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2374] = 26
                    mem[_2374 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _2397 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2397 + idx + 68] = mem[_2374 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2397 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _2397 + -mem[64] + 100
                if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                    revert with 'NH{q', 17
                if not 0 / totalAllocPoint:
                    revert with 'NH{q', 18
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                _2560 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2560] = 26
                mem[_2560 + 32] = 'SafeMath: division by zero'
                if poolInfo[idx].field_512 > 0:
                    if not poolInfo[idx].field_512:
                        revert with 'NH{q', 18
                    if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                        revert with 'NH{q', 17
                    if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                    poolInfo[idx].field_1280 = block.number
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                _2577 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_2577 + idx + 68] = mem[_2560 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_2577 + 94] = 0
                revert with memory
                  from mem[64]
                   len _2577 + -mem[64] + 100
            if (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 and sushiPerBlock > -1 / (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100:
                revert with 'NH{q', 17
            if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100:
                revert with 'NH{q', 18
            if (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock / (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 != sushiPerBlock:
                revert with 0, 'SafeMath: multiplication overflow'
            if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock:
                _2050 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2050] = 26
                mem[_2050 + 32] = 'SafeMath: division by zero'
                if totalAllocPoint <= 0:
                    _2073 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2073 + idx + 68] = mem[_2050 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2073 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _2073 + -mem[64] + 100
                if not totalAllocPoint:
                    revert with 'NH{q', 18
                if not 0 / totalAllocPoint:
                    mem[mem[64]] = 0
                    emit Mint(0, this.address);
                    _2424 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2424] = 26
                    mem[_2424 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _2454 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2454 + idx + 68] = mem[_2424 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2454 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _2454 + -mem[64] + 100
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = 0 / totalAllocPoint
                require ext_code.size(sushiAddress)
                call sushiAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args address(this.address), 0 / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 0 / totalAllocPoint
                emit Mint((0 / totalAllocPoint), this.address);
                if not 0 / totalAllocPoint:
                    _2559 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2559] = 26
                    mem[_2559 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _2576 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2576 + idx + 68] = mem[_2559 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2576 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _2576 + -mem[64] + 100
                if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                    revert with 'NH{q', 17
                if not 0 / totalAllocPoint:
                    revert with 'NH{q', 18
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                _2715 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2715] = 26
                mem[_2715 + 32] = 'SafeMath: division by zero'
                if poolInfo[idx].field_512 > 0:
                    if not poolInfo[idx].field_512:
                        revert with 'NH{q', 18
                    if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                        revert with 'NH{q', 17
                    if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                    poolInfo[idx].field_1280 = block.number
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                _2727 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_2727 + idx + 68] = mem[_2715 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_2727 + 94] = 0
                revert with memory
                  from mem[64]
                   len _2727 + -mem[64] + 100
            if (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock and poolInfo[idx].field_256 > -1 / (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock:
                revert with 'NH{q', 17
            if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock:
                revert with 'NH{q', 18
            if (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock != poolInfo[idx].field_256:
                revert with 0, 'SafeMath: multiplication overflow'
            _2250 = mem[64]
            mem[64] = mem[64] + 64
            mem[_2250] = 26
            mem[_2250 + 32] = 'SafeMath: division by zero'
            if totalAllocPoint <= 0:
                _2280 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_2280 + idx + 68] = mem[_2250 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_2280 + 94] = 0
                revert with memory
                  from mem[64]
                   len _2280 + -mem[64] + 100
            if not totalAllocPoint:
                revert with 'NH{q', 18
            if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                mem[mem[64]] = 0
                emit Mint(0, this.address);
                _2601 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2601] = 26
                mem[_2601 + 32] = 'SafeMath: division by zero'
                if poolInfo[idx].field_512 > 0:
                    if not poolInfo[idx].field_512:
                        revert with 'NH{q', 18
                    if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                        revert with 'NH{q', 17
                    if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                    poolInfo[idx].field_1280 = block.number
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                _2624 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_2624 + idx + 68] = mem[_2601 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_2624 + 94] = 0
                revert with memory
                  from mem[64]
                   len _2624 + -mem[64] + 100
            mem[mem[64] + 4] = this.address
            mem[mem[64] + 36] = (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
            require ext_code.size(sushiAddress)
            call sushiAddress.0x40c10f19 with:
                 gas gas_remaining wei
                args address(this.address), (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[mem[64]] = (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
            emit Mint(((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint), this.address);
            if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                _2714 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2714] = 26
                mem[_2714 + 32] = 'SafeMath: division by zero'
                if poolInfo[idx].field_512 > 0:
                    if not poolInfo[idx].field_512:
                        revert with 'NH{q', 18
                    if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                        revert with 'NH{q', 17
                    if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                    poolInfo[idx].field_1280 = block.number
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                _2726 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_2726 + idx + 68] = mem[_2714 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_2726 + 94] = 0
                revert with memory
                  from mem[64]
                   len _2726 + -mem[64] + 100
            if (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint and 10^12 > -1 / (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                revert with 'NH{q', 17
            if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                revert with 'NH{q', 18
            if 10^12 * (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint != 10^12:
                revert with 0, 'SafeMath: multiplication overflow'
            _2830 = mem[64]
            mem[64] = mem[64] + 64
            mem[_2830] = 26
            mem[_2830 + 32] = 'SafeMath: division by zero'
            if poolInfo[idx].field_512 > 0:
                if not poolInfo[idx].field_512:
                    revert with 'NH{q', 18
                if poolInfo[idx].field_1536 > -(10^12 * (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                    revert with 'NH{q', 17
                if poolInfo[idx].field_1536 + (10^12 * (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                    revert with 0, 'SafeMath: addition overflow'
                poolInfo[idx].field_1536 += 10^12 * (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512
                poolInfo[idx].field_1280 = block.number
                if idx == -1:
                    revert with 'NH{q', 17
                idx = idx + 1
                continue 
            _2983 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[_2983 + idx + 68] = mem[_2830 + idx + 32]
                idx = idx + 32
                continue 
            mem[_2983 + 94] = 0
            revert with memory
              from mem[64]
               len _2983 + -mem[64] + 100
        if bonusEndBlock - poolInfo[idx].field_1280 and -sub_e600038d + 100 > -1 / bonusEndBlock - poolInfo[idx].field_1280:
            revert with 'NH{q', 17
        if not bonusEndBlock - poolInfo[idx].field_1280:
            revert with 'NH{q', 18
        if (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / bonusEndBlock - poolInfo[idx].field_1280 != -sub_e600038d + 100:
            revert with 0, 'SafeMath: multiplication overflow'
        _1690 = mem[64]
        mem[64] = mem[64] + 64
        mem[_1690] = 26
        mem[_1690 + 32] = 'SafeMath: division by zero'
        if (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 > -((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100) - 1:
            revert with 'NH{q', 17
        if ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100) < (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100:
            revert with 0, 'SafeMath: addition overflow'
        if not ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100):
            _2049 = mem[64]
            mem[64] = mem[64] + 64
            mem[_2049] = 26
            mem[_2049 + 32] = 'SafeMath: division by zero'
            if totalAllocPoint <= 0:
                _2072 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_2072 + idx + 68] = mem[_2049 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_2072 + 94] = 0
                revert with memory
                  from mem[64]
                   len _2072 + -mem[64] + 100
            if not totalAllocPoint:
                revert with 'NH{q', 18
            if not 0 / totalAllocPoint:
                mem[mem[64]] = 0
                emit Mint(0, this.address);
                _2421 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2421] = 26
                mem[_2421 + 32] = 'SafeMath: division by zero'
                if poolInfo[idx].field_512 > 0:
                    if not poolInfo[idx].field_512:
                        revert with 'NH{q', 18
                    if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                        revert with 'NH{q', 17
                    if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                    poolInfo[idx].field_1280 = block.number
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                _2453 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_2453 + idx + 68] = mem[_2421 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_2453 + 94] = 0
                revert with memory
                  from mem[64]
                   len _2453 + -mem[64] + 100
            mem[mem[64] + 4] = this.address
            mem[mem[64] + 36] = 0 / totalAllocPoint
            require ext_code.size(sushiAddress)
            call sushiAddress.0x40c10f19 with:
                 gas gas_remaining wei
                args address(this.address), 0 / totalAllocPoint
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[mem[64]] = 0 / totalAllocPoint
            emit Mint((0 / totalAllocPoint), this.address);
            if not 0 / totalAllocPoint:
                _2557 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2557] = 26
                mem[_2557 + 32] = 'SafeMath: division by zero'
                if poolInfo[idx].field_512 > 0:
                    if not poolInfo[idx].field_512:
                        revert with 'NH{q', 18
                    if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                        revert with 'NH{q', 17
                    if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                    poolInfo[idx].field_1280 = block.number
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                _2574 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_2574 + idx + 68] = mem[_2557 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_2574 + 94] = 0
                revert with memory
                  from mem[64]
                   len _2574 + -mem[64] + 100
            if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                revert with 'NH{q', 17
            if not 0 / totalAllocPoint:
                revert with 'NH{q', 18
            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                revert with 0, 'SafeMath: multiplication overflow'
            _2713 = mem[64]
            mem[64] = mem[64] + 64
            mem[_2713] = 26
            mem[_2713 + 32] = 'SafeMath: division by zero'
            if poolInfo[idx].field_512 > 0:
                if not poolInfo[idx].field_512:
                    revert with 'NH{q', 18
                if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                    revert with 'NH{q', 17
                if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                    revert with 0, 'SafeMath: addition overflow'
                poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                poolInfo[idx].field_1280 = block.number
                if idx == -1:
                    revert with 'NH{q', 17
                idx = idx + 1
                continue 
            _2724 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[_2724 + idx + 68] = mem[_2713 + idx + 32]
                idx = idx + 32
                continue 
            mem[_2724 + 94] = 0
            revert with memory
              from mem[64]
               len _2724 + -mem[64] + 100
        if ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100) and sushiPerBlock > -1 / ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100):
            revert with 'NH{q', 17
        if not ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100):
            revert with 'NH{q', 18
        if ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock) / ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100) != sushiPerBlock:
            revert with 0, 'SafeMath: multiplication overflow'
        if not ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock):
            _2249 = mem[64]
            mem[64] = mem[64] + 64
            mem[_2249] = 26
            mem[_2249 + 32] = 'SafeMath: division by zero'
            if totalAllocPoint <= 0:
                _2278 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_2278 + idx + 68] = mem[_2249 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_2278 + 94] = 0
                revert with memory
                  from mem[64]
                   len _2278 + -mem[64] + 100
            if not totalAllocPoint:
                revert with 'NH{q', 18
            if not 0 / totalAllocPoint:
                mem[mem[64]] = 0
                emit Mint(0, this.address);
                _2600 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2600] = 26
                mem[_2600 + 32] = 'SafeMath: division by zero'
                if poolInfo[idx].field_512 > 0:
                    if not poolInfo[idx].field_512:
                        revert with 'NH{q', 18
                    if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                        revert with 'NH{q', 17
                    if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                    poolInfo[idx].field_1280 = block.number
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                _2621 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_2621 + idx + 68] = mem[_2600 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_2621 + 94] = 0
                revert with memory
                  from mem[64]
                   len _2621 + -mem[64] + 100
            mem[mem[64] + 4] = this.address
            mem[mem[64] + 36] = 0 / totalAllocPoint
            require ext_code.size(sushiAddress)
            call sushiAddress.0x40c10f19 with:
                 gas gas_remaining wei
                args address(this.address), 0 / totalAllocPoint
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[mem[64]] = 0 / totalAllocPoint
            emit Mint((0 / totalAllocPoint), this.address);
            if not 0 / totalAllocPoint:
                _2712 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2712] = 26
                mem[_2712 + 32] = 'SafeMath: division by zero'
                if poolInfo[idx].field_512 > 0:
                    if not poolInfo[idx].field_512:
                        revert with 'NH{q', 18
                    if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                        revert with 'NH{q', 17
                    if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                    poolInfo[idx].field_1280 = block.number
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                _2723 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_2723 + idx + 68] = mem[_2712 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_2723 + 94] = 0
                revert with memory
                  from mem[64]
                   len _2723 + -mem[64] + 100
            if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                revert with 'NH{q', 17
            if not 0 / totalAllocPoint:
                revert with 'NH{q', 18
            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                revert with 0, 'SafeMath: multiplication overflow'
            _2829 = mem[64]
            mem[64] = mem[64] + 64
            mem[_2829] = 26
            mem[_2829 + 32] = 'SafeMath: division by zero'
            if poolInfo[idx].field_512 > 0:
                if not poolInfo[idx].field_512:
                    revert with 'NH{q', 18
                if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                    revert with 'NH{q', 17
                if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                    revert with 0, 'SafeMath: addition overflow'
                poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                poolInfo[idx].field_1280 = block.number
                if idx == -1:
                    revert with 'NH{q', 17
                idx = idx + 1
                continue 
            _2982 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[_2982 + idx + 68] = mem[_2829 + idx + 32]
                idx = idx + 32
                continue 
            mem[_2982 + 94] = 0
            revert with memory
              from mem[64]
               len _2982 + -mem[64] + 100
        if ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock) and poolInfo[idx].field_256 > -1 / ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock):
            revert with 'NH{q', 17
        if not ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock):
            revert with 'NH{q', 18
        if ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock) != poolInfo[idx].field_256:
            revert with 0, 'SafeMath: multiplication overflow'
        _2452 = mem[64]
        mem[64] = mem[64] + 64
        mem[_2452] = 26
        mem[_2452 + 32] = 'SafeMath: division by zero'
        if totalAllocPoint <= 0:
            _2484 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[_2484 + idx + 68] = mem[_2452 + idx + 32]
                idx = idx + 32
                continue 
            mem[_2484 + 94] = 0
            revert with memory
              from mem[64]
               len _2484 + -mem[64] + 100
        if not totalAllocPoint:
            revert with 'NH{q', 18
        if not ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint:
            mem[mem[64]] = 0
            emit Mint(0, this.address);
            _2744 = mem[64]
            mem[64] = mem[64] + 64
            mem[_2744] = 26
            mem[_2744 + 32] = 'SafeMath: division by zero'
            if poolInfo[idx].field_512 > 0:
                if not poolInfo[idx].field_512:
                    revert with 'NH{q', 18
                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                    revert with 'NH{q', 17
                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                    revert with 0, 'SafeMath: addition overflow'
                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                poolInfo[idx].field_1280 = block.number
                if idx == -1:
                    revert with 'NH{q', 17
                idx = idx + 1
                continue 
            _2762 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[_2762 + idx + 68] = mem[_2744 + idx + 32]
                idx = idx + 32
                continue 
            mem[_2762 + 94] = 0
            revert with memory
              from mem[64]
               len _2762 + -mem[64] + 100
        mem[mem[64] + 4] = this.address
        mem[mem[64] + 36] = ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint
        require ext_code.size(sushiAddress)
        call sushiAddress.0x40c10f19 with:
             gas gas_remaining wei
            args address(this.address), ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        mem[mem[64]] = ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint
        emit Mint((((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint), this.address);
        if not ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint:
            _2828 = mem[64]
            mem[64] = mem[64] + 64
            mem[_2828] = 26
            mem[_2828 + 32] = 'SafeMath: division by zero'
            if poolInfo[idx].field_512 > 0:
                if not poolInfo[idx].field_512:
                    revert with 'NH{q', 18
                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                    revert with 'NH{q', 17
                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                    revert with 0, 'SafeMath: addition overflow'
                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                poolInfo[idx].field_1280 = block.number
                if idx == -1:
                    revert with 'NH{q', 17
                idx = idx + 1
                continue 
            _2981 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[_2981 + idx + 68] = mem[_2828 + idx + 32]
                idx = idx + 32
                continue 
            mem[_2981 + 94] = 0
            revert with memory
              from mem[64]
               len _2981 + -mem[64] + 100
        if ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint and 10^12 > -1 / ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint:
            revert with 'NH{q', 17
        if not ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint:
            revert with 'NH{q', 18
        if 10^12 * ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint / ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
            revert with 0, 'SafeMath: multiplication overflow'
        _3319 = mem[64]
        mem[64] = mem[64] + 64
        mem[_3319] = 26
        mem[_3319 + 32] = 'SafeMath: division by zero'
        if poolInfo[idx].field_512 > 0:
            if not poolInfo[idx].field_512:
                revert with 'NH{q', 18
            if poolInfo[idx].field_1536 > -(10^12 * ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_512) - 1:
                revert with 'NH{q', 17
            if poolInfo[idx].field_1536 + (10^12 * ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                revert with 0, 'SafeMath: addition overflow'
            poolInfo[idx].field_1536 += 10^12 * ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_512
            poolInfo[idx].field_1280 = block.number
            if idx == -1:
                revert with 'NH{q', 17
            idx = idx + 1
            continue 
        _3320 = mem[64]
        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = 32
        mem[mem[64] + 36] = 26
        idx = 0
        while idx < 26:
            mem[_3320 + idx + 68] = mem[_3319 + idx + 32]
            idx = idx + 32
            continue 
        mem[_3320 + 94] = 0
        revert with memory
          from mem[64]
           len _3320 + -mem[64] + 100
}

function add(uint256 arg1, address arg2, bool arg3, bool arg4, uint256 arg5) payable {
    mem[64] = 96
    require not msg.value
    require calldata.size - 4 >= 160
    require arg1 == arg1
    require arg2 == arg2
    require arg3 == arg3
    require arg4 == arg4
    require arg5 == arg5
    if owner != msg.sender:
        revert with 0, '!dev addr'
    if arg3:
        idx = 0
        while idx < poolInfo.length:
            mem[0] = 7
            if block.number <= poolInfo[idx].field_1280:
                if idx == -1:
                    revert with 'NH{q', 17
                idx = idx + 1
                continue 
            if not poolInfo[idx].field_512:
                poolInfo[idx].field_1280 = block.number
                if idx == -1:
                    revert with 'NH{q', 17
                idx = idx + 1
                continue 
            if block.number <= bonusEndBlock:
                if not poolInfo[idx].field_768:
                    _1031 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1031] = 30
                    mem[_1031 + 32] = 'SafeMath: subtraction overflow'
                    if poolInfo[idx].field_1280 > block.number:
                        _1034 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_1034 + idx + 68] = mem[_1031 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1034 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _1034 + -mem[64] + 100
                    if block.number < poolInfo[idx].field_1280:
                        revert with 'NH{q', 17
                    if not block.number - poolInfo[idx].field_1280:
                        _1096 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1096] = 26
                        mem[_1096 + 32] = 'SafeMath: division by zero'
                        _1132 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1132] = 26
                        mem[_1132 + 32] = 'SafeMath: division by zero'
                        if totalAllocPoint <= 0:
                            _1138 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_1138 + idx + 68] = mem[_1132 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_1138 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _1138 + -mem[64] + 100
                        if not totalAllocPoint:
                            revert with 'NH{q', 18
                        if not 0 / totalAllocPoint:
                            mem[mem[64]] = 0
                            emit Mint(0, this.address);
                            _1218 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1218] = 26
                            mem[_1218 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _1227 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_1227 + idx + 68] = mem[_1218 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_1227 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _1227 + -mem[64] + 100
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sushiAddress)
                        call sushiAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args address(this.address), 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0 / totalAllocPoint
                        emit Mint((0 / totalAllocPoint), this.address);
                        if not 0 / totalAllocPoint:
                            _1282 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1282] = 26
                            mem[_1282 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _1298 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_1298 + idx + 68] = mem[_1282 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_1298 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _1298 + -mem[64] + 100
                        if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                            revert with 'NH{q', 17
                        if not 0 / totalAllocPoint:
                            revert with 'NH{q', 18
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _1397 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1397] = 26
                        mem[_1397 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _1422 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1422 + idx + 68] = mem[_1397 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1422 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1422 + -mem[64] + 100
                    if block.number - poolInfo[idx].field_1280 and sub_e600038d > -1 / block.number - poolInfo[idx].field_1280:
                        revert with 'NH{q', 17
                    if not block.number - poolInfo[idx].field_1280:
                        revert with 'NH{q', 18
                    if (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / block.number - poolInfo[idx].field_1280 != sub_e600038d:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _1122 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1122] = 26
                    mem[_1122 + 32] = 'SafeMath: division by zero'
                    if not (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100:
                        _1166 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1166] = 26
                        mem[_1166 + 32] = 'SafeMath: division by zero'
                        if totalAllocPoint <= 0:
                            _1170 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_1170 + idx + 68] = mem[_1166 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_1170 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _1170 + -mem[64] + 100
                        if not totalAllocPoint:
                            revert with 'NH{q', 18
                        if not 0 / totalAllocPoint:
                            mem[mem[64]] = 0
                            emit Mint(0, this.address);
                            _1306 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1306] = 26
                            mem[_1306 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _1314 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_1314 + idx + 68] = mem[_1306 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_1314 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _1314 + -mem[64] + 100
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sushiAddress)
                        call sushiAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args address(this.address), 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0 / totalAllocPoint
                        emit Mint((0 / totalAllocPoint), this.address);
                        if not 0 / totalAllocPoint:
                            _1396 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1396] = 26
                            mem[_1396 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _1421 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_1421 + idx + 68] = mem[_1396 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_1421 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _1421 + -mem[64] + 100
                        if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                            revert with 'NH{q', 17
                        if not 0 / totalAllocPoint:
                            revert with 'NH{q', 18
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _1560 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1560] = 26
                        mem[_1560 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _1585 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1585 + idx + 68] = mem[_1560 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1585 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1585 + -mem[64] + 100
                    if (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 and sushiPerBlock > -1 / (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100:
                        revert with 'NH{q', 17
                    if not (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100:
                        revert with 'NH{q', 18
                    if (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock / (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 != sushiPerBlock:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock:
                        _1226 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1226] = 26
                        mem[_1226 + 32] = 'SafeMath: division by zero'
                        if totalAllocPoint <= 0:
                            _1233 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_1233 + idx + 68] = mem[_1226 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_1233 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _1233 + -mem[64] + 100
                        if not totalAllocPoint:
                            revert with 'NH{q', 18
                        if not 0 / totalAllocPoint:
                            mem[mem[64]] = 0
                            emit Mint(0, this.address);
                            _1433 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1433] = 26
                            mem[_1433 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _1450 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_1450 + idx + 68] = mem[_1433 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_1450 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _1450 + -mem[64] + 100
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sushiAddress)
                        call sushiAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args address(this.address), 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0 / totalAllocPoint
                        emit Mint((0 / totalAllocPoint), this.address);
                        if not 0 / totalAllocPoint:
                            _1559 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1559] = 26
                            mem[_1559 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _1584 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_1584 + idx + 68] = mem[_1559 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_1584 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _1584 + -mem[64] + 100
                        if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                            revert with 'NH{q', 17
                        if not 0 / totalAllocPoint:
                            revert with 'NH{q', 18
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _1749 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1749] = 26
                        mem[_1749 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _1779 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1779 + idx + 68] = mem[_1749 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1779 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1779 + -mem[64] + 100
                    if (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock and poolInfo[idx].field_256 > -1 / (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock:
                        revert with 'NH{q', 17
                    if not (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock:
                        revert with 'NH{q', 18
                    if (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock != poolInfo[idx].field_256:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _1313 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1313] = 26
                    mem[_1313 + 32] = 'SafeMath: division by zero'
                    if totalAllocPoint <= 0:
                        _1325 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1325 + idx + 68] = mem[_1313 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1325 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1325 + -mem[64] + 100
                    if not totalAllocPoint:
                        revert with 'NH{q', 18
                    if not (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _1595 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1595] = 26
                        mem[_1595 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _1619 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1619 + idx + 68] = mem[_1595 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1619 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1619 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                    require ext_code.size(sushiAddress)
                    call sushiAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args address(this.address), (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                    emit Mint(((block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint), this.address);
                    if not (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                        _1748 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1748] = 26
                        mem[_1748 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _1778 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1778 + idx + 68] = mem[_1748 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1778 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1778 + -mem[64] + 100
                    if (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint and 10^12 > -1 / (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                        revert with 'NH{q', 17
                    if not (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                        revert with 'NH{q', 18
                    if 10^12 * (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _1954 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1954] = 26
                    mem[_1954 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _1984 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_1984 + idx + 68] = mem[_1954 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1984 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _1984 + -mem[64] + 100
                if 100 < sub_e600038d:
                    revert with 'NH{q', 17
                _1044 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1044] = 30
                mem[_1044 + 32] = 'SafeMath: subtraction overflow'
                if poolInfo[idx].field_1280 > block.number:
                    _1083 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_1083 + idx + 68] = mem[_1044 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1083 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _1083 + -mem[64] + 100
                if block.number < poolInfo[idx].field_1280:
                    revert with 'NH{q', 17
                if not block.number - poolInfo[idx].field_1280:
                    _1108 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1108] = 26
                    mem[_1108 + 32] = 'SafeMath: division by zero'
                    _1149 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1149] = 26
                    mem[_1149 + 32] = 'SafeMath: division by zero'
                    if totalAllocPoint <= 0:
                        _1154 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1154 + idx + 68] = mem[_1149 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1154 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1154 + -mem[64] + 100
                    if not totalAllocPoint:
                        revert with 'NH{q', 18
                    if not 0 / totalAllocPoint:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _1254 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1254] = 26
                        mem[_1254 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _1268 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1268 + idx + 68] = mem[_1254 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1268 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1268 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sushiAddress)
                    call sushiAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args address(this.address), 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0 / totalAllocPoint
                    emit Mint((0 / totalAllocPoint), this.address);
                    if not 0 / totalAllocPoint:
                        _1328 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1328] = 26
                        mem[_1328 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _1350 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1350 + idx + 68] = mem[_1328 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1350 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1350 + -mem[64] + 100
                    if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                        revert with 'NH{q', 17
                    if not 0 / totalAllocPoint:
                        revert with 'NH{q', 18
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _1473 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1473] = 26
                    mem[_1473 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _1493 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_1493 + idx + 68] = mem[_1473 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1493 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _1493 + -mem[64] + 100
                if block.number - poolInfo[idx].field_1280 and -sub_e600038d + 100 > -1 / block.number - poolInfo[idx].field_1280:
                    revert with 'NH{q', 17
                if not block.number - poolInfo[idx].field_1280:
                    revert with 'NH{q', 18
                if (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / block.number - poolInfo[idx].field_1280 != -sub_e600038d + 100:
                    revert with 0, 'SafeMath: multiplication overflow'
                _1133 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1133] = 26
                mem[_1133 + 32] = 'SafeMath: division by zero'
                if not (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100:
                    _1193 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1193] = 26
                    mem[_1193 + 32] = 'SafeMath: division by zero'
                    if totalAllocPoint <= 0:
                        _1200 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1200 + idx + 68] = mem[_1193 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1200 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1200 + -mem[64] + 100
                    if not totalAllocPoint:
                        revert with 'NH{q', 18
                    if not 0 / totalAllocPoint:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _1358 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1358] = 26
                        mem[_1358 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _1372 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1372 + idx + 68] = mem[_1358 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1372 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1372 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sushiAddress)
                    call sushiAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args address(this.address), 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0 / totalAllocPoint
                    emit Mint((0 / totalAllocPoint), this.address);
                    if not 0 / totalAllocPoint:
                        _1472 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1472] = 26
                        mem[_1472 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _1492 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1492 + idx + 68] = mem[_1472 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1492 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1492 + -mem[64] + 100
                    if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                        revert with 'NH{q', 17
                    if not 0 / totalAllocPoint:
                        revert with 'NH{q', 18
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _1643 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1643] = 26
                    mem[_1643 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _1662 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_1662 + idx + 68] = mem[_1643 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1662 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _1662 + -mem[64] + 100
                if (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 and sushiPerBlock > -1 / (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100:
                    revert with 'NH{q', 17
                if not (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100:
                    revert with 'NH{q', 18
                if (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock / (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 != sushiPerBlock:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock:
                    _1267 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1267] = 26
                    mem[_1267 + 32] = 'SafeMath: division by zero'
                    if totalAllocPoint <= 0:
                        _1275 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1275 + idx + 68] = mem[_1267 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1275 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1275 + -mem[64] + 100
                    if not totalAllocPoint:
                        revert with 'NH{q', 18
                    if not 0 / totalAllocPoint:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _1503 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1503] = 26
                        mem[_1503 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _1528 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1528 + idx + 68] = mem[_1503 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1528 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1528 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sushiAddress)
                    call sushiAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args address(this.address), 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0 / totalAllocPoint
                    emit Mint((0 / totalAllocPoint), this.address);
                    if not 0 / totalAllocPoint:
                        _1642 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1642] = 26
                        mem[_1642 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _1661 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1661 + idx + 68] = mem[_1642 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1661 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1661 + -mem[64] + 100
                    if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                        revert with 'NH{q', 17
                    if not 0 / totalAllocPoint:
                        revert with 'NH{q', 18
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _1834 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1834] = 26
                    mem[_1834 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _1855 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_1855 + idx + 68] = mem[_1834 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1855 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _1855 + -mem[64] + 100
                if (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock and poolInfo[idx].field_256 > -1 / (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock:
                    revert with 'NH{q', 17
                if not (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock:
                    revert with 'NH{q', 18
                if (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock != poolInfo[idx].field_256:
                    revert with 0, 'SafeMath: multiplication overflow'
                _1371 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1371] = 26
                mem[_1371 + 32] = 'SafeMath: division by zero'
                if totalAllocPoint <= 0:
                    _1388 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_1388 + idx + 68] = mem[_1371 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1388 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _1388 + -mem[64] + 100
                if not totalAllocPoint:
                    revert with 'NH{q', 18
                if not (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                    mem[mem[64]] = 0
                    emit Mint(0, this.address);
                    _1674 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1674] = 26
                    mem[_1674 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _1711 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_1711 + idx + 68] = mem[_1674 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1711 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _1711 + -mem[64] + 100
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                require ext_code.size(sushiAddress)
                call sushiAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args address(this.address), (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                emit Mint(((100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint), this.address);
                if not (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                    _1833 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1833] = 26
                    mem[_1833 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _1854 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_1854 + idx + 68] = mem[_1833 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1854 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _1854 + -mem[64] + 100
                if (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint and 10^12 > -1 / (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                    revert with 'NH{q', 17
                if not (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                    revert with 'NH{q', 18
                if 10^12 * (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                _2035 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2035] = 26
                mem[_2035 + 32] = 'SafeMath: division by zero'
                if poolInfo[idx].field_512 > 0:
                    if not poolInfo[idx].field_512:
                        revert with 'NH{q', 18
                    if poolInfo[idx].field_1536 > -(10^12 * (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                        revert with 'NH{q', 17
                    if poolInfo[idx].field_1536 + (10^12 * (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_1536 += 10^12 * (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512
                    poolInfo[idx].field_1280 = block.number
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                _2059 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_2059 + idx + 68] = mem[_2035 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_2059 + 94] = 0
                revert with memory
                  from mem[64]
                   len _2059 + -mem[64] + 100
            if poolInfo[idx].field_1280 >= bonusEndBlock:
                if not poolInfo[idx].field_768:
                    _1033 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1033] = 30
                    mem[_1033 + 32] = 'SafeMath: subtraction overflow'
                    if poolInfo[idx].field_1280 > block.number:
                        _1036 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_1036 + idx + 68] = mem[_1033 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1036 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _1036 + -mem[64] + 100
                    if block.number < poolInfo[idx].field_1280:
                        revert with 'NH{q', 17
                    if not block.number - poolInfo[idx].field_1280:
                        _1098 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1098] = 26
                        mem[_1098 + 32] = 'SafeMath: division by zero'
                        _1135 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1135] = 26
                        mem[_1135 + 32] = 'SafeMath: division by zero'
                        if totalAllocPoint <= 0:
                            _1139 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_1139 + idx + 68] = mem[_1135 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_1139 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _1139 + -mem[64] + 100
                        if not totalAllocPoint:
                            revert with 'NH{q', 18
                        if not 0 / totalAllocPoint:
                            mem[mem[64]] = 0
                            emit Mint(0, this.address);
                            _1222 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1222] = 26
                            mem[_1222 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _1231 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_1231 + idx + 68] = mem[_1222 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_1231 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _1231 + -mem[64] + 100
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sushiAddress)
                        call sushiAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args address(this.address), 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0 / totalAllocPoint
                        emit Mint((0 / totalAllocPoint), this.address);
                        if not 0 / totalAllocPoint:
                            _1288 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1288] = 26
                            mem[_1288 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _1302 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_1302 + idx + 68] = mem[_1288 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_1302 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _1302 + -mem[64] + 100
                        if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                            revert with 'NH{q', 17
                        if not 0 / totalAllocPoint:
                            revert with 'NH{q', 18
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _1410 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1410] = 26
                        mem[_1410 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _1428 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1428 + idx + 68] = mem[_1410 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1428 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1428 + -mem[64] + 100
                    if block.number - poolInfo[idx].field_1280 and sub_a054b70a > -1 / block.number - poolInfo[idx].field_1280:
                        revert with 'NH{q', 17
                    if not block.number - poolInfo[idx].field_1280:
                        revert with 'NH{q', 18
                    if (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / block.number - poolInfo[idx].field_1280 != sub_a054b70a:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _1124 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1124] = 26
                    mem[_1124 + 32] = 'SafeMath: division by zero'
                    if not (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100:
                        _1168 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1168] = 26
                        mem[_1168 + 32] = 'SafeMath: division by zero'
                        if totalAllocPoint <= 0:
                            _1172 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_1172 + idx + 68] = mem[_1168 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_1172 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _1172 + -mem[64] + 100
                        if not totalAllocPoint:
                            revert with 'NH{q', 18
                        if not 0 / totalAllocPoint:
                            mem[mem[64]] = 0
                            emit Mint(0, this.address);
                            _1311 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1311] = 26
                            mem[_1311 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _1318 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_1318 + idx + 68] = mem[_1311 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_1318 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _1318 + -mem[64] + 100
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sushiAddress)
                        call sushiAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args address(this.address), 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0 / totalAllocPoint
                        emit Mint((0 / totalAllocPoint), this.address);
                        if not 0 / totalAllocPoint:
                            _1409 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1409] = 26
                            mem[_1409 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _1427 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_1427 + idx + 68] = mem[_1409 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_1427 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _1427 + -mem[64] + 100
                        if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                            revert with 'NH{q', 17
                        if not 0 / totalAllocPoint:
                            revert with 'NH{q', 18
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _1574 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1574] = 26
                        mem[_1574 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _1592 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1592 + idx + 68] = mem[_1574 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1592 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1592 + -mem[64] + 100
                    if (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 and sushiPerBlock > -1 / (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100:
                        revert with 'NH{q', 17
                    if not (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100:
                        revert with 'NH{q', 18
                    if (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock / (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 != sushiPerBlock:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock:
                        _1230 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1230] = 26
                        mem[_1230 + 32] = 'SafeMath: division by zero'
                        if totalAllocPoint <= 0:
                            _1237 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_1237 + idx + 68] = mem[_1230 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_1237 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _1237 + -mem[64] + 100
                        if not totalAllocPoint:
                            revert with 'NH{q', 18
                        if not 0 / totalAllocPoint:
                            mem[mem[64]] = 0
                            emit Mint(0, this.address);
                            _1442 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1442] = 26
                            mem[_1442 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _1455 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_1455 + idx + 68] = mem[_1442 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_1455 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _1455 + -mem[64] + 100
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sushiAddress)
                        call sushiAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args address(this.address), 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0 / totalAllocPoint
                        emit Mint((0 / totalAllocPoint), this.address);
                        if not 0 / totalAllocPoint:
                            _1573 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1573] = 26
                            mem[_1573 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _1591 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_1591 + idx + 68] = mem[_1573 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_1591 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _1591 + -mem[64] + 100
                        if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                            revert with 'NH{q', 17
                        if not 0 / totalAllocPoint:
                            revert with 'NH{q', 18
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _1764 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1764] = 26
                        mem[_1764 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _1786 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1786 + idx + 68] = mem[_1764 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1786 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1786 + -mem[64] + 100
                    if (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock and poolInfo[idx].field_256 > -1 / (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock:
                        revert with 'NH{q', 17
                    if not (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock:
                        revert with 'NH{q', 18
                    if (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock != poolInfo[idx].field_256:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _1317 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1317] = 26
                    mem[_1317 + 32] = 'SafeMath: division by zero'
                    if totalAllocPoint <= 0:
                        _1332 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1332 + idx + 68] = mem[_1317 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1332 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1332 + -mem[64] + 100
                    if not totalAllocPoint:
                        revert with 'NH{q', 18
                    if not (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _1607 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1607] = 26
                        mem[_1607 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _1627 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1627 + idx + 68] = mem[_1607 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1627 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1627 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                    require ext_code.size(sushiAddress)
                    call sushiAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args address(this.address), (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                    emit Mint(((block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint), this.address);
                    if not (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                        _1763 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1763] = 26
                        mem[_1763 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _1785 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1785 + idx + 68] = mem[_1763 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1785 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1785 + -mem[64] + 100
                    if (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint and 10^12 > -1 / (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                        revert with 'NH{q', 17
                    if not (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                        revert with 'NH{q', 18
                    if 10^12 * (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _1970 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1970] = 26
                    mem[_1970 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _1990 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_1990 + idx + 68] = mem[_1970 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1990 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _1990 + -mem[64] + 100
                if 100 < sub_a054b70a:
                    revert with 'NH{q', 17
                _1082 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1082] = 30
                mem[_1082 + 32] = 'SafeMath: subtraction overflow'
                if poolInfo[idx].field_1280 > block.number:
                    _1085 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_1085 + idx + 68] = mem[_1082 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1085 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _1085 + -mem[64] + 100
                if block.number < poolInfo[idx].field_1280:
                    revert with 'NH{q', 17
                if not block.number - poolInfo[idx].field_1280:
                    _1110 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1110] = 26
                    mem[_1110 + 32] = 'SafeMath: division by zero'
                    _1152 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1152] = 26
                    mem[_1152 + 32] = 'SafeMath: division by zero'
                    if totalAllocPoint <= 0:
                        _1156 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1156 + idx + 68] = mem[_1152 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1156 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1156 + -mem[64] + 100
                    if not totalAllocPoint:
                        revert with 'NH{q', 18
                    if not 0 / totalAllocPoint:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _1260 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1260] = 26
                        mem[_1260 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _1271 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1271 + idx + 68] = mem[_1260 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1271 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1271 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sushiAddress)
                    call sushiAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args address(this.address), 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0 / totalAllocPoint
                    emit Mint((0 / totalAllocPoint), this.address);
                    if not 0 / totalAllocPoint:
                        _1335 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1335] = 26
                        mem[_1335 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _1354 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1354 + idx + 68] = mem[_1335 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1354 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1354 + -mem[64] + 100
                    if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                        revert with 'NH{q', 17
                    if not 0 / totalAllocPoint:
                        revert with 'NH{q', 18
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _1478 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1478] = 26
                    mem[_1478 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _1499 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_1499 + idx + 68] = mem[_1478 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1499 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _1499 + -mem[64] + 100
                if block.number - poolInfo[idx].field_1280 and -sub_a054b70a + 100 > -1 / block.number - poolInfo[idx].field_1280:
                    revert with 'NH{q', 17
                if not block.number - poolInfo[idx].field_1280:
                    revert with 'NH{q', 18
                if (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / block.number - poolInfo[idx].field_1280 != -sub_a054b70a + 100:
                    revert with 0, 'SafeMath: multiplication overflow'
                _1136 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1136] = 26
                mem[_1136 + 32] = 'SafeMath: division by zero'
                if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100:
                    _1196 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1196] = 26
                    mem[_1196 + 32] = 'SafeMath: division by zero'
                    if totalAllocPoint <= 0:
                        _1204 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1204 + idx + 68] = mem[_1196 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1204 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1204 + -mem[64] + 100
                    if not totalAllocPoint:
                        revert with 'NH{q', 18
                    if not 0 / totalAllocPoint:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _1363 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1363] = 26
                        mem[_1363 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _1378 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1378 + idx + 68] = mem[_1363 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1378 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1378 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sushiAddress)
                    call sushiAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args address(this.address), 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0 / totalAllocPoint
                    emit Mint((0 / totalAllocPoint), this.address);
                    if not 0 / totalAllocPoint:
                        _1477 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1477] = 26
                        mem[_1477 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _1498 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1498 + idx + 68] = mem[_1477 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1498 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1498 + -mem[64] + 100
                    if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                        revert with 'NH{q', 17
                    if not 0 / totalAllocPoint:
                        revert with 'NH{q', 18
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _1648 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1648] = 26
                    mem[_1648 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _1671 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_1671 + idx + 68] = mem[_1648 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1671 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _1671 + -mem[64] + 100
                if (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 and sushiPerBlock > -1 / (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100:
                    revert with 'NH{q', 17
                if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100:
                    revert with 'NH{q', 18
                if (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock / (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 != sushiPerBlock:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock:
                    _1270 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1270] = 26
                    mem[_1270 + 32] = 'SafeMath: division by zero'
                    if totalAllocPoint <= 0:
                        _1279 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1279 + idx + 68] = mem[_1270 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1279 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1279 + -mem[64] + 100
                    if not totalAllocPoint:
                        revert with 'NH{q', 18
                    if not 0 / totalAllocPoint:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _1511 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1511] = 26
                        mem[_1511 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _1538 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1538 + idx + 68] = mem[_1511 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1538 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1538 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sushiAddress)
                    call sushiAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args address(this.address), 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0 / totalAllocPoint
                    emit Mint((0 / totalAllocPoint), this.address);
                    if not 0 / totalAllocPoint:
                        _1647 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1647] = 26
                        mem[_1647 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _1670 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1670 + idx + 68] = mem[_1647 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1670 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1670 + -mem[64] + 100
                    if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                        revert with 'NH{q', 17
                    if not 0 / totalAllocPoint:
                        revert with 'NH{q', 18
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _1842 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1842] = 26
                    mem[_1842 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _1867 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_1867 + idx + 68] = mem[_1842 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1867 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _1867 + -mem[64] + 100
                if (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock and poolInfo[idx].field_256 > -1 / (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock:
                    revert with 'NH{q', 17
                if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock:
                    revert with 'NH{q', 18
                if (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock != poolInfo[idx].field_256:
                    revert with 0, 'SafeMath: multiplication overflow'
                _1377 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1377] = 26
                mem[_1377 + 32] = 'SafeMath: division by zero'
                if totalAllocPoint <= 0:
                    _1393 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_1393 + idx + 68] = mem[_1377 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1393 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _1393 + -mem[64] + 100
                if not totalAllocPoint:
                    revert with 'NH{q', 18
                if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                    mem[mem[64]] = 0
                    emit Mint(0, this.address);
                    _1688 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1688] = 26
                    mem[_1688 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _1723 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_1723 + idx + 68] = mem[_1688 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1723 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _1723 + -mem[64] + 100
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                require ext_code.size(sushiAddress)
                call sushiAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args address(this.address), (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                emit Mint(((100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint), this.address);
                if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                    _1841 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1841] = 26
                    mem[_1841 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _1866 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_1866 + idx + 68] = mem[_1841 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1866 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _1866 + -mem[64] + 100
                if (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint and 10^12 > -1 / (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                    revert with 'NH{q', 17
                if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                    revert with 'NH{q', 18
                if 10^12 * (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                _2047 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2047] = 26
                mem[_2047 + 32] = 'SafeMath: division by zero'
                if poolInfo[idx].field_512 > 0:
                    if not poolInfo[idx].field_512:
                        revert with 'NH{q', 18
                    if poolInfo[idx].field_1536 > -(10^12 * (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                        revert with 'NH{q', 17
                    if poolInfo[idx].field_1536 + (10^12 * (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_1536 += 10^12 * (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512
                    poolInfo[idx].field_1280 = block.number
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                _2071 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_2071 + idx + 68] = mem[_2047 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_2071 + 94] = 0
                revert with memory
                  from mem[64]
                   len _2071 + -mem[64] + 100
            if not poolInfo[idx].field_768:
                _1032 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1032] = 30
                mem[_1032 + 32] = 'SafeMath: subtraction overflow'
                if bonusEndBlock > block.number:
                    _1035 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_1035 + idx + 68] = mem[_1032 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1035 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _1035 + -mem[64] + 100
                if block.number < bonusEndBlock:
                    revert with 'NH{q', 17
                if not block.number - bonusEndBlock:
                    _1097 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1097] = 26
                    mem[_1097 + 32] = 'SafeMath: division by zero'
                    _1119 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1119] = 30
                    mem[_1119 + 32] = 'SafeMath: subtraction overflow'
                    if poolInfo[idx].field_1280 > bonusEndBlock:
                        _1121 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_1121 + idx + 68] = mem[_1119 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1121 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _1121 + -mem[64] + 100
                    if bonusEndBlock < poolInfo[idx].field_1280:
                        revert with 'NH{q', 17
                    if not bonusEndBlock - poolInfo[idx].field_1280:
                        _1147 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1147] = 26
                        mem[_1147 + 32] = 'SafeMath: division by zero'
                        _1272 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1272] = 26
                        mem[_1272 + 32] = 'SafeMath: division by zero'
                        if totalAllocPoint <= 0:
                            _1286 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_1286 + idx + 68] = mem[_1272 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_1286 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _1286 + -mem[64] + 100
                        if not totalAllocPoint:
                            revert with 'NH{q', 18
                        if not 0 / totalAllocPoint:
                            mem[mem[64]] = 0
                            emit Mint(0, this.address);
                            _1522 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1522] = 26
                            mem[_1522 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _1547 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_1547 + idx + 68] = mem[_1522 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_1547 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _1547 + -mem[64] + 100
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sushiAddress)
                        call sushiAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args address(this.address), 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0 / totalAllocPoint
                        emit Mint((0 / totalAllocPoint), this.address);
                        if not 0 / totalAllocPoint:
                            _1654 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1654] = 26
                            mem[_1654 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _1682 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_1682 + idx + 68] = mem[_1654 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_1682 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _1682 + -mem[64] + 100
                        if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                            revert with 'NH{q', 17
                        if not 0 / totalAllocPoint:
                            revert with 'NH{q', 18
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _1849 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1849] = 26
                        mem[_1849 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _1879 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1879 + idx + 68] = mem[_1849 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1879 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1879 + -mem[64] + 100
                    if bonusEndBlock - poolInfo[idx].field_1280 and sub_e600038d > -1 / bonusEndBlock - poolInfo[idx].field_1280:
                        revert with 'NH{q', 17
                    if not bonusEndBlock - poolInfo[idx].field_1280:
                        revert with 'NH{q', 18
                    if (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / bonusEndBlock - poolInfo[idx].field_1280 != sub_e600038d:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _1189 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1189] = 26
                    mem[_1189 + 32] = 'SafeMath: division by zero'
                    if (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 > -1:
                        revert with 'NH{q', 17
                    if (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 < (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100:
                        revert with 0, 'SafeMath: addition overflow'
                    if not (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100:
                        _1383 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1383] = 26
                        mem[_1383 + 32] = 'SafeMath: division by zero'
                        if totalAllocPoint <= 0:
                            _1404 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_1404 + idx + 68] = mem[_1383 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_1404 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _1404 + -mem[64] + 100
                        if not totalAllocPoint:
                            revert with 'NH{q', 18
                        if not 0 / totalAllocPoint:
                            mem[mem[64]] = 0
                            emit Mint(0, this.address);
                            _1703 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1703] = 26
                            mem[_1703 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _1734 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_1734 + idx + 68] = mem[_1703 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_1734 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _1734 + -mem[64] + 100
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sushiAddress)
                        call sushiAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args address(this.address), 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0 / totalAllocPoint
                        emit Mint((0 / totalAllocPoint), this.address);
                        if not 0 / totalAllocPoint:
                            _1848 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1848] = 26
                            mem[_1848 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _1878 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_1878 + idx + 68] = mem[_1848 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_1878 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _1878 + -mem[64] + 100
                        if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                            revert with 'NH{q', 17
                        if not 0 / totalAllocPoint:
                            revert with 'NH{q', 18
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _2055 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2055] = 26
                        mem[_2055 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _2085 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2085 + idx + 68] = mem[_2055 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2085 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2085 + -mem[64] + 100
                    if (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 and sushiPerBlock > -1 / (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100:
                        revert with 'NH{q', 17
                    if not (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100:
                        revert with 'NH{q', 18
                    if (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock / (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 != sushiPerBlock:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock:
                        _1546 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1546] = 26
                        mem[_1546 + 32] = 'SafeMath: division by zero'
                        if totalAllocPoint <= 0:
                            _1568 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_1568 + idx + 68] = mem[_1546 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_1568 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _1568 + -mem[64] + 100
                        if not totalAllocPoint:
                            revert with 'NH{q', 18
                        if not 0 / totalAllocPoint:
                            mem[mem[64]] = 0
                            emit Mint(0, this.address);
                            _1904 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1904] = 26
                            mem[_1904 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _1937 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_1937 + idx + 68] = mem[_1904 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_1937 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _1937 + -mem[64] + 100
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sushiAddress)
                        call sushiAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args address(this.address), 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0 / totalAllocPoint
                        emit Mint((0 / totalAllocPoint), this.address);
                        if not 0 / totalAllocPoint:
                            _2054 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2054] = 26
                            mem[_2054 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _2084 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2084 + idx + 68] = mem[_2054 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2084 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2084 + -mem[64] + 100
                        if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                            revert with 'NH{q', 17
                        if not 0 / totalAllocPoint:
                            revert with 'NH{q', 18
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _2239 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2239] = 26
                        mem[_2239 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _2264 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2264 + idx + 68] = mem[_2239 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2264 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2264 + -mem[64] + 100
                    if (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock and poolInfo[idx].field_256 > -1 / (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock:
                        revert with 'NH{q', 17
                    if not (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock:
                        revert with 'NH{q', 18
                    if (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock != poolInfo[idx].field_256:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _1733 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1733] = 26
                    mem[_1733 + 32] = 'SafeMath: division by zero'
                    if totalAllocPoint <= 0:
                        _1757 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1757 + idx + 68] = mem[_1733 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1757 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1757 + -mem[64] + 100
                    if not totalAllocPoint:
                        revert with 'NH{q', 18
                    if not (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _2111 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2111] = 26
                        mem[_2111 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _2142 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2142 + idx + 68] = mem[_2111 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2142 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2142 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                    require ext_code.size(sushiAddress)
                    call sushiAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args address(this.address), (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                    emit Mint(((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint), this.address);
                    if not (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                        _2238 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2238] = 26
                        mem[_2238 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _2263 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2263 + idx + 68] = mem[_2238 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2263 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2263 + -mem[64] + 100
                    if (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint and 10^12 > -1 / (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                        revert with 'NH{q', 17
                    if not (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                        revert with 'NH{q', 18
                    if 10^12 * (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _2390 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2390] = 26
                    mem[_2390 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _2410 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2410 + idx + 68] = mem[_2390 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2410 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _2410 + -mem[64] + 100
                if block.number - bonusEndBlock and sub_a054b70a > -1 / block.number - bonusEndBlock:
                    revert with 'NH{q', 17
                if not block.number - bonusEndBlock:
                    revert with 'NH{q', 18
                if (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / block.number - bonusEndBlock != sub_a054b70a:
                    revert with 0, 'SafeMath: multiplication overflow'
                _1123 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1123] = 26
                mem[_1123 + 32] = 'SafeMath: division by zero'
                _1145 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1145] = 30
                mem[_1145 + 32] = 'SafeMath: subtraction overflow'
                if poolInfo[idx].field_1280 > bonusEndBlock:
                    _1150 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_1150 + idx + 68] = mem[_1145 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1150 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _1150 + -mem[64] + 100
                if bonusEndBlock < poolInfo[idx].field_1280:
                    revert with 'NH{q', 17
                if not bonusEndBlock - poolInfo[idx].field_1280:
                    _1188 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1188] = 26
                    mem[_1188 + 32] = 'SafeMath: division by zero'
                    if 0 > -((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100) - 1:
                        revert with 'NH{q', 17
                    if (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    if not (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100:
                        _1382 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1382] = 26
                        mem[_1382 + 32] = 'SafeMath: division by zero'
                        if totalAllocPoint <= 0:
                            _1403 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_1403 + idx + 68] = mem[_1382 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_1403 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _1403 + -mem[64] + 100
                        if not totalAllocPoint:
                            revert with 'NH{q', 18
                        if not 0 / totalAllocPoint:
                            mem[mem[64]] = 0
                            emit Mint(0, this.address);
                            _1700 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1700] = 26
                            mem[_1700 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _1732 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_1732 + idx + 68] = mem[_1700 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_1732 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _1732 + -mem[64] + 100
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sushiAddress)
                        call sushiAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args address(this.address), 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0 / totalAllocPoint
                        emit Mint((0 / totalAllocPoint), this.address);
                        if not 0 / totalAllocPoint:
                            _1846 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1846] = 26
                            mem[_1846 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _1876 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_1876 + idx + 68] = mem[_1846 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_1876 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _1876 + -mem[64] + 100
                        if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                            revert with 'NH{q', 17
                        if not 0 / totalAllocPoint:
                            revert with 'NH{q', 18
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _2052 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2052] = 26
                        mem[_2052 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _2081 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2081 + idx + 68] = mem[_2052 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2081 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2081 + -mem[64] + 100
                    if (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 and sushiPerBlock > -1 / (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100:
                        revert with 'NH{q', 17
                    if not (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100:
                        revert with 'NH{q', 18
                    if (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock / (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 != sushiPerBlock:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock:
                        _1545 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1545] = 26
                        mem[_1545 + 32] = 'SafeMath: division by zero'
                        if totalAllocPoint <= 0:
                            _1566 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_1566 + idx + 68] = mem[_1545 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_1566 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _1566 + -mem[64] + 100
                        if not totalAllocPoint:
                            revert with 'NH{q', 18
                        if not 0 / totalAllocPoint:
                            mem[mem[64]] = 0
                            emit Mint(0, this.address);
                            _1901 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1901] = 26
                            mem[_1901 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _1934 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_1934 + idx + 68] = mem[_1901 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_1934 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _1934 + -mem[64] + 100
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sushiAddress)
                        call sushiAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args address(this.address), 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0 / totalAllocPoint
                        emit Mint((0 / totalAllocPoint), this.address);
                        if not 0 / totalAllocPoint:
                            _2051 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2051] = 26
                            mem[_2051 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _2080 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2080 + idx + 68] = mem[_2051 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2080 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2080 + -mem[64] + 100
                        if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                            revert with 'NH{q', 17
                        if not 0 / totalAllocPoint:
                            revert with 'NH{q', 18
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _2237 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2237] = 26
                        mem[_2237 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _2260 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2260 + idx + 68] = mem[_2237 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2260 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2260 + -mem[64] + 100
                    if (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock and poolInfo[idx].field_256 > -1 / (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock:
                        revert with 'NH{q', 17
                    if not (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock:
                        revert with 'NH{q', 18
                    if (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock != poolInfo[idx].field_256:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _1731 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1731] = 26
                    mem[_1731 + 32] = 'SafeMath: division by zero'
                    if totalAllocPoint <= 0:
                        _1755 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1755 + idx + 68] = mem[_1731 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1755 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1755 + -mem[64] + 100
                    if not totalAllocPoint:
                        revert with 'NH{q', 18
                    if not (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _2108 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2108] = 26
                        mem[_2108 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _2137 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2137 + idx + 68] = mem[_2108 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2137 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2137 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                    require ext_code.size(sushiAddress)
                    call sushiAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args address(this.address), (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                    emit Mint(((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint), this.address);
                    if not (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                        _2236 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2236] = 26
                        mem[_2236 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _2259 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2259 + idx + 68] = mem[_2236 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2259 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2259 + -mem[64] + 100
                    if (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint and 10^12 > -1 / (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                        revert with 'NH{q', 17
                    if not (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                        revert with 'NH{q', 18
                    if 10^12 * (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _2389 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2389] = 26
                    mem[_2389 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _2407 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2407 + idx + 68] = mem[_2389 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2407 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _2407 + -mem[64] + 100
                if bonusEndBlock - poolInfo[idx].field_1280 and sub_e600038d > -1 / bonusEndBlock - poolInfo[idx].field_1280:
                    revert with 'NH{q', 17
                if not bonusEndBlock - poolInfo[idx].field_1280:
                    revert with 'NH{q', 18
                if (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / bonusEndBlock - poolInfo[idx].field_1280 != sub_e600038d:
                    revert with 0, 'SafeMath: multiplication overflow'
                _1263 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1263] = 26
                mem[_1263 + 32] = 'SafeMath: division by zero'
                if (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 > -((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100) - 1:
                    revert with 'NH{q', 17
                if ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100) < (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100:
                    revert with 0, 'SafeMath: addition overflow'
                if not ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100):
                    _1544 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1544] = 26
                    mem[_1544 + 32] = 'SafeMath: division by zero'
                    if totalAllocPoint <= 0:
                        _1565 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1565 + idx + 68] = mem[_1544 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1565 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1565 + -mem[64] + 100
                    if not totalAllocPoint:
                        revert with 'NH{q', 18
                    if not 0 / totalAllocPoint:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _1898 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1898] = 26
                        mem[_1898 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _1933 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1933 + idx + 68] = mem[_1898 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1933 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1933 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sushiAddress)
                    call sushiAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args address(this.address), 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0 / totalAllocPoint
                    emit Mint((0 / totalAllocPoint), this.address);
                    if not 0 / totalAllocPoint:
                        _2049 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2049] = 26
                        mem[_2049 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _2078 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2078 + idx + 68] = mem[_2049 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2078 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2078 + -mem[64] + 100
                    if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                        revert with 'NH{q', 17
                    if not 0 / totalAllocPoint:
                        revert with 'NH{q', 18
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _2235 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2235] = 26
                    mem[_2235 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _2257 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2257 + idx + 68] = mem[_2235 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2257 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _2257 + -mem[64] + 100
                if ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100) and sushiPerBlock > -1 / ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100):
                    revert with 'NH{q', 17
                if not ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100):
                    revert with 'NH{q', 18
                if ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock) / ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100) != sushiPerBlock:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock):
                    _1730 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1730] = 26
                    mem[_1730 + 32] = 'SafeMath: division by zero'
                    if totalAllocPoint <= 0:
                        _1753 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1753 + idx + 68] = mem[_1730 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1753 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1753 + -mem[64] + 100
                    if not totalAllocPoint:
                        revert with 'NH{q', 18
                    if not 0 / totalAllocPoint:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _2107 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2107] = 26
                        mem[_2107 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _2134 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2134 + idx + 68] = mem[_2107 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2134 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2134 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sushiAddress)
                    call sushiAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args address(this.address), 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0 / totalAllocPoint
                    emit Mint((0 / totalAllocPoint), this.address);
                    if not 0 / totalAllocPoint:
                        _2234 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2234] = 26
                        mem[_2234 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _2256 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2256 + idx + 68] = mem[_2234 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2256 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2256 + -mem[64] + 100
                    if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                        revert with 'NH{q', 17
                    if not 0 / totalAllocPoint:
                        revert with 'NH{q', 18
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _2388 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2388] = 26
                    mem[_2388 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _2404 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2404 + idx + 68] = mem[_2388 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2404 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _2404 + -mem[64] + 100
                if ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock) and poolInfo[idx].field_256 > -1 / ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock):
                    revert with 'NH{q', 17
                if not ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock):
                    revert with 'NH{q', 18
                if ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock) != poolInfo[idx].field_256:
                    revert with 0, 'SafeMath: multiplication overflow'
                _1932 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1932] = 26
                mem[_1932 + 32] = 'SafeMath: division by zero'
                if totalAllocPoint <= 0:
                    _1956 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_1956 + idx + 68] = mem[_1932 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1956 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _1956 + -mem[64] + 100
                if not totalAllocPoint:
                    revert with 'NH{q', 18
                if not ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                    mem[mem[64]] = 0
                    emit Mint(0, this.address);
                    _2279 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2279] = 26
                    mem[_2279 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _2305 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2305 + idx + 68] = mem[_2279 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2305 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _2305 + -mem[64] + 100
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                require ext_code.size(sushiAddress)
                call sushiAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args address(this.address), ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                emit Mint((((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint), this.address);
                if not ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                    _2387 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2387] = 26
                    mem[_2387 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _2403 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2403 + idx + 68] = mem[_2387 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2403 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _2403 + -mem[64] + 100
                if ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint and 10^12 > -1 / ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                    revert with 'NH{q', 17
                if not ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                    revert with 'NH{q', 18
                if 10^12 * ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint / ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                _2501 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2501] = 26
                mem[_2501 + 32] = 'SafeMath: division by zero'
                if poolInfo[idx].field_512 > 0:
                    if not poolInfo[idx].field_512:
                        revert with 'NH{q', 18
                    if poolInfo[idx].field_1536 > -(10^12 * ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_512) - 1:
                        revert with 'NH{q', 17
                    if poolInfo[idx].field_1536 + (10^12 * ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_1536 += 10^12 * ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_512
                    poolInfo[idx].field_1280 = block.number
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                _2654 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_2654 + idx + 68] = mem[_2501 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_2654 + 94] = 0
                revert with memory
                  from mem[64]
                   len _2654 + -mem[64] + 100
            if 100 < sub_a054b70a:
                revert with 'NH{q', 17
            _1081 = mem[64]
            mem[64] = mem[64] + 64
            mem[_1081] = 30
            mem[_1081 + 32] = 'SafeMath: subtraction overflow'
            if bonusEndBlock > block.number:
                _1084 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_1084 + idx + 68] = mem[_1081 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_1084 + 98] = 0
                revert with memory
                  from mem[64]
                   len _1084 + -mem[64] + 100
            if block.number < bonusEndBlock:
                revert with 'NH{q', 17
            if not block.number - bonusEndBlock:
                _1109 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1109] = 26
                mem[_1109 + 32] = 'SafeMath: division by zero'
                if 100 < sub_e600038d:
                    revert with 'NH{q', 17
                _1143 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1143] = 30
                mem[_1143 + 32] = 'SafeMath: subtraction overflow'
                if poolInfo[idx].field_1280 > bonusEndBlock:
                    _1148 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_1148 + idx + 68] = mem[_1143 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1148 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _1148 + -mem[64] + 100
                if bonusEndBlock < poolInfo[idx].field_1280:
                    revert with 'NH{q', 17
                if not bonusEndBlock - poolInfo[idx].field_1280:
                    _1183 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1183] = 26
                    mem[_1183 + 32] = 'SafeMath: division by zero'
                    _1375 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1375] = 26
                    mem[_1375 + 32] = 'SafeMath: division by zero'
                    if totalAllocPoint <= 0:
                        _1390 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1390 + idx + 68] = mem[_1375 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1390 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1390 + -mem[64] + 100
                    if not totalAllocPoint:
                        revert with 'NH{q', 18
                    if not 0 / totalAllocPoint:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _1687 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1687] = 26
                        mem[_1687 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _1721 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1721 + idx + 68] = mem[_1687 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1721 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1721 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sushiAddress)
                    call sushiAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args address(this.address), 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0 / totalAllocPoint
                    emit Mint((0 / totalAllocPoint), this.address);
                    if not 0 / totalAllocPoint:
                        _1840 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1840] = 26
                        mem[_1840 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _1865 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1865 + idx + 68] = mem[_1840 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1865 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1865 + -mem[64] + 100
                    if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                        revert with 'NH{q', 17
                    if not 0 / totalAllocPoint:
                        revert with 'NH{q', 18
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _2046 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2046] = 26
                    mem[_2046 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _2069 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2069 + idx + 68] = mem[_2046 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2069 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _2069 + -mem[64] + 100
                if bonusEndBlock - poolInfo[idx].field_1280 and -sub_e600038d + 100 > -1 / bonusEndBlock - poolInfo[idx].field_1280:
                    revert with 'NH{q', 17
                if not bonusEndBlock - poolInfo[idx].field_1280:
                    revert with 'NH{q', 18
                if (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / bonusEndBlock - poolInfo[idx].field_1280 != -sub_e600038d + 100:
                    revert with 0, 'SafeMath: multiplication overflow'
                _1256 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1256] = 26
                mem[_1256 + 32] = 'SafeMath: division by zero'
                if (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 > -1:
                    revert with 'NH{q', 17
                if (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 < (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100:
                    revert with 0, 'SafeMath: addition overflow'
                if not (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100:
                    _1536 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1536] = 26
                    mem[_1536 + 32] = 'SafeMath: division by zero'
                    if totalAllocPoint <= 0:
                        _1553 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1553 + idx + 68] = mem[_1536 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1553 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1553 + -mem[64] + 100
                    if not totalAllocPoint:
                        revert with 'NH{q', 18
                    if not 0 / totalAllocPoint:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _1888 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1888] = 26
                        mem[_1888 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _1922 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1922 + idx + 68] = mem[_1888 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1922 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1922 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sushiAddress)
                    call sushiAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args address(this.address), 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0 / totalAllocPoint
                    emit Mint((0 / totalAllocPoint), this.address);
                    if not 0 / totalAllocPoint:
                        _2045 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2045] = 26
                        mem[_2045 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _2068 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2068 + idx + 68] = mem[_2045 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2068 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2068 + -mem[64] + 100
                    if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                        revert with 'NH{q', 17
                    if not 0 / totalAllocPoint:
                        revert with 'NH{q', 18
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _2232 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2232] = 26
                    mem[_2232 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _2250 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2250 + idx + 68] = mem[_2232 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2250 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _2250 + -mem[64] + 100
                if (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 and sushiPerBlock > -1 / (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100:
                    revert with 'NH{q', 17
                if not (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100:
                    revert with 'NH{q', 18
                if (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock / (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 != sushiPerBlock:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock:
                    _1720 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1720] = 26
                    mem[_1720 + 32] = 'SafeMath: division by zero'
                    if totalAllocPoint <= 0:
                        _1744 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1744 + idx + 68] = mem[_1720 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1744 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1744 + -mem[64] + 100
                    if not totalAllocPoint:
                        revert with 'NH{q', 18
                    if not 0 / totalAllocPoint:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _2096 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2096] = 26
                        mem[_2096 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _2126 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2126 + idx + 68] = mem[_2096 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2126 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2126 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sushiAddress)
                    call sushiAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args address(this.address), 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0 / totalAllocPoint
                    emit Mint((0 / totalAllocPoint), this.address);
                    if not 0 / totalAllocPoint:
                        _2231 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2231] = 26
                        mem[_2231 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _2249 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2249 + idx + 68] = mem[_2231 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2249 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2249 + -mem[64] + 100
                    if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                        revert with 'NH{q', 17
                    if not 0 / totalAllocPoint:
                        revert with 'NH{q', 18
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _2386 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2386] = 26
                    mem[_2386 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _2400 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2400 + idx + 68] = mem[_2386 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2400 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _2400 + -mem[64] + 100
                if (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock and poolInfo[idx].field_256 > -1 / (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock:
                    revert with 'NH{q', 17
                if not (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock:
                    revert with 'NH{q', 18
                if (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock != poolInfo[idx].field_256:
                    revert with 0, 'SafeMath: multiplication overflow'
                _1921 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1921] = 26
                mem[_1921 + 32] = 'SafeMath: division by zero'
                if totalAllocPoint <= 0:
                    _1951 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_1951 + idx + 68] = mem[_1921 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1951 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _1951 + -mem[64] + 100
                if not totalAllocPoint:
                    revert with 'NH{q', 18
                if not (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                    mem[mem[64]] = 0
                    emit Mint(0, this.address);
                    _2273 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2273] = 26
                    mem[_2273 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _2298 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2298 + idx + 68] = mem[_2273 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2298 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _2298 + -mem[64] + 100
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                require ext_code.size(sushiAddress)
                call sushiAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args address(this.address), (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                emit Mint(((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint), this.address);
                if not (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                    _2385 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2385] = 26
                    mem[_2385 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _2399 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2399 + idx + 68] = mem[_2385 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2399 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _2399 + -mem[64] + 100
                if (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint and 10^12 > -1 / (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                    revert with 'NH{q', 17
                if not (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                    revert with 'NH{q', 18
                if 10^12 * (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                _2500 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2500] = 26
                mem[_2500 + 32] = 'SafeMath: division by zero'
                if poolInfo[idx].field_512 > 0:
                    if not poolInfo[idx].field_512:
                        revert with 'NH{q', 18
                    if poolInfo[idx].field_1536 > -(10^12 * (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                        revert with 'NH{q', 17
                    if poolInfo[idx].field_1536 + (10^12 * (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_1536 += 10^12 * (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512
                    poolInfo[idx].field_1280 = block.number
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                _2653 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_2653 + idx + 68] = mem[_2500 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_2653 + 94] = 0
                revert with memory
                  from mem[64]
                   len _2653 + -mem[64] + 100
            if block.number - bonusEndBlock and -sub_a054b70a + 100 > -1 / block.number - bonusEndBlock:
                revert with 'NH{q', 17
            if not block.number - bonusEndBlock:
                revert with 'NH{q', 18
            if (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / block.number - bonusEndBlock != -sub_a054b70a + 100:
                revert with 0, 'SafeMath: multiplication overflow'
            _1134 = mem[64]
            mem[64] = mem[64] + 64
            mem[_1134] = 26
            mem[_1134 + 32] = 'SafeMath: division by zero'
            if 100 < sub_e600038d:
                revert with 'NH{q', 17
            _1179 = mem[64]
            mem[64] = mem[64] + 64
            mem[_1179] = 30
            mem[_1179 + 32] = 'SafeMath: subtraction overflow'
            if poolInfo[idx].field_1280 > bonusEndBlock:
                _1190 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_1190 + idx + 68] = mem[_1179 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_1190 + 98] = 0
                revert with memory
                  from mem[64]
                   len _1190 + -mem[64] + 100
            if bonusEndBlock < poolInfo[idx].field_1280:
                revert with 'NH{q', 17
            if not bonusEndBlock - poolInfo[idx].field_1280:
                _1255 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1255] = 26
                mem[_1255 + 32] = 'SafeMath: division by zero'
                if 0 > -((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100) - 1:
                    revert with 'NH{q', 17
                if (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 < 0:
                    revert with 0, 'SafeMath: addition overflow'
                if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100:
                    _1535 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1535] = 26
                    mem[_1535 + 32] = 'SafeMath: division by zero'
                    if totalAllocPoint <= 0:
                        _1552 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1552 + idx + 68] = mem[_1535 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1552 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1552 + -mem[64] + 100
                    if not totalAllocPoint:
                        revert with 'NH{q', 18
                    if not 0 / totalAllocPoint:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _1885 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1885] = 26
                        mem[_1885 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _1920 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1920 + idx + 68] = mem[_1885 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1920 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1920 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sushiAddress)
                    call sushiAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args address(this.address), 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0 / totalAllocPoint
                    emit Mint((0 / totalAllocPoint), this.address);
                    if not 0 / totalAllocPoint:
                        _2043 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2043] = 26
                        mem[_2043 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _2066 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2066 + idx + 68] = mem[_2043 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2066 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2066 + -mem[64] + 100
                    if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                        revert with 'NH{q', 17
                    if not 0 / totalAllocPoint:
                        revert with 'NH{q', 18
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _2229 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2229] = 26
                    mem[_2229 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _2246 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2246 + idx + 68] = mem[_2229 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2246 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _2246 + -mem[64] + 100
                if (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 and sushiPerBlock > -1 / (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100:
                    revert with 'NH{q', 17
                if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100:
                    revert with 'NH{q', 18
                if (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock / (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 != sushiPerBlock:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock:
                    _1719 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1719] = 26
                    mem[_1719 + 32] = 'SafeMath: division by zero'
                    if totalAllocPoint <= 0:
                        _1742 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1742 + idx + 68] = mem[_1719 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1742 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1742 + -mem[64] + 100
                    if not totalAllocPoint:
                        revert with 'NH{q', 18
                    if not 0 / totalAllocPoint:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _2093 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2093] = 26
                        mem[_2093 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _2123 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2123 + idx + 68] = mem[_2093 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2123 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2123 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sushiAddress)
                    call sushiAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args address(this.address), 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0 / totalAllocPoint
                    emit Mint((0 / totalAllocPoint), this.address);
                    if not 0 / totalAllocPoint:
                        _2228 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2228] = 26
                        mem[_2228 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _2245 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2245 + idx + 68] = mem[_2228 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2245 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2245 + -mem[64] + 100
                    if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                        revert with 'NH{q', 17
                    if not 0 / totalAllocPoint:
                        revert with 'NH{q', 18
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _2384 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2384] = 26
                    mem[_2384 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _2396 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2396 + idx + 68] = mem[_2384 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2396 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _2396 + -mem[64] + 100
                if (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock and poolInfo[idx].field_256 > -1 / (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock:
                    revert with 'NH{q', 17
                if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock:
                    revert with 'NH{q', 18
                if (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock != poolInfo[idx].field_256:
                    revert with 0, 'SafeMath: multiplication overflow'
                _1919 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1919] = 26
                mem[_1919 + 32] = 'SafeMath: division by zero'
                if totalAllocPoint <= 0:
                    _1949 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_1949 + idx + 68] = mem[_1919 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1949 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _1949 + -mem[64] + 100
                if not totalAllocPoint:
                    revert with 'NH{q', 18
                if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                    mem[mem[64]] = 0
                    emit Mint(0, this.address);
                    _2270 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2270] = 26
                    mem[_2270 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _2293 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2293 + idx + 68] = mem[_2270 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2293 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _2293 + -mem[64] + 100
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                require ext_code.size(sushiAddress)
                call sushiAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args address(this.address), (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                emit Mint(((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint), this.address);
                if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                    _2383 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2383] = 26
                    mem[_2383 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _2395 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2395 + idx + 68] = mem[_2383 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2395 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _2395 + -mem[64] + 100
                if (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint and 10^12 > -1 / (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                    revert with 'NH{q', 17
                if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                    revert with 'NH{q', 18
                if 10^12 * (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                _2499 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2499] = 26
                mem[_2499 + 32] = 'SafeMath: division by zero'
                if poolInfo[idx].field_512 > 0:
                    if not poolInfo[idx].field_512:
                        revert with 'NH{q', 18
                    if poolInfo[idx].field_1536 > -(10^12 * (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                        revert with 'NH{q', 17
                    if poolInfo[idx].field_1536 + (10^12 * (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_1536 += 10^12 * (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512
                    poolInfo[idx].field_1280 = block.number
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                _2652 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_2652 + idx + 68] = mem[_2499 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_2652 + 94] = 0
                revert with memory
                  from mem[64]
                   len _2652 + -mem[64] + 100
            if bonusEndBlock - poolInfo[idx].field_1280 and -sub_e600038d + 100 > -1 / bonusEndBlock - poolInfo[idx].field_1280:
                revert with 'NH{q', 17
            if not bonusEndBlock - poolInfo[idx].field_1280:
                revert with 'NH{q', 18
            if (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / bonusEndBlock - poolInfo[idx].field_1280 != -sub_e600038d + 100:
                revert with 0, 'SafeMath: multiplication overflow'
            _1359 = mem[64]
            mem[64] = mem[64] + 64
            mem[_1359] = 26
            mem[_1359 + 32] = 'SafeMath: division by zero'
            if (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 > -((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100) - 1:
                revert with 'NH{q', 17
            if ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100) < (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100:
                revert with 0, 'SafeMath: addition overflow'
            if not ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100):
                _1718 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1718] = 26
                mem[_1718 + 32] = 'SafeMath: division by zero'
                if totalAllocPoint <= 0:
                    _1741 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_1741 + idx + 68] = mem[_1718 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1741 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _1741 + -mem[64] + 100
                if not totalAllocPoint:
                    revert with 'NH{q', 18
                if not 0 / totalAllocPoint:
                    mem[mem[64]] = 0
                    emit Mint(0, this.address);
                    _2090 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2090] = 26
                    mem[_2090 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _2122 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2122 + idx + 68] = mem[_2090 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2122 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _2122 + -mem[64] + 100
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = 0 / totalAllocPoint
                require ext_code.size(sushiAddress)
                call sushiAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args address(this.address), 0 / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 0 / totalAllocPoint
                emit Mint((0 / totalAllocPoint), this.address);
                if not 0 / totalAllocPoint:
                    _2226 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2226] = 26
                    mem[_2226 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _2243 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2243 + idx + 68] = mem[_2226 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2243 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _2243 + -mem[64] + 100
                if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                    revert with 'NH{q', 17
                if not 0 / totalAllocPoint:
                    revert with 'NH{q', 18
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                _2382 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2382] = 26
                mem[_2382 + 32] = 'SafeMath: division by zero'
                if poolInfo[idx].field_512 > 0:
                    if not poolInfo[idx].field_512:
                        revert with 'NH{q', 18
                    if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                        revert with 'NH{q', 17
                    if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                    poolInfo[idx].field_1280 = block.number
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                _2393 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_2393 + idx + 68] = mem[_2382 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_2393 + 94] = 0
                revert with memory
                  from mem[64]
                   len _2393 + -mem[64] + 100
            if ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100) and sushiPerBlock > -1 / ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100):
                revert with 'NH{q', 17
            if not ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100):
                revert with 'NH{q', 18
            if ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock) / ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100) != sushiPerBlock:
                revert with 0, 'SafeMath: multiplication overflow'
            if not ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock):
                _1918 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1918] = 26
                mem[_1918 + 32] = 'SafeMath: division by zero'
                if totalAllocPoint <= 0:
                    _1947 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_1947 + idx + 68] = mem[_1918 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1947 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _1947 + -mem[64] + 100
                if not totalAllocPoint:
                    revert with 'NH{q', 18
                if not 0 / totalAllocPoint:
                    mem[mem[64]] = 0
                    emit Mint(0, this.address);
                    _2269 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2269] = 26
                    mem[_2269 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _2290 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2290 + idx + 68] = mem[_2269 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2290 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _2290 + -mem[64] + 100
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = 0 / totalAllocPoint
                require ext_code.size(sushiAddress)
                call sushiAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args address(this.address), 0 / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 0 / totalAllocPoint
                emit Mint((0 / totalAllocPoint), this.address);
                if not 0 / totalAllocPoint:
                    _2381 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2381] = 26
                    mem[_2381 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _2392 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2392 + idx + 68] = mem[_2381 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2392 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _2392 + -mem[64] + 100
                if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                    revert with 'NH{q', 17
                if not 0 / totalAllocPoint:
                    revert with 'NH{q', 18
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                _2498 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2498] = 26
                mem[_2498 + 32] = 'SafeMath: division by zero'
                if poolInfo[idx].field_512 > 0:
                    if not poolInfo[idx].field_512:
                        revert with 'NH{q', 18
                    if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                        revert with 'NH{q', 17
                    if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                    poolInfo[idx].field_1280 = block.number
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                _2651 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_2651 + idx + 68] = mem[_2498 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_2651 + 94] = 0
                revert with memory
                  from mem[64]
                   len _2651 + -mem[64] + 100
            if ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock) and poolInfo[idx].field_256 > -1 / ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock):
                revert with 'NH{q', 17
            if not ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock):
                revert with 'NH{q', 18
            if ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock) != poolInfo[idx].field_256:
                revert with 0, 'SafeMath: multiplication overflow'
            _2121 = mem[64]
            mem[64] = mem[64] + 64
            mem[_2121] = 26
            mem[_2121 + 32] = 'SafeMath: division by zero'
            if totalAllocPoint <= 0:
                _2153 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_2153 + idx + 68] = mem[_2121 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_2153 + 94] = 0
                revert with memory
                  from mem[64]
                   len _2153 + -mem[64] + 100
            if not totalAllocPoint:
                revert with 'NH{q', 18
            if not ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                mem[mem[64]] = 0
                emit Mint(0, this.address);
                _2413 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2413] = 26
                mem[_2413 + 32] = 'SafeMath: division by zero'
                if poolInfo[idx].field_512 > 0:
                    if not poolInfo[idx].field_512:
                        revert with 'NH{q', 18
                    if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                        revert with 'NH{q', 17
                    if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                    poolInfo[idx].field_1280 = block.number
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                _2431 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_2431 + idx + 68] = mem[_2413 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_2431 + 94] = 0
                revert with memory
                  from mem[64]
                   len _2431 + -mem[64] + 100
            mem[mem[64] + 4] = this.address
            mem[mem[64] + 36] = ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint
            require ext_code.size(sushiAddress)
            call sushiAddress.0x40c10f19 with:
                 gas gas_remaining wei
                args address(this.address), ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[mem[64]] = ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint
            emit Mint((((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint), this.address);
            if not ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                _2497 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2497] = 26
                mem[_2497 + 32] = 'SafeMath: division by zero'
                if poolInfo[idx].field_512 > 0:
                    if not poolInfo[idx].field_512:
                        revert with 'NH{q', 18
                    if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                        revert with 'NH{q', 17
                    if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                    poolInfo[idx].field_1280 = block.number
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                _2650 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_2650 + idx + 68] = mem[_2497 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_2650 + 94] = 0
                revert with memory
                  from mem[64]
                   len _2650 + -mem[64] + 100
            if ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint and 10^12 > -1 / ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                revert with 'NH{q', 17
            if not ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                revert with 'NH{q', 18
            if 10^12 * ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint / ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                revert with 0, 'SafeMath: multiplication overflow'
            _2988 = mem[64]
            mem[64] = mem[64] + 64
            mem[_2988] = 26
            mem[_2988 + 32] = 'SafeMath: division by zero'
            if poolInfo[idx].field_512 > 0:
                if not poolInfo[idx].field_512:
                    revert with 'NH{q', 18
                if poolInfo[idx].field_1536 > -(10^12 * ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_512) - 1:
                    revert with 'NH{q', 17
                if poolInfo[idx].field_1536 + (10^12 * ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                    revert with 0, 'SafeMath: addition overflow'
                poolInfo[idx].field_1536 += 10^12 * ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_512
                poolInfo[idx].field_1280 = block.number
                if idx == -1:
                    revert with 'NH{q', 17
                idx = idx + 1
                continue 
            _2989 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[_2989 + idx + 68] = mem[_2988 + idx + 32]
                idx = idx + 32
                continue 
            mem[_2989 + 94] = 0
            revert with memory
              from mem[64]
               len _2989 + -mem[64] + 100
    if not arg4:
        if totalAllocPoint > -arg1 - 1:
            revert with 'NH{q', 17
        if totalAllocPoint + arg1 < totalAllocPoint:
            revert with 0, 'SafeMath: addition overflow'
        totalAllocPoint += arg1
    else:
        if sub_9e98edc6 > -arg1 - 1:
            revert with 'NH{q', 17
        if sub_9e98edc6 + arg1 < sub_9e98edc6:
            revert with 0, 'SafeMath: addition overflow'
        sub_9e98edc6 += arg1
    poolInfo.length++
    poolInfo[poolInfo.length].field_0 = arg2
    poolInfo[poolInfo.length].field_256 = arg1
    poolInfo[poolInfo.length].field_512 = 0
    poolInfo[poolInfo.length].field_768 = uint8(arg4)
    poolInfo[poolInfo.length].field_1024 = arg5
    if block.number > startBlock:
        poolInfo[poolInfo.length].field_1280 = block.number
    else:
        poolInfo[poolInfo.length].field_1280 = startBlock
    poolInfo[poolInfo.length].field_1536 = 0
}

function set(uint256 arg1, uint256 arg2, bool arg3, uint256 arg4) payable {
    mem[64] = 96
    require not msg.value
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg2 == arg2
    require arg3 == arg3
    require arg4 == arg4
    if owner != msg.sender:
        revert with 0, '!dev addr'
    if arg1 >= poolInfo.length:
        revert with 'NH{q', 50
    mem[0] = 7
    if arg3:
        idx = 0
        while idx < poolInfo.length:
            mem[0] = 7
            if block.number <= poolInfo[idx].field_1280:
                if idx == -1:
                    revert with 'NH{q', 17
                idx = idx + 1
                continue 
            if not poolInfo[idx].field_512:
                poolInfo[idx].field_1280 = block.number
                if idx == -1:
                    revert with 'NH{q', 17
                idx = idx + 1
                continue 
            if block.number <= bonusEndBlock:
                if not poolInfo[idx].field_768:
                    _1108 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1108] = 30
                    mem[_1108 + 32] = 'SafeMath: subtraction overflow'
                    if poolInfo[idx].field_1280 > block.number:
                        _1113 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_1113 + idx + 68] = mem[_1108 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1113 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _1113 + -mem[64] + 100
                    if block.number < poolInfo[idx].field_1280:
                        revert with 'NH{q', 17
                    if not block.number - poolInfo[idx].field_1280:
                        _1137 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1137] = 26
                        mem[_1137 + 32] = 'SafeMath: division by zero'
                        _1181 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1181] = 26
                        mem[_1181 + 32] = 'SafeMath: division by zero'
                        if totalAllocPoint <= 0:
                            _1187 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_1187 + idx + 68] = mem[_1181 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_1187 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _1187 + -mem[64] + 100
                        if not totalAllocPoint:
                            revert with 'NH{q', 18
                        if not 0 / totalAllocPoint:
                            mem[mem[64]] = 0
                            emit Mint(0, this.address);
                            _1267 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1267] = 26
                            mem[_1267 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _1276 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_1276 + idx + 68] = mem[_1267 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_1276 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _1276 + -mem[64] + 100
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sushiAddress)
                        call sushiAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args address(this.address), 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0 / totalAllocPoint
                        emit Mint((0 / totalAllocPoint), this.address);
                        if not 0 / totalAllocPoint:
                            _1331 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1331] = 26
                            mem[_1331 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _1347 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_1347 + idx + 68] = mem[_1331 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_1347 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _1347 + -mem[64] + 100
                        if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                            revert with 'NH{q', 17
                        if not 0 / totalAllocPoint:
                            revert with 'NH{q', 18
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _1446 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1446] = 26
                        mem[_1446 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _1471 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1471 + idx + 68] = mem[_1446 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1471 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1471 + -mem[64] + 100
                    if block.number - poolInfo[idx].field_1280 and sub_e600038d > -1 / block.number - poolInfo[idx].field_1280:
                        revert with 'NH{q', 17
                    if not block.number - poolInfo[idx].field_1280:
                        revert with 'NH{q', 18
                    if (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / block.number - poolInfo[idx].field_1280 != sub_e600038d:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _1171 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1171] = 26
                    mem[_1171 + 32] = 'SafeMath: division by zero'
                    if not (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100:
                        _1215 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1215] = 26
                        mem[_1215 + 32] = 'SafeMath: division by zero'
                        if totalAllocPoint <= 0:
                            _1219 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_1219 + idx + 68] = mem[_1215 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_1219 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _1219 + -mem[64] + 100
                        if not totalAllocPoint:
                            revert with 'NH{q', 18
                        if not 0 / totalAllocPoint:
                            mem[mem[64]] = 0
                            emit Mint(0, this.address);
                            _1355 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1355] = 26
                            mem[_1355 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _1363 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_1363 + idx + 68] = mem[_1355 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_1363 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _1363 + -mem[64] + 100
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sushiAddress)
                        call sushiAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args address(this.address), 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0 / totalAllocPoint
                        emit Mint((0 / totalAllocPoint), this.address);
                        if not 0 / totalAllocPoint:
                            _1445 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1445] = 26
                            mem[_1445 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _1470 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_1470 + idx + 68] = mem[_1445 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_1470 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _1470 + -mem[64] + 100
                        if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                            revert with 'NH{q', 17
                        if not 0 / totalAllocPoint:
                            revert with 'NH{q', 18
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _1609 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1609] = 26
                        mem[_1609 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _1634 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1634 + idx + 68] = mem[_1609 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1634 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1634 + -mem[64] + 100
                    if (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 and sushiPerBlock > -1 / (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100:
                        revert with 'NH{q', 17
                    if not (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100:
                        revert with 'NH{q', 18
                    if (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock / (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 != sushiPerBlock:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock:
                        _1275 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1275] = 26
                        mem[_1275 + 32] = 'SafeMath: division by zero'
                        if totalAllocPoint <= 0:
                            _1282 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_1282 + idx + 68] = mem[_1275 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_1282 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _1282 + -mem[64] + 100
                        if not totalAllocPoint:
                            revert with 'NH{q', 18
                        if not 0 / totalAllocPoint:
                            mem[mem[64]] = 0
                            emit Mint(0, this.address);
                            _1482 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1482] = 26
                            mem[_1482 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _1499 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_1499 + idx + 68] = mem[_1482 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_1499 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _1499 + -mem[64] + 100
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sushiAddress)
                        call sushiAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args address(this.address), 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0 / totalAllocPoint
                        emit Mint((0 / totalAllocPoint), this.address);
                        if not 0 / totalAllocPoint:
                            _1608 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1608] = 26
                            mem[_1608 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _1633 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_1633 + idx + 68] = mem[_1608 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_1633 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _1633 + -mem[64] + 100
                        if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                            revert with 'NH{q', 17
                        if not 0 / totalAllocPoint:
                            revert with 'NH{q', 18
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _1798 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1798] = 26
                        mem[_1798 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _1828 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1828 + idx + 68] = mem[_1798 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1828 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1828 + -mem[64] + 100
                    if (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock and poolInfo[idx].field_256 > -1 / (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock:
                        revert with 'NH{q', 17
                    if not (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock:
                        revert with 'NH{q', 18
                    if (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock != poolInfo[idx].field_256:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _1362 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1362] = 26
                    mem[_1362 + 32] = 'SafeMath: division by zero'
                    if totalAllocPoint <= 0:
                        _1374 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1374 + idx + 68] = mem[_1362 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1374 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1374 + -mem[64] + 100
                    if not totalAllocPoint:
                        revert with 'NH{q', 18
                    if not (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _1644 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1644] = 26
                        mem[_1644 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _1668 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1668 + idx + 68] = mem[_1644 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1668 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1668 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                    require ext_code.size(sushiAddress)
                    call sushiAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args address(this.address), (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                    emit Mint(((block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint), this.address);
                    if not (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                        _1797 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1797] = 26
                        mem[_1797 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _1827 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1827 + idx + 68] = mem[_1797 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1827 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1827 + -mem[64] + 100
                    if (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint and 10^12 > -1 / (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                        revert with 'NH{q', 17
                    if not (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                        revert with 'NH{q', 18
                    if 10^12 * (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _2003 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2003] = 26
                    mem[_2003 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * (block.number * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _2033 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2033 + idx + 68] = mem[_2003 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2033 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _2033 + -mem[64] + 100
                if 100 < sub_e600038d:
                    revert with 'NH{q', 17
                _1119 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1119] = 30
                mem[_1119 + 32] = 'SafeMath: subtraction overflow'
                if poolInfo[idx].field_1280 > block.number:
                    _1124 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_1124 + idx + 68] = mem[_1119 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1124 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _1124 + -mem[64] + 100
                if block.number < poolInfo[idx].field_1280:
                    revert with 'NH{q', 17
                if not block.number - poolInfo[idx].field_1280:
                    _1157 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1157] = 26
                    mem[_1157 + 32] = 'SafeMath: division by zero'
                    _1198 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1198] = 26
                    mem[_1198 + 32] = 'SafeMath: division by zero'
                    if totalAllocPoint <= 0:
                        _1203 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1203 + idx + 68] = mem[_1198 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1203 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1203 + -mem[64] + 100
                    if not totalAllocPoint:
                        revert with 'NH{q', 18
                    if not 0 / totalAllocPoint:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _1303 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1303] = 26
                        mem[_1303 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _1317 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1317 + idx + 68] = mem[_1303 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1317 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1317 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sushiAddress)
                    call sushiAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args address(this.address), 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0 / totalAllocPoint
                    emit Mint((0 / totalAllocPoint), this.address);
                    if not 0 / totalAllocPoint:
                        _1377 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1377] = 26
                        mem[_1377 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _1399 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1399 + idx + 68] = mem[_1377 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1399 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1399 + -mem[64] + 100
                    if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                        revert with 'NH{q', 17
                    if not 0 / totalAllocPoint:
                        revert with 'NH{q', 18
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _1522 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1522] = 26
                    mem[_1522 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _1542 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_1542 + idx + 68] = mem[_1522 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1542 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _1542 + -mem[64] + 100
                if block.number - poolInfo[idx].field_1280 and -sub_e600038d + 100 > -1 / block.number - poolInfo[idx].field_1280:
                    revert with 'NH{q', 17
                if not block.number - poolInfo[idx].field_1280:
                    revert with 'NH{q', 18
                if (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / block.number - poolInfo[idx].field_1280 != -sub_e600038d + 100:
                    revert with 0, 'SafeMath: multiplication overflow'
                _1182 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1182] = 26
                mem[_1182 + 32] = 'SafeMath: division by zero'
                if not (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100:
                    _1242 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1242] = 26
                    mem[_1242 + 32] = 'SafeMath: division by zero'
                    if totalAllocPoint <= 0:
                        _1249 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1249 + idx + 68] = mem[_1242 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1249 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1249 + -mem[64] + 100
                    if not totalAllocPoint:
                        revert with 'NH{q', 18
                    if not 0 / totalAllocPoint:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _1407 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1407] = 26
                        mem[_1407 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _1421 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1421 + idx + 68] = mem[_1407 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1421 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1421 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sushiAddress)
                    call sushiAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args address(this.address), 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0 / totalAllocPoint
                    emit Mint((0 / totalAllocPoint), this.address);
                    if not 0 / totalAllocPoint:
                        _1521 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1521] = 26
                        mem[_1521 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _1541 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1541 + idx + 68] = mem[_1521 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1541 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1541 + -mem[64] + 100
                    if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                        revert with 'NH{q', 17
                    if not 0 / totalAllocPoint:
                        revert with 'NH{q', 18
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _1692 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1692] = 26
                    mem[_1692 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _1711 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_1711 + idx + 68] = mem[_1692 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1711 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _1711 + -mem[64] + 100
                if (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 and sushiPerBlock > -1 / (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100:
                    revert with 'NH{q', 17
                if not (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100:
                    revert with 'NH{q', 18
                if (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock / (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 != sushiPerBlock:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock:
                    _1316 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1316] = 26
                    mem[_1316 + 32] = 'SafeMath: division by zero'
                    if totalAllocPoint <= 0:
                        _1324 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1324 + idx + 68] = mem[_1316 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1324 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1324 + -mem[64] + 100
                    if not totalAllocPoint:
                        revert with 'NH{q', 18
                    if not 0 / totalAllocPoint:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _1552 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1552] = 26
                        mem[_1552 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _1577 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1577 + idx + 68] = mem[_1552 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1577 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1577 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sushiAddress)
                    call sushiAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args address(this.address), 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0 / totalAllocPoint
                    emit Mint((0 / totalAllocPoint), this.address);
                    if not 0 / totalAllocPoint:
                        _1691 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1691] = 26
                        mem[_1691 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _1710 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1710 + idx + 68] = mem[_1691 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1710 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1710 + -mem[64] + 100
                    if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                        revert with 'NH{q', 17
                    if not 0 / totalAllocPoint:
                        revert with 'NH{q', 18
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _1883 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1883] = 26
                    mem[_1883 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _1904 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_1904 + idx + 68] = mem[_1883 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1904 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _1904 + -mem[64] + 100
                if (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock and poolInfo[idx].field_256 > -1 / (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock:
                    revert with 'NH{q', 17
                if not (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock:
                    revert with 'NH{q', 18
                if (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock != poolInfo[idx].field_256:
                    revert with 0, 'SafeMath: multiplication overflow'
                _1420 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1420] = 26
                mem[_1420 + 32] = 'SafeMath: division by zero'
                if totalAllocPoint <= 0:
                    _1437 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_1437 + idx + 68] = mem[_1420 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1437 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _1437 + -mem[64] + 100
                if not totalAllocPoint:
                    revert with 'NH{q', 18
                if not (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                    mem[mem[64]] = 0
                    emit Mint(0, this.address);
                    _1723 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1723] = 26
                    mem[_1723 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _1760 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_1760 + idx + 68] = mem[_1723 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1760 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _1760 + -mem[64] + 100
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                require ext_code.size(sushiAddress)
                call sushiAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args address(this.address), (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                emit Mint(((100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint), this.address);
                if not (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                    _1882 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1882] = 26
                    mem[_1882 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _1903 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_1903 + idx + 68] = mem[_1882 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1903 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _1903 + -mem[64] + 100
                if (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint and 10^12 > -1 / (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                    revert with 'NH{q', 17
                if not (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                    revert with 'NH{q', 18
                if 10^12 * (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                _2084 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2084] = 26
                mem[_2084 + 32] = 'SafeMath: division by zero'
                if poolInfo[idx].field_512 > 0:
                    if not poolInfo[idx].field_512:
                        revert with 'NH{q', 18
                    if poolInfo[idx].field_1536 > -(10^12 * (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                        revert with 'NH{q', 17
                    if poolInfo[idx].field_1536 + (10^12 * (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_1536 += 10^12 * (100 * block.number) - (sub_e600038d * block.number) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512
                    poolInfo[idx].field_1280 = block.number
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                _2108 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_2108 + idx + 68] = mem[_2084 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_2108 + 94] = 0
                revert with memory
                  from mem[64]
                   len _2108 + -mem[64] + 100
            if poolInfo[idx].field_1280 >= bonusEndBlock:
                if not poolInfo[idx].field_768:
                    _1110 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1110] = 30
                    mem[_1110 + 32] = 'SafeMath: subtraction overflow'
                    if poolInfo[idx].field_1280 > block.number:
                        _1115 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_1115 + idx + 68] = mem[_1110 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1115 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _1115 + -mem[64] + 100
                    if block.number < poolInfo[idx].field_1280:
                        revert with 'NH{q', 17
                    if not block.number - poolInfo[idx].field_1280:
                        _1141 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1141] = 26
                        mem[_1141 + 32] = 'SafeMath: division by zero'
                        _1184 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1184] = 26
                        mem[_1184 + 32] = 'SafeMath: division by zero'
                        if totalAllocPoint <= 0:
                            _1188 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_1188 + idx + 68] = mem[_1184 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_1188 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _1188 + -mem[64] + 100
                        if not totalAllocPoint:
                            revert with 'NH{q', 18
                        if not 0 / totalAllocPoint:
                            mem[mem[64]] = 0
                            emit Mint(0, this.address);
                            _1271 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1271] = 26
                            mem[_1271 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _1280 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_1280 + idx + 68] = mem[_1271 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_1280 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _1280 + -mem[64] + 100
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sushiAddress)
                        call sushiAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args address(this.address), 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0 / totalAllocPoint
                        emit Mint((0 / totalAllocPoint), this.address);
                        if not 0 / totalAllocPoint:
                            _1337 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1337] = 26
                            mem[_1337 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _1351 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_1351 + idx + 68] = mem[_1337 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_1351 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _1351 + -mem[64] + 100
                        if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                            revert with 'NH{q', 17
                        if not 0 / totalAllocPoint:
                            revert with 'NH{q', 18
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _1459 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1459] = 26
                        mem[_1459 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _1477 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1477 + idx + 68] = mem[_1459 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1477 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1477 + -mem[64] + 100
                    if block.number - poolInfo[idx].field_1280 and sub_a054b70a > -1 / block.number - poolInfo[idx].field_1280:
                        revert with 'NH{q', 17
                    if not block.number - poolInfo[idx].field_1280:
                        revert with 'NH{q', 18
                    if (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / block.number - poolInfo[idx].field_1280 != sub_a054b70a:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _1173 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1173] = 26
                    mem[_1173 + 32] = 'SafeMath: division by zero'
                    if not (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100:
                        _1217 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1217] = 26
                        mem[_1217 + 32] = 'SafeMath: division by zero'
                        if totalAllocPoint <= 0:
                            _1221 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_1221 + idx + 68] = mem[_1217 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_1221 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _1221 + -mem[64] + 100
                        if not totalAllocPoint:
                            revert with 'NH{q', 18
                        if not 0 / totalAllocPoint:
                            mem[mem[64]] = 0
                            emit Mint(0, this.address);
                            _1360 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1360] = 26
                            mem[_1360 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _1367 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_1367 + idx + 68] = mem[_1360 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_1367 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _1367 + -mem[64] + 100
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sushiAddress)
                        call sushiAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args address(this.address), 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0 / totalAllocPoint
                        emit Mint((0 / totalAllocPoint), this.address);
                        if not 0 / totalAllocPoint:
                            _1458 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1458] = 26
                            mem[_1458 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _1476 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_1476 + idx + 68] = mem[_1458 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_1476 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _1476 + -mem[64] + 100
                        if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                            revert with 'NH{q', 17
                        if not 0 / totalAllocPoint:
                            revert with 'NH{q', 18
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _1623 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1623] = 26
                        mem[_1623 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _1641 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1641 + idx + 68] = mem[_1623 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1641 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1641 + -mem[64] + 100
                    if (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 and sushiPerBlock > -1 / (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100:
                        revert with 'NH{q', 17
                    if not (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100:
                        revert with 'NH{q', 18
                    if (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock / (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 != sushiPerBlock:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock:
                        _1279 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1279] = 26
                        mem[_1279 + 32] = 'SafeMath: division by zero'
                        if totalAllocPoint <= 0:
                            _1286 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_1286 + idx + 68] = mem[_1279 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_1286 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _1286 + -mem[64] + 100
                        if not totalAllocPoint:
                            revert with 'NH{q', 18
                        if not 0 / totalAllocPoint:
                            mem[mem[64]] = 0
                            emit Mint(0, this.address);
                            _1491 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1491] = 26
                            mem[_1491 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _1504 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_1504 + idx + 68] = mem[_1491 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_1504 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _1504 + -mem[64] + 100
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sushiAddress)
                        call sushiAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args address(this.address), 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0 / totalAllocPoint
                        emit Mint((0 / totalAllocPoint), this.address);
                        if not 0 / totalAllocPoint:
                            _1622 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1622] = 26
                            mem[_1622 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _1640 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_1640 + idx + 68] = mem[_1622 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_1640 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _1640 + -mem[64] + 100
                        if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                            revert with 'NH{q', 17
                        if not 0 / totalAllocPoint:
                            revert with 'NH{q', 18
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _1813 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1813] = 26
                        mem[_1813 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _1835 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1835 + idx + 68] = mem[_1813 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1835 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1835 + -mem[64] + 100
                    if (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock and poolInfo[idx].field_256 > -1 / (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock:
                        revert with 'NH{q', 17
                    if not (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock:
                        revert with 'NH{q', 18
                    if (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock != poolInfo[idx].field_256:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _1366 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1366] = 26
                    mem[_1366 + 32] = 'SafeMath: division by zero'
                    if totalAllocPoint <= 0:
                        _1381 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1381 + idx + 68] = mem[_1366 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1381 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1381 + -mem[64] + 100
                    if not totalAllocPoint:
                        revert with 'NH{q', 18
                    if not (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _1656 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1656] = 26
                        mem[_1656 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _1676 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1676 + idx + 68] = mem[_1656 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1676 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1676 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                    require ext_code.size(sushiAddress)
                    call sushiAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args address(this.address), (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                    emit Mint(((block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint), this.address);
                    if not (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                        _1812 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1812] = 26
                        mem[_1812 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _1834 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1834 + idx + 68] = mem[_1812 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1834 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1834 + -mem[64] + 100
                    if (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint and 10^12 > -1 / (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                        revert with 'NH{q', 17
                    if not (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                        revert with 'NH{q', 18
                    if 10^12 * (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _2019 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2019] = 26
                    mem[_2019 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * (block.number * sub_a054b70a) - (poolInfo[idx].field_1280 * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _2039 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2039 + idx + 68] = mem[_2019 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2039 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _2039 + -mem[64] + 100
                if 100 < sub_a054b70a:
                    revert with 'NH{q', 17
                _1123 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1123] = 30
                mem[_1123 + 32] = 'SafeMath: subtraction overflow'
                if poolInfo[idx].field_1280 > block.number:
                    _1126 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_1126 + idx + 68] = mem[_1123 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1126 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _1126 + -mem[64] + 100
                if block.number < poolInfo[idx].field_1280:
                    revert with 'NH{q', 17
                if not block.number - poolInfo[idx].field_1280:
                    _1159 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1159] = 26
                    mem[_1159 + 32] = 'SafeMath: division by zero'
                    _1201 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1201] = 26
                    mem[_1201 + 32] = 'SafeMath: division by zero'
                    if totalAllocPoint <= 0:
                        _1205 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1205 + idx + 68] = mem[_1201 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1205 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1205 + -mem[64] + 100
                    if not totalAllocPoint:
                        revert with 'NH{q', 18
                    if not 0 / totalAllocPoint:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _1309 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1309] = 26
                        mem[_1309 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _1320 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1320 + idx + 68] = mem[_1309 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1320 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1320 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sushiAddress)
                    call sushiAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args address(this.address), 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0 / totalAllocPoint
                    emit Mint((0 / totalAllocPoint), this.address);
                    if not 0 / totalAllocPoint:
                        _1384 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1384] = 26
                        mem[_1384 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _1403 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1403 + idx + 68] = mem[_1384 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1403 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1403 + -mem[64] + 100
                    if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                        revert with 'NH{q', 17
                    if not 0 / totalAllocPoint:
                        revert with 'NH{q', 18
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _1527 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1527] = 26
                    mem[_1527 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _1548 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_1548 + idx + 68] = mem[_1527 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1548 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _1548 + -mem[64] + 100
                if block.number - poolInfo[idx].field_1280 and -sub_a054b70a + 100 > -1 / block.number - poolInfo[idx].field_1280:
                    revert with 'NH{q', 17
                if not block.number - poolInfo[idx].field_1280:
                    revert with 'NH{q', 18
                if (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / block.number - poolInfo[idx].field_1280 != -sub_a054b70a + 100:
                    revert with 0, 'SafeMath: multiplication overflow'
                _1185 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1185] = 26
                mem[_1185 + 32] = 'SafeMath: division by zero'
                if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100:
                    _1245 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1245] = 26
                    mem[_1245 + 32] = 'SafeMath: division by zero'
                    if totalAllocPoint <= 0:
                        _1253 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1253 + idx + 68] = mem[_1245 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1253 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1253 + -mem[64] + 100
                    if not totalAllocPoint:
                        revert with 'NH{q', 18
                    if not 0 / totalAllocPoint:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _1412 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1412] = 26
                        mem[_1412 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _1427 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1427 + idx + 68] = mem[_1412 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1427 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1427 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sushiAddress)
                    call sushiAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args address(this.address), 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0 / totalAllocPoint
                    emit Mint((0 / totalAllocPoint), this.address);
                    if not 0 / totalAllocPoint:
                        _1526 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1526] = 26
                        mem[_1526 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _1547 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1547 + idx + 68] = mem[_1526 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1547 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1547 + -mem[64] + 100
                    if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                        revert with 'NH{q', 17
                    if not 0 / totalAllocPoint:
                        revert with 'NH{q', 18
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _1697 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1697] = 26
                    mem[_1697 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _1720 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_1720 + idx + 68] = mem[_1697 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1720 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _1720 + -mem[64] + 100
                if (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 and sushiPerBlock > -1 / (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100:
                    revert with 'NH{q', 17
                if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100:
                    revert with 'NH{q', 18
                if (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock / (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 != sushiPerBlock:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock:
                    _1319 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1319] = 26
                    mem[_1319 + 32] = 'SafeMath: division by zero'
                    if totalAllocPoint <= 0:
                        _1328 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1328 + idx + 68] = mem[_1319 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1328 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1328 + -mem[64] + 100
                    if not totalAllocPoint:
                        revert with 'NH{q', 18
                    if not 0 / totalAllocPoint:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _1560 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1560] = 26
                        mem[_1560 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _1587 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1587 + idx + 68] = mem[_1560 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1587 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1587 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sushiAddress)
                    call sushiAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args address(this.address), 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0 / totalAllocPoint
                    emit Mint((0 / totalAllocPoint), this.address);
                    if not 0 / totalAllocPoint:
                        _1696 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1696] = 26
                        mem[_1696 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _1719 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1719 + idx + 68] = mem[_1696 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1719 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1719 + -mem[64] + 100
                    if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                        revert with 'NH{q', 17
                    if not 0 / totalAllocPoint:
                        revert with 'NH{q', 18
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _1891 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1891] = 26
                    mem[_1891 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _1916 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_1916 + idx + 68] = mem[_1891 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1916 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _1916 + -mem[64] + 100
                if (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock and poolInfo[idx].field_256 > -1 / (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock:
                    revert with 'NH{q', 17
                if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock:
                    revert with 'NH{q', 18
                if (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock != poolInfo[idx].field_256:
                    revert with 0, 'SafeMath: multiplication overflow'
                _1426 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1426] = 26
                mem[_1426 + 32] = 'SafeMath: division by zero'
                if totalAllocPoint <= 0:
                    _1442 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_1442 + idx + 68] = mem[_1426 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1442 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _1442 + -mem[64] + 100
                if not totalAllocPoint:
                    revert with 'NH{q', 18
                if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                    mem[mem[64]] = 0
                    emit Mint(0, this.address);
                    _1737 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1737] = 26
                    mem[_1737 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _1772 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_1772 + idx + 68] = mem[_1737 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1772 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _1772 + -mem[64] + 100
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                require ext_code.size(sushiAddress)
                call sushiAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args address(this.address), (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                emit Mint(((100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint), this.address);
                if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                    _1890 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1890] = 26
                    mem[_1890 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _1915 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_1915 + idx + 68] = mem[_1890 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1915 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _1915 + -mem[64] + 100
                if (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint and 10^12 > -1 / (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                    revert with 'NH{q', 17
                if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                    revert with 'NH{q', 18
                if 10^12 * (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                _2096 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2096] = 26
                mem[_2096 + 32] = 'SafeMath: division by zero'
                if poolInfo[idx].field_512 > 0:
                    if not poolInfo[idx].field_512:
                        revert with 'NH{q', 18
                    if poolInfo[idx].field_1536 > -(10^12 * (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                        revert with 'NH{q', 17
                    if poolInfo[idx].field_1536 + (10^12 * (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_1536 += 10^12 * (100 * block.number) - (sub_a054b70a * block.number) - (100 * poolInfo[idx].field_1280) + (sub_a054b70a * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512
                    poolInfo[idx].field_1280 = block.number
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                _2120 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_2120 + idx + 68] = mem[_2096 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_2120 + 94] = 0
                revert with memory
                  from mem[64]
                   len _2120 + -mem[64] + 100
            if not poolInfo[idx].field_768:
                _1109 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1109] = 30
                mem[_1109 + 32] = 'SafeMath: subtraction overflow'
                if bonusEndBlock > block.number:
                    _1114 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_1114 + idx + 68] = mem[_1109 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1114 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _1114 + -mem[64] + 100
                if block.number < bonusEndBlock:
                    revert with 'NH{q', 17
                if not block.number - bonusEndBlock:
                    _1140 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1140] = 26
                    mem[_1140 + 32] = 'SafeMath: division by zero'
                    _1168 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1168] = 30
                    mem[_1168 + 32] = 'SafeMath: subtraction overflow'
                    if poolInfo[idx].field_1280 > bonusEndBlock:
                        _1170 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_1170 + idx + 68] = mem[_1168 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1170 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _1170 + -mem[64] + 100
                    if bonusEndBlock < poolInfo[idx].field_1280:
                        revert with 'NH{q', 17
                    if not bonusEndBlock - poolInfo[idx].field_1280:
                        _1196 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1196] = 26
                        mem[_1196 + 32] = 'SafeMath: division by zero'
                        _1321 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1321] = 26
                        mem[_1321 + 32] = 'SafeMath: division by zero'
                        if totalAllocPoint <= 0:
                            _1335 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_1335 + idx + 68] = mem[_1321 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_1335 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _1335 + -mem[64] + 100
                        if not totalAllocPoint:
                            revert with 'NH{q', 18
                        if not 0 / totalAllocPoint:
                            mem[mem[64]] = 0
                            emit Mint(0, this.address);
                            _1571 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1571] = 26
                            mem[_1571 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _1596 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_1596 + idx + 68] = mem[_1571 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_1596 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _1596 + -mem[64] + 100
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sushiAddress)
                        call sushiAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args address(this.address), 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0 / totalAllocPoint
                        emit Mint((0 / totalAllocPoint), this.address);
                        if not 0 / totalAllocPoint:
                            _1703 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1703] = 26
                            mem[_1703 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _1731 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_1731 + idx + 68] = mem[_1703 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_1731 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _1731 + -mem[64] + 100
                        if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                            revert with 'NH{q', 17
                        if not 0 / totalAllocPoint:
                            revert with 'NH{q', 18
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _1898 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1898] = 26
                        mem[_1898 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _1928 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1928 + idx + 68] = mem[_1898 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1928 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1928 + -mem[64] + 100
                    if bonusEndBlock - poolInfo[idx].field_1280 and sub_e600038d > -1 / bonusEndBlock - poolInfo[idx].field_1280:
                        revert with 'NH{q', 17
                    if not bonusEndBlock - poolInfo[idx].field_1280:
                        revert with 'NH{q', 18
                    if (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / bonusEndBlock - poolInfo[idx].field_1280 != sub_e600038d:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _1238 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1238] = 26
                    mem[_1238 + 32] = 'SafeMath: division by zero'
                    if (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 > -1:
                        revert with 'NH{q', 17
                    if (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 < (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100:
                        revert with 0, 'SafeMath: addition overflow'
                    if not (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100:
                        _1432 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1432] = 26
                        mem[_1432 + 32] = 'SafeMath: division by zero'
                        if totalAllocPoint <= 0:
                            _1453 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_1453 + idx + 68] = mem[_1432 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_1453 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _1453 + -mem[64] + 100
                        if not totalAllocPoint:
                            revert with 'NH{q', 18
                        if not 0 / totalAllocPoint:
                            mem[mem[64]] = 0
                            emit Mint(0, this.address);
                            _1752 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1752] = 26
                            mem[_1752 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _1783 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_1783 + idx + 68] = mem[_1752 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_1783 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _1783 + -mem[64] + 100
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sushiAddress)
                        call sushiAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args address(this.address), 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0 / totalAllocPoint
                        emit Mint((0 / totalAllocPoint), this.address);
                        if not 0 / totalAllocPoint:
                            _1897 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1897] = 26
                            mem[_1897 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _1927 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_1927 + idx + 68] = mem[_1897 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_1927 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _1927 + -mem[64] + 100
                        if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                            revert with 'NH{q', 17
                        if not 0 / totalAllocPoint:
                            revert with 'NH{q', 18
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _2104 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2104] = 26
                        mem[_2104 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _2134 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2134 + idx + 68] = mem[_2104 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2134 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2134 + -mem[64] + 100
                    if (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 and sushiPerBlock > -1 / (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100:
                        revert with 'NH{q', 17
                    if not (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100:
                        revert with 'NH{q', 18
                    if (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock / (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 != sushiPerBlock:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock:
                        _1595 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1595] = 26
                        mem[_1595 + 32] = 'SafeMath: division by zero'
                        if totalAllocPoint <= 0:
                            _1617 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_1617 + idx + 68] = mem[_1595 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_1617 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _1617 + -mem[64] + 100
                        if not totalAllocPoint:
                            revert with 'NH{q', 18
                        if not 0 / totalAllocPoint:
                            mem[mem[64]] = 0
                            emit Mint(0, this.address);
                            _1953 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1953] = 26
                            mem[_1953 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _1986 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_1986 + idx + 68] = mem[_1953 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_1986 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _1986 + -mem[64] + 100
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sushiAddress)
                        call sushiAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args address(this.address), 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0 / totalAllocPoint
                        emit Mint((0 / totalAllocPoint), this.address);
                        if not 0 / totalAllocPoint:
                            _2103 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2103] = 26
                            mem[_2103 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _2133 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2133 + idx + 68] = mem[_2103 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2133 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2133 + -mem[64] + 100
                        if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                            revert with 'NH{q', 17
                        if not 0 / totalAllocPoint:
                            revert with 'NH{q', 18
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _2288 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2288] = 26
                        mem[_2288 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _2313 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2313 + idx + 68] = mem[_2288 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2313 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2313 + -mem[64] + 100
                    if (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock and poolInfo[idx].field_256 > -1 / (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock:
                        revert with 'NH{q', 17
                    if not (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock:
                        revert with 'NH{q', 18
                    if (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock != poolInfo[idx].field_256:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _1782 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1782] = 26
                    mem[_1782 + 32] = 'SafeMath: division by zero'
                    if totalAllocPoint <= 0:
                        _1806 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1806 + idx + 68] = mem[_1782 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1806 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1806 + -mem[64] + 100
                    if not totalAllocPoint:
                        revert with 'NH{q', 18
                    if not (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _2160 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2160] = 26
                        mem[_2160 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _2191 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2191 + idx + 68] = mem[_2160 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2191 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2191 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                    require ext_code.size(sushiAddress)
                    call sushiAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args address(this.address), (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                    emit Mint(((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint), this.address);
                    if not (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                        _2287 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2287] = 26
                        mem[_2287 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _2312 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2312 + idx + 68] = mem[_2287 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2312 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2312 + -mem[64] + 100
                    if (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint and 10^12 > -1 / (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                        revert with 'NH{q', 17
                    if not (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                        revert with 'NH{q', 18
                    if 10^12 * (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _2439 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2439] = 26
                    mem[_2439 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _2459 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2459 + idx + 68] = mem[_2439 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2459 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _2459 + -mem[64] + 100
                if block.number - bonusEndBlock and sub_a054b70a > -1 / block.number - bonusEndBlock:
                    revert with 'NH{q', 17
                if not block.number - bonusEndBlock:
                    revert with 'NH{q', 18
                if (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / block.number - bonusEndBlock != sub_a054b70a:
                    revert with 0, 'SafeMath: multiplication overflow'
                _1172 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1172] = 26
                mem[_1172 + 32] = 'SafeMath: division by zero'
                _1194 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1194] = 30
                mem[_1194 + 32] = 'SafeMath: subtraction overflow'
                if poolInfo[idx].field_1280 > bonusEndBlock:
                    _1199 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_1199 + idx + 68] = mem[_1194 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1199 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _1199 + -mem[64] + 100
                if bonusEndBlock < poolInfo[idx].field_1280:
                    revert with 'NH{q', 17
                if not bonusEndBlock - poolInfo[idx].field_1280:
                    _1237 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1237] = 26
                    mem[_1237 + 32] = 'SafeMath: division by zero'
                    if 0 > -((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100) - 1:
                        revert with 'NH{q', 17
                    if (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    if not (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100:
                        _1431 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1431] = 26
                        mem[_1431 + 32] = 'SafeMath: division by zero'
                        if totalAllocPoint <= 0:
                            _1452 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_1452 + idx + 68] = mem[_1431 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_1452 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _1452 + -mem[64] + 100
                        if not totalAllocPoint:
                            revert with 'NH{q', 18
                        if not 0 / totalAllocPoint:
                            mem[mem[64]] = 0
                            emit Mint(0, this.address);
                            _1749 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1749] = 26
                            mem[_1749 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _1781 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_1781 + idx + 68] = mem[_1749 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_1781 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _1781 + -mem[64] + 100
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sushiAddress)
                        call sushiAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args address(this.address), 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0 / totalAllocPoint
                        emit Mint((0 / totalAllocPoint), this.address);
                        if not 0 / totalAllocPoint:
                            _1895 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1895] = 26
                            mem[_1895 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _1925 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_1925 + idx + 68] = mem[_1895 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_1925 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _1925 + -mem[64] + 100
                        if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                            revert with 'NH{q', 17
                        if not 0 / totalAllocPoint:
                            revert with 'NH{q', 18
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _2101 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2101] = 26
                        mem[_2101 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _2130 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2130 + idx + 68] = mem[_2101 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2130 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2130 + -mem[64] + 100
                    if (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 and sushiPerBlock > -1 / (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100:
                        revert with 'NH{q', 17
                    if not (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100:
                        revert with 'NH{q', 18
                    if (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock / (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 != sushiPerBlock:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock:
                        _1594 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1594] = 26
                        mem[_1594 + 32] = 'SafeMath: division by zero'
                        if totalAllocPoint <= 0:
                            _1615 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_1615 + idx + 68] = mem[_1594 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_1615 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _1615 + -mem[64] + 100
                        if not totalAllocPoint:
                            revert with 'NH{q', 18
                        if not 0 / totalAllocPoint:
                            mem[mem[64]] = 0
                            emit Mint(0, this.address);
                            _1950 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1950] = 26
                            mem[_1950 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _1983 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_1983 + idx + 68] = mem[_1950 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_1983 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _1983 + -mem[64] + 100
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sushiAddress)
                        call sushiAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args address(this.address), 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0 / totalAllocPoint
                        emit Mint((0 / totalAllocPoint), this.address);
                        if not 0 / totalAllocPoint:
                            _2100 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2100] = 26
                            mem[_2100 + 32] = 'SafeMath: division by zero'
                            if poolInfo[idx].field_512 > 0:
                                if not poolInfo[idx].field_512:
                                    revert with 'NH{q', 18
                                if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                    revert with 'NH{q', 17
                                if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                                poolInfo[idx].field_1280 = block.number
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                continue 
                            _2129 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2129 + idx + 68] = mem[_2100 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2129 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _2129 + -mem[64] + 100
                        if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                            revert with 'NH{q', 17
                        if not 0 / totalAllocPoint:
                            revert with 'NH{q', 18
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _2286 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2286] = 26
                        mem[_2286 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _2309 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2309 + idx + 68] = mem[_2286 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2309 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2309 + -mem[64] + 100
                    if (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock and poolInfo[idx].field_256 > -1 / (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock:
                        revert with 'NH{q', 17
                    if not (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock:
                        revert with 'NH{q', 18
                    if (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock != poolInfo[idx].field_256:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _1780 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1780] = 26
                    mem[_1780 + 32] = 'SafeMath: division by zero'
                    if totalAllocPoint <= 0:
                        _1804 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1804 + idx + 68] = mem[_1780 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1804 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1804 + -mem[64] + 100
                    if not totalAllocPoint:
                        revert with 'NH{q', 18
                    if not (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _2157 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2157] = 26
                        mem[_2157 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _2186 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2186 + idx + 68] = mem[_2157 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2186 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2186 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                    require ext_code.size(sushiAddress)
                    call sushiAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args address(this.address), (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                    emit Mint(((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint), this.address);
                    if not (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                        _2285 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2285] = 26
                        mem[_2285 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _2308 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2308 + idx + 68] = mem[_2285 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2308 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2308 + -mem[64] + 100
                    if (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint and 10^12 > -1 / (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                        revert with 'NH{q', 17
                    if not (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                        revert with 'NH{q', 18
                    if 10^12 * (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _2438 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2438] = 26
                    mem[_2438 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * (block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _2456 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2456 + idx + 68] = mem[_2438 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2456 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _2456 + -mem[64] + 100
                if bonusEndBlock - poolInfo[idx].field_1280 and sub_e600038d > -1 / bonusEndBlock - poolInfo[idx].field_1280:
                    revert with 'NH{q', 17
                if not bonusEndBlock - poolInfo[idx].field_1280:
                    revert with 'NH{q', 18
                if (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / bonusEndBlock - poolInfo[idx].field_1280 != sub_e600038d:
                    revert with 0, 'SafeMath: multiplication overflow'
                _1312 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1312] = 26
                mem[_1312 + 32] = 'SafeMath: division by zero'
                if (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 > -((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100) - 1:
                    revert with 'NH{q', 17
                if ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100) < (bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100:
                    revert with 0, 'SafeMath: addition overflow'
                if not ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100):
                    _1593 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1593] = 26
                    mem[_1593 + 32] = 'SafeMath: division by zero'
                    if totalAllocPoint <= 0:
                        _1614 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1614 + idx + 68] = mem[_1593 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1614 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1614 + -mem[64] + 100
                    if not totalAllocPoint:
                        revert with 'NH{q', 18
                    if not 0 / totalAllocPoint:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _1947 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1947] = 26
                        mem[_1947 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _1982 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1982 + idx + 68] = mem[_1947 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1982 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1982 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sushiAddress)
                    call sushiAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args address(this.address), 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0 / totalAllocPoint
                    emit Mint((0 / totalAllocPoint), this.address);
                    if not 0 / totalAllocPoint:
                        _2098 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2098] = 26
                        mem[_2098 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _2127 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2127 + idx + 68] = mem[_2098 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2127 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2127 + -mem[64] + 100
                    if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                        revert with 'NH{q', 17
                    if not 0 / totalAllocPoint:
                        revert with 'NH{q', 18
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _2284 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2284] = 26
                    mem[_2284 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _2306 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2306 + idx + 68] = mem[_2284 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2306 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _2306 + -mem[64] + 100
                if ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100) and sushiPerBlock > -1 / ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100):
                    revert with 'NH{q', 17
                if not ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100):
                    revert with 'NH{q', 18
                if ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock) / ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100) != sushiPerBlock:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock):
                    _1779 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1779] = 26
                    mem[_1779 + 32] = 'SafeMath: division by zero'
                    if totalAllocPoint <= 0:
                        _1802 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1802 + idx + 68] = mem[_1779 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1802 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1802 + -mem[64] + 100
                    if not totalAllocPoint:
                        revert with 'NH{q', 18
                    if not 0 / totalAllocPoint:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _2156 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2156] = 26
                        mem[_2156 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _2183 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2183 + idx + 68] = mem[_2156 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2183 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2183 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sushiAddress)
                    call sushiAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args address(this.address), 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0 / totalAllocPoint
                    emit Mint((0 / totalAllocPoint), this.address);
                    if not 0 / totalAllocPoint:
                        _2283 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2283] = 26
                        mem[_2283 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _2305 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2305 + idx + 68] = mem[_2283 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2305 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2305 + -mem[64] + 100
                    if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                        revert with 'NH{q', 17
                    if not 0 / totalAllocPoint:
                        revert with 'NH{q', 18
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _2437 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2437] = 26
                    mem[_2437 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _2453 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2453 + idx + 68] = mem[_2437 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2453 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _2453 + -mem[64] + 100
                if ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock) and poolInfo[idx].field_256 > -1 / ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock):
                    revert with 'NH{q', 17
                if not ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock):
                    revert with 'NH{q', 18
                if ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock) != poolInfo[idx].field_256:
                    revert with 0, 'SafeMath: multiplication overflow'
                _1981 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1981] = 26
                mem[_1981 + 32] = 'SafeMath: division by zero'
                if totalAllocPoint <= 0:
                    _2005 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2005 + idx + 68] = mem[_1981 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2005 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _2005 + -mem[64] + 100
                if not totalAllocPoint:
                    revert with 'NH{q', 18
                if not ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                    mem[mem[64]] = 0
                    emit Mint(0, this.address);
                    _2328 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2328] = 26
                    mem[_2328 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _2354 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2354 + idx + 68] = mem[_2328 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2354 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _2354 + -mem[64] + 100
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                require ext_code.size(sushiAddress)
                call sushiAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args address(this.address), ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint
                emit Mint((((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint), this.address);
                if not ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                    _2436 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2436] = 26
                    mem[_2436 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _2452 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2452 + idx + 68] = mem[_2436 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2452 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _2452 + -mem[64] + 100
                if ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint and 10^12 > -1 / ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                    revert with 'NH{q', 17
                if not ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                    revert with 'NH{q', 18
                if 10^12 * ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint / ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                _2552 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2552] = 26
                mem[_2552 + 32] = 'SafeMath: division by zero'
                if poolInfo[idx].field_512 > 0:
                    if not poolInfo[idx].field_512:
                        revert with 'NH{q', 18
                    if poolInfo[idx].field_1536 > -(10^12 * ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_512) - 1:
                        revert with 'NH{q', 17
                    if poolInfo[idx].field_1536 + (10^12 * ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_1536 += 10^12 * ((bonusEndBlock * sub_e600038d) - (poolInfo[idx].field_1280 * sub_e600038d) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((block.number * sub_a054b70a) - (bonusEndBlock * sub_a054b70a) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_512
                    poolInfo[idx].field_1280 = block.number
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                _2705 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_2705 + idx + 68] = mem[_2552 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_2705 + 94] = 0
                revert with memory
                  from mem[64]
                   len _2705 + -mem[64] + 100
            if 100 < sub_a054b70a:
                revert with 'NH{q', 17
            _1122 = mem[64]
            mem[64] = mem[64] + 64
            mem[_1122] = 30
            mem[_1122 + 32] = 'SafeMath: subtraction overflow'
            if bonusEndBlock > block.number:
                _1125 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_1125 + idx + 68] = mem[_1122 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_1125 + 98] = 0
                revert with memory
                  from mem[64]
                   len _1125 + -mem[64] + 100
            if block.number < bonusEndBlock:
                revert with 'NH{q', 17
            if not block.number - bonusEndBlock:
                _1158 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1158] = 26
                mem[_1158 + 32] = 'SafeMath: division by zero'
                if 100 < sub_e600038d:
                    revert with 'NH{q', 17
                _1192 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1192] = 30
                mem[_1192 + 32] = 'SafeMath: subtraction overflow'
                if poolInfo[idx].field_1280 > bonusEndBlock:
                    _1197 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_1197 + idx + 68] = mem[_1192 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1197 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _1197 + -mem[64] + 100
                if bonusEndBlock < poolInfo[idx].field_1280:
                    revert with 'NH{q', 17
                if not bonusEndBlock - poolInfo[idx].field_1280:
                    _1232 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1232] = 26
                    mem[_1232 + 32] = 'SafeMath: division by zero'
                    _1424 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1424] = 26
                    mem[_1424 + 32] = 'SafeMath: division by zero'
                    if totalAllocPoint <= 0:
                        _1439 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1439 + idx + 68] = mem[_1424 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1439 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1439 + -mem[64] + 100
                    if not totalAllocPoint:
                        revert with 'NH{q', 18
                    if not 0 / totalAllocPoint:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _1736 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1736] = 26
                        mem[_1736 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _1770 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1770 + idx + 68] = mem[_1736 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1770 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1770 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sushiAddress)
                    call sushiAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args address(this.address), 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0 / totalAllocPoint
                    emit Mint((0 / totalAllocPoint), this.address);
                    if not 0 / totalAllocPoint:
                        _1889 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1889] = 26
                        mem[_1889 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _1914 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1914 + idx + 68] = mem[_1889 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1914 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1914 + -mem[64] + 100
                    if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                        revert with 'NH{q', 17
                    if not 0 / totalAllocPoint:
                        revert with 'NH{q', 18
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _2095 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2095] = 26
                    mem[_2095 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _2118 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2118 + idx + 68] = mem[_2095 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2118 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _2118 + -mem[64] + 100
                if bonusEndBlock - poolInfo[idx].field_1280 and -sub_e600038d + 100 > -1 / bonusEndBlock - poolInfo[idx].field_1280:
                    revert with 'NH{q', 17
                if not bonusEndBlock - poolInfo[idx].field_1280:
                    revert with 'NH{q', 18
                if (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / bonusEndBlock - poolInfo[idx].field_1280 != -sub_e600038d + 100:
                    revert with 0, 'SafeMath: multiplication overflow'
                _1305 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1305] = 26
                mem[_1305 + 32] = 'SafeMath: division by zero'
                if (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 > -1:
                    revert with 'NH{q', 17
                if (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 < (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100:
                    revert with 0, 'SafeMath: addition overflow'
                if not (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100:
                    _1585 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1585] = 26
                    mem[_1585 + 32] = 'SafeMath: division by zero'
                    if totalAllocPoint <= 0:
                        _1602 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1602 + idx + 68] = mem[_1585 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1602 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1602 + -mem[64] + 100
                    if not totalAllocPoint:
                        revert with 'NH{q', 18
                    if not 0 / totalAllocPoint:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _1937 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1937] = 26
                        mem[_1937 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _1971 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1971 + idx + 68] = mem[_1937 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1971 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1971 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sushiAddress)
                    call sushiAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args address(this.address), 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0 / totalAllocPoint
                    emit Mint((0 / totalAllocPoint), this.address);
                    if not 0 / totalAllocPoint:
                        _2094 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2094] = 26
                        mem[_2094 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _2117 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2117 + idx + 68] = mem[_2094 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2117 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2117 + -mem[64] + 100
                    if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                        revert with 'NH{q', 17
                    if not 0 / totalAllocPoint:
                        revert with 'NH{q', 18
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _2281 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2281] = 26
                    mem[_2281 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _2299 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2299 + idx + 68] = mem[_2281 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2299 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _2299 + -mem[64] + 100
                if (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 and sushiPerBlock > -1 / (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100:
                    revert with 'NH{q', 17
                if not (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100:
                    revert with 'NH{q', 18
                if (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock / (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 != sushiPerBlock:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock:
                    _1769 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1769] = 26
                    mem[_1769 + 32] = 'SafeMath: division by zero'
                    if totalAllocPoint <= 0:
                        _1793 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1793 + idx + 68] = mem[_1769 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1793 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1793 + -mem[64] + 100
                    if not totalAllocPoint:
                        revert with 'NH{q', 18
                    if not 0 / totalAllocPoint:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _2145 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2145] = 26
                        mem[_2145 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _2175 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2175 + idx + 68] = mem[_2145 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2175 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2175 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sushiAddress)
                    call sushiAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args address(this.address), 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0 / totalAllocPoint
                    emit Mint((0 / totalAllocPoint), this.address);
                    if not 0 / totalAllocPoint:
                        _2280 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2280] = 26
                        mem[_2280 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _2298 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2298 + idx + 68] = mem[_2280 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2298 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2298 + -mem[64] + 100
                    if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                        revert with 'NH{q', 17
                    if not 0 / totalAllocPoint:
                        revert with 'NH{q', 18
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _2435 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2435] = 26
                    mem[_2435 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _2449 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2449 + idx + 68] = mem[_2435 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2449 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _2449 + -mem[64] + 100
                if (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock and poolInfo[idx].field_256 > -1 / (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock:
                    revert with 'NH{q', 17
                if not (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock:
                    revert with 'NH{q', 18
                if (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock != poolInfo[idx].field_256:
                    revert with 0, 'SafeMath: multiplication overflow'
                _1970 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1970] = 26
                mem[_1970 + 32] = 'SafeMath: division by zero'
                if totalAllocPoint <= 0:
                    _2000 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2000 + idx + 68] = mem[_1970 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2000 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _2000 + -mem[64] + 100
                if not totalAllocPoint:
                    revert with 'NH{q', 18
                if not (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                    mem[mem[64]] = 0
                    emit Mint(0, this.address);
                    _2322 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2322] = 26
                    mem[_2322 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _2347 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2347 + idx + 68] = mem[_2322 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2347 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _2347 + -mem[64] + 100
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                require ext_code.size(sushiAddress)
                call sushiAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args address(this.address), (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                emit Mint(((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint), this.address);
                if not (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                    _2434 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2434] = 26
                    mem[_2434 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _2448 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2448 + idx + 68] = mem[_2434 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2448 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _2448 + -mem[64] + 100
                if (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint and 10^12 > -1 / (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                    revert with 'NH{q', 17
                if not (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                    revert with 'NH{q', 18
                if 10^12 * (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                _2549 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2549] = 26
                mem[_2549 + 32] = 'SafeMath: division by zero'
                if poolInfo[idx].field_512 > 0:
                    if not poolInfo[idx].field_512:
                        revert with 'NH{q', 18
                    if poolInfo[idx].field_1536 > -(10^12 * (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                        revert with 'NH{q', 17
                    if poolInfo[idx].field_1536 + (10^12 * (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_1536 += 10^12 * (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512
                    poolInfo[idx].field_1280 = block.number
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                _2704 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_2704 + idx + 68] = mem[_2549 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_2704 + 94] = 0
                revert with memory
                  from mem[64]
                   len _2704 + -mem[64] + 100
            if block.number - bonusEndBlock and -sub_a054b70a + 100 > -1 / block.number - bonusEndBlock:
                revert with 'NH{q', 17
            if not block.number - bonusEndBlock:
                revert with 'NH{q', 18
            if (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / block.number - bonusEndBlock != -sub_a054b70a + 100:
                revert with 0, 'SafeMath: multiplication overflow'
            _1183 = mem[64]
            mem[64] = mem[64] + 64
            mem[_1183] = 26
            mem[_1183 + 32] = 'SafeMath: division by zero'
            if 100 < sub_e600038d:
                revert with 'NH{q', 17
            _1228 = mem[64]
            mem[64] = mem[64] + 64
            mem[_1228] = 30
            mem[_1228 + 32] = 'SafeMath: subtraction overflow'
            if poolInfo[idx].field_1280 > bonusEndBlock:
                _1239 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_1239 + idx + 68] = mem[_1228 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_1239 + 98] = 0
                revert with memory
                  from mem[64]
                   len _1239 + -mem[64] + 100
            if bonusEndBlock < poolInfo[idx].field_1280:
                revert with 'NH{q', 17
            if not bonusEndBlock - poolInfo[idx].field_1280:
                _1304 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1304] = 26
                mem[_1304 + 32] = 'SafeMath: division by zero'
                if 0 > -((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100) - 1:
                    revert with 'NH{q', 17
                if (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 < 0:
                    revert with 0, 'SafeMath: addition overflow'
                if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100:
                    _1584 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1584] = 26
                    mem[_1584 + 32] = 'SafeMath: division by zero'
                    if totalAllocPoint <= 0:
                        _1601 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1601 + idx + 68] = mem[_1584 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1601 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1601 + -mem[64] + 100
                    if not totalAllocPoint:
                        revert with 'NH{q', 18
                    if not 0 / totalAllocPoint:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _1934 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1934] = 26
                        mem[_1934 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _1969 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1969 + idx + 68] = mem[_1934 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1969 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1969 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sushiAddress)
                    call sushiAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args address(this.address), 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0 / totalAllocPoint
                    emit Mint((0 / totalAllocPoint), this.address);
                    if not 0 / totalAllocPoint:
                        _2092 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2092] = 26
                        mem[_2092 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _2115 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2115 + idx + 68] = mem[_2092 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2115 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2115 + -mem[64] + 100
                    if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                        revert with 'NH{q', 17
                    if not 0 / totalAllocPoint:
                        revert with 'NH{q', 18
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _2278 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2278] = 26
                    mem[_2278 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _2295 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2295 + idx + 68] = mem[_2278 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2295 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _2295 + -mem[64] + 100
                if (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 and sushiPerBlock > -1 / (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100:
                    revert with 'NH{q', 17
                if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100:
                    revert with 'NH{q', 18
                if (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock / (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 != sushiPerBlock:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock:
                    _1768 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1768] = 26
                    mem[_1768 + 32] = 'SafeMath: division by zero'
                    if totalAllocPoint <= 0:
                        _1791 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_1791 + idx + 68] = mem[_1768 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1791 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1791 + -mem[64] + 100
                    if not totalAllocPoint:
                        revert with 'NH{q', 18
                    if not 0 / totalAllocPoint:
                        mem[mem[64]] = 0
                        emit Mint(0, this.address);
                        _2142 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2142] = 26
                        mem[_2142 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _2172 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2172 + idx + 68] = mem[_2142 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2172 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2172 + -mem[64] + 100
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sushiAddress)
                    call sushiAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args address(this.address), 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0 / totalAllocPoint
                    emit Mint((0 / totalAllocPoint), this.address);
                    if not 0 / totalAllocPoint:
                        _2277 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2277] = 26
                        mem[_2277 + 32] = 'SafeMath: division by zero'
                        if poolInfo[idx].field_512 > 0:
                            if not poolInfo[idx].field_512:
                                revert with 'NH{q', 18
                            if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                                revert with 'NH{q', 17
                            if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                            poolInfo[idx].field_1280 = block.number
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            continue 
                        _2294 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2294 + idx + 68] = mem[_2277 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2294 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _2294 + -mem[64] + 100
                    if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                        revert with 'NH{q', 17
                    if not 0 / totalAllocPoint:
                        revert with 'NH{q', 18
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _2433 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2433] = 26
                    mem[_2433 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _2445 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2445 + idx + 68] = mem[_2433 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2445 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _2445 + -mem[64] + 100
                if (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock and poolInfo[idx].field_256 > -1 / (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock:
                    revert with 'NH{q', 17
                if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock:
                    revert with 'NH{q', 18
                if (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock != poolInfo[idx].field_256:
                    revert with 0, 'SafeMath: multiplication overflow'
                _1968 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1968] = 26
                mem[_1968 + 32] = 'SafeMath: division by zero'
                if totalAllocPoint <= 0:
                    _1998 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_1998 + idx + 68] = mem[_1968 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1998 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _1998 + -mem[64] + 100
                if not totalAllocPoint:
                    revert with 'NH{q', 18
                if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                    mem[mem[64]] = 0
                    emit Mint(0, this.address);
                    _2319 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2319] = 26
                    mem[_2319 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _2342 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2342 + idx + 68] = mem[_2319 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2342 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _2342 + -mem[64] + 100
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                require ext_code.size(sushiAddress)
                call sushiAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args address(this.address), (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint
                emit Mint(((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint), this.address);
                if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                    _2432 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2432] = 26
                    mem[_2432 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _2444 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2444 + idx + 68] = mem[_2432 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2444 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _2444 + -mem[64] + 100
                if (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint and 10^12 > -1 / (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                    revert with 'NH{q', 17
                if not (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint:
                    revert with 'NH{q', 18
                if 10^12 * (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                _2548 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2548] = 26
                mem[_2548 + 32] = 'SafeMath: division by zero'
                if poolInfo[idx].field_512 > 0:
                    if not poolInfo[idx].field_512:
                        revert with 'NH{q', 18
                    if poolInfo[idx].field_1536 > -(10^12 * (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                        revert with 'NH{q', 17
                    if poolInfo[idx].field_1536 + (10^12 * (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_1536 += 10^12 * (100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256 / totalAllocPoint / poolInfo[idx].field_512
                    poolInfo[idx].field_1280 = block.number
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                _2703 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_2703 + idx + 68] = mem[_2548 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_2703 + 94] = 0
                revert with memory
                  from mem[64]
                   len _2703 + -mem[64] + 100
            if bonusEndBlock - poolInfo[idx].field_1280 and -sub_e600038d + 100 > -1 / bonusEndBlock - poolInfo[idx].field_1280:
                revert with 'NH{q', 17
            if not bonusEndBlock - poolInfo[idx].field_1280:
                revert with 'NH{q', 18
            if (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / bonusEndBlock - poolInfo[idx].field_1280 != -sub_e600038d + 100:
                revert with 0, 'SafeMath: multiplication overflow'
            _1408 = mem[64]
            mem[64] = mem[64] + 64
            mem[_1408] = 26
            mem[_1408 + 32] = 'SafeMath: division by zero'
            if (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 > -((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100) - 1:
                revert with 'NH{q', 17
            if ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100) < (100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100:
                revert with 0, 'SafeMath: addition overflow'
            if not ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100):
                _1767 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1767] = 26
                mem[_1767 + 32] = 'SafeMath: division by zero'
                if totalAllocPoint <= 0:
                    _1790 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_1790 + idx + 68] = mem[_1767 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1790 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _1790 + -mem[64] + 100
                if not totalAllocPoint:
                    revert with 'NH{q', 18
                if not 0 / totalAllocPoint:
                    mem[mem[64]] = 0
                    emit Mint(0, this.address);
                    _2139 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2139] = 26
                    mem[_2139 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _2171 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2171 + idx + 68] = mem[_2139 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2171 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _2171 + -mem[64] + 100
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = 0 / totalAllocPoint
                require ext_code.size(sushiAddress)
                call sushiAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args address(this.address), 0 / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 0 / totalAllocPoint
                emit Mint((0 / totalAllocPoint), this.address);
                if not 0 / totalAllocPoint:
                    _2275 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2275] = 26
                    mem[_2275 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _2292 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2292 + idx + 68] = mem[_2275 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2292 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _2292 + -mem[64] + 100
                if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                    revert with 'NH{q', 17
                if not 0 / totalAllocPoint:
                    revert with 'NH{q', 18
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                _2431 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2431] = 26
                mem[_2431 + 32] = 'SafeMath: division by zero'
                if poolInfo[idx].field_512 > 0:
                    if not poolInfo[idx].field_512:
                        revert with 'NH{q', 18
                    if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                        revert with 'NH{q', 17
                    if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                    poolInfo[idx].field_1280 = block.number
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                _2442 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_2442 + idx + 68] = mem[_2431 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_2442 + 94] = 0
                revert with memory
                  from mem[64]
                   len _2442 + -mem[64] + 100
            if ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100) and sushiPerBlock > -1 / ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100):
                revert with 'NH{q', 17
            if not ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100):
                revert with 'NH{q', 18
            if ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock) / ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100) != sushiPerBlock:
                revert with 0, 'SafeMath: multiplication overflow'
            if not ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock):
                _1967 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1967] = 26
                mem[_1967 + 32] = 'SafeMath: division by zero'
                if totalAllocPoint <= 0:
                    _1996 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_1996 + idx + 68] = mem[_1967 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1996 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _1996 + -mem[64] + 100
                if not totalAllocPoint:
                    revert with 'NH{q', 18
                if not 0 / totalAllocPoint:
                    mem[mem[64]] = 0
                    emit Mint(0, this.address);
                    _2318 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2318] = 26
                    mem[_2318 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _2339 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2339 + idx + 68] = mem[_2318 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2339 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _2339 + -mem[64] + 100
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = 0 / totalAllocPoint
                require ext_code.size(sushiAddress)
                call sushiAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args address(this.address), 0 / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 0 / totalAllocPoint
                emit Mint((0 / totalAllocPoint), this.address);
                if not 0 / totalAllocPoint:
                    _2430 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2430] = 26
                    mem[_2430 + 32] = 'SafeMath: division by zero'
                    if poolInfo[idx].field_512 > 0:
                        if not poolInfo[idx].field_512:
                            revert with 'NH{q', 18
                        if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                            revert with 'NH{q', 17
                        if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                        poolInfo[idx].field_1280 = block.number
                        if idx == -1:
                            revert with 'NH{q', 17
                        idx = idx + 1
                        continue 
                    _2441 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2441 + idx + 68] = mem[_2430 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2441 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _2441 + -mem[64] + 100
                if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                    revert with 'NH{q', 17
                if not 0 / totalAllocPoint:
                    revert with 'NH{q', 18
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                _2547 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2547] = 26
                mem[_2547 + 32] = 'SafeMath: division by zero'
                if poolInfo[idx].field_512 > 0:
                    if not poolInfo[idx].field_512:
                        revert with 'NH{q', 18
                    if poolInfo[idx].field_1536 > -(10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) - 1:
                        revert with 'NH{q', 17
                    if poolInfo[idx].field_1536 + (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_1536 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_512
                    poolInfo[idx].field_1280 = block.number
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                _2702 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_2702 + idx + 68] = mem[_2547 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_2702 + 94] = 0
                revert with memory
                  from mem[64]
                   len _2702 + -mem[64] + 100
            if ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock) and poolInfo[idx].field_256 > -1 / ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock):
                revert with 'NH{q', 17
            if not ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock):
                revert with 'NH{q', 18
            if ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock) != poolInfo[idx].field_256:
                revert with 0, 'SafeMath: multiplication overflow'
            _2170 = mem[64]
            mem[64] = mem[64] + 64
            mem[_2170] = 26
            mem[_2170 + 32] = 'SafeMath: division by zero'
            if totalAllocPoint <= 0:
                _2202 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_2202 + idx + 68] = mem[_2170 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_2202 + 94] = 0
                revert with memory
                  from mem[64]
                   len _2202 + -mem[64] + 100
            if not totalAllocPoint:
                revert with 'NH{q', 18
            if not ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                mem[mem[64]] = 0
                emit Mint(0, this.address);
                _2462 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2462] = 26
                mem[_2462 + 32] = 'SafeMath: division by zero'
                if poolInfo[idx].field_512 > 0:
                    if not poolInfo[idx].field_512:
                        revert with 'NH{q', 18
                    if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                        revert with 'NH{q', 17
                    if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                    poolInfo[idx].field_1280 = block.number
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                _2480 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_2480 + idx + 68] = mem[_2462 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_2480 + 94] = 0
                revert with memory
                  from mem[64]
                   len _2480 + -mem[64] + 100
            mem[mem[64] + 4] = this.address
            mem[mem[64] + 36] = ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint
            require ext_code.size(sushiAddress)
            call sushiAddress.0x40c10f19 with:
                 gas gas_remaining wei
                args address(this.address), ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[mem[64]] = ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint
            emit Mint((((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint), this.address);
            if not ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                _2546 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2546] = 26
                mem[_2546 + 32] = 'SafeMath: division by zero'
                if poolInfo[idx].field_512 > 0:
                    if not poolInfo[idx].field_512:
                        revert with 'NH{q', 18
                    if poolInfo[idx].field_1536 > -(0 / poolInfo[idx].field_512) - 1:
                        revert with 'NH{q', 17
                    if poolInfo[idx].field_1536 + (0 / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_1536 += 0 / poolInfo[idx].field_512
                    poolInfo[idx].field_1280 = block.number
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    continue 
                _2701 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_2701 + idx + 68] = mem[_2546 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_2701 + 94] = 0
                revert with memory
                  from mem[64]
                   len _2701 + -mem[64] + 100
            if ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint and 10^12 > -1 / ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                revert with 'NH{q', 17
            if not ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint:
                revert with 'NH{q', 18
            if 10^12 * ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint / ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                revert with 0, 'SafeMath: multiplication overflow'
            _3043 = mem[64]
            mem[64] = mem[64] + 64
            mem[_3043] = 26
            mem[_3043 + 32] = 'SafeMath: division by zero'
            if poolInfo[idx].field_512 > 0:
                if not poolInfo[idx].field_512:
                    revert with 'NH{q', 18
                if poolInfo[idx].field_1536 > -(10^12 * ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_512) - 1:
                    revert with 'NH{q', 17
                if poolInfo[idx].field_1536 + (10^12 * ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_512) < poolInfo[idx].field_1536:
                    revert with 0, 'SafeMath: addition overflow'
                poolInfo[idx].field_1536 += 10^12 * ((100 * bonusEndBlock) - (sub_e600038d * bonusEndBlock) - (100 * poolInfo[idx].field_1280) + (sub_e600038d * poolInfo[idx].field_1280) / 100 * sushiPerBlock * poolInfo[idx].field_256) + ((100 * block.number) - (sub_a054b70a * block.number) - (100 * bonusEndBlock) + (sub_a054b70a * bonusEndBlock) / 100 * sushiPerBlock * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_512
                poolInfo[idx].field_1280 = block.number
                if idx == -1:
                    revert with 'NH{q', 17
                idx = idx + 1
                continue 
            _3044 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[_3044 + idx + 68] = mem[_3043 + idx + 32]
                idx = idx + 32
                continue 
            mem[_3044 + 94] = 0
            revert with memory
              from mem[64]
               len _3044 + -mem[64] + 100
    if arg1 >= poolInfo.length:
        revert with 'NH{q', 50
    if not poolInfo[arg1].field_768:
        if poolInfo[arg1].field_256 > totalAllocPoint:
            revert with 0, 'SafeMath: subtraction overflow', 0
        if totalAllocPoint < poolInfo[arg1].field_256:
            revert with 'NH{q', 17
        if totalAllocPoint - poolInfo[arg1].field_256 > -arg2 - 1:
            revert with 'NH{q', 17
        if arg2 < 0:
            revert with 0, 'SafeMath: addition overflow'
        totalAllocPoint = totalAllocPoint - poolInfo[arg1].field_256 + arg2
    else:
        if poolInfo[arg1].field_256 > sub_9e98edc6:
            revert with 0, 'SafeMath: subtraction overflow', 0
        if sub_9e98edc6 < poolInfo[arg1].field_256:
            revert with 'NH{q', 17
        if sub_9e98edc6 - poolInfo[arg1].field_256 > -arg2 - 1:
            revert with 'NH{q', 17
        if arg2 < 0:
            revert with 0, 'SafeMath: addition overflow'
        sub_9e98edc6 = sub_9e98edc6 - poolInfo[arg1].field_256 + arg2
    if arg1 >= poolInfo.length:
        revert with 'NH{q', 50
    poolInfo[arg1].field_256 = arg2
    poolInfo[arg1].field_1024 = arg4
}



}

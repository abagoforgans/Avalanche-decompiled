contract main {




// =====================  Runtime code  =====================


#
#  - sub_5891fde9(?)
#
address stor1;
address stor2;
address stor3;
address stor4;
mapping of address stor9;
mapping of address stor10;
mapping of address stor11;

function _fallback() payable {
    revert
}

function sub_4387fb30(?) payable {
    require calldata.size - 4 >= 96
    require arg1 == address(arg1)
    require arg2 == arg2
    require arg3 == address(arg3)
    mem[100] = msg.sender
    mem[132] = this.address
    mem[164] = arg2
    require ext_code.size(stor1)
    call stor1.0x23b872dd with:
         gas gas_remaining wei
        args msg.sender, address(this.address), arg2
    mem[96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    require address(arg1)
    mem[ceil32(return_data.size) + 100] = address(arg3)
    mem[ceil32(return_data.size) + 132] = arg2
    require ext_code.size(stor1)
    call stor1.approve(address arg1, uint256 arg2) with:
         gas gas_remaining wei
        args address(arg3), arg2
    mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    mem[(2 * ceil32(return_data.size)) + 96] = 2
    mem[(2 * ceil32(return_data.size)) + 128] = stor1
    mem[(2 * ceil32(return_data.size)) + 160] = address(arg1)
    if block.timestamp > -61:
        revert with 'NH{q', 17
    mem[(2 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
    mem[(2 * ceil32(return_data.size)) + 196] = arg2
    mem[(2 * ceil32(return_data.size)) + 228] = 0
    mem[(2 * ceil32(return_data.size)) + 260] = 160
    mem[(2 * ceil32(return_data.size)) + 356] = 2
    idx = 0
    s = (2 * ceil32(return_data.size)) + 128
    t = (2 * ceil32(return_data.size)) + 388
    while idx < 2:
        mem[t] = mem[s + 12 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    mem[(2 * ceil32(return_data.size)) + 292] = this.address
    mem[(2 * ceil32(return_data.size)) + 324] = block.timestamp + 60
    require ext_code.size(address(arg3))
    call address(arg3).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
         gas gas_remaining wei
        args arg2, 0, 160, address(this.address), block.timestamp + 60, 2, mem[(2 * ceil32(return_data.size)) + 388 len 64]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    mem[(2 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
    mem[64] = (4 * ceil32(return_data.size)) + 192
    require return_data.size >= 32
    _33 = mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32
    require mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 <= test266151307()
    require (2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 223 < (2 * ceil32(return_data.size)) + return_data.size + 192
    _34 = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192]
    if mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192] > test266151307():
        revert with 'NH{q', 65
    if (4 * ceil32(return_data.size)) + floor32(mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 193 > test266151307() or floor32(mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 1 < 0:
        revert with 'NH{q', 65
    mem[64] = (4 * ceil32(return_data.size)) + floor32(mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 193
    mem[(4 * ceil32(return_data.size)) + 192] = _34
    require _33 + (32 * _34) + 32 <= return_data.size
    idx = 0
    s = (2 * ceil32(return_data.size)) + _33 + 224
    t = (4 * ceil32(return_data.size)) + 224
    while idx < _34:
        require mem[s] == mem[s]
        mem[t] = mem[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    mem[mem[64] + 4] = this.address
    require ext_code.size(address(arg1))
    staticcall address(arg1).0x70a08231 with:
            gas gas_remaining wei
           args address(this.address)
    mem[mem[64]] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _70 = mem[64]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    _71 = mem[_70]
    require mem[_70] == mem[_70]
    mem[0] = address(arg1)
    mem[32] = 11
    mem[mem[64] + 4] = stor11[address(arg1)]
    mem[mem[64] + 36] = _71
    require ext_code.size(address(arg1))
    call address(arg1).approve(address arg1, uint256 arg2) with:
         gas gas_remaining wei
        args stor11[address(arg1)], _71
    mem[mem[64]] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _75 = mem[64]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    require mem[_75] == bool(mem[_75])
    require ext_code.size(stor11[address(arg1)])
    staticcall stor11[address(arg1)].bondPrice() with:
            gas gas_remaining wei
    mem[mem[64]] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _79 = mem[64]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    _80 = mem[_79]
    require mem[_79] == mem[_79]
    require ext_code.size(stor11[address(arg1)])
    staticcall stor11[address(arg1)].bondInfo(address arg1) with:
            gas gas_remaining wei
           args msg.sender
    mem[mem[64] len 128] = ext_call.return_data[0 len 128]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _83 = mem[64]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 128
    _84 = mem[_83]
    require mem[_83] == mem[_83]
    require mem[_83 + 32] == mem[_83 + 32]
    require mem[_83 + 64] == mem[_83 + 92 len 4]
    require mem[_83 + 96] == mem[_83 + 124 len 4]
    mem[mem[64] + 4] = _71
    mem[mem[64] + 36] = _80
    mem[mem[64] + 68] = msg.sender
    require ext_code.size(stor11[address(arg1)])
    call stor11[address(arg1)].deposit(uint256 arg1, uint256 arg2, address arg3) with:
         gas gas_remaining wei
        args _71, _80, msg.sender
    mem[mem[64]] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _90 = mem[64]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    require mem[_90] == mem[_90]
    require ext_code.size(stor11[address(arg1)])
    staticcall stor11[address(arg1)].bondInfo(address arg1) with:
            gas gas_remaining wei
           args msg.sender
    mem[mem[64] len 128] = ext_call.return_data[0 len 128]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _94 = mem[64]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 128
    require mem[_94] == mem[_94]
    require mem[_94 + 32] == mem[_94 + 32]
    require mem[_94 + 64] == mem[_94 + 92 len 4]
    require mem[_94 + 96] == mem[_94 + 124 len 4]
    if mem[_94] < _84:
        revert with 'NH{q', 17
    mem[mem[64]] = mem[_94] - _84
    return memory
      from mem[64]
       len 32
}

function sub_26df4c04(?) payable {
    require calldata.size - 4 >= 128
    require arg1 == address(arg1)
    require arg2 == arg2
    require arg3 == address(arg3)
    require arg4 == address(arg4)
    mem[100] = msg.sender
    mem[132] = this.address
    mem[164] = arg2
    require ext_code.size(stor1)
    call stor1.0x23b872dd with:
         gas gas_remaining wei
        args msg.sender, address(this.address), arg2
    mem[96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    require address(arg1)
    mem[ceil32(return_data.size) + 100] = address(arg3)
    mem[ceil32(return_data.size) + 132] = arg2
    require ext_code.size(stor1)
    call stor1.approve(address arg1, uint256 arg2) with:
         gas gas_remaining wei
        args address(arg3), arg2
    mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    mem[(2 * ceil32(return_data.size)) + 96] = 3
    mem[(2 * ceil32(return_data.size)) + 128] = stor1
    mem[(2 * ceil32(return_data.size)) + 160] = address(arg4)
    mem[(2 * ceil32(return_data.size)) + 192] = address(arg1)
    if block.timestamp > -61:
        revert with 'NH{q', 17
    mem[(2 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
    mem[(2 * ceil32(return_data.size)) + 228] = arg2
    mem[(2 * ceil32(return_data.size)) + 260] = 0
    mem[(2 * ceil32(return_data.size)) + 292] = 160
    mem[(2 * ceil32(return_data.size)) + 388] = 3
    idx = 0
    s = (2 * ceil32(return_data.size)) + 128
    t = (2 * ceil32(return_data.size)) + 420
    while idx < 3:
        mem[t] = mem[s + 12 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    mem[(2 * ceil32(return_data.size)) + 324] = this.address
    mem[(2 * ceil32(return_data.size)) + 356] = block.timestamp + 60
    require ext_code.size(address(arg3))
    call address(arg3).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
         gas gas_remaining wei
        args arg2, 0, 160, address(this.address), block.timestamp + 60, 3, mem[(2 * ceil32(return_data.size)) + 420 len 96]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    mem[(2 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
    mem[64] = (4 * ceil32(return_data.size)) + 224
    require return_data.size >= 32
    _32 = mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg2) >> 32
    require mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg2) >> 32 <= test266151307()
    require (2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg2) >> 32 + 255 < (2 * ceil32(return_data.size)) + return_data.size + 224
    _33 = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg2) >> 32 + 224]
    if mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg2) >> 32 + 224] > test266151307():
        revert with 'NH{q', 65
    if (4 * ceil32(return_data.size)) + floor32(mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg2) >> 32 + 224]) + 225 > test266151307() or floor32(mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg2) >> 32 + 224]) + 1 < 0:
        revert with 'NH{q', 65
    mem[64] = (4 * ceil32(return_data.size)) + floor32(mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg2) >> 32 + 224]) + 225
    mem[(4 * ceil32(return_data.size)) + 224] = _33
    require _32 + (32 * _33) + 32 <= return_data.size
    idx = 0
    s = (2 * ceil32(return_data.size)) + _32 + 256
    t = (4 * ceil32(return_data.size)) + 256
    while idx < _33:
        require mem[s] == mem[s]
        mem[t] = mem[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    mem[mem[64] + 4] = this.address
    require ext_code.size(address(arg1))
    staticcall address(arg1).0x70a08231 with:
            gas gas_remaining wei
           args address(this.address)
    mem[mem[64]] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _69 = mem[64]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    _70 = mem[_69]
    require mem[_69] == mem[_69]
    mem[0] = address(arg1)
    mem[32] = 11
    mem[mem[64] + 4] = stor11[address(arg1)]
    mem[mem[64] + 36] = _70
    require ext_code.size(address(arg1))
    call address(arg1).approve(address arg1, uint256 arg2) with:
         gas gas_remaining wei
        args stor11[address(arg1)], _70
    mem[mem[64]] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _74 = mem[64]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    require mem[_74] == bool(mem[_74])
    require ext_code.size(stor11[address(arg1)])
    staticcall stor11[address(arg1)].bondPrice() with:
            gas gas_remaining wei
    mem[mem[64]] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _78 = mem[64]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    _79 = mem[_78]
    require mem[_78] == mem[_78]
    require ext_code.size(stor11[address(arg1)])
    staticcall stor11[address(arg1)].bondInfo(address arg1) with:
            gas gas_remaining wei
           args msg.sender
    mem[mem[64] len 128] = ext_call.return_data[0 len 128]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _82 = mem[64]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 128
    _83 = mem[_82]
    require mem[_82] == mem[_82]
    require mem[_82 + 32] == mem[_82 + 32]
    require mem[_82 + 64] == mem[_82 + 92 len 4]
    require mem[_82 + 96] == mem[_82 + 124 len 4]
    mem[mem[64] + 4] = _70
    mem[mem[64] + 36] = _79
    mem[mem[64] + 68] = msg.sender
    require ext_code.size(stor11[address(arg1)])
    call stor11[address(arg1)].deposit(uint256 arg1, uint256 arg2, address arg3) with:
         gas gas_remaining wei
        args _70, _79, msg.sender
    mem[mem[64]] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _89 = mem[64]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    require mem[_89] == mem[_89]
    require ext_code.size(stor11[address(arg1)])
    staticcall stor11[address(arg1)].bondInfo(address arg1) with:
            gas gas_remaining wei
           args msg.sender
    mem[mem[64] len 128] = ext_call.return_data[0 len 128]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _93 = mem[64]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 128
    require mem[_93] == mem[_93]
    require mem[_93 + 32] == mem[_93 + 32]
    require mem[_93 + 64] == mem[_93 + 92 len 4]
    require mem[_93 + 96] == mem[_93 + 124 len 4]
    if mem[_93] < _83:
        revert with 'NH{q', 17
    mem[mem[64]] = mem[_93] - _83
    return memory
      from mem[64]
       len 32
}

function sub_af04c15f(?) payable {
    require calldata.size - 4 >= 160
    require arg1 == address(arg1)
    require arg2 == arg2
    require arg3 == address(arg3)
    require arg4 == address(arg4)
    require arg5 == address(arg5)
    mem[100] = msg.sender
    mem[132] = this.address
    mem[164] = arg2
    require ext_code.size(stor1)
    call stor1.0x23b872dd with:
         gas gas_remaining wei
        args msg.sender, address(this.address), arg2
    mem[96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    require address(arg1)
    mem[ceil32(return_data.size) + 100] = address(arg3)
    mem[ceil32(return_data.size) + 132] = arg2
    require ext_code.size(stor1)
    call stor1.approve(address arg1, uint256 arg2) with:
         gas gas_remaining wei
        args address(arg3), arg2
    mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    mem[(2 * ceil32(return_data.size)) + 96] = 4
    mem[(2 * ceil32(return_data.size)) + 128] = stor1
    mem[(2 * ceil32(return_data.size)) + 160] = address(arg4)
    mem[(2 * ceil32(return_data.size)) + 192] = address(arg5)
    mem[(2 * ceil32(return_data.size)) + 224] = address(arg1)
    if block.timestamp > -61:
        revert with 'NH{q', 17
    mem[(2 * ceil32(return_data.size)) + 256] = 0x38ed173900000000000000000000000000000000000000000000000000000000
    mem[(2 * ceil32(return_data.size)) + 260] = arg2
    mem[(2 * ceil32(return_data.size)) + 292] = 0
    mem[(2 * ceil32(return_data.size)) + 324] = 160
    mem[(2 * ceil32(return_data.size)) + 420] = 4
    idx = 0
    s = (2 * ceil32(return_data.size)) + 128
    t = (2 * ceil32(return_data.size)) + 452
    while idx < 4:
        mem[t] = mem[s + 12 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    mem[(2 * ceil32(return_data.size)) + 356] = this.address
    mem[(2 * ceil32(return_data.size)) + 388] = block.timestamp + 60
    require ext_code.size(address(arg3))
    call address(arg3).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
         gas gas_remaining wei
        args arg2, 0, 160, address(this.address), block.timestamp + 60, 4, mem[(2 * ceil32(return_data.size)) + 452 len 128]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    mem[(2 * ceil32(return_data.size)) + 256 len return_data.size] = ext_call.return_data[0 len return_data.size]
    mem[64] = (4 * ceil32(return_data.size)) + 256
    require return_data.size >= 32
    _32 = mem[(2 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg2) >> 32
    require mem[(2 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg2) >> 32 <= test266151307()
    require (2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg2) >> 32 + 287 < (2 * ceil32(return_data.size)) + return_data.size + 256
    _33 = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg2) >> 32 + 256]
    if mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg2) >> 32 + 256] > test266151307():
        revert with 'NH{q', 65
    if (4 * ceil32(return_data.size)) + floor32(mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg2) >> 32 + 256]) + 257 > test266151307() or floor32(mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg2) >> 32 + 256]) + 1 < 0:
        revert with 'NH{q', 65
    mem[64] = (4 * ceil32(return_data.size)) + floor32(mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, arg2) >> 32 + 256]) + 257
    mem[(4 * ceil32(return_data.size)) + 256] = _33
    require _32 + (32 * _33) + 32 <= return_data.size
    idx = 0
    s = (2 * ceil32(return_data.size)) + _32 + 288
    t = (4 * ceil32(return_data.size)) + 288
    while idx < _33:
        require mem[s] == mem[s]
        mem[t] = mem[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    mem[mem[64] + 4] = this.address
    require ext_code.size(address(arg1))
    staticcall address(arg1).0x70a08231 with:
            gas gas_remaining wei
           args address(this.address)
    mem[mem[64]] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _69 = mem[64]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    _70 = mem[_69]
    require mem[_69] == mem[_69]
    mem[0] = address(arg1)
    mem[32] = 11
    mem[mem[64] + 4] = stor11[address(arg1)]
    mem[mem[64] + 36] = _70
    require ext_code.size(address(arg1))
    call address(arg1).approve(address arg1, uint256 arg2) with:
         gas gas_remaining wei
        args stor11[address(arg1)], _70
    mem[mem[64]] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _74 = mem[64]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    require mem[_74] == bool(mem[_74])
    require ext_code.size(stor11[address(arg1)])
    staticcall stor11[address(arg1)].bondPrice() with:
            gas gas_remaining wei
    mem[mem[64]] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _78 = mem[64]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    _79 = mem[_78]
    require mem[_78] == mem[_78]
    require ext_code.size(stor11[address(arg1)])
    staticcall stor11[address(arg1)].bondInfo(address arg1) with:
            gas gas_remaining wei
           args msg.sender
    mem[mem[64] len 128] = ext_call.return_data[0 len 128]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _82 = mem[64]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 128
    _83 = mem[_82]
    require mem[_82] == mem[_82]
    require mem[_82 + 32] == mem[_82 + 32]
    require mem[_82 + 64] == mem[_82 + 92 len 4]
    require mem[_82 + 96] == mem[_82 + 124 len 4]
    mem[mem[64] + 4] = _70
    mem[mem[64] + 36] = _79
    mem[mem[64] + 68] = msg.sender
    require ext_code.size(stor11[address(arg1)])
    call stor11[address(arg1)].deposit(uint256 arg1, uint256 arg2, address arg3) with:
         gas gas_remaining wei
        args _70, _79, msg.sender
    mem[mem[64]] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _89 = mem[64]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    require mem[_89] == mem[_89]
    require ext_code.size(stor11[address(arg1)])
    staticcall stor11[address(arg1)].bondInfo(address arg1) with:
            gas gas_remaining wei
           args msg.sender
    mem[mem[64] len 128] = ext_call.return_data[0 len 128]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _93 = mem[64]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 128
    require mem[_93] == mem[_93]
    require mem[_93 + 32] == mem[_93 + 32]
    require mem[_93 + 64] == mem[_93 + 92 len 4]
    require mem[_93 + 96] == mem[_93 + 124 len 4]
    if mem[_93] < _83:
        revert with 'NH{q', 17
    mem[mem[64]] = mem[_93] - _83
    return memory
      from mem[64]
       len 32
}

function sub_4e38c882(?) payable {
    require calldata.size - 4 >= 128
    require arg1 == address(arg1)
    require arg2 == arg2
    require arg3 == arg3
    require arg4 == address(arg4)
    mem[100] = msg.sender
    mem[132] = this.address
    mem[164] = arg2
    require ext_code.size(stor1)
    call stor1.0x23b872dd with:
         gas gas_remaining wei
        args msg.sender, address(this.address), arg2
    mem[96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    require address(arg1)
    mem[ceil32(return_data.size) + 100] = address(arg4)
    mem[ceil32(return_data.size) + 132] = arg2
    require ext_code.size(stor1)
    call stor1.approve(address arg1, uint256 arg2) with:
         gas gas_remaining wei
        args address(arg4), arg2
    mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    mem[(2 * ceil32(return_data.size)) + 96] = 2
    mem[(2 * ceil32(return_data.size)) + 128] = stor1
    mem[(2 * ceil32(return_data.size)) + 160] = address(arg1)
    if block.timestamp > -61:
        revert with 'NH{q', 17
    mem[(2 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
    mem[(2 * ceil32(return_data.size)) + 196] = arg2
    mem[(2 * ceil32(return_data.size)) + 228] = 0
    mem[(2 * ceil32(return_data.size)) + 260] = 160
    mem[(2 * ceil32(return_data.size)) + 356] = 2
    idx = 0
    s = (2 * ceil32(return_data.size)) + 128
    t = (2 * ceil32(return_data.size)) + 388
    while idx < 2:
        mem[t] = mem[s + 12 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    mem[(2 * ceil32(return_data.size)) + 292] = this.address
    mem[(2 * ceil32(return_data.size)) + 324] = block.timestamp + 60
    require ext_code.size(address(arg4))
    call address(arg4).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
         gas gas_remaining wei
        args arg2, 0, 160, address(this.address), block.timestamp + 60, 2, mem[(2 * ceil32(return_data.size)) + 388 len 64]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    mem[(2 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
    mem[64] = (4 * ceil32(return_data.size)) + 192
    require return_data.size >= 32
    _32 = mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32
    require mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 <= test266151307()
    require (2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 223 < (2 * ceil32(return_data.size)) + return_data.size + 192
    _33 = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192]
    if mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192] > test266151307():
        revert with 'NH{q', 65
    if (4 * ceil32(return_data.size)) + floor32(mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 193 > test266151307() or floor32(mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 1 < 0:
        revert with 'NH{q', 65
    mem[64] = (4 * ceil32(return_data.size)) + floor32(mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 193
    mem[(4 * ceil32(return_data.size)) + 192] = _33
    require _32 + (32 * _33) + 32 <= return_data.size
    idx = 0
    s = (2 * ceil32(return_data.size)) + _32 + 224
    t = (4 * ceil32(return_data.size)) + 224
    while idx < _33:
        require mem[s] == mem[s]
        mem[t] = mem[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    mem[mem[64] + 4] = this.address
    require ext_code.size(address(arg1))
    staticcall address(arg1).0x70a08231 with:
            gas gas_remaining wei
           args address(this.address)
    mem[mem[64]] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _69 = mem[64]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    _70 = mem[_69]
    require mem[_69] == mem[_69]
    mem[0] = address(arg1)
    mem[32] = 11
    mem[mem[64] + 4] = stor11[address(arg1)]
    mem[mem[64] + 36] = _70
    require ext_code.size(address(arg1))
    call address(arg1).approve(address arg1, uint256 arg2) with:
         gas gas_remaining wei
        args stor11[address(arg1)], _70
    mem[mem[64]] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _74 = mem[64]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    require mem[_74] == bool(mem[_74])
    require ext_code.size(stor11[address(arg1)])
    staticcall stor11[address(arg1)].bondPrice() with:
            gas gas_remaining wei
    mem[mem[64]] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _78 = mem[64]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    _79 = mem[_78]
    require mem[_78] == mem[_78]
    require ext_code.size(stor11[address(arg1)])
    staticcall stor11[address(arg1)].bondInfo(address arg1) with:
            gas gas_remaining wei
           args msg.sender
    mem[mem[64] len 128] = ext_call.return_data[0 len 128]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _82 = mem[64]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 128
    _83 = mem[_82]
    require mem[_82] == mem[_82]
    require mem[_82 + 32] == mem[_82 + 32]
    require mem[_82 + 64] == mem[_82 + 92 len 4]
    require mem[_82 + 96] == mem[_82 + 124 len 4]
    mem[mem[64] + 4] = _70
    mem[mem[64] + 36] = _79
    mem[mem[64] + 68] = msg.sender
    require ext_code.size(stor11[address(arg1)])
    call stor11[address(arg1)].deposit(uint256 arg1, uint256 arg2, address arg3) with:
         gas gas_remaining wei
        args _70, _79, msg.sender
    mem[mem[64]] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _89 = mem[64]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    require mem[_89] == mem[_89]
    require ext_code.size(stor11[address(arg1)])
    staticcall stor11[address(arg1)].bondInfo(address arg1) with:
            gas gas_remaining wei
           args msg.sender
    mem[mem[64] len 128] = ext_call.return_data[0 len 128]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _93 = mem[64]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 128
    require mem[_93] == mem[_93]
    require mem[_93 + 32] == mem[_93 + 32]
    require mem[_93 + 64] == mem[_93 + 92 len 4]
    require mem[_93 + 96] == mem[_93 + 124 len 4]
    if mem[_93] < _83:
        revert with 'NH{q', 17
    if mem[_93] - _83 < arg3:
        revert with 0, 'insufficient profit, either ROI plummeted or your slippage is too tight'
    mem[mem[64] + 4] = this.address
    require ext_code.size(address(arg1))
    staticcall address(arg1).0x70a08231 with:
            gas gas_remaining wei
           args address(this.address)
    mem[mem[64]] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _102 = mem[64]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    _103 = mem[_102]
    require mem[_102] == mem[_102]
    if mem[_102] <= 0:
        mem[mem[64] + 4] = this.address
        require ext_code.size(stor1)
        staticcall stor1.0x70a08231 with:
                gas gas_remaining wei
               args address(this.address)
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _107 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _110 = mem[_107]
        require mem[_107] == mem[_107]
        if mem[_107] > 0:
            mem[mem[64] + 4] = msg.sender
            mem[mem[64] + 36] = _110
            require ext_code.size(stor1)
            call stor1.0xa9059cbb with:
                 gas gas_remaining wei
                args msg.sender, _110
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _116 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_116] == bool(mem[_116])
    else:
        mem[mem[64] + 4] = msg.sender
        mem[mem[64] + 36] = _103
        require ext_code.size(address(arg1))
        call address(arg1).0xa9059cbb with:
             gas gas_remaining wei
            args msg.sender, _103
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _109 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        require mem[_109] == bool(mem[_109])
        mem[mem[64] + 4] = this.address
        require ext_code.size(stor1)
        staticcall stor1.0x70a08231 with:
                gas gas_remaining wei
               args address(this.address)
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _117 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _119 = mem[_117]
        require mem[_117] == mem[_117]
        if mem[_117] > 0:
            mem[mem[64] + 4] = msg.sender
            mem[mem[64] + 36] = _119
            require ext_code.size(stor1)
            call stor1.0xa9059cbb with:
                 gas gas_remaining wei
                args msg.sender, _119
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _122 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_122] == bool(mem[_122])
}

function sub_fb62762b(?) payable {
    require calldata.size - 4 >= 160
    require arg1 == address(arg1)
    require arg2 == arg2
    require arg3 == arg3
    require arg4 == address(arg4)
    require arg5 == address(arg5)
    mem[100] = msg.sender
    mem[132] = this.address
    mem[164] = arg2
    require ext_code.size(stor1)
    call stor1.0x23b872dd with:
         gas gas_remaining wei
        args msg.sender, address(this.address), arg2
    mem[96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    require address(arg1)
    mem[ceil32(return_data.size) + 100] = address(arg4)
    mem[ceil32(return_data.size) + 132] = arg2
    require ext_code.size(stor1)
    call stor1.approve(address arg1, uint256 arg2) with:
         gas gas_remaining wei
        args address(arg4), arg2
    mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    mem[(2 * ceil32(return_data.size)) + 96] = 3
    mem[(2 * ceil32(return_data.size)) + 128] = stor1
    mem[(2 * ceil32(return_data.size)) + 160] = address(arg5)
    mem[(2 * ceil32(return_data.size)) + 192] = address(arg1)
    if block.timestamp > -61:
        revert with 'NH{q', 17
    mem[(2 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
    mem[(2 * ceil32(return_data.size)) + 228] = arg2
    mem[(2 * ceil32(return_data.size)) + 260] = 0
    mem[(2 * ceil32(return_data.size)) + 292] = 160
    mem[(2 * ceil32(return_data.size)) + 388] = 3
    idx = 0
    s = (2 * ceil32(return_data.size)) + 128
    t = (2 * ceil32(return_data.size)) + 420
    while idx < 3:
        mem[t] = mem[s + 12 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    mem[(2 * ceil32(return_data.size)) + 324] = this.address
    mem[(2 * ceil32(return_data.size)) + 356] = block.timestamp + 60
    require ext_code.size(address(arg4))
    call address(arg4).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
         gas gas_remaining wei
        args arg2, 0, 160, address(this.address), block.timestamp + 60, 3, mem[(2 * ceil32(return_data.size)) + 420 len 96]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    mem[(2 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
    mem[64] = (4 * ceil32(return_data.size)) + 224
    require return_data.size >= 32
    _31 = mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg2) >> 32
    require mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg2) >> 32 <= test266151307()
    require (2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg2) >> 32 + 255 < (2 * ceil32(return_data.size)) + return_data.size + 224
    _32 = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg2) >> 32 + 224]
    if mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg2) >> 32 + 224] > test266151307():
        revert with 'NH{q', 65
    if (4 * ceil32(return_data.size)) + floor32(mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg2) >> 32 + 224]) + 225 > test266151307() or floor32(mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg2) >> 32 + 224]) + 1 < 0:
        revert with 'NH{q', 65
    mem[64] = (4 * ceil32(return_data.size)) + floor32(mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg2) >> 32 + 224]) + 225
    mem[(4 * ceil32(return_data.size)) + 224] = _32
    require _31 + (32 * _32) + 32 <= return_data.size
    idx = 0
    s = (2 * ceil32(return_data.size)) + _31 + 256
    t = (4 * ceil32(return_data.size)) + 256
    while idx < _32:
        require mem[s] == mem[s]
        mem[t] = mem[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    mem[mem[64] + 4] = this.address
    require ext_code.size(address(arg1))
    staticcall address(arg1).0x70a08231 with:
            gas gas_remaining wei
           args address(this.address)
    mem[mem[64]] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _68 = mem[64]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    _69 = mem[_68]
    require mem[_68] == mem[_68]
    mem[0] = address(arg1)
    mem[32] = 11
    mem[mem[64] + 4] = stor11[address(arg1)]
    mem[mem[64] + 36] = _69
    require ext_code.size(address(arg1))
    call address(arg1).approve(address arg1, uint256 arg2) with:
         gas gas_remaining wei
        args stor11[address(arg1)], _69
    mem[mem[64]] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _73 = mem[64]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    require mem[_73] == bool(mem[_73])
    require ext_code.size(stor11[address(arg1)])
    staticcall stor11[address(arg1)].bondPrice() with:
            gas gas_remaining wei
    mem[mem[64]] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _77 = mem[64]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    _78 = mem[_77]
    require mem[_77] == mem[_77]
    require ext_code.size(stor11[address(arg1)])
    staticcall stor11[address(arg1)].bondInfo(address arg1) with:
            gas gas_remaining wei
           args msg.sender
    mem[mem[64] len 128] = ext_call.return_data[0 len 128]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _81 = mem[64]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 128
    _82 = mem[_81]
    require mem[_81] == mem[_81]
    require mem[_81 + 32] == mem[_81 + 32]
    require mem[_81 + 64] == mem[_81 + 92 len 4]
    require mem[_81 + 96] == mem[_81 + 124 len 4]
    mem[mem[64] + 4] = _69
    mem[mem[64] + 36] = _78
    mem[mem[64] + 68] = msg.sender
    require ext_code.size(stor11[address(arg1)])
    call stor11[address(arg1)].deposit(uint256 arg1, uint256 arg2, address arg3) with:
         gas gas_remaining wei
        args _69, _78, msg.sender
    mem[mem[64]] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _88 = mem[64]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    require mem[_88] == mem[_88]
    require ext_code.size(stor11[address(arg1)])
    staticcall stor11[address(arg1)].bondInfo(address arg1) with:
            gas gas_remaining wei
           args msg.sender
    mem[mem[64] len 128] = ext_call.return_data[0 len 128]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _92 = mem[64]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 128
    require mem[_92] == mem[_92]
    require mem[_92 + 32] == mem[_92 + 32]
    require mem[_92 + 64] == mem[_92 + 92 len 4]
    require mem[_92 + 96] == mem[_92 + 124 len 4]
    if mem[_92] < _82:
        revert with 'NH{q', 17
    if mem[_92] - _82 < arg3:
        revert with 0, 'insufficient profit, either ROI plummeted or your slippage is too tight'
    mem[mem[64] + 4] = this.address
    require ext_code.size(address(arg1))
    staticcall address(arg1).0x70a08231 with:
            gas gas_remaining wei
           args address(this.address)
    mem[mem[64]] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _101 = mem[64]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    _102 = mem[_101]
    require mem[_101] == mem[_101]
    if mem[_101] <= 0:
        mem[mem[64] + 4] = this.address
        require ext_code.size(stor1)
        staticcall stor1.0x70a08231 with:
                gas gas_remaining wei
               args address(this.address)
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _106 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _109 = mem[_106]
        require mem[_106] == mem[_106]
        if mem[_106] > 0:
            mem[mem[64] + 4] = msg.sender
            mem[mem[64] + 36] = _109
            require ext_code.size(stor1)
            call stor1.0xa9059cbb with:
                 gas gas_remaining wei
                args msg.sender, _109
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _115 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_115] == bool(mem[_115])
    else:
        mem[mem[64] + 4] = msg.sender
        mem[mem[64] + 36] = _102
        require ext_code.size(address(arg1))
        call address(arg1).0xa9059cbb with:
             gas gas_remaining wei
            args msg.sender, _102
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _108 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        require mem[_108] == bool(mem[_108])
        mem[mem[64] + 4] = this.address
        require ext_code.size(stor1)
        staticcall stor1.0x70a08231 with:
                gas gas_remaining wei
               args address(this.address)
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _116 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _118 = mem[_116]
        require mem[_116] == mem[_116]
        if mem[_116] > 0:
            mem[mem[64] + 4] = msg.sender
            mem[mem[64] + 36] = _118
            require ext_code.size(stor1)
            call stor1.0xa9059cbb with:
                 gas gas_remaining wei
                args msg.sender, _118
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _121 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_121] == bool(mem[_121])
}

function sub_74d6602b(?) payable {
    require calldata.size - 4 >= 96
    require arg1 == address(arg1)
    require arg2 == arg2
    require arg3 == address(arg3)
    mem[100] = msg.sender
    mem[132] = this.address
    mem[164] = arg2
    require ext_code.size(stor1)
    call stor1.0x23b872dd with:
         gas gas_remaining wei
        args msg.sender, address(this.address), arg2
    mem[96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    mem[0] = address(arg1)
    mem[32] = 9
    require stor9[address(arg1)]
    require ext_code.size(stor9[address(arg1)])
    staticcall stor9[address(arg1)].getReserves() with:
            gas gas_remaining wei
    mem[ceil32(return_data.size) + 96 len 96] = ext_call.return_data[0 len 96]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 96
    require ext_call.return_data[0] == ext_call.return_data[18 len 14]
    require ext_call.return_data[32] == ext_call.return_data[50 len 14]
    require ext_call.return_data[64] == ext_call.return_data[92 len 4]
    require ext_code.size(stor9[address(arg1)])
    staticcall stor9[address(arg1)].token0() with:
            gas gas_remaining wei
    mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    require ext_code.size(stor9[address(arg1)])
    staticcall stor9[address(arg1)].token1() with:
            gas gas_remaining wei
    mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    if address(ext_call.return_data[0]) != address(arg1):
        if ext_call.return_data[12 len 20] != address(arg1):
            revert with 0, 'bad LP token'
        if address(ext_call.return_data[0]) != stor1:
            revert with 0, 'bad LP token'
        if Mask(112, 0, ext_call.return_data[0]) > 0x20d135b66ae990fc484cea55e38a936bcf497445394d4cc984add428823e4d:
            revert with 'NH{q', 17
        if 1000 * Mask(112, 0, ext_call.return_data[0]) and arg2 > -1 / 1000 * Mask(112, 0, ext_call.return_data[0]):
            revert with 'NH{q', 17
        if arg2 / 2 > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
            revert with 'NH{q', 17
        if 1994 * arg2 / 2 > (-1997 * Mask(112, 0, ext_call.return_data[0])) - 1:
            revert with 'NH{q', 17
        if arg2 / 2 > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
            revert with 'NH{q', 17
        if 997 * arg2 / 2 and arg2 / 2 > -1 / 997 * arg2 / 2:
            revert with 'NH{q', 17
        if 997 * arg2 / 2 * arg2 / 2 > (-1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) - 1:
            revert with 'NH{q', 17
        if not (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])):
            revert with 'NH{q', 18
        if (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
            revert with 'NH{q', 17
        if 1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) > (-1997 * Mask(112, 0, ext_call.return_data[0])) - 1:
            revert with 'NH{q', 17
        if (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
            revert with 'NH{q', 17
        if 997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) and (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) > -1 / 997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])):
            revert with 'NH{q', 17
        if 997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) > (-1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) - 1:
            revert with 'NH{q', 17
        if not (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])):
            revert with 'NH{q', 18
        if (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
            revert with 'NH{q', 17
        if 1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) > (-1997 * Mask(112, 0, ext_call.return_data[0])) - 1:
            revert with 'NH{q', 17
        if (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
            revert with 'NH{q', 17
        if 997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) and (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) > -1 / 997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])):
            revert with 'NH{q', 17
        if 997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) > (-1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) - 1:
            revert with 'NH{q', 17
        if not (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])):
            revert with 'NH{q', 18
        require address(arg1)
        mem[(6 * ceil32(return_data.size)) + 100] = address(arg3)
        mem[(6 * ceil32(return_data.size)) + 132] = (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))
        require ext_code.size(stor1)
        call stor1.approve(address arg1, uint256 arg2) with:
             gas gas_remaining wei
            args address(arg3), (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))
        mem[(6 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == bool(ext_call.return_data[0])
        mem[(7 * ceil32(return_data.size)) + 96] = 2
        mem[(7 * ceil32(return_data.size)) + 128] = stor1
        mem[(7 * ceil32(return_data.size)) + 160] = address(arg1)
        if block.timestamp > -61:
            revert with 'NH{q', 17
        mem[(7 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
        mem[(7 * ceil32(return_data.size)) + 196] = (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))
        mem[(7 * ceil32(return_data.size)) + 228] = 0
        mem[(7 * ceil32(return_data.size)) + 260] = 160
        mem[(7 * ceil32(return_data.size)) + 356] = 2
        idx = 0
        s = (7 * ceil32(return_data.size)) + 128
        t = (7 * ceil32(return_data.size)) + 388
        while idx < 2:
            mem[t] = mem[s + 12 len 20]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        mem[(7 * ceil32(return_data.size)) + 292] = this.address
        mem[(7 * ceil32(return_data.size)) + 324] = block.timestamp + 60
        require ext_code.size(address(arg3))
        call address(arg3).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
             gas gas_remaining wei
            args (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])), 0, 160, address(this.address), block.timestamp + 60, 2, mem[(7 * ceil32(return_data.size)) + 388 len 64]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        mem[(7 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = (8 * ceil32(return_data.size)) + 192
        require return_data.size >= 32
        _100 = mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32
        require mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 <= test266151307()
        require (7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 223 < (7 * ceil32(return_data.size)) + return_data.size + 192
        _103 = mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]
        if mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192] > test266151307():
            revert with 'NH{q', 65
        if (8 * ceil32(return_data.size)) + floor32(mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]) + 193 > test266151307() or floor32(mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]) + 1 < 0:
            revert with 'NH{q', 65
        mem[64] = (8 * ceil32(return_data.size)) + floor32(mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]) + 193
        mem[(8 * ceil32(return_data.size)) + 192] = _103
        require _100 + (32 * _103) + 32 <= return_data.size
        idx = 0
        s = (7 * ceil32(return_data.size)) + _100 + 224
        t = (8 * ceil32(return_data.size)) + 224
        while idx < _103:
            require mem[s] == mem[s]
            mem[t] = mem[s]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        mem[mem[64] + 4] = this.address
        require ext_code.size(address(arg1))
        staticcall address(arg1).0x70a08231 with:
                gas gas_remaining wei
               args address(this.address)
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _223 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _226 = mem[_223]
        require mem[_223] == mem[_223]
        mem[mem[64] + 4] = this.address
        require ext_code.size(stor1)
        staticcall stor1.0x70a08231 with:
                gas gas_remaining wei
               args address(this.address)
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _235 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _238 = mem[_235]
        require mem[_235] == mem[_235]
        if address(arg1) == stor2:
            mem[mem[64] + 4] = stor4
            mem[mem[64] + 36] = _226
            require ext_code.size(address(arg1))
            call address(arg1).approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args stor4, _226
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _253 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_253] == bool(mem[_253])
            mem[mem[64] + 4] = stor4
            mem[mem[64] + 36] = _238
            require ext_code.size(stor1)
            call stor1.approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args stor4, _238
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _277 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_277] == bool(mem[_277])
            if block.timestamp > -61:
                revert with 'NH{q', 17
            mem[mem[64] + 68] = _238
            mem[mem[64] + 100] = _226
            mem[mem[64] + 132] = 0
            mem[mem[64] + 164] = 0
            mem[mem[64] + 196] = this.address
            mem[mem[64] + 228] = block.timestamp + 60
            require ext_code.size(stor4)
            call stor4.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                 gas gas_remaining wei
                args stor1, address(arg1), _238, _226, 0, 0, address(this.address), block.timestamp + 60
            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _301 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 96
            require mem[_301] == mem[_301]
            require mem[_301 + 32] == mem[_301 + 32]
            require mem[_301 + 64] == mem[_301 + 64]
            mem[0] = address(arg1)
            mem[32] = 9
            mem[mem[64] + 4] = this.address
            require ext_code.size(stor9[address(arg1)])
            staticcall stor9[address(arg1)].0x70a08231 with:
                    gas gas_remaining wei
                   args address(this.address)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _343 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _349 = mem[_343]
            require mem[_343] == mem[_343]
            mem[0] = stor9[address(arg1)]
            mem[32] = 11
            mem[mem[64] + 4] = stor11[stor9[address(arg1)]]
            mem[mem[64] + 36] = _349
            require ext_code.size(stor9[address(arg1)])
            call stor9[address(arg1)].approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args stor11[stor9[address(arg1)]], _349
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _373 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_373] == bool(mem[_373])
            require ext_code.size(stor11[stor9[address(arg1)]])
            staticcall stor11[stor9[address(arg1)]].bondPrice() with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _397 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _403 = mem[_397]
            require mem[_397] == mem[_397]
            require ext_code.size(stor11[stor9[address(arg1)]])
            staticcall stor11[stor9[address(arg1)]].bondInfo(address arg1) with:
                    gas gas_remaining wei
                   args msg.sender
            mem[mem[64] len 128] = ext_call.return_data[0 len 128]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _421 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 128
            _427 = mem[_421]
            require mem[_421] == mem[_421]
            require mem[_421 + 32] == mem[_421 + 32]
            require mem[_421 + 64] == mem[_421 + 92 len 4]
            require mem[_421 + 96] == mem[_421 + 124 len 4]
            mem[mem[64] + 4] = _349
            mem[mem[64] + 36] = _403
            mem[mem[64] + 68] = msg.sender
            require ext_code.size(stor11[stor9[address(arg1)]])
            call stor11[stor9[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                 gas gas_remaining wei
                args _349, _403, msg.sender
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _463 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_463] == mem[_463]
            require ext_code.size(stor11[stor9[address(arg1)]])
            staticcall stor11[stor9[address(arg1)]].bondInfo(address arg1) with:
                    gas gas_remaining wei
                   args msg.sender
            mem[mem[64] len 128] = ext_call.return_data[0 len 128]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _487 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 128
            require mem[_487] == mem[_487]
            require mem[_487 + 32] == mem[_487 + 32]
            require mem[_487 + 64] == mem[_487 + 92 len 4]
            require mem[_487 + 96] == mem[_487 + 124 len 4]
            if mem[_487] < _427:
                revert with 'NH{q', 17
            mem[mem[64]] = mem[_487] - _427
        else:
            mem[mem[64] + 4] = stor3
            mem[mem[64] + 36] = _226
            require ext_code.size(address(arg1))
            call address(arg1).approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args stor3, _226
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _254 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_254] == bool(mem[_254])
            mem[mem[64] + 4] = stor3
            mem[mem[64] + 36] = _238
            require ext_code.size(stor1)
            call stor1.approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args stor3, _238
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _278 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_278] == bool(mem[_278])
            if block.timestamp > -61:
                revert with 'NH{q', 17
            mem[mem[64] + 68] = _238
            mem[mem[64] + 100] = _226
            mem[mem[64] + 132] = 0
            mem[mem[64] + 164] = 0
            mem[mem[64] + 196] = this.address
            mem[mem[64] + 228] = block.timestamp + 60
            require ext_code.size(stor3)
            call stor3.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                 gas gas_remaining wei
                args stor1, address(arg1), _238, _226, 0, 0, address(this.address), block.timestamp + 60
            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _302 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 96
            require mem[_302] == mem[_302]
            require mem[_302 + 32] == mem[_302 + 32]
            require mem[_302 + 64] == mem[_302 + 64]
            mem[0] = address(arg1)
            mem[32] = 9
            mem[mem[64] + 4] = this.address
            require ext_code.size(stor9[address(arg1)])
            staticcall stor9[address(arg1)].0x70a08231 with:
                    gas gas_remaining wei
                   args address(this.address)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _344 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _350 = mem[_344]
            require mem[_344] == mem[_344]
            mem[0] = stor9[address(arg1)]
            mem[32] = 11
            mem[mem[64] + 4] = stor11[stor9[address(arg1)]]
            mem[mem[64] + 36] = _350
            require ext_code.size(stor9[address(arg1)])
            call stor9[address(arg1)].approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args stor11[stor9[address(arg1)]], _350
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _374 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_374] == bool(mem[_374])
            require ext_code.size(stor11[stor9[address(arg1)]])
            staticcall stor11[stor9[address(arg1)]].bondPrice() with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _398 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _404 = mem[_398]
            require mem[_398] == mem[_398]
            require ext_code.size(stor11[stor9[address(arg1)]])
            staticcall stor11[stor9[address(arg1)]].bondInfo(address arg1) with:
                    gas gas_remaining wei
                   args msg.sender
            mem[mem[64] len 128] = ext_call.return_data[0 len 128]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _422 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 128
            _428 = mem[_422]
            require mem[_422] == mem[_422]
            require mem[_422 + 32] == mem[_422 + 32]
            require mem[_422 + 64] == mem[_422 + 92 len 4]
            require mem[_422 + 96] == mem[_422 + 124 len 4]
            mem[mem[64] + 4] = _350
            mem[mem[64] + 36] = _404
            mem[mem[64] + 68] = msg.sender
            require ext_code.size(stor11[stor9[address(arg1)]])
            call stor11[stor9[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                 gas gas_remaining wei
                args _350, _404, msg.sender
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _464 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_464] == mem[_464]
            require ext_code.size(stor11[stor9[address(arg1)]])
            staticcall stor11[stor9[address(arg1)]].bondInfo(address arg1) with:
                    gas gas_remaining wei
                   args msg.sender
            mem[mem[64] len 128] = ext_call.return_data[0 len 128]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _488 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 128
            require mem[_488] == mem[_488]
            require mem[_488 + 32] == mem[_488 + 32]
            require mem[_488 + 64] == mem[_488 + 92 len 4]
            require mem[_488 + 96] == mem[_488 + 124 len 4]
            if mem[_488] < _428:
                revert with 'NH{q', 17
            mem[mem[64]] = mem[_488] - _428
    else:
        if ext_call.return_data[12 len 20] == stor1:
            if Mask(112, 0, ext_call.return_data[32]) > 0x20d135b66ae990fc484cea55e38a936bcf497445394d4cc984add428823e4d:
                revert with 'NH{q', 17
            if 1000 * Mask(112, 0, ext_call.return_data[32]) and arg2 > -1 / 1000 * Mask(112, 0, ext_call.return_data[32]):
                revert with 'NH{q', 17
            if arg2 / 2 > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                revert with 'NH{q', 17
            if 1994 * arg2 / 2 > (-1997 * Mask(112, 0, ext_call.return_data[32])) - 1:
                revert with 'NH{q', 17
            if arg2 / 2 > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                revert with 'NH{q', 17
            if 997 * arg2 / 2 and arg2 / 2 > -1 / 997 * arg2 / 2:
                revert with 'NH{q', 17
            if 997 * arg2 / 2 * arg2 / 2 > (-1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) - 1:
                revert with 'NH{q', 17
            if not (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])):
                revert with 'NH{q', 18
            if (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                revert with 'NH{q', 17
            if 1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) > (-1997 * Mask(112, 0, ext_call.return_data[32])) - 1:
                revert with 'NH{q', 17
            if (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                revert with 'NH{q', 17
            if 997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) and (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) > -1 / 997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])):
                revert with 'NH{q', 17
            if 997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) > (-1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) - 1:
                revert with 'NH{q', 17
            if not (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])):
                revert with 'NH{q', 18
            if (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                revert with 'NH{q', 17
            if 1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) > (-1997 * Mask(112, 0, ext_call.return_data[32])) - 1:
                revert with 'NH{q', 17
            if (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                revert with 'NH{q', 17
            if 997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) and (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) > -1 / 997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])):
                revert with 'NH{q', 17
            if 997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) > (-1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) - 1:
                revert with 'NH{q', 17
            if not (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])):
                revert with 'NH{q', 18
            require address(arg1)
            mem[(6 * ceil32(return_data.size)) + 100] = address(arg3)
            mem[(6 * ceil32(return_data.size)) + 132] = (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))
            require ext_code.size(stor1)
            call stor1.approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args address(arg3), (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))
            mem[(6 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == bool(ext_call.return_data[0])
            mem[(7 * ceil32(return_data.size)) + 96] = 2
            mem[(7 * ceil32(return_data.size)) + 128] = stor1
            mem[(7 * ceil32(return_data.size)) + 160] = address(arg1)
            if block.timestamp > -61:
                revert with 'NH{q', 17
            mem[(7 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
            mem[(7 * ceil32(return_data.size)) + 196] = (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))
            mem[(7 * ceil32(return_data.size)) + 228] = 0
            mem[(7 * ceil32(return_data.size)) + 260] = 160
            mem[(7 * ceil32(return_data.size)) + 356] = 2
            idx = 0
            s = (7 * ceil32(return_data.size)) + 128
            t = (7 * ceil32(return_data.size)) + 388
            while idx < 2:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[(7 * ceil32(return_data.size)) + 292] = this.address
            mem[(7 * ceil32(return_data.size)) + 324] = block.timestamp + 60
            require ext_code.size(address(arg3))
            call address(arg3).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                 gas gas_remaining wei
                args (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])), 0, 160, address(this.address), block.timestamp + 60, 2, mem[(7 * ceil32(return_data.size)) + 388 len 64]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[(7 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = (8 * ceil32(return_data.size)) + 192
            require return_data.size >= 32
            _102 = mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32
            require mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 <= test266151307()
            require (7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 + 223 < (7 * ceil32(return_data.size)) + return_data.size + 192
            _105 = mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 + 192]
            if mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 + 192] > test266151307():
                revert with 'NH{q', 65
            if (8 * ceil32(return_data.size)) + floor32(mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 + 192]) + 193 > test266151307() or floor32(mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 + 192]) + 1 < 0:
                revert with 'NH{q', 65
            mem[64] = (8 * ceil32(return_data.size)) + floor32(mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 + 192]) + 193
            mem[(8 * ceil32(return_data.size)) + 192] = _105
            require _102 + (32 * _105) + 32 <= return_data.size
            idx = 0
            s = (7 * ceil32(return_data.size)) + _102 + 224
            t = (8 * ceil32(return_data.size)) + 224
            while idx < _105:
                require mem[s] == mem[s]
                mem[t] = mem[s]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[mem[64] + 4] = this.address
            require ext_code.size(address(arg1))
            staticcall address(arg1).0x70a08231 with:
                    gas gas_remaining wei
                   args address(this.address)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _225 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _228 = mem[_225]
            require mem[_225] == mem[_225]
            mem[mem[64] + 4] = this.address
            require ext_code.size(stor1)
            staticcall stor1.0x70a08231 with:
                    gas gas_remaining wei
                   args address(this.address)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _237 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _240 = mem[_237]
            require mem[_237] == mem[_237]
            if address(arg1) == stor2:
                mem[mem[64] + 4] = stor4
                mem[mem[64] + 36] = _228
                require ext_code.size(address(arg1))
                call address(arg1).approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor4, _228
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _257 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_257] == bool(mem[_257])
                mem[mem[64] + 4] = stor4
                mem[mem[64] + 36] = _240
                require ext_code.size(stor1)
                call stor1.approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor4, _240
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _281 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_281] == bool(mem[_281])
                if block.timestamp > -61:
                    revert with 'NH{q', 17
                mem[mem[64] + 68] = _240
                mem[mem[64] + 100] = _228
                mem[mem[64] + 132] = 0
                mem[mem[64] + 164] = 0
                mem[mem[64] + 196] = this.address
                mem[mem[64] + 228] = block.timestamp + 60
                require ext_code.size(stor4)
                call stor4.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                     gas gas_remaining wei
                    args stor1, address(arg1), _240, _228, 0, 0, address(this.address), block.timestamp + 60
                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _305 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 96
                require mem[_305] == mem[_305]
                require mem[_305 + 32] == mem[_305 + 32]
                require mem[_305 + 64] == mem[_305 + 64]
                mem[0] = address(arg1)
                mem[32] = 9
                mem[mem[64] + 4] = this.address
                require ext_code.size(stor9[address(arg1)])
                staticcall stor9[address(arg1)].0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _347 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _353 = mem[_347]
                require mem[_347] == mem[_347]
                mem[0] = stor9[address(arg1)]
                mem[32] = 11
                mem[mem[64] + 4] = stor11[stor9[address(arg1)]]
                mem[mem[64] + 36] = _353
                require ext_code.size(stor9[address(arg1)])
                call stor9[address(arg1)].approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor11[stor9[address(arg1)]], _353
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _377 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_377] == bool(mem[_377])
                require ext_code.size(stor11[stor9[address(arg1)]])
                staticcall stor11[stor9[address(arg1)]].bondPrice() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _401 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _407 = mem[_401]
                require mem[_401] == mem[_401]
                require ext_code.size(stor11[stor9[address(arg1)]])
                staticcall stor11[stor9[address(arg1)]].bondInfo(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _425 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 128
                _431 = mem[_425]
                require mem[_425] == mem[_425]
                require mem[_425 + 32] == mem[_425 + 32]
                require mem[_425 + 64] == mem[_425 + 92 len 4]
                require mem[_425 + 96] == mem[_425 + 124 len 4]
                mem[mem[64] + 4] = _353
                mem[mem[64] + 36] = _407
                mem[mem[64] + 68] = msg.sender
                require ext_code.size(stor11[stor9[address(arg1)]])
                call stor11[stor9[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                     gas gas_remaining wei
                    args _353, _407, msg.sender
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _467 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_467] == mem[_467]
                require ext_code.size(stor11[stor9[address(arg1)]])
                staticcall stor11[stor9[address(arg1)]].bondInfo(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _491 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 128
                require mem[_491] == mem[_491]
                require mem[_491 + 32] == mem[_491 + 32]
                require mem[_491 + 64] == mem[_491 + 92 len 4]
                require mem[_491 + 96] == mem[_491 + 124 len 4]
                if mem[_491] < _431:
                    revert with 'NH{q', 17
                mem[mem[64]] = mem[_491] - _431
            else:
                mem[mem[64] + 4] = stor3
                mem[mem[64] + 36] = _228
                require ext_code.size(address(arg1))
                call address(arg1).approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor3, _228
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _258 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_258] == bool(mem[_258])
                mem[mem[64] + 4] = stor3
                mem[mem[64] + 36] = _240
                require ext_code.size(stor1)
                call stor1.approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor3, _240
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _282 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_282] == bool(mem[_282])
                if block.timestamp > -61:
                    revert with 'NH{q', 17
                mem[mem[64] + 68] = _240
                mem[mem[64] + 100] = _228
                mem[mem[64] + 132] = 0
                mem[mem[64] + 164] = 0
                mem[mem[64] + 196] = this.address
                mem[mem[64] + 228] = block.timestamp + 60
                require ext_code.size(stor3)
                call stor3.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                     gas gas_remaining wei
                    args stor1, address(arg1), _240, _228, 0, 0, address(this.address), block.timestamp + 60
                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _306 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 96
                require mem[_306] == mem[_306]
                require mem[_306 + 32] == mem[_306 + 32]
                require mem[_306 + 64] == mem[_306 + 64]
                mem[0] = address(arg1)
                mem[32] = 9
                mem[mem[64] + 4] = this.address
                require ext_code.size(stor9[address(arg1)])
                staticcall stor9[address(arg1)].0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _348 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _354 = mem[_348]
                require mem[_348] == mem[_348]
                mem[0] = stor9[address(arg1)]
                mem[32] = 11
                mem[mem[64] + 4] = stor11[stor9[address(arg1)]]
                mem[mem[64] + 36] = _354
                require ext_code.size(stor9[address(arg1)])
                call stor9[address(arg1)].approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor11[stor9[address(arg1)]], _354
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _378 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_378] == bool(mem[_378])
                require ext_code.size(stor11[stor9[address(arg1)]])
                staticcall stor11[stor9[address(arg1)]].bondPrice() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _402 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _408 = mem[_402]
                require mem[_402] == mem[_402]
                require ext_code.size(stor11[stor9[address(arg1)]])
                staticcall stor11[stor9[address(arg1)]].bondInfo(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _426 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 128
                _432 = mem[_426]
                require mem[_426] == mem[_426]
                require mem[_426 + 32] == mem[_426 + 32]
                require mem[_426 + 64] == mem[_426 + 92 len 4]
                require mem[_426 + 96] == mem[_426 + 124 len 4]
                mem[mem[64] + 4] = _354
                mem[mem[64] + 36] = _408
                mem[mem[64] + 68] = msg.sender
                require ext_code.size(stor11[stor9[address(arg1)]])
                call stor11[stor9[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                     gas gas_remaining wei
                    args _354, _408, msg.sender
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _468 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_468] == mem[_468]
                require ext_code.size(stor11[stor9[address(arg1)]])
                staticcall stor11[stor9[address(arg1)]].bondInfo(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _492 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 128
                require mem[_492] == mem[_492]
                require mem[_492 + 32] == mem[_492 + 32]
                require mem[_492 + 64] == mem[_492 + 92 len 4]
                require mem[_492 + 96] == mem[_492 + 124 len 4]
                if mem[_492] < _432:
                    revert with 'NH{q', 17
                mem[mem[64]] = mem[_492] - _432
        else:
            if ext_call.return_data[12 len 20] != address(arg1):
                revert with 0, 'bad LP token'
            if address(ext_call.return_data[0]) != stor1:
                revert with 0, 'bad LP token'
            if Mask(112, 0, ext_call.return_data[0]) > 0x20d135b66ae990fc484cea55e38a936bcf497445394d4cc984add428823e4d:
                revert with 'NH{q', 17
            if 1000 * Mask(112, 0, ext_call.return_data[0]) and arg2 > -1 / 1000 * Mask(112, 0, ext_call.return_data[0]):
                revert with 'NH{q', 17
            if arg2 / 2 > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                revert with 'NH{q', 17
            if 1994 * arg2 / 2 > (-1997 * Mask(112, 0, ext_call.return_data[0])) - 1:
                revert with 'NH{q', 17
            if arg2 / 2 > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                revert with 'NH{q', 17
            if 997 * arg2 / 2 and arg2 / 2 > -1 / 997 * arg2 / 2:
                revert with 'NH{q', 17
            if 997 * arg2 / 2 * arg2 / 2 > (-1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) - 1:
                revert with 'NH{q', 17
            if not (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])):
                revert with 'NH{q', 18
            if (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                revert with 'NH{q', 17
            if 1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) > (-1997 * Mask(112, 0, ext_call.return_data[0])) - 1:
                revert with 'NH{q', 17
            if (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                revert with 'NH{q', 17
            if 997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) and (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) > -1 / 997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])):
                revert with 'NH{q', 17
            if 997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) > (-1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) - 1:
                revert with 'NH{q', 17
            if not (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])):
                revert with 'NH{q', 18
            if (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                revert with 'NH{q', 17
            if 1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) > (-1997 * Mask(112, 0, ext_call.return_data[0])) - 1:
                revert with 'NH{q', 17
            if (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                revert with 'NH{q', 17
            if 997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) and (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) > -1 / 997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])):
                revert with 'NH{q', 17
            if 997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) > (-1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) - 1:
                revert with 'NH{q', 17
            if not (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])):
                revert with 'NH{q', 18
            require address(arg1)
            mem[(6 * ceil32(return_data.size)) + 100] = address(arg3)
            mem[(6 * ceil32(return_data.size)) + 132] = (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))
            require ext_code.size(stor1)
            call stor1.approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args address(arg3), (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))
            mem[(6 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == bool(ext_call.return_data[0])
            mem[(7 * ceil32(return_data.size)) + 96] = 2
            mem[(7 * ceil32(return_data.size)) + 128] = stor1
            mem[(7 * ceil32(return_data.size)) + 160] = address(arg1)
            if block.timestamp > -61:
                revert with 'NH{q', 17
            mem[(7 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
            mem[(7 * ceil32(return_data.size)) + 196] = (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))
            mem[(7 * ceil32(return_data.size)) + 228] = 0
            mem[(7 * ceil32(return_data.size)) + 260] = 160
            mem[(7 * ceil32(return_data.size)) + 356] = 2
            idx = 0
            s = (7 * ceil32(return_data.size)) + 128
            t = (7 * ceil32(return_data.size)) + 388
            while idx < 2:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[(7 * ceil32(return_data.size)) + 292] = this.address
            mem[(7 * ceil32(return_data.size)) + 324] = block.timestamp + 60
            require ext_code.size(address(arg3))
            call address(arg3).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                 gas gas_remaining wei
                args (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])), 0, 160, address(this.address), block.timestamp + 60, 2, mem[(7 * ceil32(return_data.size)) + 388 len 64]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[(7 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = (8 * ceil32(return_data.size)) + 192
            require return_data.size >= 32
            _101 = mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32
            require mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 <= test266151307()
            require (7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 223 < (7 * ceil32(return_data.size)) + return_data.size + 192
            _104 = mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]
            if mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192] > test266151307():
                revert with 'NH{q', 65
            if (8 * ceil32(return_data.size)) + floor32(mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]) + 193 > test266151307() or floor32(mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]) + 1 < 0:
                revert with 'NH{q', 65
            mem[64] = (8 * ceil32(return_data.size)) + floor32(mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]) + 193
            mem[(8 * ceil32(return_data.size)) + 192] = _104
            require _101 + (32 * _104) + 32 <= return_data.size
            idx = 0
            s = (7 * ceil32(return_data.size)) + _101 + 224
            t = (8 * ceil32(return_data.size)) + 224
            while idx < _104:
                require mem[s] == mem[s]
                mem[t] = mem[s]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[mem[64] + 4] = this.address
            require ext_code.size(address(arg1))
            staticcall address(arg1).0x70a08231 with:
                    gas gas_remaining wei
                   args address(this.address)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _224 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _227 = mem[_224]
            require mem[_224] == mem[_224]
            mem[mem[64] + 4] = this.address
            require ext_code.size(stor1)
            staticcall stor1.0x70a08231 with:
                    gas gas_remaining wei
                   args address(this.address)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _236 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _239 = mem[_236]
            require mem[_236] == mem[_236]
            if address(arg1) == stor2:
                mem[mem[64] + 4] = stor4
                mem[mem[64] + 36] = _227
                require ext_code.size(address(arg1))
                call address(arg1).approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor4, _227
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _255 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_255] == bool(mem[_255])
                mem[mem[64] + 4] = stor4
                mem[mem[64] + 36] = _239
                require ext_code.size(stor1)
                call stor1.approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor4, _239
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _279 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_279] == bool(mem[_279])
                if block.timestamp > -61:
                    revert with 'NH{q', 17
                mem[mem[64] + 68] = _239
                mem[mem[64] + 100] = _227
                mem[mem[64] + 132] = 0
                mem[mem[64] + 164] = 0
                mem[mem[64] + 196] = this.address
                mem[mem[64] + 228] = block.timestamp + 60
                require ext_code.size(stor4)
                call stor4.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                     gas gas_remaining wei
                    args stor1, address(arg1), _239, _227, 0, 0, address(this.address), block.timestamp + 60
                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _303 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 96
                require mem[_303] == mem[_303]
                require mem[_303 + 32] == mem[_303 + 32]
                require mem[_303 + 64] == mem[_303 + 64]
                mem[0] = address(arg1)
                mem[32] = 9
                mem[mem[64] + 4] = this.address
                require ext_code.size(stor9[address(arg1)])
                staticcall stor9[address(arg1)].0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _345 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _351 = mem[_345]
                require mem[_345] == mem[_345]
                mem[0] = stor9[address(arg1)]
                mem[32] = 11
                mem[mem[64] + 4] = stor11[stor9[address(arg1)]]
                mem[mem[64] + 36] = _351
                require ext_code.size(stor9[address(arg1)])
                call stor9[address(arg1)].approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor11[stor9[address(arg1)]], _351
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _375 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_375] == bool(mem[_375])
                require ext_code.size(stor11[stor9[address(arg1)]])
                staticcall stor11[stor9[address(arg1)]].bondPrice() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _399 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _405 = mem[_399]
                require mem[_399] == mem[_399]
                require ext_code.size(stor11[stor9[address(arg1)]])
                staticcall stor11[stor9[address(arg1)]].bondInfo(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _423 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 128
                _429 = mem[_423]
                require mem[_423] == mem[_423]
                require mem[_423 + 32] == mem[_423 + 32]
                require mem[_423 + 64] == mem[_423 + 92 len 4]
                require mem[_423 + 96] == mem[_423 + 124 len 4]
                mem[mem[64] + 4] = _351
                mem[mem[64] + 36] = _405
                mem[mem[64] + 68] = msg.sender
                require ext_code.size(stor11[stor9[address(arg1)]])
                call stor11[stor9[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                     gas gas_remaining wei
                    args _351, _405, msg.sender
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _465 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_465] == mem[_465]
                require ext_code.size(stor11[stor9[address(arg1)]])
                staticcall stor11[stor9[address(arg1)]].bondInfo(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _489 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 128
                require mem[_489] == mem[_489]
                require mem[_489 + 32] == mem[_489 + 32]
                require mem[_489 + 64] == mem[_489 + 92 len 4]
                require mem[_489 + 96] == mem[_489 + 124 len 4]
                if mem[_489] < _429:
                    revert with 'NH{q', 17
                mem[mem[64]] = mem[_489] - _429
            else:
                mem[mem[64] + 4] = stor3
                mem[mem[64] + 36] = _227
                require ext_code.size(address(arg1))
                call address(arg1).approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor3, _227
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _256 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_256] == bool(mem[_256])
                mem[mem[64] + 4] = stor3
                mem[mem[64] + 36] = _239
                require ext_code.size(stor1)
                call stor1.approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor3, _239
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _280 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_280] == bool(mem[_280])
                if block.timestamp > -61:
                    revert with 'NH{q', 17
                mem[mem[64] + 68] = _239
                mem[mem[64] + 100] = _227
                mem[mem[64] + 132] = 0
                mem[mem[64] + 164] = 0
                mem[mem[64] + 196] = this.address
                mem[mem[64] + 228] = block.timestamp + 60
                require ext_code.size(stor3)
                call stor3.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                     gas gas_remaining wei
                    args stor1, address(arg1), _239, _227, 0, 0, address(this.address), block.timestamp + 60
                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _304 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 96
                require mem[_304] == mem[_304]
                require mem[_304 + 32] == mem[_304 + 32]
                require mem[_304 + 64] == mem[_304 + 64]
                mem[0] = address(arg1)
                mem[32] = 9
                mem[mem[64] + 4] = this.address
                require ext_code.size(stor9[address(arg1)])
                staticcall stor9[address(arg1)].0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _346 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _352 = mem[_346]
                require mem[_346] == mem[_346]
                mem[0] = stor9[address(arg1)]
                mem[32] = 11
                mem[mem[64] + 4] = stor11[stor9[address(arg1)]]
                mem[mem[64] + 36] = _352
                require ext_code.size(stor9[address(arg1)])
                call stor9[address(arg1)].approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor11[stor9[address(arg1)]], _352
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _376 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_376] == bool(mem[_376])
                require ext_code.size(stor11[stor9[address(arg1)]])
                staticcall stor11[stor9[address(arg1)]].bondPrice() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _400 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _406 = mem[_400]
                require mem[_400] == mem[_400]
                require ext_code.size(stor11[stor9[address(arg1)]])
                staticcall stor11[stor9[address(arg1)]].bondInfo(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _424 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 128
                _430 = mem[_424]
                require mem[_424] == mem[_424]
                require mem[_424 + 32] == mem[_424 + 32]
                require mem[_424 + 64] == mem[_424 + 92 len 4]
                require mem[_424 + 96] == mem[_424 + 124 len 4]
                mem[mem[64] + 4] = _352
                mem[mem[64] + 36] = _406
                mem[mem[64] + 68] = msg.sender
                require ext_code.size(stor11[stor9[address(arg1)]])
                call stor11[stor9[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                     gas gas_remaining wei
                    args _352, _406, msg.sender
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _466 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_466] == mem[_466]
                require ext_code.size(stor11[stor9[address(arg1)]])
                staticcall stor11[stor9[address(arg1)]].bondInfo(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _490 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 128
                require mem[_490] == mem[_490]
                require mem[_490 + 32] == mem[_490 + 32]
                require mem[_490 + 64] == mem[_490 + 92 len 4]
                require mem[_490 + 96] == mem[_490 + 124 len 4]
                if mem[_490] < _430:
                    revert with 'NH{q', 17
                mem[mem[64]] = mem[_490] - _430
    return memory
      from mem[64]
       len 32
}

function sub_e6035c7e(?) payable {
    require calldata.size - 4 >= 128
    require arg1 == address(arg1)
    require arg2 == arg2
    require arg3 == address(arg3)
    require arg4 == address(arg4)
    mem[100] = msg.sender
    mem[132] = this.address
    mem[164] = arg2
    require ext_code.size(stor1)
    call stor1.0x23b872dd with:
         gas gas_remaining wei
        args msg.sender, address(this.address), arg2
    mem[96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    mem[0] = address(arg1)
    mem[32] = 9
    require stor9[address(arg1)]
    require ext_code.size(stor9[address(arg1)])
    staticcall stor9[address(arg1)].getReserves() with:
            gas gas_remaining wei
    mem[ceil32(return_data.size) + 96 len 96] = ext_call.return_data[0 len 96]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 96
    require ext_call.return_data[0] == ext_call.return_data[18 len 14]
    require ext_call.return_data[32] == ext_call.return_data[50 len 14]
    require ext_call.return_data[64] == ext_call.return_data[92 len 4]
    require ext_code.size(stor9[address(arg1)])
    staticcall stor9[address(arg1)].token0() with:
            gas gas_remaining wei
    mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    require ext_code.size(stor9[address(arg1)])
    staticcall stor9[address(arg1)].token1() with:
            gas gas_remaining wei
    mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    if address(ext_call.return_data[0]) != address(arg1):
        if ext_call.return_data[12 len 20] != address(arg1):
            revert with 0, 'bad LP token'
        if address(ext_call.return_data[0]) != stor1:
            revert with 0, 'bad LP token'
        if Mask(112, 0, ext_call.return_data[0]) > 0x20d135b66ae990fc484cea55e38a936bcf497445394d4cc984add428823e4d:
            revert with 'NH{q', 17
        if 1000 * Mask(112, 0, ext_call.return_data[0]) and arg2 > -1 / 1000 * Mask(112, 0, ext_call.return_data[0]):
            revert with 'NH{q', 17
        if arg2 / 2 > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
            revert with 'NH{q', 17
        if 1994 * arg2 / 2 > (-1997 * Mask(112, 0, ext_call.return_data[0])) - 1:
            revert with 'NH{q', 17
        if arg2 / 2 > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
            revert with 'NH{q', 17
        if 997 * arg2 / 2 and arg2 / 2 > -1 / 997 * arg2 / 2:
            revert with 'NH{q', 17
        if 997 * arg2 / 2 * arg2 / 2 > (-1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) - 1:
            revert with 'NH{q', 17
        if not (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])):
            revert with 'NH{q', 18
        if (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
            revert with 'NH{q', 17
        if 1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) > (-1997 * Mask(112, 0, ext_call.return_data[0])) - 1:
            revert with 'NH{q', 17
        if (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
            revert with 'NH{q', 17
        if 997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) and (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) > -1 / 997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])):
            revert with 'NH{q', 17
        if 997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) > (-1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) - 1:
            revert with 'NH{q', 17
        if not (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])):
            revert with 'NH{q', 18
        if (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
            revert with 'NH{q', 17
        if 1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) > (-1997 * Mask(112, 0, ext_call.return_data[0])) - 1:
            revert with 'NH{q', 17
        if (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
            revert with 'NH{q', 17
        if 997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) and (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) > -1 / 997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])):
            revert with 'NH{q', 17
        if 997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) > (-1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) - 1:
            revert with 'NH{q', 17
        if not (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])):
            revert with 'NH{q', 18
        require address(arg1)
        mem[(6 * ceil32(return_data.size)) + 100] = address(arg3)
        mem[(6 * ceil32(return_data.size)) + 132] = (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))
        require ext_code.size(stor1)
        call stor1.approve(address arg1, uint256 arg2) with:
             gas gas_remaining wei
            args address(arg3), (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))
        mem[(6 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == bool(ext_call.return_data[0])
        mem[(7 * ceil32(return_data.size)) + 96] = 3
        mem[(7 * ceil32(return_data.size)) + 128] = stor1
        mem[(7 * ceil32(return_data.size)) + 160] = address(arg4)
        mem[(7 * ceil32(return_data.size)) + 192] = address(arg1)
        if block.timestamp > -61:
            revert with 'NH{q', 17
        mem[(7 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
        mem[(7 * ceil32(return_data.size)) + 228] = (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))
        mem[(7 * ceil32(return_data.size)) + 260] = 0
        mem[(7 * ceil32(return_data.size)) + 292] = 160
        mem[(7 * ceil32(return_data.size)) + 388] = 3
        idx = 0
        s = (7 * ceil32(return_data.size)) + 128
        t = (7 * ceil32(return_data.size)) + 420
        while idx < 3:
            mem[t] = mem[s + 12 len 20]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        mem[(7 * ceil32(return_data.size)) + 324] = this.address
        mem[(7 * ceil32(return_data.size)) + 356] = block.timestamp + 60
        require ext_code.size(address(arg3))
        call address(arg3).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
             gas gas_remaining wei
            args (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])), 0, 160, address(this.address), block.timestamp + 60, 3, mem[(7 * ceil32(return_data.size)) + 420 len 96]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        mem[(7 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = (8 * ceil32(return_data.size)) + 224
        require return_data.size >= 32
        _98 = mem[(7 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32
        require mem[(7 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 <= test266151307()
        require (7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 255 < (7 * ceil32(return_data.size)) + return_data.size + 224
        _101 = mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 224]
        if mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 224] > test266151307():
            revert with 'NH{q', 65
        if (8 * ceil32(return_data.size)) + floor32(mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 224]) + 225 > test266151307() or floor32(mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 224]) + 1 < 0:
            revert with 'NH{q', 65
        mem[64] = (8 * ceil32(return_data.size)) + floor32(mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 224]) + 225
        mem[(8 * ceil32(return_data.size)) + 224] = _101
        require _98 + (32 * _101) + 32 <= return_data.size
        idx = 0
        s = (7 * ceil32(return_data.size)) + _98 + 256
        t = (8 * ceil32(return_data.size)) + 256
        while idx < _101:
            require mem[s] == mem[s]
            mem[t] = mem[s]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        mem[mem[64] + 4] = this.address
        require ext_code.size(address(arg1))
        staticcall address(arg1).0x70a08231 with:
                gas gas_remaining wei
               args address(this.address)
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _221 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _224 = mem[_221]
        require mem[_221] == mem[_221]
        mem[mem[64] + 4] = this.address
        require ext_code.size(stor1)
        staticcall stor1.0x70a08231 with:
                gas gas_remaining wei
               args address(this.address)
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _233 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _236 = mem[_233]
        require mem[_233] == mem[_233]
        if address(arg1) == stor2:
            mem[mem[64] + 4] = stor4
            mem[mem[64] + 36] = _224
            require ext_code.size(address(arg1))
            call address(arg1).approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args stor4, _224
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _251 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_251] == bool(mem[_251])
            mem[mem[64] + 4] = stor4
            mem[mem[64] + 36] = _236
            require ext_code.size(stor1)
            call stor1.approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args stor4, _236
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _275 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_275] == bool(mem[_275])
            if block.timestamp > -61:
                revert with 'NH{q', 17
            mem[mem[64] + 68] = _236
            mem[mem[64] + 100] = _224
            mem[mem[64] + 132] = 0
            mem[mem[64] + 164] = 0
            mem[mem[64] + 196] = this.address
            mem[mem[64] + 228] = block.timestamp + 60
            require ext_code.size(stor4)
            call stor4.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                 gas gas_remaining wei
                args stor1, address(arg1), _236, _224, 0, 0, address(this.address), block.timestamp + 60
            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _299 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 96
            require mem[_299] == mem[_299]
            require mem[_299 + 32] == mem[_299 + 32]
            require mem[_299 + 64] == mem[_299 + 64]
            mem[0] = address(arg1)
            mem[32] = 9
            mem[mem[64] + 4] = this.address
            require ext_code.size(stor9[address(arg1)])
            staticcall stor9[address(arg1)].0x70a08231 with:
                    gas gas_remaining wei
                   args address(this.address)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _341 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _347 = mem[_341]
            require mem[_341] == mem[_341]
            mem[0] = stor9[address(arg1)]
            mem[32] = 11
            mem[mem[64] + 4] = stor11[stor9[address(arg1)]]
            mem[mem[64] + 36] = _347
            require ext_code.size(stor9[address(arg1)])
            call stor9[address(arg1)].approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args stor11[stor9[address(arg1)]], _347
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _371 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_371] == bool(mem[_371])
            require ext_code.size(stor11[stor9[address(arg1)]])
            staticcall stor11[stor9[address(arg1)]].bondPrice() with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _395 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _401 = mem[_395]
            require mem[_395] == mem[_395]
            require ext_code.size(stor11[stor9[address(arg1)]])
            staticcall stor11[stor9[address(arg1)]].bondInfo(address arg1) with:
                    gas gas_remaining wei
                   args msg.sender
            mem[mem[64] len 128] = ext_call.return_data[0 len 128]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _419 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 128
            _425 = mem[_419]
            require mem[_419] == mem[_419]
            require mem[_419 + 32] == mem[_419 + 32]
            require mem[_419 + 64] == mem[_419 + 92 len 4]
            require mem[_419 + 96] == mem[_419 + 124 len 4]
            mem[mem[64] + 4] = _347
            mem[mem[64] + 36] = _401
            mem[mem[64] + 68] = msg.sender
            require ext_code.size(stor11[stor9[address(arg1)]])
            call stor11[stor9[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                 gas gas_remaining wei
                args _347, _401, msg.sender
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _461 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_461] == mem[_461]
            require ext_code.size(stor11[stor9[address(arg1)]])
            staticcall stor11[stor9[address(arg1)]].bondInfo(address arg1) with:
                    gas gas_remaining wei
                   args msg.sender
            mem[mem[64] len 128] = ext_call.return_data[0 len 128]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _485 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 128
            require mem[_485] == mem[_485]
            require mem[_485 + 32] == mem[_485 + 32]
            require mem[_485 + 64] == mem[_485 + 92 len 4]
            require mem[_485 + 96] == mem[_485 + 124 len 4]
            if mem[_485] < _425:
                revert with 'NH{q', 17
            mem[mem[64]] = mem[_485] - _425
        else:
            mem[mem[64] + 4] = stor3
            mem[mem[64] + 36] = _224
            require ext_code.size(address(arg1))
            call address(arg1).approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args stor3, _224
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _252 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_252] == bool(mem[_252])
            mem[mem[64] + 4] = stor3
            mem[mem[64] + 36] = _236
            require ext_code.size(stor1)
            call stor1.approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args stor3, _236
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _276 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_276] == bool(mem[_276])
            if block.timestamp > -61:
                revert with 'NH{q', 17
            mem[mem[64] + 68] = _236
            mem[mem[64] + 100] = _224
            mem[mem[64] + 132] = 0
            mem[mem[64] + 164] = 0
            mem[mem[64] + 196] = this.address
            mem[mem[64] + 228] = block.timestamp + 60
            require ext_code.size(stor3)
            call stor3.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                 gas gas_remaining wei
                args stor1, address(arg1), _236, _224, 0, 0, address(this.address), block.timestamp + 60
            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _300 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 96
            require mem[_300] == mem[_300]
            require mem[_300 + 32] == mem[_300 + 32]
            require mem[_300 + 64] == mem[_300 + 64]
            mem[0] = address(arg1)
            mem[32] = 9
            mem[mem[64] + 4] = this.address
            require ext_code.size(stor9[address(arg1)])
            staticcall stor9[address(arg1)].0x70a08231 with:
                    gas gas_remaining wei
                   args address(this.address)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _342 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _348 = mem[_342]
            require mem[_342] == mem[_342]
            mem[0] = stor9[address(arg1)]
            mem[32] = 11
            mem[mem[64] + 4] = stor11[stor9[address(arg1)]]
            mem[mem[64] + 36] = _348
            require ext_code.size(stor9[address(arg1)])
            call stor9[address(arg1)].approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args stor11[stor9[address(arg1)]], _348
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _372 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_372] == bool(mem[_372])
            require ext_code.size(stor11[stor9[address(arg1)]])
            staticcall stor11[stor9[address(arg1)]].bondPrice() with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _396 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _402 = mem[_396]
            require mem[_396] == mem[_396]
            require ext_code.size(stor11[stor9[address(arg1)]])
            staticcall stor11[stor9[address(arg1)]].bondInfo(address arg1) with:
                    gas gas_remaining wei
                   args msg.sender
            mem[mem[64] len 128] = ext_call.return_data[0 len 128]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _420 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 128
            _426 = mem[_420]
            require mem[_420] == mem[_420]
            require mem[_420 + 32] == mem[_420 + 32]
            require mem[_420 + 64] == mem[_420 + 92 len 4]
            require mem[_420 + 96] == mem[_420 + 124 len 4]
            mem[mem[64] + 4] = _348
            mem[mem[64] + 36] = _402
            mem[mem[64] + 68] = msg.sender
            require ext_code.size(stor11[stor9[address(arg1)]])
            call stor11[stor9[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                 gas gas_remaining wei
                args _348, _402, msg.sender
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _462 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_462] == mem[_462]
            require ext_code.size(stor11[stor9[address(arg1)]])
            staticcall stor11[stor9[address(arg1)]].bondInfo(address arg1) with:
                    gas gas_remaining wei
                   args msg.sender
            mem[mem[64] len 128] = ext_call.return_data[0 len 128]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _486 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 128
            require mem[_486] == mem[_486]
            require mem[_486 + 32] == mem[_486 + 32]
            require mem[_486 + 64] == mem[_486 + 92 len 4]
            require mem[_486 + 96] == mem[_486 + 124 len 4]
            if mem[_486] < _426:
                revert with 'NH{q', 17
            mem[mem[64]] = mem[_486] - _426
    else:
        if ext_call.return_data[12 len 20] == stor1:
            if Mask(112, 0, ext_call.return_data[32]) > 0x20d135b66ae990fc484cea55e38a936bcf497445394d4cc984add428823e4d:
                revert with 'NH{q', 17
            if 1000 * Mask(112, 0, ext_call.return_data[32]) and arg2 > -1 / 1000 * Mask(112, 0, ext_call.return_data[32]):
                revert with 'NH{q', 17
            if arg2 / 2 > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                revert with 'NH{q', 17
            if 1994 * arg2 / 2 > (-1997 * Mask(112, 0, ext_call.return_data[32])) - 1:
                revert with 'NH{q', 17
            if arg2 / 2 > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                revert with 'NH{q', 17
            if 997 * arg2 / 2 and arg2 / 2 > -1 / 997 * arg2 / 2:
                revert with 'NH{q', 17
            if 997 * arg2 / 2 * arg2 / 2 > (-1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) - 1:
                revert with 'NH{q', 17
            if not (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])):
                revert with 'NH{q', 18
            if (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                revert with 'NH{q', 17
            if 1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) > (-1997 * Mask(112, 0, ext_call.return_data[32])) - 1:
                revert with 'NH{q', 17
            if (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                revert with 'NH{q', 17
            if 997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) and (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) > -1 / 997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])):
                revert with 'NH{q', 17
            if 997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) > (-1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) - 1:
                revert with 'NH{q', 17
            if not (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])):
                revert with 'NH{q', 18
            if (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                revert with 'NH{q', 17
            if 1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) > (-1997 * Mask(112, 0, ext_call.return_data[32])) - 1:
                revert with 'NH{q', 17
            if (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                revert with 'NH{q', 17
            if 997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) and (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) > -1 / 997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])):
                revert with 'NH{q', 17
            if 997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) > (-1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) - 1:
                revert with 'NH{q', 17
            if not (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])):
                revert with 'NH{q', 18
            require address(arg1)
            mem[(6 * ceil32(return_data.size)) + 100] = address(arg3)
            mem[(6 * ceil32(return_data.size)) + 132] = (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))
            require ext_code.size(stor1)
            call stor1.approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args address(arg3), (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))
            mem[(6 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == bool(ext_call.return_data[0])
            mem[(7 * ceil32(return_data.size)) + 96] = 3
            mem[(7 * ceil32(return_data.size)) + 128] = stor1
            mem[(7 * ceil32(return_data.size)) + 160] = address(arg4)
            mem[(7 * ceil32(return_data.size)) + 192] = address(arg1)
            if block.timestamp > -61:
                revert with 'NH{q', 17
            mem[(7 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
            mem[(7 * ceil32(return_data.size)) + 228] = (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))
            mem[(7 * ceil32(return_data.size)) + 260] = 0
            mem[(7 * ceil32(return_data.size)) + 292] = 160
            mem[(7 * ceil32(return_data.size)) + 388] = 3
            idx = 0
            s = (7 * ceil32(return_data.size)) + 128
            t = (7 * ceil32(return_data.size)) + 420
            while idx < 3:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[(7 * ceil32(return_data.size)) + 324] = this.address
            mem[(7 * ceil32(return_data.size)) + 356] = block.timestamp + 60
            require ext_code.size(address(arg3))
            call address(arg3).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                 gas gas_remaining wei
                args (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])), 0, 160, address(this.address), block.timestamp + 60, 3, mem[(7 * ceil32(return_data.size)) + 420 len 96]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[(7 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = (8 * ceil32(return_data.size)) + 224
            require return_data.size >= 32
            _100 = mem[(7 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32
            require mem[(7 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 <= test266151307()
            require (7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 + 255 < (7 * ceil32(return_data.size)) + return_data.size + 224
            _103 = mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 + 224]
            if mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 + 224] > test266151307():
                revert with 'NH{q', 65
            if (8 * ceil32(return_data.size)) + floor32(mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 + 224]) + 225 > test266151307() or floor32(mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 + 224]) + 1 < 0:
                revert with 'NH{q', 65
            mem[64] = (8 * ceil32(return_data.size)) + floor32(mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 + 224]) + 225
            mem[(8 * ceil32(return_data.size)) + 224] = _103
            require _100 + (32 * _103) + 32 <= return_data.size
            idx = 0
            s = (7 * ceil32(return_data.size)) + _100 + 256
            t = (8 * ceil32(return_data.size)) + 256
            while idx < _103:
                require mem[s] == mem[s]
                mem[t] = mem[s]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[mem[64] + 4] = this.address
            require ext_code.size(address(arg1))
            staticcall address(arg1).0x70a08231 with:
                    gas gas_remaining wei
                   args address(this.address)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _223 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _226 = mem[_223]
            require mem[_223] == mem[_223]
            mem[mem[64] + 4] = this.address
            require ext_code.size(stor1)
            staticcall stor1.0x70a08231 with:
                    gas gas_remaining wei
                   args address(this.address)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _235 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _238 = mem[_235]
            require mem[_235] == mem[_235]
            if address(arg1) == stor2:
                mem[mem[64] + 4] = stor4
                mem[mem[64] + 36] = _226
                require ext_code.size(address(arg1))
                call address(arg1).approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor4, _226
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _255 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_255] == bool(mem[_255])
                mem[mem[64] + 4] = stor4
                mem[mem[64] + 36] = _238
                require ext_code.size(stor1)
                call stor1.approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor4, _238
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _279 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_279] == bool(mem[_279])
                if block.timestamp > -61:
                    revert with 'NH{q', 17
                mem[mem[64] + 68] = _238
                mem[mem[64] + 100] = _226
                mem[mem[64] + 132] = 0
                mem[mem[64] + 164] = 0
                mem[mem[64] + 196] = this.address
                mem[mem[64] + 228] = block.timestamp + 60
                require ext_code.size(stor4)
                call stor4.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                     gas gas_remaining wei
                    args stor1, address(arg1), _238, _226, 0, 0, address(this.address), block.timestamp + 60
                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _303 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 96
                require mem[_303] == mem[_303]
                require mem[_303 + 32] == mem[_303 + 32]
                require mem[_303 + 64] == mem[_303 + 64]
                mem[0] = address(arg1)
                mem[32] = 9
                mem[mem[64] + 4] = this.address
                require ext_code.size(stor9[address(arg1)])
                staticcall stor9[address(arg1)].0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _345 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _351 = mem[_345]
                require mem[_345] == mem[_345]
                mem[0] = stor9[address(arg1)]
                mem[32] = 11
                mem[mem[64] + 4] = stor11[stor9[address(arg1)]]
                mem[mem[64] + 36] = _351
                require ext_code.size(stor9[address(arg1)])
                call stor9[address(arg1)].approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor11[stor9[address(arg1)]], _351
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _375 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_375] == bool(mem[_375])
                require ext_code.size(stor11[stor9[address(arg1)]])
                staticcall stor11[stor9[address(arg1)]].bondPrice() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _399 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _405 = mem[_399]
                require mem[_399] == mem[_399]
                require ext_code.size(stor11[stor9[address(arg1)]])
                staticcall stor11[stor9[address(arg1)]].bondInfo(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _423 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 128
                _429 = mem[_423]
                require mem[_423] == mem[_423]
                require mem[_423 + 32] == mem[_423 + 32]
                require mem[_423 + 64] == mem[_423 + 92 len 4]
                require mem[_423 + 96] == mem[_423 + 124 len 4]
                mem[mem[64] + 4] = _351
                mem[mem[64] + 36] = _405
                mem[mem[64] + 68] = msg.sender
                require ext_code.size(stor11[stor9[address(arg1)]])
                call stor11[stor9[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                     gas gas_remaining wei
                    args _351, _405, msg.sender
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _465 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_465] == mem[_465]
                require ext_code.size(stor11[stor9[address(arg1)]])
                staticcall stor11[stor9[address(arg1)]].bondInfo(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _489 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 128
                require mem[_489] == mem[_489]
                require mem[_489 + 32] == mem[_489 + 32]
                require mem[_489 + 64] == mem[_489 + 92 len 4]
                require mem[_489 + 96] == mem[_489 + 124 len 4]
                if mem[_489] < _429:
                    revert with 'NH{q', 17
                mem[mem[64]] = mem[_489] - _429
            else:
                mem[mem[64] + 4] = stor3
                mem[mem[64] + 36] = _226
                require ext_code.size(address(arg1))
                call address(arg1).approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor3, _226
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _256 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_256] == bool(mem[_256])
                mem[mem[64] + 4] = stor3
                mem[mem[64] + 36] = _238
                require ext_code.size(stor1)
                call stor1.approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor3, _238
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _280 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_280] == bool(mem[_280])
                if block.timestamp > -61:
                    revert with 'NH{q', 17
                mem[mem[64] + 68] = _238
                mem[mem[64] + 100] = _226
                mem[mem[64] + 132] = 0
                mem[mem[64] + 164] = 0
                mem[mem[64] + 196] = this.address
                mem[mem[64] + 228] = block.timestamp + 60
                require ext_code.size(stor3)
                call stor3.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                     gas gas_remaining wei
                    args stor1, address(arg1), _238, _226, 0, 0, address(this.address), block.timestamp + 60
                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _304 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 96
                require mem[_304] == mem[_304]
                require mem[_304 + 32] == mem[_304 + 32]
                require mem[_304 + 64] == mem[_304 + 64]
                mem[0] = address(arg1)
                mem[32] = 9
                mem[mem[64] + 4] = this.address
                require ext_code.size(stor9[address(arg1)])
                staticcall stor9[address(arg1)].0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _346 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _352 = mem[_346]
                require mem[_346] == mem[_346]
                mem[0] = stor9[address(arg1)]
                mem[32] = 11
                mem[mem[64] + 4] = stor11[stor9[address(arg1)]]
                mem[mem[64] + 36] = _352
                require ext_code.size(stor9[address(arg1)])
                call stor9[address(arg1)].approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor11[stor9[address(arg1)]], _352
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _376 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_376] == bool(mem[_376])
                require ext_code.size(stor11[stor9[address(arg1)]])
                staticcall stor11[stor9[address(arg1)]].bondPrice() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _400 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _406 = mem[_400]
                require mem[_400] == mem[_400]
                require ext_code.size(stor11[stor9[address(arg1)]])
                staticcall stor11[stor9[address(arg1)]].bondInfo(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _424 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 128
                _430 = mem[_424]
                require mem[_424] == mem[_424]
                require mem[_424 + 32] == mem[_424 + 32]
                require mem[_424 + 64] == mem[_424 + 92 len 4]
                require mem[_424 + 96] == mem[_424 + 124 len 4]
                mem[mem[64] + 4] = _352
                mem[mem[64] + 36] = _406
                mem[mem[64] + 68] = msg.sender
                require ext_code.size(stor11[stor9[address(arg1)]])
                call stor11[stor9[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                     gas gas_remaining wei
                    args _352, _406, msg.sender
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _466 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_466] == mem[_466]
                require ext_code.size(stor11[stor9[address(arg1)]])
                staticcall stor11[stor9[address(arg1)]].bondInfo(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _490 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 128
                require mem[_490] == mem[_490]
                require mem[_490 + 32] == mem[_490 + 32]
                require mem[_490 + 64] == mem[_490 + 92 len 4]
                require mem[_490 + 96] == mem[_490 + 124 len 4]
                if mem[_490] < _430:
                    revert with 'NH{q', 17
                mem[mem[64]] = mem[_490] - _430
        else:
            if ext_call.return_data[12 len 20] != address(arg1):
                revert with 0, 'bad LP token'
            if address(ext_call.return_data[0]) != stor1:
                revert with 0, 'bad LP token'
            if Mask(112, 0, ext_call.return_data[0]) > 0x20d135b66ae990fc484cea55e38a936bcf497445394d4cc984add428823e4d:
                revert with 'NH{q', 17
            if 1000 * Mask(112, 0, ext_call.return_data[0]) and arg2 > -1 / 1000 * Mask(112, 0, ext_call.return_data[0]):
                revert with 'NH{q', 17
            if arg2 / 2 > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                revert with 'NH{q', 17
            if 1994 * arg2 / 2 > (-1997 * Mask(112, 0, ext_call.return_data[0])) - 1:
                revert with 'NH{q', 17
            if arg2 / 2 > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                revert with 'NH{q', 17
            if 997 * arg2 / 2 and arg2 / 2 > -1 / 997 * arg2 / 2:
                revert with 'NH{q', 17
            if 997 * arg2 / 2 * arg2 / 2 > (-1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) - 1:
                revert with 'NH{q', 17
            if not (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])):
                revert with 'NH{q', 18
            if (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                revert with 'NH{q', 17
            if 1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) > (-1997 * Mask(112, 0, ext_call.return_data[0])) - 1:
                revert with 'NH{q', 17
            if (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                revert with 'NH{q', 17
            if 997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) and (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) > -1 / 997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])):
                revert with 'NH{q', 17
            if 997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) > (-1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) - 1:
                revert with 'NH{q', 17
            if not (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])):
                revert with 'NH{q', 18
            if (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                revert with 'NH{q', 17
            if 1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) > (-1997 * Mask(112, 0, ext_call.return_data[0])) - 1:
                revert with 'NH{q', 17
            if (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                revert with 'NH{q', 17
            if 997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) and (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) > -1 / 997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])):
                revert with 'NH{q', 17
            if 997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) > (-1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) - 1:
                revert with 'NH{q', 17
            if not (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])):
                revert with 'NH{q', 18
            require address(arg1)
            mem[(6 * ceil32(return_data.size)) + 100] = address(arg3)
            mem[(6 * ceil32(return_data.size)) + 132] = (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))
            require ext_code.size(stor1)
            call stor1.approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args address(arg3), (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))
            mem[(6 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == bool(ext_call.return_data[0])
            mem[(7 * ceil32(return_data.size)) + 96] = 3
            mem[(7 * ceil32(return_data.size)) + 128] = stor1
            mem[(7 * ceil32(return_data.size)) + 160] = address(arg4)
            mem[(7 * ceil32(return_data.size)) + 192] = address(arg1)
            if block.timestamp > -61:
                revert with 'NH{q', 17
            mem[(7 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
            mem[(7 * ceil32(return_data.size)) + 228] = (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))
            mem[(7 * ceil32(return_data.size)) + 260] = 0
            mem[(7 * ceil32(return_data.size)) + 292] = 160
            mem[(7 * ceil32(return_data.size)) + 388] = 3
            idx = 0
            s = (7 * ceil32(return_data.size)) + 128
            t = (7 * ceil32(return_data.size)) + 420
            while idx < 3:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[(7 * ceil32(return_data.size)) + 324] = this.address
            mem[(7 * ceil32(return_data.size)) + 356] = block.timestamp + 60
            require ext_code.size(address(arg3))
            call address(arg3).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                 gas gas_remaining wei
                args (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])), 0, 160, address(this.address), block.timestamp + 60, 3, mem[(7 * ceil32(return_data.size)) + 420 len 96]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[(7 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = (8 * ceil32(return_data.size)) + 224
            require return_data.size >= 32
            _99 = mem[(7 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32
            require mem[(7 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 <= test266151307()
            require (7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 255 < (7 * ceil32(return_data.size)) + return_data.size + 224
            _102 = mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 224]
            if mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 224] > test266151307():
                revert with 'NH{q', 65
            if (8 * ceil32(return_data.size)) + floor32(mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 224]) + 225 > test266151307() or floor32(mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 224]) + 1 < 0:
                revert with 'NH{q', 65
            mem[64] = (8 * ceil32(return_data.size)) + floor32(mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 224]) + 225
            mem[(8 * ceil32(return_data.size)) + 224] = _102
            require _99 + (32 * _102) + 32 <= return_data.size
            idx = 0
            s = (7 * ceil32(return_data.size)) + _99 + 256
            t = (8 * ceil32(return_data.size)) + 256
            while idx < _102:
                require mem[s] == mem[s]
                mem[t] = mem[s]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[mem[64] + 4] = this.address
            require ext_code.size(address(arg1))
            staticcall address(arg1).0x70a08231 with:
                    gas gas_remaining wei
                   args address(this.address)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _222 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _225 = mem[_222]
            require mem[_222] == mem[_222]
            mem[mem[64] + 4] = this.address
            require ext_code.size(stor1)
            staticcall stor1.0x70a08231 with:
                    gas gas_remaining wei
                   args address(this.address)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _234 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _237 = mem[_234]
            require mem[_234] == mem[_234]
            if address(arg1) == stor2:
                mem[mem[64] + 4] = stor4
                mem[mem[64] + 36] = _225
                require ext_code.size(address(arg1))
                call address(arg1).approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor4, _225
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _253 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_253] == bool(mem[_253])
                mem[mem[64] + 4] = stor4
                mem[mem[64] + 36] = _237
                require ext_code.size(stor1)
                call stor1.approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor4, _237
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _277 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_277] == bool(mem[_277])
                if block.timestamp > -61:
                    revert with 'NH{q', 17
                mem[mem[64] + 68] = _237
                mem[mem[64] + 100] = _225
                mem[mem[64] + 132] = 0
                mem[mem[64] + 164] = 0
                mem[mem[64] + 196] = this.address
                mem[mem[64] + 228] = block.timestamp + 60
                require ext_code.size(stor4)
                call stor4.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                     gas gas_remaining wei
                    args stor1, address(arg1), _237, _225, 0, 0, address(this.address), block.timestamp + 60
                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _301 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 96
                require mem[_301] == mem[_301]
                require mem[_301 + 32] == mem[_301 + 32]
                require mem[_301 + 64] == mem[_301 + 64]
                mem[0] = address(arg1)
                mem[32] = 9
                mem[mem[64] + 4] = this.address
                require ext_code.size(stor9[address(arg1)])
                staticcall stor9[address(arg1)].0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _343 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _349 = mem[_343]
                require mem[_343] == mem[_343]
                mem[0] = stor9[address(arg1)]
                mem[32] = 11
                mem[mem[64] + 4] = stor11[stor9[address(arg1)]]
                mem[mem[64] + 36] = _349
                require ext_code.size(stor9[address(arg1)])
                call stor9[address(arg1)].approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor11[stor9[address(arg1)]], _349
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _373 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_373] == bool(mem[_373])
                require ext_code.size(stor11[stor9[address(arg1)]])
                staticcall stor11[stor9[address(arg1)]].bondPrice() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _397 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _403 = mem[_397]
                require mem[_397] == mem[_397]
                require ext_code.size(stor11[stor9[address(arg1)]])
                staticcall stor11[stor9[address(arg1)]].bondInfo(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _421 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 128
                _427 = mem[_421]
                require mem[_421] == mem[_421]
                require mem[_421 + 32] == mem[_421 + 32]
                require mem[_421 + 64] == mem[_421 + 92 len 4]
                require mem[_421 + 96] == mem[_421 + 124 len 4]
                mem[mem[64] + 4] = _349
                mem[mem[64] + 36] = _403
                mem[mem[64] + 68] = msg.sender
                require ext_code.size(stor11[stor9[address(arg1)]])
                call stor11[stor9[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                     gas gas_remaining wei
                    args _349, _403, msg.sender
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _463 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_463] == mem[_463]
                require ext_code.size(stor11[stor9[address(arg1)]])
                staticcall stor11[stor9[address(arg1)]].bondInfo(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _487 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 128
                require mem[_487] == mem[_487]
                require mem[_487 + 32] == mem[_487 + 32]
                require mem[_487 + 64] == mem[_487 + 92 len 4]
                require mem[_487 + 96] == mem[_487 + 124 len 4]
                if mem[_487] < _427:
                    revert with 'NH{q', 17
                mem[mem[64]] = mem[_487] - _427
            else:
                mem[mem[64] + 4] = stor3
                mem[mem[64] + 36] = _225
                require ext_code.size(address(arg1))
                call address(arg1).approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor3, _225
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _254 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_254] == bool(mem[_254])
                mem[mem[64] + 4] = stor3
                mem[mem[64] + 36] = _237
                require ext_code.size(stor1)
                call stor1.approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor3, _237
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _278 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_278] == bool(mem[_278])
                if block.timestamp > -61:
                    revert with 'NH{q', 17
                mem[mem[64] + 68] = _237
                mem[mem[64] + 100] = _225
                mem[mem[64] + 132] = 0
                mem[mem[64] + 164] = 0
                mem[mem[64] + 196] = this.address
                mem[mem[64] + 228] = block.timestamp + 60
                require ext_code.size(stor3)
                call stor3.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                     gas gas_remaining wei
                    args stor1, address(arg1), _237, _225, 0, 0, address(this.address), block.timestamp + 60
                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _302 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 96
                require mem[_302] == mem[_302]
                require mem[_302 + 32] == mem[_302 + 32]
                require mem[_302 + 64] == mem[_302 + 64]
                mem[0] = address(arg1)
                mem[32] = 9
                mem[mem[64] + 4] = this.address
                require ext_code.size(stor9[address(arg1)])
                staticcall stor9[address(arg1)].0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _344 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _350 = mem[_344]
                require mem[_344] == mem[_344]
                mem[0] = stor9[address(arg1)]
                mem[32] = 11
                mem[mem[64] + 4] = stor11[stor9[address(arg1)]]
                mem[mem[64] + 36] = _350
                require ext_code.size(stor9[address(arg1)])
                call stor9[address(arg1)].approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor11[stor9[address(arg1)]], _350
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _374 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_374] == bool(mem[_374])
                require ext_code.size(stor11[stor9[address(arg1)]])
                staticcall stor11[stor9[address(arg1)]].bondPrice() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _398 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _404 = mem[_398]
                require mem[_398] == mem[_398]
                require ext_code.size(stor11[stor9[address(arg1)]])
                staticcall stor11[stor9[address(arg1)]].bondInfo(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _422 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 128
                _428 = mem[_422]
                require mem[_422] == mem[_422]
                require mem[_422 + 32] == mem[_422 + 32]
                require mem[_422 + 64] == mem[_422 + 92 len 4]
                require mem[_422 + 96] == mem[_422 + 124 len 4]
                mem[mem[64] + 4] = _350
                mem[mem[64] + 36] = _404
                mem[mem[64] + 68] = msg.sender
                require ext_code.size(stor11[stor9[address(arg1)]])
                call stor11[stor9[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                     gas gas_remaining wei
                    args _350, _404, msg.sender
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _464 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_464] == mem[_464]
                require ext_code.size(stor11[stor9[address(arg1)]])
                staticcall stor11[stor9[address(arg1)]].bondInfo(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _488 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 128
                require mem[_488] == mem[_488]
                require mem[_488 + 32] == mem[_488 + 32]
                require mem[_488 + 64] == mem[_488 + 92 len 4]
                require mem[_488 + 96] == mem[_488 + 124 len 4]
                if mem[_488] < _428:
                    revert with 'NH{q', 17
                mem[mem[64]] = mem[_488] - _428
    return memory
      from mem[64]
       len 32
}

function sub_be1dbb4f(?) payable {
    require calldata.size - 4 >= 160
    require arg1 == address(arg1)
    require arg2 == arg2
    require arg3 == address(arg3)
    require arg4 == address(arg4)
    require arg5 == address(arg5)
    mem[100] = msg.sender
    mem[132] = this.address
    mem[164] = arg2
    require ext_code.size(stor1)
    call stor1.0x23b872dd with:
         gas gas_remaining wei
        args msg.sender, address(this.address), arg2
    mem[96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    mem[0] = address(arg1)
    mem[32] = 9
    require stor9[address(arg1)]
    require ext_code.size(stor9[address(arg1)])
    staticcall stor9[address(arg1)].getReserves() with:
            gas gas_remaining wei
    mem[ceil32(return_data.size) + 96 len 96] = ext_call.return_data[0 len 96]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 96
    require ext_call.return_data[0] == ext_call.return_data[18 len 14]
    require ext_call.return_data[32] == ext_call.return_data[50 len 14]
    require ext_call.return_data[64] == ext_call.return_data[92 len 4]
    require ext_code.size(stor9[address(arg1)])
    staticcall stor9[address(arg1)].token0() with:
            gas gas_remaining wei
    mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    require ext_code.size(stor9[address(arg1)])
    staticcall stor9[address(arg1)].token1() with:
            gas gas_remaining wei
    mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    if address(ext_call.return_data[0]) != address(arg1):
        if ext_call.return_data[12 len 20] != address(arg1):
            revert with 0, 'bad LP token'
        if address(ext_call.return_data[0]) != stor1:
            revert with 0, 'bad LP token'
        if Mask(112, 0, ext_call.return_data[0]) > 0x20d135b66ae990fc484cea55e38a936bcf497445394d4cc984add428823e4d:
            revert with 'NH{q', 17
        if 1000 * Mask(112, 0, ext_call.return_data[0]) and arg2 > -1 / 1000 * Mask(112, 0, ext_call.return_data[0]):
            revert with 'NH{q', 17
        if arg2 / 2 > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
            revert with 'NH{q', 17
        if 1994 * arg2 / 2 > (-1997 * Mask(112, 0, ext_call.return_data[0])) - 1:
            revert with 'NH{q', 17
        if arg2 / 2 > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
            revert with 'NH{q', 17
        if 997 * arg2 / 2 and arg2 / 2 > -1 / 997 * arg2 / 2:
            revert with 'NH{q', 17
        if 997 * arg2 / 2 * arg2 / 2 > (-1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) - 1:
            revert with 'NH{q', 17
        if not (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])):
            revert with 'NH{q', 18
        if (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
            revert with 'NH{q', 17
        if 1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) > (-1997 * Mask(112, 0, ext_call.return_data[0])) - 1:
            revert with 'NH{q', 17
        if (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
            revert with 'NH{q', 17
        if 997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) and (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) > -1 / 997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])):
            revert with 'NH{q', 17
        if 997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) > (-1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) - 1:
            revert with 'NH{q', 17
        if not (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])):
            revert with 'NH{q', 18
        if (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
            revert with 'NH{q', 17
        if 1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) > (-1997 * Mask(112, 0, ext_call.return_data[0])) - 1:
            revert with 'NH{q', 17
        if (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
            revert with 'NH{q', 17
        if 997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) and (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) > -1 / 997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])):
            revert with 'NH{q', 17
        if 997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) > (-1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) - 1:
            revert with 'NH{q', 17
        if not (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])):
            revert with 'NH{q', 18
        require address(arg1)
        mem[(6 * ceil32(return_data.size)) + 100] = address(arg3)
        mem[(6 * ceil32(return_data.size)) + 132] = (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))
        require ext_code.size(stor1)
        call stor1.approve(address arg1, uint256 arg2) with:
             gas gas_remaining wei
            args address(arg3), (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))
        mem[(6 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == bool(ext_call.return_data[0])
        mem[(7 * ceil32(return_data.size)) + 96] = 4
        mem[(7 * ceil32(return_data.size)) + 128] = stor1
        mem[(7 * ceil32(return_data.size)) + 160] = address(arg4)
        mem[(7 * ceil32(return_data.size)) + 192] = address(arg5)
        mem[(7 * ceil32(return_data.size)) + 224] = address(arg1)
        if block.timestamp > -61:
            revert with 'NH{q', 17
        mem[(7 * ceil32(return_data.size)) + 256] = 0x38ed173900000000000000000000000000000000000000000000000000000000
        mem[(7 * ceil32(return_data.size)) + 260] = (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))
        mem[(7 * ceil32(return_data.size)) + 292] = 0
        mem[(7 * ceil32(return_data.size)) + 324] = 160
        mem[(7 * ceil32(return_data.size)) + 420] = 4
        idx = 0
        s = (7 * ceil32(return_data.size)) + 128
        t = (7 * ceil32(return_data.size)) + 452
        while idx < 4:
            mem[t] = mem[s + 12 len 20]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        mem[(7 * ceil32(return_data.size)) + 356] = this.address
        mem[(7 * ceil32(return_data.size)) + 388] = block.timestamp + 60
        require ext_code.size(address(arg3))
        call address(arg3).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
             gas gas_remaining wei
            args (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])), 0, 160, address(this.address), block.timestamp + 60, 4, mem[(7 * ceil32(return_data.size)) + 452 len 128]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        mem[(7 * ceil32(return_data.size)) + 256 len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = (8 * ceil32(return_data.size)) + 256
        require return_data.size >= 32
        _94 = mem[(7 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32
        require mem[(7 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 <= test266151307()
        require (7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 287 < (7 * ceil32(return_data.size)) + return_data.size + 256
        _97 = mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 256]
        if mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 256] > test266151307():
            revert with 'NH{q', 65
        if (8 * ceil32(return_data.size)) + floor32(mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 256]) + 257 > test266151307() or floor32(mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 256]) + 1 < 0:
            revert with 'NH{q', 65
        mem[64] = (8 * ceil32(return_data.size)) + floor32(mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 256]) + 257
        mem[(8 * ceil32(return_data.size)) + 256] = _97
        require _94 + (32 * _97) + 32 <= return_data.size
        idx = 0
        s = (7 * ceil32(return_data.size)) + _94 + 288
        t = (8 * ceil32(return_data.size)) + 288
        while idx < _97:
            require mem[s] == mem[s]
            mem[t] = mem[s]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        mem[mem[64] + 4] = this.address
        require ext_code.size(address(arg1))
        staticcall address(arg1).0x70a08231 with:
                gas gas_remaining wei
               args address(this.address)
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _217 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _220 = mem[_217]
        require mem[_217] == mem[_217]
        mem[mem[64] + 4] = this.address
        require ext_code.size(stor1)
        staticcall stor1.0x70a08231 with:
                gas gas_remaining wei
               args address(this.address)
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _229 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _232 = mem[_229]
        require mem[_229] == mem[_229]
        if address(arg1) == stor2:
            mem[mem[64] + 4] = stor4
            mem[mem[64] + 36] = _220
            require ext_code.size(address(arg1))
            call address(arg1).approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args stor4, _220
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _247 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_247] == bool(mem[_247])
            mem[mem[64] + 4] = stor4
            mem[mem[64] + 36] = _232
            require ext_code.size(stor1)
            call stor1.approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args stor4, _232
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _271 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_271] == bool(mem[_271])
            if block.timestamp > -61:
                revert with 'NH{q', 17
            mem[mem[64] + 68] = _232
            mem[mem[64] + 100] = _220
            mem[mem[64] + 132] = 0
            mem[mem[64] + 164] = 0
            mem[mem[64] + 196] = this.address
            mem[mem[64] + 228] = block.timestamp + 60
            require ext_code.size(stor4)
            call stor4.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                 gas gas_remaining wei
                args stor1, address(arg1), _232, _220, 0, 0, address(this.address), block.timestamp + 60
            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _295 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 96
            require mem[_295] == mem[_295]
            require mem[_295 + 32] == mem[_295 + 32]
            require mem[_295 + 64] == mem[_295 + 64]
            mem[0] = address(arg1)
            mem[32] = 9
            mem[mem[64] + 4] = this.address
            require ext_code.size(stor9[address(arg1)])
            staticcall stor9[address(arg1)].0x70a08231 with:
                    gas gas_remaining wei
                   args address(this.address)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _337 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _343 = mem[_337]
            require mem[_337] == mem[_337]
            mem[0] = stor9[address(arg1)]
            mem[32] = 11
            mem[mem[64] + 4] = stor11[stor9[address(arg1)]]
            mem[mem[64] + 36] = _343
            require ext_code.size(stor9[address(arg1)])
            call stor9[address(arg1)].approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args stor11[stor9[address(arg1)]], _343
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _367 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_367] == bool(mem[_367])
            require ext_code.size(stor11[stor9[address(arg1)]])
            staticcall stor11[stor9[address(arg1)]].bondPrice() with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _391 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _397 = mem[_391]
            require mem[_391] == mem[_391]
            require ext_code.size(stor11[stor9[address(arg1)]])
            staticcall stor11[stor9[address(arg1)]].bondInfo(address arg1) with:
                    gas gas_remaining wei
                   args msg.sender
            mem[mem[64] len 128] = ext_call.return_data[0 len 128]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _415 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 128
            _421 = mem[_415]
            require mem[_415] == mem[_415]
            require mem[_415 + 32] == mem[_415 + 32]
            require mem[_415 + 64] == mem[_415 + 92 len 4]
            require mem[_415 + 96] == mem[_415 + 124 len 4]
            mem[mem[64] + 4] = _343
            mem[mem[64] + 36] = _397
            mem[mem[64] + 68] = msg.sender
            require ext_code.size(stor11[stor9[address(arg1)]])
            call stor11[stor9[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                 gas gas_remaining wei
                args _343, _397, msg.sender
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _457 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_457] == mem[_457]
            require ext_code.size(stor11[stor9[address(arg1)]])
            staticcall stor11[stor9[address(arg1)]].bondInfo(address arg1) with:
                    gas gas_remaining wei
                   args msg.sender
            mem[mem[64] len 128] = ext_call.return_data[0 len 128]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _481 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 128
            require mem[_481] == mem[_481]
            require mem[_481 + 32] == mem[_481 + 32]
            require mem[_481 + 64] == mem[_481 + 92 len 4]
            require mem[_481 + 96] == mem[_481 + 124 len 4]
            if mem[_481] < _421:
                revert with 'NH{q', 17
            mem[mem[64]] = mem[_481] - _421
        else:
            mem[mem[64] + 4] = stor3
            mem[mem[64] + 36] = _220
            require ext_code.size(address(arg1))
            call address(arg1).approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args stor3, _220
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _248 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_248] == bool(mem[_248])
            mem[mem[64] + 4] = stor3
            mem[mem[64] + 36] = _232
            require ext_code.size(stor1)
            call stor1.approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args stor3, _232
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _272 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_272] == bool(mem[_272])
            if block.timestamp > -61:
                revert with 'NH{q', 17
            mem[mem[64] + 68] = _232
            mem[mem[64] + 100] = _220
            mem[mem[64] + 132] = 0
            mem[mem[64] + 164] = 0
            mem[mem[64] + 196] = this.address
            mem[mem[64] + 228] = block.timestamp + 60
            require ext_code.size(stor3)
            call stor3.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                 gas gas_remaining wei
                args stor1, address(arg1), _232, _220, 0, 0, address(this.address), block.timestamp + 60
            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _296 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 96
            require mem[_296] == mem[_296]
            require mem[_296 + 32] == mem[_296 + 32]
            require mem[_296 + 64] == mem[_296 + 64]
            mem[0] = address(arg1)
            mem[32] = 9
            mem[mem[64] + 4] = this.address
            require ext_code.size(stor9[address(arg1)])
            staticcall stor9[address(arg1)].0x70a08231 with:
                    gas gas_remaining wei
                   args address(this.address)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _338 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _344 = mem[_338]
            require mem[_338] == mem[_338]
            mem[0] = stor9[address(arg1)]
            mem[32] = 11
            mem[mem[64] + 4] = stor11[stor9[address(arg1)]]
            mem[mem[64] + 36] = _344
            require ext_code.size(stor9[address(arg1)])
            call stor9[address(arg1)].approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args stor11[stor9[address(arg1)]], _344
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _368 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_368] == bool(mem[_368])
            require ext_code.size(stor11[stor9[address(arg1)]])
            staticcall stor11[stor9[address(arg1)]].bondPrice() with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _392 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _398 = mem[_392]
            require mem[_392] == mem[_392]
            require ext_code.size(stor11[stor9[address(arg1)]])
            staticcall stor11[stor9[address(arg1)]].bondInfo(address arg1) with:
                    gas gas_remaining wei
                   args msg.sender
            mem[mem[64] len 128] = ext_call.return_data[0 len 128]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _416 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 128
            _422 = mem[_416]
            require mem[_416] == mem[_416]
            require mem[_416 + 32] == mem[_416 + 32]
            require mem[_416 + 64] == mem[_416 + 92 len 4]
            require mem[_416 + 96] == mem[_416 + 124 len 4]
            mem[mem[64] + 4] = _344
            mem[mem[64] + 36] = _398
            mem[mem[64] + 68] = msg.sender
            require ext_code.size(stor11[stor9[address(arg1)]])
            call stor11[stor9[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                 gas gas_remaining wei
                args _344, _398, msg.sender
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _458 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_458] == mem[_458]
            require ext_code.size(stor11[stor9[address(arg1)]])
            staticcall stor11[stor9[address(arg1)]].bondInfo(address arg1) with:
                    gas gas_remaining wei
                   args msg.sender
            mem[mem[64] len 128] = ext_call.return_data[0 len 128]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _482 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 128
            require mem[_482] == mem[_482]
            require mem[_482 + 32] == mem[_482 + 32]
            require mem[_482 + 64] == mem[_482 + 92 len 4]
            require mem[_482 + 96] == mem[_482 + 124 len 4]
            if mem[_482] < _422:
                revert with 'NH{q', 17
            mem[mem[64]] = mem[_482] - _422
    else:
        if ext_call.return_data[12 len 20] == stor1:
            if Mask(112, 0, ext_call.return_data[32]) > 0x20d135b66ae990fc484cea55e38a936bcf497445394d4cc984add428823e4d:
                revert with 'NH{q', 17
            if 1000 * Mask(112, 0, ext_call.return_data[32]) and arg2 > -1 / 1000 * Mask(112, 0, ext_call.return_data[32]):
                revert with 'NH{q', 17
            if arg2 / 2 > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                revert with 'NH{q', 17
            if 1994 * arg2 / 2 > (-1997 * Mask(112, 0, ext_call.return_data[32])) - 1:
                revert with 'NH{q', 17
            if arg2 / 2 > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                revert with 'NH{q', 17
            if 997 * arg2 / 2 and arg2 / 2 > -1 / 997 * arg2 / 2:
                revert with 'NH{q', 17
            if 997 * arg2 / 2 * arg2 / 2 > (-1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) - 1:
                revert with 'NH{q', 17
            if not (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])):
                revert with 'NH{q', 18
            if (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                revert with 'NH{q', 17
            if 1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) > (-1997 * Mask(112, 0, ext_call.return_data[32])) - 1:
                revert with 'NH{q', 17
            if (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                revert with 'NH{q', 17
            if 997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) and (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) > -1 / 997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])):
                revert with 'NH{q', 17
            if 997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) > (-1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) - 1:
                revert with 'NH{q', 17
            if not (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])):
                revert with 'NH{q', 18
            if (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                revert with 'NH{q', 17
            if 1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) > (-1997 * Mask(112, 0, ext_call.return_data[32])) - 1:
                revert with 'NH{q', 17
            if (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                revert with 'NH{q', 17
            if 997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) and (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) > -1 / 997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])):
                revert with 'NH{q', 17
            if 997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) > (-1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) - 1:
                revert with 'NH{q', 17
            if not (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])):
                revert with 'NH{q', 18
            require address(arg1)
            mem[(6 * ceil32(return_data.size)) + 100] = address(arg3)
            mem[(6 * ceil32(return_data.size)) + 132] = (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))
            require ext_code.size(stor1)
            call stor1.approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args address(arg3), (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))
            mem[(6 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == bool(ext_call.return_data[0])
            mem[(7 * ceil32(return_data.size)) + 96] = 4
            mem[(7 * ceil32(return_data.size)) + 128] = stor1
            mem[(7 * ceil32(return_data.size)) + 160] = address(arg4)
            mem[(7 * ceil32(return_data.size)) + 192] = address(arg5)
            mem[(7 * ceil32(return_data.size)) + 224] = address(arg1)
            if block.timestamp > -61:
                revert with 'NH{q', 17
            mem[(7 * ceil32(return_data.size)) + 256] = 0x38ed173900000000000000000000000000000000000000000000000000000000
            mem[(7 * ceil32(return_data.size)) + 260] = (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))
            mem[(7 * ceil32(return_data.size)) + 292] = 0
            mem[(7 * ceil32(return_data.size)) + 324] = 160
            mem[(7 * ceil32(return_data.size)) + 420] = 4
            idx = 0
            s = (7 * ceil32(return_data.size)) + 128
            t = (7 * ceil32(return_data.size)) + 452
            while idx < 4:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[(7 * ceil32(return_data.size)) + 356] = this.address
            mem[(7 * ceil32(return_data.size)) + 388] = block.timestamp + 60
            require ext_code.size(address(arg3))
            call address(arg3).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                 gas gas_remaining wei
                args (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])), 0, 160, address(this.address), block.timestamp + 60, 4, mem[(7 * ceil32(return_data.size)) + 452 len 128]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[(7 * ceil32(return_data.size)) + 256 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = (8 * ceil32(return_data.size)) + 256
            require return_data.size >= 32
            _96 = mem[(7 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32
            require mem[(7 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 <= test266151307()
            require (7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 + 287 < (7 * ceil32(return_data.size)) + return_data.size + 256
            _99 = mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 + 256]
            if mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 + 256] > test266151307():
                revert with 'NH{q', 65
            if (8 * ceil32(return_data.size)) + floor32(mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 + 256]) + 257 > test266151307() or floor32(mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 + 256]) + 1 < 0:
                revert with 'NH{q', 65
            mem[64] = (8 * ceil32(return_data.size)) + floor32(mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 + 256]) + 257
            mem[(8 * ceil32(return_data.size)) + 256] = _99
            require _96 + (32 * _99) + 32 <= return_data.size
            idx = 0
            s = (7 * ceil32(return_data.size)) + _96 + 288
            t = (8 * ceil32(return_data.size)) + 288
            while idx < _99:
                require mem[s] == mem[s]
                mem[t] = mem[s]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[mem[64] + 4] = this.address
            require ext_code.size(address(arg1))
            staticcall address(arg1).0x70a08231 with:
                    gas gas_remaining wei
                   args address(this.address)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _219 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _222 = mem[_219]
            require mem[_219] == mem[_219]
            mem[mem[64] + 4] = this.address
            require ext_code.size(stor1)
            staticcall stor1.0x70a08231 with:
                    gas gas_remaining wei
                   args address(this.address)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _231 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _234 = mem[_231]
            require mem[_231] == mem[_231]
            if address(arg1) == stor2:
                mem[mem[64] + 4] = stor4
                mem[mem[64] + 36] = _222
                require ext_code.size(address(arg1))
                call address(arg1).approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor4, _222
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _251 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_251] == bool(mem[_251])
                mem[mem[64] + 4] = stor4
                mem[mem[64] + 36] = _234
                require ext_code.size(stor1)
                call stor1.approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor4, _234
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _275 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_275] == bool(mem[_275])
                if block.timestamp > -61:
                    revert with 'NH{q', 17
                mem[mem[64] + 68] = _234
                mem[mem[64] + 100] = _222
                mem[mem[64] + 132] = 0
                mem[mem[64] + 164] = 0
                mem[mem[64] + 196] = this.address
                mem[mem[64] + 228] = block.timestamp + 60
                require ext_code.size(stor4)
                call stor4.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                     gas gas_remaining wei
                    args stor1, address(arg1), _234, _222, 0, 0, address(this.address), block.timestamp + 60
                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _299 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 96
                require mem[_299] == mem[_299]
                require mem[_299 + 32] == mem[_299 + 32]
                require mem[_299 + 64] == mem[_299 + 64]
                mem[0] = address(arg1)
                mem[32] = 9
                mem[mem[64] + 4] = this.address
                require ext_code.size(stor9[address(arg1)])
                staticcall stor9[address(arg1)].0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _341 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _347 = mem[_341]
                require mem[_341] == mem[_341]
                mem[0] = stor9[address(arg1)]
                mem[32] = 11
                mem[mem[64] + 4] = stor11[stor9[address(arg1)]]
                mem[mem[64] + 36] = _347
                require ext_code.size(stor9[address(arg1)])
                call stor9[address(arg1)].approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor11[stor9[address(arg1)]], _347
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _371 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_371] == bool(mem[_371])
                require ext_code.size(stor11[stor9[address(arg1)]])
                staticcall stor11[stor9[address(arg1)]].bondPrice() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _395 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _401 = mem[_395]
                require mem[_395] == mem[_395]
                require ext_code.size(stor11[stor9[address(arg1)]])
                staticcall stor11[stor9[address(arg1)]].bondInfo(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _419 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 128
                _425 = mem[_419]
                require mem[_419] == mem[_419]
                require mem[_419 + 32] == mem[_419 + 32]
                require mem[_419 + 64] == mem[_419 + 92 len 4]
                require mem[_419 + 96] == mem[_419 + 124 len 4]
                mem[mem[64] + 4] = _347
                mem[mem[64] + 36] = _401
                mem[mem[64] + 68] = msg.sender
                require ext_code.size(stor11[stor9[address(arg1)]])
                call stor11[stor9[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                     gas gas_remaining wei
                    args _347, _401, msg.sender
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _461 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_461] == mem[_461]
                require ext_code.size(stor11[stor9[address(arg1)]])
                staticcall stor11[stor9[address(arg1)]].bondInfo(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _485 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 128
                require mem[_485] == mem[_485]
                require mem[_485 + 32] == mem[_485 + 32]
                require mem[_485 + 64] == mem[_485 + 92 len 4]
                require mem[_485 + 96] == mem[_485 + 124 len 4]
                if mem[_485] < _425:
                    revert with 'NH{q', 17
                mem[mem[64]] = mem[_485] - _425
            else:
                mem[mem[64] + 4] = stor3
                mem[mem[64] + 36] = _222
                require ext_code.size(address(arg1))
                call address(arg1).approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor3, _222
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _252 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_252] == bool(mem[_252])
                mem[mem[64] + 4] = stor3
                mem[mem[64] + 36] = _234
                require ext_code.size(stor1)
                call stor1.approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor3, _234
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _276 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_276] == bool(mem[_276])
                if block.timestamp > -61:
                    revert with 'NH{q', 17
                mem[mem[64] + 68] = _234
                mem[mem[64] + 100] = _222
                mem[mem[64] + 132] = 0
                mem[mem[64] + 164] = 0
                mem[mem[64] + 196] = this.address
                mem[mem[64] + 228] = block.timestamp + 60
                require ext_code.size(stor3)
                call stor3.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                     gas gas_remaining wei
                    args stor1, address(arg1), _234, _222, 0, 0, address(this.address), block.timestamp + 60
                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _300 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 96
                require mem[_300] == mem[_300]
                require mem[_300 + 32] == mem[_300 + 32]
                require mem[_300 + 64] == mem[_300 + 64]
                mem[0] = address(arg1)
                mem[32] = 9
                mem[mem[64] + 4] = this.address
                require ext_code.size(stor9[address(arg1)])
                staticcall stor9[address(arg1)].0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _342 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _348 = mem[_342]
                require mem[_342] == mem[_342]
                mem[0] = stor9[address(arg1)]
                mem[32] = 11
                mem[mem[64] + 4] = stor11[stor9[address(arg1)]]
                mem[mem[64] + 36] = _348
                require ext_code.size(stor9[address(arg1)])
                call stor9[address(arg1)].approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor11[stor9[address(arg1)]], _348
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _372 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_372] == bool(mem[_372])
                require ext_code.size(stor11[stor9[address(arg1)]])
                staticcall stor11[stor9[address(arg1)]].bondPrice() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _396 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _402 = mem[_396]
                require mem[_396] == mem[_396]
                require ext_code.size(stor11[stor9[address(arg1)]])
                staticcall stor11[stor9[address(arg1)]].bondInfo(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _420 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 128
                _426 = mem[_420]
                require mem[_420] == mem[_420]
                require mem[_420 + 32] == mem[_420 + 32]
                require mem[_420 + 64] == mem[_420 + 92 len 4]
                require mem[_420 + 96] == mem[_420 + 124 len 4]
                mem[mem[64] + 4] = _348
                mem[mem[64] + 36] = _402
                mem[mem[64] + 68] = msg.sender
                require ext_code.size(stor11[stor9[address(arg1)]])
                call stor11[stor9[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                     gas gas_remaining wei
                    args _348, _402, msg.sender
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _462 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_462] == mem[_462]
                require ext_code.size(stor11[stor9[address(arg1)]])
                staticcall stor11[stor9[address(arg1)]].bondInfo(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _486 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 128
                require mem[_486] == mem[_486]
                require mem[_486 + 32] == mem[_486 + 32]
                require mem[_486 + 64] == mem[_486 + 92 len 4]
                require mem[_486 + 96] == mem[_486 + 124 len 4]
                if mem[_486] < _426:
                    revert with 'NH{q', 17
                mem[mem[64]] = mem[_486] - _426
        else:
            if ext_call.return_data[12 len 20] != address(arg1):
                revert with 0, 'bad LP token'
            if address(ext_call.return_data[0]) != stor1:
                revert with 0, 'bad LP token'
            if Mask(112, 0, ext_call.return_data[0]) > 0x20d135b66ae990fc484cea55e38a936bcf497445394d4cc984add428823e4d:
                revert with 'NH{q', 17
            if 1000 * Mask(112, 0, ext_call.return_data[0]) and arg2 > -1 / 1000 * Mask(112, 0, ext_call.return_data[0]):
                revert with 'NH{q', 17
            if arg2 / 2 > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                revert with 'NH{q', 17
            if 1994 * arg2 / 2 > (-1997 * Mask(112, 0, ext_call.return_data[0])) - 1:
                revert with 'NH{q', 17
            if arg2 / 2 > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                revert with 'NH{q', 17
            if 997 * arg2 / 2 and arg2 / 2 > -1 / 997 * arg2 / 2:
                revert with 'NH{q', 17
            if 997 * arg2 / 2 * arg2 / 2 > (-1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) - 1:
                revert with 'NH{q', 17
            if not (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])):
                revert with 'NH{q', 18
            if (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                revert with 'NH{q', 17
            if 1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) > (-1997 * Mask(112, 0, ext_call.return_data[0])) - 1:
                revert with 'NH{q', 17
            if (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                revert with 'NH{q', 17
            if 997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) and (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) > -1 / 997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])):
                revert with 'NH{q', 17
            if 997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) > (-1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) - 1:
                revert with 'NH{q', 17
            if not (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])):
                revert with 'NH{q', 18
            if (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                revert with 'NH{q', 17
            if 1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) > (-1997 * Mask(112, 0, ext_call.return_data[0])) - 1:
                revert with 'NH{q', 17
            if (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                revert with 'NH{q', 17
            if 997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) and (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) > -1 / 997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])):
                revert with 'NH{q', 17
            if 997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) > (-1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) - 1:
                revert with 'NH{q', 17
            if not (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])):
                revert with 'NH{q', 18
            require address(arg1)
            mem[(6 * ceil32(return_data.size)) + 100] = address(arg3)
            mem[(6 * ceil32(return_data.size)) + 132] = (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))
            require ext_code.size(stor1)
            call stor1.approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args address(arg3), (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))
            mem[(6 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == bool(ext_call.return_data[0])
            mem[(7 * ceil32(return_data.size)) + 96] = 4
            mem[(7 * ceil32(return_data.size)) + 128] = stor1
            mem[(7 * ceil32(return_data.size)) + 160] = address(arg4)
            mem[(7 * ceil32(return_data.size)) + 192] = address(arg5)
            mem[(7 * ceil32(return_data.size)) + 224] = address(arg1)
            if block.timestamp > -61:
                revert with 'NH{q', 17
            mem[(7 * ceil32(return_data.size)) + 256] = 0x38ed173900000000000000000000000000000000000000000000000000000000
            mem[(7 * ceil32(return_data.size)) + 260] = (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))
            mem[(7 * ceil32(return_data.size)) + 292] = 0
            mem[(7 * ceil32(return_data.size)) + 324] = 160
            mem[(7 * ceil32(return_data.size)) + 420] = 4
            idx = 0
            s = (7 * ceil32(return_data.size)) + 128
            t = (7 * ceil32(return_data.size)) + 452
            while idx < 4:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[(7 * ceil32(return_data.size)) + 356] = this.address
            mem[(7 * ceil32(return_data.size)) + 388] = block.timestamp + 60
            require ext_code.size(address(arg3))
            call address(arg3).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                 gas gas_remaining wei
                args (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])), 0, 160, address(this.address), block.timestamp + 60, 4, mem[(7 * ceil32(return_data.size)) + 452 len 128]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[(7 * ceil32(return_data.size)) + 256 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = (8 * ceil32(return_data.size)) + 256
            require return_data.size >= 32
            _95 = mem[(7 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32
            require mem[(7 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 <= test266151307()
            require (7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 287 < (7 * ceil32(return_data.size)) + return_data.size + 256
            _98 = mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 256]
            if mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 256] > test266151307():
                revert with 'NH{q', 65
            if (8 * ceil32(return_data.size)) + floor32(mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 256]) + 257 > test266151307() or floor32(mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 256]) + 1 < 0:
                revert with 'NH{q', 65
            mem[64] = (8 * ceil32(return_data.size)) + floor32(mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 256 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 256]) + 257
            mem[(8 * ceil32(return_data.size)) + 256] = _98
            require _95 + (32 * _98) + 32 <= return_data.size
            idx = 0
            s = (7 * ceil32(return_data.size)) + _95 + 288
            t = (8 * ceil32(return_data.size)) + 288
            while idx < _98:
                require mem[s] == mem[s]
                mem[t] = mem[s]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[mem[64] + 4] = this.address
            require ext_code.size(address(arg1))
            staticcall address(arg1).0x70a08231 with:
                    gas gas_remaining wei
                   args address(this.address)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _218 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _221 = mem[_218]
            require mem[_218] == mem[_218]
            mem[mem[64] + 4] = this.address
            require ext_code.size(stor1)
            staticcall stor1.0x70a08231 with:
                    gas gas_remaining wei
                   args address(this.address)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _230 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _233 = mem[_230]
            require mem[_230] == mem[_230]
            if address(arg1) == stor2:
                mem[mem[64] + 4] = stor4
                mem[mem[64] + 36] = _221
                require ext_code.size(address(arg1))
                call address(arg1).approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor4, _221
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _249 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_249] == bool(mem[_249])
                mem[mem[64] + 4] = stor4
                mem[mem[64] + 36] = _233
                require ext_code.size(stor1)
                call stor1.approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor4, _233
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _273 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_273] == bool(mem[_273])
                if block.timestamp > -61:
                    revert with 'NH{q', 17
                mem[mem[64] + 68] = _233
                mem[mem[64] + 100] = _221
                mem[mem[64] + 132] = 0
                mem[mem[64] + 164] = 0
                mem[mem[64] + 196] = this.address
                mem[mem[64] + 228] = block.timestamp + 60
                require ext_code.size(stor4)
                call stor4.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                     gas gas_remaining wei
                    args stor1, address(arg1), _233, _221, 0, 0, address(this.address), block.timestamp + 60
                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _297 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 96
                require mem[_297] == mem[_297]
                require mem[_297 + 32] == mem[_297 + 32]
                require mem[_297 + 64] == mem[_297 + 64]
                mem[0] = address(arg1)
                mem[32] = 9
                mem[mem[64] + 4] = this.address
                require ext_code.size(stor9[address(arg1)])
                staticcall stor9[address(arg1)].0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _339 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _345 = mem[_339]
                require mem[_339] == mem[_339]
                mem[0] = stor9[address(arg1)]
                mem[32] = 11
                mem[mem[64] + 4] = stor11[stor9[address(arg1)]]
                mem[mem[64] + 36] = _345
                require ext_code.size(stor9[address(arg1)])
                call stor9[address(arg1)].approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor11[stor9[address(arg1)]], _345
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _369 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_369] == bool(mem[_369])
                require ext_code.size(stor11[stor9[address(arg1)]])
                staticcall stor11[stor9[address(arg1)]].bondPrice() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _393 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _399 = mem[_393]
                require mem[_393] == mem[_393]
                require ext_code.size(stor11[stor9[address(arg1)]])
                staticcall stor11[stor9[address(arg1)]].bondInfo(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _417 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 128
                _423 = mem[_417]
                require mem[_417] == mem[_417]
                require mem[_417 + 32] == mem[_417 + 32]
                require mem[_417 + 64] == mem[_417 + 92 len 4]
                require mem[_417 + 96] == mem[_417 + 124 len 4]
                mem[mem[64] + 4] = _345
                mem[mem[64] + 36] = _399
                mem[mem[64] + 68] = msg.sender
                require ext_code.size(stor11[stor9[address(arg1)]])
                call stor11[stor9[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                     gas gas_remaining wei
                    args _345, _399, msg.sender
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _459 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_459] == mem[_459]
                require ext_code.size(stor11[stor9[address(arg1)]])
                staticcall stor11[stor9[address(arg1)]].bondInfo(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _483 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 128
                require mem[_483] == mem[_483]
                require mem[_483 + 32] == mem[_483 + 32]
                require mem[_483 + 64] == mem[_483 + 92 len 4]
                require mem[_483 + 96] == mem[_483 + 124 len 4]
                if mem[_483] < _423:
                    revert with 'NH{q', 17
                mem[mem[64]] = mem[_483] - _423
            else:
                mem[mem[64] + 4] = stor3
                mem[mem[64] + 36] = _221
                require ext_code.size(address(arg1))
                call address(arg1).approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor3, _221
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _250 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_250] == bool(mem[_250])
                mem[mem[64] + 4] = stor3
                mem[mem[64] + 36] = _233
                require ext_code.size(stor1)
                call stor1.approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor3, _233
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _274 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_274] == bool(mem[_274])
                if block.timestamp > -61:
                    revert with 'NH{q', 17
                mem[mem[64] + 68] = _233
                mem[mem[64] + 100] = _221
                mem[mem[64] + 132] = 0
                mem[mem[64] + 164] = 0
                mem[mem[64] + 196] = this.address
                mem[mem[64] + 228] = block.timestamp + 60
                require ext_code.size(stor3)
                call stor3.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                     gas gas_remaining wei
                    args stor1, address(arg1), _233, _221, 0, 0, address(this.address), block.timestamp + 60
                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _298 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 96
                require mem[_298] == mem[_298]
                require mem[_298 + 32] == mem[_298 + 32]
                require mem[_298 + 64] == mem[_298 + 64]
                mem[0] = address(arg1)
                mem[32] = 9
                mem[mem[64] + 4] = this.address
                require ext_code.size(stor9[address(arg1)])
                staticcall stor9[address(arg1)].0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _340 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _346 = mem[_340]
                require mem[_340] == mem[_340]
                mem[0] = stor9[address(arg1)]
                mem[32] = 11
                mem[mem[64] + 4] = stor11[stor9[address(arg1)]]
                mem[mem[64] + 36] = _346
                require ext_code.size(stor9[address(arg1)])
                call stor9[address(arg1)].approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor11[stor9[address(arg1)]], _346
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _370 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_370] == bool(mem[_370])
                require ext_code.size(stor11[stor9[address(arg1)]])
                staticcall stor11[stor9[address(arg1)]].bondPrice() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _394 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _400 = mem[_394]
                require mem[_394] == mem[_394]
                require ext_code.size(stor11[stor9[address(arg1)]])
                staticcall stor11[stor9[address(arg1)]].bondInfo(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _418 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 128
                _424 = mem[_418]
                require mem[_418] == mem[_418]
                require mem[_418 + 32] == mem[_418 + 32]
                require mem[_418 + 64] == mem[_418 + 92 len 4]
                require mem[_418 + 96] == mem[_418 + 124 len 4]
                mem[mem[64] + 4] = _346
                mem[mem[64] + 36] = _400
                mem[mem[64] + 68] = msg.sender
                require ext_code.size(stor11[stor9[address(arg1)]])
                call stor11[stor9[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                     gas gas_remaining wei
                    args _346, _400, msg.sender
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _460 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_460] == mem[_460]
                require ext_code.size(stor11[stor9[address(arg1)]])
                staticcall stor11[stor9[address(arg1)]].bondInfo(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _484 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 128
                require mem[_484] == mem[_484]
                require mem[_484 + 32] == mem[_484 + 32]
                require mem[_484 + 64] == mem[_484 + 92 len 4]
                require mem[_484 + 96] == mem[_484 + 124 len 4]
                if mem[_484] < _424:
                    revert with 'NH{q', 17
                mem[mem[64]] = mem[_484] - _424
    return memory
      from mem[64]
       len 32
}

function sub_9cacfde2(?) payable {
    require calldata.size - 4 >= 128
    require arg1 == address(arg1)
    require arg2 == arg2
    require arg3 == arg3
    require arg4 == address(arg4)
    mem[100] = msg.sender
    mem[132] = this.address
    mem[164] = arg2
    require ext_code.size(stor1)
    call stor1.0x23b872dd with:
         gas gas_remaining wei
        args msg.sender, address(this.address), arg2
    mem[96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    mem[0] = address(arg1)
    mem[32] = 9
    require stor9[address(arg1)]
    require ext_code.size(stor9[address(arg1)])
    staticcall stor9[address(arg1)].getReserves() with:
            gas gas_remaining wei
    mem[ceil32(return_data.size) + 96 len 96] = ext_call.return_data[0 len 96]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 96
    require ext_call.return_data[0] == ext_call.return_data[18 len 14]
    require ext_call.return_data[32] == ext_call.return_data[50 len 14]
    require ext_call.return_data[64] == ext_call.return_data[92 len 4]
    require ext_code.size(stor9[address(arg1)])
    staticcall stor9[address(arg1)].token0() with:
            gas gas_remaining wei
    mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    require ext_code.size(stor9[address(arg1)])
    staticcall stor9[address(arg1)].token1() with:
            gas gas_remaining wei
    mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    if address(ext_call.return_data[0]) != address(arg1):
        if ext_call.return_data[12 len 20] != address(arg1):
            revert with 0, 'bad LP token'
        if address(ext_call.return_data[0]) != stor1:
            revert with 0, 'bad LP token'
        if Mask(112, 0, ext_call.return_data[0]) > 0x20d135b66ae990fc484cea55e38a936bcf497445394d4cc984add428823e4d:
            revert with 'NH{q', 17
        if 1000 * Mask(112, 0, ext_call.return_data[0]) and arg2 > -1 / 1000 * Mask(112, 0, ext_call.return_data[0]):
            revert with 'NH{q', 17
        if arg2 / 2 > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
            revert with 'NH{q', 17
        if 1994 * arg2 / 2 > (-1997 * Mask(112, 0, ext_call.return_data[0])) - 1:
            revert with 'NH{q', 17
        if arg2 / 2 > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
            revert with 'NH{q', 17
        if 997 * arg2 / 2 and arg2 / 2 > -1 / 997 * arg2 / 2:
            revert with 'NH{q', 17
        if 997 * arg2 / 2 * arg2 / 2 > (-1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) - 1:
            revert with 'NH{q', 17
        if not (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])):
            revert with 'NH{q', 18
        if (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
            revert with 'NH{q', 17
        if 1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) > (-1997 * Mask(112, 0, ext_call.return_data[0])) - 1:
            revert with 'NH{q', 17
        if (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
            revert with 'NH{q', 17
        if 997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) and (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) > -1 / 997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])):
            revert with 'NH{q', 17
        if 997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) > (-1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) - 1:
            revert with 'NH{q', 17
        if not (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])):
            revert with 'NH{q', 18
        if (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
            revert with 'NH{q', 17
        if 1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) > (-1997 * Mask(112, 0, ext_call.return_data[0])) - 1:
            revert with 'NH{q', 17
        if (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
            revert with 'NH{q', 17
        if 997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) and (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) > -1 / 997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])):
            revert with 'NH{q', 17
        if 997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) > (-1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) - 1:
            revert with 'NH{q', 17
        if not (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])):
            revert with 'NH{q', 18
        require address(arg1)
        mem[(6 * ceil32(return_data.size)) + 100] = address(arg4)
        mem[(6 * ceil32(return_data.size)) + 132] = (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))
        require ext_code.size(stor1)
        call stor1.approve(address arg1, uint256 arg2) with:
             gas gas_remaining wei
            args address(arg4), (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))
        mem[(6 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == bool(ext_call.return_data[0])
        mem[(7 * ceil32(return_data.size)) + 96] = 2
        mem[(7 * ceil32(return_data.size)) + 128] = stor1
        mem[(7 * ceil32(return_data.size)) + 160] = address(arg1)
        if block.timestamp > -61:
            revert with 'NH{q', 17
        mem[(7 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
        mem[(7 * ceil32(return_data.size)) + 196] = (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))
        mem[(7 * ceil32(return_data.size)) + 228] = 0
        mem[(7 * ceil32(return_data.size)) + 260] = 160
        mem[(7 * ceil32(return_data.size)) + 356] = 2
        idx = 0
        s = (7 * ceil32(return_data.size)) + 128
        t = (7 * ceil32(return_data.size)) + 388
        while idx < 2:
            mem[t] = mem[s + 12 len 20]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        mem[(7 * ceil32(return_data.size)) + 292] = this.address
        mem[(7 * ceil32(return_data.size)) + 324] = block.timestamp + 60
        require ext_code.size(address(arg4))
        call address(arg4).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
             gas gas_remaining wei
            args (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])), 0, 160, address(this.address), block.timestamp + 60, 2, mem[(7 * ceil32(return_data.size)) + 388 len 64]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        mem[(7 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = (8 * ceil32(return_data.size)) + 192
        require return_data.size >= 32
        _97 = mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32
        require mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 <= test266151307()
        require (7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 223 < (7 * ceil32(return_data.size)) + return_data.size + 192
        _100 = mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]
        if mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192] > test266151307():
            revert with 'NH{q', 65
        if (8 * ceil32(return_data.size)) + floor32(mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]) + 193 > test266151307() or floor32(mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]) + 1 < 0:
            revert with 'NH{q', 65
        mem[64] = (8 * ceil32(return_data.size)) + floor32(mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]) + 193
        mem[(8 * ceil32(return_data.size)) + 192] = _100
        require _97 + (32 * _100) + 32 <= return_data.size
        idx = 0
        s = (7 * ceil32(return_data.size)) + _97 + 224
        t = (8 * ceil32(return_data.size)) + 224
        while idx < _100:
            require mem[s] == mem[s]
            mem[t] = mem[s]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        mem[mem[64] + 4] = this.address
        require ext_code.size(address(arg1))
        staticcall address(arg1).0x70a08231 with:
                gas gas_remaining wei
               args address(this.address)
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _220 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _223 = mem[_220]
        require mem[_220] == mem[_220]
        mem[mem[64] + 4] = this.address
        require ext_code.size(stor1)
        staticcall stor1.0x70a08231 with:
                gas gas_remaining wei
               args address(this.address)
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _232 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _235 = mem[_232]
        require mem[_232] == mem[_232]
        if address(arg1) == stor2:
            mem[mem[64] + 4] = stor4
            mem[mem[64] + 36] = _223
            require ext_code.size(address(arg1))
            call address(arg1).approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args stor4, _223
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _250 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_250] == bool(mem[_250])
            mem[mem[64] + 4] = stor4
            mem[mem[64] + 36] = _235
            require ext_code.size(stor1)
            call stor1.approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args stor4, _235
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _274 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_274] == bool(mem[_274])
            if block.timestamp > -61:
                revert with 'NH{q', 17
            mem[mem[64] + 68] = _235
            mem[mem[64] + 100] = _223
            mem[mem[64] + 132] = 0
            mem[mem[64] + 164] = 0
            mem[mem[64] + 196] = this.address
            mem[mem[64] + 228] = block.timestamp + 60
            require ext_code.size(stor4)
            call stor4.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                 gas gas_remaining wei
                args stor1, address(arg1), _235, _223, 0, 0, address(this.address), block.timestamp + 60
            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _298 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 96
            require mem[_298] == mem[_298]
            require mem[_298 + 32] == mem[_298 + 32]
            require mem[_298 + 64] == mem[_298 + 64]
            mem[0] = address(arg1)
            mem[32] = 9
            mem[mem[64] + 4] = this.address
            require ext_code.size(stor9[address(arg1)])
            staticcall stor9[address(arg1)].0x70a08231 with:
                    gas gas_remaining wei
                   args address(this.address)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _340 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _346 = mem[_340]
            require mem[_340] == mem[_340]
            mem[0] = stor9[address(arg1)]
            mem[32] = 11
            mem[mem[64] + 4] = stor11[stor9[address(arg1)]]
            mem[mem[64] + 36] = _346
            require ext_code.size(stor9[address(arg1)])
            call stor9[address(arg1)].approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args stor11[stor9[address(arg1)]], _346
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _370 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_370] == bool(mem[_370])
            require ext_code.size(stor11[stor9[address(arg1)]])
            staticcall stor11[stor9[address(arg1)]].bondPrice() with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _394 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _400 = mem[_394]
            require mem[_394] == mem[_394]
            require ext_code.size(stor11[stor9[address(arg1)]])
            staticcall stor11[stor9[address(arg1)]].bondInfo(address arg1) with:
                    gas gas_remaining wei
                   args msg.sender
            mem[mem[64] len 128] = ext_call.return_data[0 len 128]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _418 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 128
            _424 = mem[_418]
            require mem[_418] == mem[_418]
            require mem[_418 + 32] == mem[_418 + 32]
            require mem[_418 + 64] == mem[_418 + 92 len 4]
            require mem[_418 + 96] == mem[_418 + 124 len 4]
            mem[mem[64] + 4] = _346
            mem[mem[64] + 36] = _400
            mem[mem[64] + 68] = msg.sender
            require ext_code.size(stor11[stor9[address(arg1)]])
            call stor11[stor9[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                 gas gas_remaining wei
                args _346, _400, msg.sender
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _460 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_460] == mem[_460]
            require ext_code.size(stor11[stor9[address(arg1)]])
            staticcall stor11[stor9[address(arg1)]].bondInfo(address arg1) with:
                    gas gas_remaining wei
                   args msg.sender
            mem[mem[64] len 128] = ext_call.return_data[0 len 128]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _484 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 128
            require mem[_484] == mem[_484]
            require mem[_484 + 32] == mem[_484 + 32]
            require mem[_484 + 64] == mem[_484 + 92 len 4]
            require mem[_484 + 96] == mem[_484 + 124 len 4]
            if mem[_484] < _424:
                revert with 'NH{q', 17
            if mem[_484] - _424 < arg3:
                revert with 0, 'insufficient profit, either ROI plummeted or your slippage is too tight'
            mem[mem[64] + 4] = this.address
            require ext_code.size(address(arg1))
            staticcall address(arg1).0x70a08231 with:
                    gas gas_remaining wei
                   args address(this.address)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _538 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _544 = mem[_538]
            require mem[_538] == mem[_538]
            if mem[_538] <= 0:
                mem[mem[64] + 4] = this.address
                require ext_code.size(stor1)
                staticcall stor1.0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _568 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _586 = mem[_568]
                require mem[_568] == mem[_568]
                if mem[_568] > 0:
                    mem[mem[64] + 4] = msg.sender
                    mem[mem[64] + 36] = _586
                    require ext_code.size(stor1)
                    call stor1.0xa9059cbb with:
                         gas gas_remaining wei
                        args msg.sender, _586
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _622 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_622] == bool(mem[_622])
            else:
                mem[mem[64] + 4] = msg.sender
                mem[mem[64] + 36] = _544
                require ext_code.size(address(arg1))
                call address(arg1).0xa9059cbb with:
                     gas gas_remaining wei
                    args msg.sender, _544
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _580 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_580] == bool(mem[_580])
                mem[mem[64] + 4] = this.address
                require ext_code.size(stor1)
                staticcall stor1.0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _623 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _635 = mem[_623]
                require mem[_623] == mem[_623]
                if mem[_623] > 0:
                    mem[mem[64] + 4] = msg.sender
                    mem[mem[64] + 36] = _635
                    require ext_code.size(stor1)
                    call stor1.0xa9059cbb with:
                         gas gas_remaining wei
                        args msg.sender, _635
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _658 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_658] == bool(mem[_658])
        else:
            mem[mem[64] + 4] = stor3
            mem[mem[64] + 36] = _223
            require ext_code.size(address(arg1))
            call address(arg1).approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args stor3, _223
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _251 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_251] == bool(mem[_251])
            mem[mem[64] + 4] = stor3
            mem[mem[64] + 36] = _235
            require ext_code.size(stor1)
            call stor1.approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args stor3, _235
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _275 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_275] == bool(mem[_275])
            if block.timestamp > -61:
                revert with 'NH{q', 17
            mem[mem[64] + 68] = _235
            mem[mem[64] + 100] = _223
            mem[mem[64] + 132] = 0
            mem[mem[64] + 164] = 0
            mem[mem[64] + 196] = this.address
            mem[mem[64] + 228] = block.timestamp + 60
            require ext_code.size(stor3)
            call stor3.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                 gas gas_remaining wei
                args stor1, address(arg1), _235, _223, 0, 0, address(this.address), block.timestamp + 60
            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _299 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 96
            require mem[_299] == mem[_299]
            require mem[_299 + 32] == mem[_299 + 32]
            require mem[_299 + 64] == mem[_299 + 64]
            mem[0] = address(arg1)
            mem[32] = 9
            mem[mem[64] + 4] = this.address
            require ext_code.size(stor9[address(arg1)])
            staticcall stor9[address(arg1)].0x70a08231 with:
                    gas gas_remaining wei
                   args address(this.address)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _341 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _347 = mem[_341]
            require mem[_341] == mem[_341]
            mem[0] = stor9[address(arg1)]
            mem[32] = 11
            mem[mem[64] + 4] = stor11[stor9[address(arg1)]]
            mem[mem[64] + 36] = _347
            require ext_code.size(stor9[address(arg1)])
            call stor9[address(arg1)].approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args stor11[stor9[address(arg1)]], _347
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _371 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_371] == bool(mem[_371])
            require ext_code.size(stor11[stor9[address(arg1)]])
            staticcall stor11[stor9[address(arg1)]].bondPrice() with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _395 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _401 = mem[_395]
            require mem[_395] == mem[_395]
            require ext_code.size(stor11[stor9[address(arg1)]])
            staticcall stor11[stor9[address(arg1)]].bondInfo(address arg1) with:
                    gas gas_remaining wei
                   args msg.sender
            mem[mem[64] len 128] = ext_call.return_data[0 len 128]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _419 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 128
            _425 = mem[_419]
            require mem[_419] == mem[_419]
            require mem[_419 + 32] == mem[_419 + 32]
            require mem[_419 + 64] == mem[_419 + 92 len 4]
            require mem[_419 + 96] == mem[_419 + 124 len 4]
            mem[mem[64] + 4] = _347
            mem[mem[64] + 36] = _401
            mem[mem[64] + 68] = msg.sender
            require ext_code.size(stor11[stor9[address(arg1)]])
            call stor11[stor9[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                 gas gas_remaining wei
                args _347, _401, msg.sender
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _461 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_461] == mem[_461]
            require ext_code.size(stor11[stor9[address(arg1)]])
            staticcall stor11[stor9[address(arg1)]].bondInfo(address arg1) with:
                    gas gas_remaining wei
                   args msg.sender
            mem[mem[64] len 128] = ext_call.return_data[0 len 128]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _485 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 128
            require mem[_485] == mem[_485]
            require mem[_485 + 32] == mem[_485 + 32]
            require mem[_485 + 64] == mem[_485 + 92 len 4]
            require mem[_485 + 96] == mem[_485 + 124 len 4]
            if mem[_485] < _425:
                revert with 'NH{q', 17
            if mem[_485] - _425 < arg3:
                revert with 0, 'insufficient profit, either ROI plummeted or your slippage is too tight'
            mem[mem[64] + 4] = this.address
            require ext_code.size(address(arg1))
            staticcall address(arg1).0x70a08231 with:
                    gas gas_remaining wei
                   args address(this.address)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _539 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _545 = mem[_539]
            require mem[_539] == mem[_539]
            if mem[_539] <= 0:
                mem[mem[64] + 4] = this.address
                require ext_code.size(stor1)
                staticcall stor1.0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _570 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _587 = mem[_570]
                require mem[_570] == mem[_570]
                if mem[_570] > 0:
                    mem[mem[64] + 4] = msg.sender
                    mem[mem[64] + 36] = _587
                    require ext_code.size(stor1)
                    call stor1.0xa9059cbb with:
                         gas gas_remaining wei
                        args msg.sender, _587
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _624 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_624] == bool(mem[_624])
            else:
                mem[mem[64] + 4] = msg.sender
                mem[mem[64] + 36] = _545
                require ext_code.size(address(arg1))
                call address(arg1).0xa9059cbb with:
                     gas gas_remaining wei
                    args msg.sender, _545
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _581 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_581] == bool(mem[_581])
                mem[mem[64] + 4] = this.address
                require ext_code.size(stor1)
                staticcall stor1.0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _625 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _637 = mem[_625]
                require mem[_625] == mem[_625]
                if mem[_625] > 0:
                    mem[mem[64] + 4] = msg.sender
                    mem[mem[64] + 36] = _637
                    require ext_code.size(stor1)
                    call stor1.0xa9059cbb with:
                         gas gas_remaining wei
                        args msg.sender, _637
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _659 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_659] == bool(mem[_659])
    else:
        if ext_call.return_data[12 len 20] == stor1:
            if Mask(112, 0, ext_call.return_data[32]) > 0x20d135b66ae990fc484cea55e38a936bcf497445394d4cc984add428823e4d:
                revert with 'NH{q', 17
            if 1000 * Mask(112, 0, ext_call.return_data[32]) and arg2 > -1 / 1000 * Mask(112, 0, ext_call.return_data[32]):
                revert with 'NH{q', 17
            if arg2 / 2 > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                revert with 'NH{q', 17
            if 1994 * arg2 / 2 > (-1997 * Mask(112, 0, ext_call.return_data[32])) - 1:
                revert with 'NH{q', 17
            if arg2 / 2 > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                revert with 'NH{q', 17
            if 997 * arg2 / 2 and arg2 / 2 > -1 / 997 * arg2 / 2:
                revert with 'NH{q', 17
            if 997 * arg2 / 2 * arg2 / 2 > (-1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) - 1:
                revert with 'NH{q', 17
            if not (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])):
                revert with 'NH{q', 18
            if (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                revert with 'NH{q', 17
            if 1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) > (-1997 * Mask(112, 0, ext_call.return_data[32])) - 1:
                revert with 'NH{q', 17
            if (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                revert with 'NH{q', 17
            if 997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) and (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) > -1 / 997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])):
                revert with 'NH{q', 17
            if 997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) > (-1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) - 1:
                revert with 'NH{q', 17
            if not (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])):
                revert with 'NH{q', 18
            if (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                revert with 'NH{q', 17
            if 1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) > (-1997 * Mask(112, 0, ext_call.return_data[32])) - 1:
                revert with 'NH{q', 17
            if (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                revert with 'NH{q', 17
            if 997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) and (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) > -1 / 997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])):
                revert with 'NH{q', 17
            if 997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) > (-1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) - 1:
                revert with 'NH{q', 17
            if not (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])):
                revert with 'NH{q', 18
            require address(arg1)
            mem[(6 * ceil32(return_data.size)) + 100] = address(arg4)
            mem[(6 * ceil32(return_data.size)) + 132] = (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))
            require ext_code.size(stor1)
            call stor1.approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args address(arg4), (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))
            mem[(6 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == bool(ext_call.return_data[0])
            mem[(7 * ceil32(return_data.size)) + 96] = 2
            mem[(7 * ceil32(return_data.size)) + 128] = stor1
            mem[(7 * ceil32(return_data.size)) + 160] = address(arg1)
            if block.timestamp > -61:
                revert with 'NH{q', 17
            mem[(7 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
            mem[(7 * ceil32(return_data.size)) + 196] = (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))
            mem[(7 * ceil32(return_data.size)) + 228] = 0
            mem[(7 * ceil32(return_data.size)) + 260] = 160
            mem[(7 * ceil32(return_data.size)) + 356] = 2
            idx = 0
            s = (7 * ceil32(return_data.size)) + 128
            t = (7 * ceil32(return_data.size)) + 388
            while idx < 2:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[(7 * ceil32(return_data.size)) + 292] = this.address
            mem[(7 * ceil32(return_data.size)) + 324] = block.timestamp + 60
            require ext_code.size(address(arg4))
            call address(arg4).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                 gas gas_remaining wei
                args (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])), 0, 160, address(this.address), block.timestamp + 60, 2, mem[(7 * ceil32(return_data.size)) + 388 len 64]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[(7 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = (8 * ceil32(return_data.size)) + 192
            require return_data.size >= 32
            _99 = mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32
            require mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 <= test266151307()
            require (7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 + 223 < (7 * ceil32(return_data.size)) + return_data.size + 192
            _102 = mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 + 192]
            if mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 + 192] > test266151307():
                revert with 'NH{q', 65
            if (8 * ceil32(return_data.size)) + floor32(mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 + 192]) + 193 > test266151307() or floor32(mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 + 192]) + 1 < 0:
                revert with 'NH{q', 65
            mem[64] = (8 * ceil32(return_data.size)) + floor32(mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 + 192]) + 193
            mem[(8 * ceil32(return_data.size)) + 192] = _102
            require _99 + (32 * _102) + 32 <= return_data.size
            idx = 0
            s = (7 * ceil32(return_data.size)) + _99 + 224
            t = (8 * ceil32(return_data.size)) + 224
            while idx < _102:
                require mem[s] == mem[s]
                mem[t] = mem[s]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[mem[64] + 4] = this.address
            require ext_code.size(address(arg1))
            staticcall address(arg1).0x70a08231 with:
                    gas gas_remaining wei
                   args address(this.address)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _222 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _225 = mem[_222]
            require mem[_222] == mem[_222]
            mem[mem[64] + 4] = this.address
            require ext_code.size(stor1)
            staticcall stor1.0x70a08231 with:
                    gas gas_remaining wei
                   args address(this.address)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _234 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _237 = mem[_234]
            require mem[_234] == mem[_234]
            if address(arg1) == stor2:
                mem[mem[64] + 4] = stor4
                mem[mem[64] + 36] = _225
                require ext_code.size(address(arg1))
                call address(arg1).approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor4, _225
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _254 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_254] == bool(mem[_254])
                mem[mem[64] + 4] = stor4
                mem[mem[64] + 36] = _237
                require ext_code.size(stor1)
                call stor1.approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor4, _237
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _278 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_278] == bool(mem[_278])
                if block.timestamp > -61:
                    revert with 'NH{q', 17
                mem[mem[64] + 68] = _237
                mem[mem[64] + 100] = _225
                mem[mem[64] + 132] = 0
                mem[mem[64] + 164] = 0
                mem[mem[64] + 196] = this.address
                mem[mem[64] + 228] = block.timestamp + 60
                require ext_code.size(stor4)
                call stor4.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                     gas gas_remaining wei
                    args stor1, address(arg1), _237, _225, 0, 0, address(this.address), block.timestamp + 60
                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _302 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 96
                require mem[_302] == mem[_302]
                require mem[_302 + 32] == mem[_302 + 32]
                require mem[_302 + 64] == mem[_302 + 64]
                mem[0] = address(arg1)
                mem[32] = 9
                mem[mem[64] + 4] = this.address
                require ext_code.size(stor9[address(arg1)])
                staticcall stor9[address(arg1)].0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _344 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _350 = mem[_344]
                require mem[_344] == mem[_344]
                mem[0] = stor9[address(arg1)]
                mem[32] = 11
                mem[mem[64] + 4] = stor11[stor9[address(arg1)]]
                mem[mem[64] + 36] = _350
                require ext_code.size(stor9[address(arg1)])
                call stor9[address(arg1)].approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor11[stor9[address(arg1)]], _350
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _374 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_374] == bool(mem[_374])
                require ext_code.size(stor11[stor9[address(arg1)]])
                staticcall stor11[stor9[address(arg1)]].bondPrice() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _398 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _404 = mem[_398]
                require mem[_398] == mem[_398]
                require ext_code.size(stor11[stor9[address(arg1)]])
                staticcall stor11[stor9[address(arg1)]].bondInfo(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _422 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 128
                _428 = mem[_422]
                require mem[_422] == mem[_422]
                require mem[_422 + 32] == mem[_422 + 32]
                require mem[_422 + 64] == mem[_422 + 92 len 4]
                require mem[_422 + 96] == mem[_422 + 124 len 4]
                mem[mem[64] + 4] = _350
                mem[mem[64] + 36] = _404
                mem[mem[64] + 68] = msg.sender
                require ext_code.size(stor11[stor9[address(arg1)]])
                call stor11[stor9[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                     gas gas_remaining wei
                    args _350, _404, msg.sender
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _464 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_464] == mem[_464]
                require ext_code.size(stor11[stor9[address(arg1)]])
                staticcall stor11[stor9[address(arg1)]].bondInfo(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _488 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 128
                require mem[_488] == mem[_488]
                require mem[_488 + 32] == mem[_488 + 32]
                require mem[_488 + 64] == mem[_488 + 92 len 4]
                require mem[_488 + 96] == mem[_488 + 124 len 4]
                if mem[_488] < _428:
                    revert with 'NH{q', 17
                if mem[_488] - _428 < arg3:
                    revert with 0, 'insufficient profit, either ROI plummeted or your slippage is too tight'
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(arg1))
                staticcall address(arg1).0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _542 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _548 = mem[_542]
                require mem[_542] == mem[_542]
                if mem[_542] <= 0:
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(stor1)
                    staticcall stor1.0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _576 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _590 = mem[_576]
                    require mem[_576] == mem[_576]
                    if mem[_576] > 0:
                        mem[mem[64] + 4] = msg.sender
                        mem[mem[64] + 36] = _590
                        require ext_code.size(stor1)
                        call stor1.0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _590
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _630 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_630] == bool(mem[_630])
                else:
                    mem[mem[64] + 4] = msg.sender
                    mem[mem[64] + 36] = _548
                    require ext_code.size(address(arg1))
                    call address(arg1).0xa9059cbb with:
                         gas gas_remaining wei
                        args msg.sender, _548
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _584 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_584] == bool(mem[_584])
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(stor1)
                    staticcall stor1.0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _631 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _643 = mem[_631]
                    require mem[_631] == mem[_631]
                    if mem[_631] > 0:
                        mem[mem[64] + 4] = msg.sender
                        mem[mem[64] + 36] = _643
                        require ext_code.size(stor1)
                        call stor1.0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _643
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _662 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_662] == bool(mem[_662])
            else:
                mem[mem[64] + 4] = stor3
                mem[mem[64] + 36] = _225
                require ext_code.size(address(arg1))
                call address(arg1).approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor3, _225
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _255 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_255] == bool(mem[_255])
                mem[mem[64] + 4] = stor3
                mem[mem[64] + 36] = _237
                require ext_code.size(stor1)
                call stor1.approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor3, _237
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _279 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_279] == bool(mem[_279])
                if block.timestamp > -61:
                    revert with 'NH{q', 17
                mem[mem[64] + 68] = _237
                mem[mem[64] + 100] = _225
                mem[mem[64] + 132] = 0
                mem[mem[64] + 164] = 0
                mem[mem[64] + 196] = this.address
                mem[mem[64] + 228] = block.timestamp + 60
                require ext_code.size(stor3)
                call stor3.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                     gas gas_remaining wei
                    args stor1, address(arg1), _237, _225, 0, 0, address(this.address), block.timestamp + 60
                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _303 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 96
                require mem[_303] == mem[_303]
                require mem[_303 + 32] == mem[_303 + 32]
                require mem[_303 + 64] == mem[_303 + 64]
                mem[0] = address(arg1)
                mem[32] = 9
                mem[mem[64] + 4] = this.address
                require ext_code.size(stor9[address(arg1)])
                staticcall stor9[address(arg1)].0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _345 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _351 = mem[_345]
                require mem[_345] == mem[_345]
                mem[0] = stor9[address(arg1)]
                mem[32] = 11
                mem[mem[64] + 4] = stor11[stor9[address(arg1)]]
                mem[mem[64] + 36] = _351
                require ext_code.size(stor9[address(arg1)])
                call stor9[address(arg1)].approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor11[stor9[address(arg1)]], _351
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _375 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_375] == bool(mem[_375])
                require ext_code.size(stor11[stor9[address(arg1)]])
                staticcall stor11[stor9[address(arg1)]].bondPrice() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _399 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _405 = mem[_399]
                require mem[_399] == mem[_399]
                require ext_code.size(stor11[stor9[address(arg1)]])
                staticcall stor11[stor9[address(arg1)]].bondInfo(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _423 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 128
                _429 = mem[_423]
                require mem[_423] == mem[_423]
                require mem[_423 + 32] == mem[_423 + 32]
                require mem[_423 + 64] == mem[_423 + 92 len 4]
                require mem[_423 + 96] == mem[_423 + 124 len 4]
                mem[mem[64] + 4] = _351
                mem[mem[64] + 36] = _405
                mem[mem[64] + 68] = msg.sender
                require ext_code.size(stor11[stor9[address(arg1)]])
                call stor11[stor9[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                     gas gas_remaining wei
                    args _351, _405, msg.sender
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _465 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_465] == mem[_465]
                require ext_code.size(stor11[stor9[address(arg1)]])
                staticcall stor11[stor9[address(arg1)]].bondInfo(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _489 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 128
                require mem[_489] == mem[_489]
                require mem[_489 + 32] == mem[_489 + 32]
                require mem[_489 + 64] == mem[_489 + 92 len 4]
                require mem[_489 + 96] == mem[_489 + 124 len 4]
                if mem[_489] < _429:
                    revert with 'NH{q', 17
                if mem[_489] - _429 < arg3:
                    revert with 0, 'insufficient profit, either ROI plummeted or your slippage is too tight'
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(arg1))
                staticcall address(arg1).0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _543 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _549 = mem[_543]
                require mem[_543] == mem[_543]
                if mem[_543] <= 0:
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(stor1)
                    staticcall stor1.0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _578 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _591 = mem[_578]
                    require mem[_578] == mem[_578]
                    if mem[_578] > 0:
                        mem[mem[64] + 4] = msg.sender
                        mem[mem[64] + 36] = _591
                        require ext_code.size(stor1)
                        call stor1.0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _591
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _632 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_632] == bool(mem[_632])
                else:
                    mem[mem[64] + 4] = msg.sender
                    mem[mem[64] + 36] = _549
                    require ext_code.size(address(arg1))
                    call address(arg1).0xa9059cbb with:
                         gas gas_remaining wei
                        args msg.sender, _549
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _585 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_585] == bool(mem[_585])
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(stor1)
                    staticcall stor1.0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _633 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _645 = mem[_633]
                    require mem[_633] == mem[_633]
                    if mem[_633] > 0:
                        mem[mem[64] + 4] = msg.sender
                        mem[mem[64] + 36] = _645
                        require ext_code.size(stor1)
                        call stor1.0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _645
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _663 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_663] == bool(mem[_663])
        else:
            if ext_call.return_data[12 len 20] != address(arg1):
                revert with 0, 'bad LP token'
            if address(ext_call.return_data[0]) != stor1:
                revert with 0, 'bad LP token'
            if Mask(112, 0, ext_call.return_data[0]) > 0x20d135b66ae990fc484cea55e38a936bcf497445394d4cc984add428823e4d:
                revert with 'NH{q', 17
            if 1000 * Mask(112, 0, ext_call.return_data[0]) and arg2 > -1 / 1000 * Mask(112, 0, ext_call.return_data[0]):
                revert with 'NH{q', 17
            if arg2 / 2 > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                revert with 'NH{q', 17
            if 1994 * arg2 / 2 > (-1997 * Mask(112, 0, ext_call.return_data[0])) - 1:
                revert with 'NH{q', 17
            if arg2 / 2 > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                revert with 'NH{q', 17
            if 997 * arg2 / 2 and arg2 / 2 > -1 / 997 * arg2 / 2:
                revert with 'NH{q', 17
            if 997 * arg2 / 2 * arg2 / 2 > (-1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) - 1:
                revert with 'NH{q', 17
            if not (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])):
                revert with 'NH{q', 18
            if (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                revert with 'NH{q', 17
            if 1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) > (-1997 * Mask(112, 0, ext_call.return_data[0])) - 1:
                revert with 'NH{q', 17
            if (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                revert with 'NH{q', 17
            if 997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) and (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) > -1 / 997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])):
                revert with 'NH{q', 17
            if 997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) > (-1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) - 1:
                revert with 'NH{q', 17
            if not (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])):
                revert with 'NH{q', 18
            if (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                revert with 'NH{q', 17
            if 1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) > (-1997 * Mask(112, 0, ext_call.return_data[0])) - 1:
                revert with 'NH{q', 17
            if (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                revert with 'NH{q', 17
            if 997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) and (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) > -1 / 997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])):
                revert with 'NH{q', 17
            if 997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) > (-1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) - 1:
                revert with 'NH{q', 17
            if not (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])):
                revert with 'NH{q', 18
            require address(arg1)
            mem[(6 * ceil32(return_data.size)) + 100] = address(arg4)
            mem[(6 * ceil32(return_data.size)) + 132] = (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))
            require ext_code.size(stor1)
            call stor1.approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args address(arg4), (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))
            mem[(6 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == bool(ext_call.return_data[0])
            mem[(7 * ceil32(return_data.size)) + 96] = 2
            mem[(7 * ceil32(return_data.size)) + 128] = stor1
            mem[(7 * ceil32(return_data.size)) + 160] = address(arg1)
            if block.timestamp > -61:
                revert with 'NH{q', 17
            mem[(7 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
            mem[(7 * ceil32(return_data.size)) + 196] = (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))
            mem[(7 * ceil32(return_data.size)) + 228] = 0
            mem[(7 * ceil32(return_data.size)) + 260] = 160
            mem[(7 * ceil32(return_data.size)) + 356] = 2
            idx = 0
            s = (7 * ceil32(return_data.size)) + 128
            t = (7 * ceil32(return_data.size)) + 388
            while idx < 2:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[(7 * ceil32(return_data.size)) + 292] = this.address
            mem[(7 * ceil32(return_data.size)) + 324] = block.timestamp + 60
            require ext_code.size(address(arg4))
            call address(arg4).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                 gas gas_remaining wei
                args (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])), 0, 160, address(this.address), block.timestamp + 60, 2, mem[(7 * ceil32(return_data.size)) + 388 len 64]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[(7 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = (8 * ceil32(return_data.size)) + 192
            require return_data.size >= 32
            _98 = mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32
            require mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 <= test266151307()
            require (7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 223 < (7 * ceil32(return_data.size)) + return_data.size + 192
            _101 = mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]
            if mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192] > test266151307():
                revert with 'NH{q', 65
            if (8 * ceil32(return_data.size)) + floor32(mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]) + 193 > test266151307() or floor32(mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]) + 1 < 0:
                revert with 'NH{q', 65
            mem[64] = (8 * ceil32(return_data.size)) + floor32(mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 192]) + 193
            mem[(8 * ceil32(return_data.size)) + 192] = _101
            require _98 + (32 * _101) + 32 <= return_data.size
            idx = 0
            s = (7 * ceil32(return_data.size)) + _98 + 224
            t = (8 * ceil32(return_data.size)) + 224
            while idx < _101:
                require mem[s] == mem[s]
                mem[t] = mem[s]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[mem[64] + 4] = this.address
            require ext_code.size(address(arg1))
            staticcall address(arg1).0x70a08231 with:
                    gas gas_remaining wei
                   args address(this.address)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _221 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _224 = mem[_221]
            require mem[_221] == mem[_221]
            mem[mem[64] + 4] = this.address
            require ext_code.size(stor1)
            staticcall stor1.0x70a08231 with:
                    gas gas_remaining wei
                   args address(this.address)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _233 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _236 = mem[_233]
            require mem[_233] == mem[_233]
            if address(arg1) == stor2:
                mem[mem[64] + 4] = stor4
                mem[mem[64] + 36] = _224
                require ext_code.size(address(arg1))
                call address(arg1).approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor4, _224
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _252 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_252] == bool(mem[_252])
                mem[mem[64] + 4] = stor4
                mem[mem[64] + 36] = _236
                require ext_code.size(stor1)
                call stor1.approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor4, _236
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _276 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_276] == bool(mem[_276])
                if block.timestamp > -61:
                    revert with 'NH{q', 17
                mem[mem[64] + 68] = _236
                mem[mem[64] + 100] = _224
                mem[mem[64] + 132] = 0
                mem[mem[64] + 164] = 0
                mem[mem[64] + 196] = this.address
                mem[mem[64] + 228] = block.timestamp + 60
                require ext_code.size(stor4)
                call stor4.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                     gas gas_remaining wei
                    args stor1, address(arg1), _236, _224, 0, 0, address(this.address), block.timestamp + 60
                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _300 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 96
                require mem[_300] == mem[_300]
                require mem[_300 + 32] == mem[_300 + 32]
                require mem[_300 + 64] == mem[_300 + 64]
                mem[0] = address(arg1)
                mem[32] = 9
                mem[mem[64] + 4] = this.address
                require ext_code.size(stor9[address(arg1)])
                staticcall stor9[address(arg1)].0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _342 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _348 = mem[_342]
                require mem[_342] == mem[_342]
                mem[0] = stor9[address(arg1)]
                mem[32] = 11
                mem[mem[64] + 4] = stor11[stor9[address(arg1)]]
                mem[mem[64] + 36] = _348
                require ext_code.size(stor9[address(arg1)])
                call stor9[address(arg1)].approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor11[stor9[address(arg1)]], _348
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _372 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_372] == bool(mem[_372])
                require ext_code.size(stor11[stor9[address(arg1)]])
                staticcall stor11[stor9[address(arg1)]].bondPrice() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _396 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _402 = mem[_396]
                require mem[_396] == mem[_396]
                require ext_code.size(stor11[stor9[address(arg1)]])
                staticcall stor11[stor9[address(arg1)]].bondInfo(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _420 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 128
                _426 = mem[_420]
                require mem[_420] == mem[_420]
                require mem[_420 + 32] == mem[_420 + 32]
                require mem[_420 + 64] == mem[_420 + 92 len 4]
                require mem[_420 + 96] == mem[_420 + 124 len 4]
                mem[mem[64] + 4] = _348
                mem[mem[64] + 36] = _402
                mem[mem[64] + 68] = msg.sender
                require ext_code.size(stor11[stor9[address(arg1)]])
                call stor11[stor9[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                     gas gas_remaining wei
                    args _348, _402, msg.sender
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _462 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_462] == mem[_462]
                require ext_code.size(stor11[stor9[address(arg1)]])
                staticcall stor11[stor9[address(arg1)]].bondInfo(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _486 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 128
                require mem[_486] == mem[_486]
                require mem[_486 + 32] == mem[_486 + 32]
                require mem[_486 + 64] == mem[_486 + 92 len 4]
                require mem[_486 + 96] == mem[_486 + 124 len 4]
                if mem[_486] < _426:
                    revert with 'NH{q', 17
                if mem[_486] - _426 < arg3:
                    revert with 0, 'insufficient profit, either ROI plummeted or your slippage is too tight'
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(arg1))
                staticcall address(arg1).0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _540 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _546 = mem[_540]
                require mem[_540] == mem[_540]
                if mem[_540] <= 0:
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(stor1)
                    staticcall stor1.0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _572 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _588 = mem[_572]
                    require mem[_572] == mem[_572]
                    if mem[_572] > 0:
                        mem[mem[64] + 4] = msg.sender
                        mem[mem[64] + 36] = _588
                        require ext_code.size(stor1)
                        call stor1.0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _588
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _626 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_626] == bool(mem[_626])
                else:
                    mem[mem[64] + 4] = msg.sender
                    mem[mem[64] + 36] = _546
                    require ext_code.size(address(arg1))
                    call address(arg1).0xa9059cbb with:
                         gas gas_remaining wei
                        args msg.sender, _546
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _582 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_582] == bool(mem[_582])
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(stor1)
                    staticcall stor1.0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _627 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _639 = mem[_627]
                    require mem[_627] == mem[_627]
                    if mem[_627] > 0:
                        mem[mem[64] + 4] = msg.sender
                        mem[mem[64] + 36] = _639
                        require ext_code.size(stor1)
                        call stor1.0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _639
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _660 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_660] == bool(mem[_660])
            else:
                mem[mem[64] + 4] = stor3
                mem[mem[64] + 36] = _224
                require ext_code.size(address(arg1))
                call address(arg1).approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor3, _224
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _253 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_253] == bool(mem[_253])
                mem[mem[64] + 4] = stor3
                mem[mem[64] + 36] = _236
                require ext_code.size(stor1)
                call stor1.approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor3, _236
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _277 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_277] == bool(mem[_277])
                if block.timestamp > -61:
                    revert with 'NH{q', 17
                mem[mem[64] + 68] = _236
                mem[mem[64] + 100] = _224
                mem[mem[64] + 132] = 0
                mem[mem[64] + 164] = 0
                mem[mem[64] + 196] = this.address
                mem[mem[64] + 228] = block.timestamp + 60
                require ext_code.size(stor3)
                call stor3.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                     gas gas_remaining wei
                    args stor1, address(arg1), _236, _224, 0, 0, address(this.address), block.timestamp + 60
                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _301 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 96
                require mem[_301] == mem[_301]
                require mem[_301 + 32] == mem[_301 + 32]
                require mem[_301 + 64] == mem[_301 + 64]
                mem[0] = address(arg1)
                mem[32] = 9
                mem[mem[64] + 4] = this.address
                require ext_code.size(stor9[address(arg1)])
                staticcall stor9[address(arg1)].0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _343 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _349 = mem[_343]
                require mem[_343] == mem[_343]
                mem[0] = stor9[address(arg1)]
                mem[32] = 11
                mem[mem[64] + 4] = stor11[stor9[address(arg1)]]
                mem[mem[64] + 36] = _349
                require ext_code.size(stor9[address(arg1)])
                call stor9[address(arg1)].approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor11[stor9[address(arg1)]], _349
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _373 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_373] == bool(mem[_373])
                require ext_code.size(stor11[stor9[address(arg1)]])
                staticcall stor11[stor9[address(arg1)]].bondPrice() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _397 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _403 = mem[_397]
                require mem[_397] == mem[_397]
                require ext_code.size(stor11[stor9[address(arg1)]])
                staticcall stor11[stor9[address(arg1)]].bondInfo(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _421 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 128
                _427 = mem[_421]
                require mem[_421] == mem[_421]
                require mem[_421 + 32] == mem[_421 + 32]
                require mem[_421 + 64] == mem[_421 + 92 len 4]
                require mem[_421 + 96] == mem[_421 + 124 len 4]
                mem[mem[64] + 4] = _349
                mem[mem[64] + 36] = _403
                mem[mem[64] + 68] = msg.sender
                require ext_code.size(stor11[stor9[address(arg1)]])
                call stor11[stor9[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                     gas gas_remaining wei
                    args _349, _403, msg.sender
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _463 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_463] == mem[_463]
                require ext_code.size(stor11[stor9[address(arg1)]])
                staticcall stor11[stor9[address(arg1)]].bondInfo(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _487 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 128
                require mem[_487] == mem[_487]
                require mem[_487 + 32] == mem[_487 + 32]
                require mem[_487 + 64] == mem[_487 + 92 len 4]
                require mem[_487 + 96] == mem[_487 + 124 len 4]
                if mem[_487] < _427:
                    revert with 'NH{q', 17
                if mem[_487] - _427 < arg3:
                    revert with 0, 'insufficient profit, either ROI plummeted or your slippage is too tight'
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(arg1))
                staticcall address(arg1).0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _541 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _547 = mem[_541]
                require mem[_541] == mem[_541]
                if mem[_541] <= 0:
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(stor1)
                    staticcall stor1.0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _574 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _589 = mem[_574]
                    require mem[_574] == mem[_574]
                    if mem[_574] > 0:
                        mem[mem[64] + 4] = msg.sender
                        mem[mem[64] + 36] = _589
                        require ext_code.size(stor1)
                        call stor1.0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _589
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _628 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_628] == bool(mem[_628])
                else:
                    mem[mem[64] + 4] = msg.sender
                    mem[mem[64] + 36] = _547
                    require ext_code.size(address(arg1))
                    call address(arg1).0xa9059cbb with:
                         gas gas_remaining wei
                        args msg.sender, _547
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _583 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_583] == bool(mem[_583])
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(stor1)
                    staticcall stor1.0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _629 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _641 = mem[_629]
                    require mem[_629] == mem[_629]
                    if mem[_629] > 0:
                        mem[mem[64] + 4] = msg.sender
                        mem[mem[64] + 36] = _641
                        require ext_code.size(stor1)
                        call stor1.0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _641
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _661 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_661] == bool(mem[_661])
}

function sub_66366543(?) payable {
    require calldata.size - 4 >= 160
    require arg1 == address(arg1)
    require arg2 == arg2
    require arg3 == arg3
    require arg4 == address(arg4)
    require arg5 == address(arg5)
    mem[100] = msg.sender
    mem[132] = this.address
    mem[164] = arg2
    require ext_code.size(stor1)
    call stor1.0x23b872dd with:
         gas gas_remaining wei
        args msg.sender, address(this.address), arg2
    mem[96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    mem[0] = address(arg1)
    mem[32] = 9
    require stor9[address(arg1)]
    require ext_code.size(stor9[address(arg1)])
    staticcall stor9[address(arg1)].getReserves() with:
            gas gas_remaining wei
    mem[ceil32(return_data.size) + 96 len 96] = ext_call.return_data[0 len 96]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 96
    require ext_call.return_data[0] == ext_call.return_data[18 len 14]
    require ext_call.return_data[32] == ext_call.return_data[50 len 14]
    require ext_call.return_data[64] == ext_call.return_data[92 len 4]
    require ext_code.size(stor9[address(arg1)])
    staticcall stor9[address(arg1)].token0() with:
            gas gas_remaining wei
    mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    require ext_code.size(stor9[address(arg1)])
    staticcall stor9[address(arg1)].token1() with:
            gas gas_remaining wei
    mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    if address(ext_call.return_data[0]) != address(arg1):
        if ext_call.return_data[12 len 20] != address(arg1):
            revert with 0, 'bad LP token'
        if address(ext_call.return_data[0]) != stor1:
            revert with 0, 'bad LP token'
        if Mask(112, 0, ext_call.return_data[0]) > 0x20d135b66ae990fc484cea55e38a936bcf497445394d4cc984add428823e4d:
            revert with 'NH{q', 17
        if 1000 * Mask(112, 0, ext_call.return_data[0]) and arg2 > -1 / 1000 * Mask(112, 0, ext_call.return_data[0]):
            revert with 'NH{q', 17
        if arg2 / 2 > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
            revert with 'NH{q', 17
        if 1994 * arg2 / 2 > (-1997 * Mask(112, 0, ext_call.return_data[0])) - 1:
            revert with 'NH{q', 17
        if arg2 / 2 > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
            revert with 'NH{q', 17
        if 997 * arg2 / 2 and arg2 / 2 > -1 / 997 * arg2 / 2:
            revert with 'NH{q', 17
        if 997 * arg2 / 2 * arg2 / 2 > (-1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) - 1:
            revert with 'NH{q', 17
        if not (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])):
            revert with 'NH{q', 18
        if (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
            revert with 'NH{q', 17
        if 1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) > (-1997 * Mask(112, 0, ext_call.return_data[0])) - 1:
            revert with 'NH{q', 17
        if (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
            revert with 'NH{q', 17
        if 997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) and (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) > -1 / 997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])):
            revert with 'NH{q', 17
        if 997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) > (-1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) - 1:
            revert with 'NH{q', 17
        if not (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])):
            revert with 'NH{q', 18
        if (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
            revert with 'NH{q', 17
        if 1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) > (-1997 * Mask(112, 0, ext_call.return_data[0])) - 1:
            revert with 'NH{q', 17
        if (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
            revert with 'NH{q', 17
        if 997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) and (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) > -1 / 997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])):
            revert with 'NH{q', 17
        if 997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) > (-1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) - 1:
            revert with 'NH{q', 17
        if not (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])):
            revert with 'NH{q', 18
        require address(arg1)
        mem[(6 * ceil32(return_data.size)) + 100] = address(arg4)
        mem[(6 * ceil32(return_data.size)) + 132] = (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))
        require ext_code.size(stor1)
        call stor1.approve(address arg1, uint256 arg2) with:
             gas gas_remaining wei
            args address(arg4), (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))
        mem[(6 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == bool(ext_call.return_data[0])
        mem[(7 * ceil32(return_data.size)) + 96] = 3
        mem[(7 * ceil32(return_data.size)) + 128] = stor1
        mem[(7 * ceil32(return_data.size)) + 160] = address(arg5)
        mem[(7 * ceil32(return_data.size)) + 192] = address(arg1)
        if block.timestamp > -61:
            revert with 'NH{q', 17
        mem[(7 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
        mem[(7 * ceil32(return_data.size)) + 228] = (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))
        mem[(7 * ceil32(return_data.size)) + 260] = 0
        mem[(7 * ceil32(return_data.size)) + 292] = 160
        mem[(7 * ceil32(return_data.size)) + 388] = 3
        idx = 0
        s = (7 * ceil32(return_data.size)) + 128
        t = (7 * ceil32(return_data.size)) + 420
        while idx < 3:
            mem[t] = mem[s + 12 len 20]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        mem[(7 * ceil32(return_data.size)) + 324] = this.address
        mem[(7 * ceil32(return_data.size)) + 356] = block.timestamp + 60
        require ext_code.size(address(arg4))
        call address(arg4).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
             gas gas_remaining wei
            args (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])), 0, 160, address(this.address), block.timestamp + 60, 3, mem[(7 * ceil32(return_data.size)) + 420 len 96]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        mem[(7 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = (8 * ceil32(return_data.size)) + 224
        require return_data.size >= 32
        _91 = mem[(7 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32
        require mem[(7 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 <= test266151307()
        require (7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 255 < (7 * ceil32(return_data.size)) + return_data.size + 224
        _94 = mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 224]
        if mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 224] > test266151307():
            revert with 'NH{q', 65
        if (8 * ceil32(return_data.size)) + floor32(mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 224]) + 225 > test266151307() or floor32(mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 224]) + 1 < 0:
            revert with 'NH{q', 65
        mem[64] = (8 * ceil32(return_data.size)) + floor32(mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 224]) + 225
        mem[(8 * ceil32(return_data.size)) + 224] = _94
        require _91 + (32 * _94) + 32 <= return_data.size
        idx = 0
        s = (7 * ceil32(return_data.size)) + _91 + 256
        t = (8 * ceil32(return_data.size)) + 256
        while idx < _94:
            require mem[s] == mem[s]
            mem[t] = mem[s]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        mem[mem[64] + 4] = this.address
        require ext_code.size(address(arg1))
        staticcall address(arg1).0x70a08231 with:
                gas gas_remaining wei
               args address(this.address)
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _214 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _217 = mem[_214]
        require mem[_214] == mem[_214]
        mem[mem[64] + 4] = this.address
        require ext_code.size(stor1)
        staticcall stor1.0x70a08231 with:
                gas gas_remaining wei
               args address(this.address)
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _226 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _229 = mem[_226]
        require mem[_226] == mem[_226]
        if address(arg1) == stor2:
            mem[mem[64] + 4] = stor4
            mem[mem[64] + 36] = _217
            require ext_code.size(address(arg1))
            call address(arg1).approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args stor4, _217
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _244 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_244] == bool(mem[_244])
            mem[mem[64] + 4] = stor4
            mem[mem[64] + 36] = _229
            require ext_code.size(stor1)
            call stor1.approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args stor4, _229
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _268 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_268] == bool(mem[_268])
            if block.timestamp > -61:
                revert with 'NH{q', 17
            mem[mem[64] + 68] = _229
            mem[mem[64] + 100] = _217
            mem[mem[64] + 132] = 0
            mem[mem[64] + 164] = 0
            mem[mem[64] + 196] = this.address
            mem[mem[64] + 228] = block.timestamp + 60
            require ext_code.size(stor4)
            call stor4.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                 gas gas_remaining wei
                args stor1, address(arg1), _229, _217, 0, 0, address(this.address), block.timestamp + 60
            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _292 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 96
            require mem[_292] == mem[_292]
            require mem[_292 + 32] == mem[_292 + 32]
            require mem[_292 + 64] == mem[_292 + 64]
            mem[0] = address(arg1)
            mem[32] = 9
            mem[mem[64] + 4] = this.address
            require ext_code.size(stor9[address(arg1)])
            staticcall stor9[address(arg1)].0x70a08231 with:
                    gas gas_remaining wei
                   args address(this.address)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _334 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _340 = mem[_334]
            require mem[_334] == mem[_334]
            mem[0] = stor9[address(arg1)]
            mem[32] = 11
            mem[mem[64] + 4] = stor11[stor9[address(arg1)]]
            mem[mem[64] + 36] = _340
            require ext_code.size(stor9[address(arg1)])
            call stor9[address(arg1)].approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args stor11[stor9[address(arg1)]], _340
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _364 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_364] == bool(mem[_364])
            require ext_code.size(stor11[stor9[address(arg1)]])
            staticcall stor11[stor9[address(arg1)]].bondPrice() with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _388 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _394 = mem[_388]
            require mem[_388] == mem[_388]
            require ext_code.size(stor11[stor9[address(arg1)]])
            staticcall stor11[stor9[address(arg1)]].bondInfo(address arg1) with:
                    gas gas_remaining wei
                   args msg.sender
            mem[mem[64] len 128] = ext_call.return_data[0 len 128]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _412 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 128
            _418 = mem[_412]
            require mem[_412] == mem[_412]
            require mem[_412 + 32] == mem[_412 + 32]
            require mem[_412 + 64] == mem[_412 + 92 len 4]
            require mem[_412 + 96] == mem[_412 + 124 len 4]
            mem[mem[64] + 4] = _340
            mem[mem[64] + 36] = _394
            mem[mem[64] + 68] = msg.sender
            require ext_code.size(stor11[stor9[address(arg1)]])
            call stor11[stor9[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                 gas gas_remaining wei
                args _340, _394, msg.sender
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _454 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_454] == mem[_454]
            require ext_code.size(stor11[stor9[address(arg1)]])
            staticcall stor11[stor9[address(arg1)]].bondInfo(address arg1) with:
                    gas gas_remaining wei
                   args msg.sender
            mem[mem[64] len 128] = ext_call.return_data[0 len 128]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _478 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 128
            require mem[_478] == mem[_478]
            require mem[_478 + 32] == mem[_478 + 32]
            require mem[_478 + 64] == mem[_478 + 92 len 4]
            require mem[_478 + 96] == mem[_478 + 124 len 4]
            if mem[_478] < _418:
                revert with 'NH{q', 17
            if mem[_478] - _418 < arg3:
                revert with 0, 'insufficient profit, either ROI plummeted or your slippage is too tight'
            mem[mem[64] + 4] = this.address
            require ext_code.size(address(arg1))
            staticcall address(arg1).0x70a08231 with:
                    gas gas_remaining wei
                   args address(this.address)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _532 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _538 = mem[_532]
            require mem[_532] == mem[_532]
            if mem[_532] <= 0:
                mem[mem[64] + 4] = this.address
                require ext_code.size(stor1)
                staticcall stor1.0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _562 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _580 = mem[_562]
                require mem[_562] == mem[_562]
                if mem[_562] > 0:
                    mem[mem[64] + 4] = msg.sender
                    mem[mem[64] + 36] = _580
                    require ext_code.size(stor1)
                    call stor1.0xa9059cbb with:
                         gas gas_remaining wei
                        args msg.sender, _580
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _616 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_616] == bool(mem[_616])
            else:
                mem[mem[64] + 4] = msg.sender
                mem[mem[64] + 36] = _538
                require ext_code.size(address(arg1))
                call address(arg1).0xa9059cbb with:
                     gas gas_remaining wei
                    args msg.sender, _538
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _574 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_574] == bool(mem[_574])
                mem[mem[64] + 4] = this.address
                require ext_code.size(stor1)
                staticcall stor1.0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _617 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _629 = mem[_617]
                require mem[_617] == mem[_617]
                if mem[_617] > 0:
                    mem[mem[64] + 4] = msg.sender
                    mem[mem[64] + 36] = _629
                    require ext_code.size(stor1)
                    call stor1.0xa9059cbb with:
                         gas gas_remaining wei
                        args msg.sender, _629
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _652 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_652] == bool(mem[_652])
        else:
            mem[mem[64] + 4] = stor3
            mem[mem[64] + 36] = _217
            require ext_code.size(address(arg1))
            call address(arg1).approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args stor3, _217
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _245 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_245] == bool(mem[_245])
            mem[mem[64] + 4] = stor3
            mem[mem[64] + 36] = _229
            require ext_code.size(stor1)
            call stor1.approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args stor3, _229
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _269 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_269] == bool(mem[_269])
            if block.timestamp > -61:
                revert with 'NH{q', 17
            mem[mem[64] + 68] = _229
            mem[mem[64] + 100] = _217
            mem[mem[64] + 132] = 0
            mem[mem[64] + 164] = 0
            mem[mem[64] + 196] = this.address
            mem[mem[64] + 228] = block.timestamp + 60
            require ext_code.size(stor3)
            call stor3.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                 gas gas_remaining wei
                args stor1, address(arg1), _229, _217, 0, 0, address(this.address), block.timestamp + 60
            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _293 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 96
            require mem[_293] == mem[_293]
            require mem[_293 + 32] == mem[_293 + 32]
            require mem[_293 + 64] == mem[_293 + 64]
            mem[0] = address(arg1)
            mem[32] = 9
            mem[mem[64] + 4] = this.address
            require ext_code.size(stor9[address(arg1)])
            staticcall stor9[address(arg1)].0x70a08231 with:
                    gas gas_remaining wei
                   args address(this.address)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _335 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _341 = mem[_335]
            require mem[_335] == mem[_335]
            mem[0] = stor9[address(arg1)]
            mem[32] = 11
            mem[mem[64] + 4] = stor11[stor9[address(arg1)]]
            mem[mem[64] + 36] = _341
            require ext_code.size(stor9[address(arg1)])
            call stor9[address(arg1)].approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args stor11[stor9[address(arg1)]], _341
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _365 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_365] == bool(mem[_365])
            require ext_code.size(stor11[stor9[address(arg1)]])
            staticcall stor11[stor9[address(arg1)]].bondPrice() with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _389 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _395 = mem[_389]
            require mem[_389] == mem[_389]
            require ext_code.size(stor11[stor9[address(arg1)]])
            staticcall stor11[stor9[address(arg1)]].bondInfo(address arg1) with:
                    gas gas_remaining wei
                   args msg.sender
            mem[mem[64] len 128] = ext_call.return_data[0 len 128]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _413 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 128
            _419 = mem[_413]
            require mem[_413] == mem[_413]
            require mem[_413 + 32] == mem[_413 + 32]
            require mem[_413 + 64] == mem[_413 + 92 len 4]
            require mem[_413 + 96] == mem[_413 + 124 len 4]
            mem[mem[64] + 4] = _341
            mem[mem[64] + 36] = _395
            mem[mem[64] + 68] = msg.sender
            require ext_code.size(stor11[stor9[address(arg1)]])
            call stor11[stor9[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                 gas gas_remaining wei
                args _341, _395, msg.sender
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _455 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_455] == mem[_455]
            require ext_code.size(stor11[stor9[address(arg1)]])
            staticcall stor11[stor9[address(arg1)]].bondInfo(address arg1) with:
                    gas gas_remaining wei
                   args msg.sender
            mem[mem[64] len 128] = ext_call.return_data[0 len 128]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _479 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 128
            require mem[_479] == mem[_479]
            require mem[_479 + 32] == mem[_479 + 32]
            require mem[_479 + 64] == mem[_479 + 92 len 4]
            require mem[_479 + 96] == mem[_479 + 124 len 4]
            if mem[_479] < _419:
                revert with 'NH{q', 17
            if mem[_479] - _419 < arg3:
                revert with 0, 'insufficient profit, either ROI plummeted or your slippage is too tight'
            mem[mem[64] + 4] = this.address
            require ext_code.size(address(arg1))
            staticcall address(arg1).0x70a08231 with:
                    gas gas_remaining wei
                   args address(this.address)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _533 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _539 = mem[_533]
            require mem[_533] == mem[_533]
            if mem[_533] <= 0:
                mem[mem[64] + 4] = this.address
                require ext_code.size(stor1)
                staticcall stor1.0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _564 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _581 = mem[_564]
                require mem[_564] == mem[_564]
                if mem[_564] > 0:
                    mem[mem[64] + 4] = msg.sender
                    mem[mem[64] + 36] = _581
                    require ext_code.size(stor1)
                    call stor1.0xa9059cbb with:
                         gas gas_remaining wei
                        args msg.sender, _581
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _618 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_618] == bool(mem[_618])
            else:
                mem[mem[64] + 4] = msg.sender
                mem[mem[64] + 36] = _539
                require ext_code.size(address(arg1))
                call address(arg1).0xa9059cbb with:
                     gas gas_remaining wei
                    args msg.sender, _539
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _575 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_575] == bool(mem[_575])
                mem[mem[64] + 4] = this.address
                require ext_code.size(stor1)
                staticcall stor1.0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _619 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _631 = mem[_619]
                require mem[_619] == mem[_619]
                if mem[_619] > 0:
                    mem[mem[64] + 4] = msg.sender
                    mem[mem[64] + 36] = _631
                    require ext_code.size(stor1)
                    call stor1.0xa9059cbb with:
                         gas gas_remaining wei
                        args msg.sender, _631
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _653 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_653] == bool(mem[_653])
    else:
        if ext_call.return_data[12 len 20] == stor1:
            if Mask(112, 0, ext_call.return_data[32]) > 0x20d135b66ae990fc484cea55e38a936bcf497445394d4cc984add428823e4d:
                revert with 'NH{q', 17
            if 1000 * Mask(112, 0, ext_call.return_data[32]) and arg2 > -1 / 1000 * Mask(112, 0, ext_call.return_data[32]):
                revert with 'NH{q', 17
            if arg2 / 2 > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                revert with 'NH{q', 17
            if 1994 * arg2 / 2 > (-1997 * Mask(112, 0, ext_call.return_data[32])) - 1:
                revert with 'NH{q', 17
            if arg2 / 2 > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                revert with 'NH{q', 17
            if 997 * arg2 / 2 and arg2 / 2 > -1 / 997 * arg2 / 2:
                revert with 'NH{q', 17
            if 997 * arg2 / 2 * arg2 / 2 > (-1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) - 1:
                revert with 'NH{q', 17
            if not (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])):
                revert with 'NH{q', 18
            if (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                revert with 'NH{q', 17
            if 1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) > (-1997 * Mask(112, 0, ext_call.return_data[32])) - 1:
                revert with 'NH{q', 17
            if (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                revert with 'NH{q', 17
            if 997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) and (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) > -1 / 997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])):
                revert with 'NH{q', 17
            if 997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) > (-1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) - 1:
                revert with 'NH{q', 17
            if not (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])):
                revert with 'NH{q', 18
            if (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                revert with 'NH{q', 17
            if 1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) > (-1997 * Mask(112, 0, ext_call.return_data[32])) - 1:
                revert with 'NH{q', 17
            if (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                revert with 'NH{q', 17
            if 997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) and (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) > -1 / 997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])):
                revert with 'NH{q', 17
            if 997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) > (-1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) - 1:
                revert with 'NH{q', 17
            if not (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])):
                revert with 'NH{q', 18
            require address(arg1)
            mem[(6 * ceil32(return_data.size)) + 100] = address(arg4)
            mem[(6 * ceil32(return_data.size)) + 132] = (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))
            require ext_code.size(stor1)
            call stor1.approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args address(arg4), (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))
            mem[(6 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == bool(ext_call.return_data[0])
            mem[(7 * ceil32(return_data.size)) + 96] = 3
            mem[(7 * ceil32(return_data.size)) + 128] = stor1
            mem[(7 * ceil32(return_data.size)) + 160] = address(arg5)
            mem[(7 * ceil32(return_data.size)) + 192] = address(arg1)
            if block.timestamp > -61:
                revert with 'NH{q', 17
            mem[(7 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
            mem[(7 * ceil32(return_data.size)) + 228] = (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))
            mem[(7 * ceil32(return_data.size)) + 260] = 0
            mem[(7 * ceil32(return_data.size)) + 292] = 160
            mem[(7 * ceil32(return_data.size)) + 388] = 3
            idx = 0
            s = (7 * ceil32(return_data.size)) + 128
            t = (7 * ceil32(return_data.size)) + 420
            while idx < 3:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[(7 * ceil32(return_data.size)) + 324] = this.address
            mem[(7 * ceil32(return_data.size)) + 356] = block.timestamp + 60
            require ext_code.size(address(arg4))
            call address(arg4).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                 gas gas_remaining wei
                args (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])), 0, 160, address(this.address), block.timestamp + 60, 3, mem[(7 * ceil32(return_data.size)) + 420 len 96]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[(7 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = (8 * ceil32(return_data.size)) + 224
            require return_data.size >= 32
            _93 = mem[(7 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32
            require mem[(7 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 <= test266151307()
            require (7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 + 255 < (7 * ceil32(return_data.size)) + return_data.size + 224
            _96 = mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 + 224]
            if mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 + 224] > test266151307():
                revert with 'NH{q', 65
            if (8 * ceil32(return_data.size)) + floor32(mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 + 224]) + 225 > test266151307() or floor32(mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 + 224]) + 1 < 0:
                revert with 'NH{q', 65
            mem[64] = (8 * ceil32(return_data.size)) + floor32(mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[32]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) + (1997 * Mask(112, 0, ext_call.return_data[32]))) >> 32 + 224]) + 225
            mem[(8 * ceil32(return_data.size)) + 224] = _96
            require _93 + (32 * _96) + 32 <= return_data.size
            idx = 0
            s = (7 * ceil32(return_data.size)) + _93 + 256
            t = (8 * ceil32(return_data.size)) + 256
            while idx < _96:
                require mem[s] == mem[s]
                mem[t] = mem[s]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[mem[64] + 4] = this.address
            require ext_code.size(address(arg1))
            staticcall address(arg1).0x70a08231 with:
                    gas gas_remaining wei
                   args address(this.address)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _216 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _219 = mem[_216]
            require mem[_216] == mem[_216]
            mem[mem[64] + 4] = this.address
            require ext_code.size(stor1)
            staticcall stor1.0x70a08231 with:
                    gas gas_remaining wei
                   args address(this.address)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _228 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _231 = mem[_228]
            require mem[_228] == mem[_228]
            if address(arg1) == stor2:
                mem[mem[64] + 4] = stor4
                mem[mem[64] + 36] = _219
                require ext_code.size(address(arg1))
                call address(arg1).approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor4, _219
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _248 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_248] == bool(mem[_248])
                mem[mem[64] + 4] = stor4
                mem[mem[64] + 36] = _231
                require ext_code.size(stor1)
                call stor1.approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor4, _231
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _272 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_272] == bool(mem[_272])
                if block.timestamp > -61:
                    revert with 'NH{q', 17
                mem[mem[64] + 68] = _231
                mem[mem[64] + 100] = _219
                mem[mem[64] + 132] = 0
                mem[mem[64] + 164] = 0
                mem[mem[64] + 196] = this.address
                mem[mem[64] + 228] = block.timestamp + 60
                require ext_code.size(stor4)
                call stor4.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                     gas gas_remaining wei
                    args stor1, address(arg1), _231, _219, 0, 0, address(this.address), block.timestamp + 60
                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _296 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 96
                require mem[_296] == mem[_296]
                require mem[_296 + 32] == mem[_296 + 32]
                require mem[_296 + 64] == mem[_296 + 64]
                mem[0] = address(arg1)
                mem[32] = 9
                mem[mem[64] + 4] = this.address
                require ext_code.size(stor9[address(arg1)])
                staticcall stor9[address(arg1)].0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _338 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _344 = mem[_338]
                require mem[_338] == mem[_338]
                mem[0] = stor9[address(arg1)]
                mem[32] = 11
                mem[mem[64] + 4] = stor11[stor9[address(arg1)]]
                mem[mem[64] + 36] = _344
                require ext_code.size(stor9[address(arg1)])
                call stor9[address(arg1)].approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor11[stor9[address(arg1)]], _344
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _368 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_368] == bool(mem[_368])
                require ext_code.size(stor11[stor9[address(arg1)]])
                staticcall stor11[stor9[address(arg1)]].bondPrice() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _392 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _398 = mem[_392]
                require mem[_392] == mem[_392]
                require ext_code.size(stor11[stor9[address(arg1)]])
                staticcall stor11[stor9[address(arg1)]].bondInfo(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _416 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 128
                _422 = mem[_416]
                require mem[_416] == mem[_416]
                require mem[_416 + 32] == mem[_416 + 32]
                require mem[_416 + 64] == mem[_416 + 92 len 4]
                require mem[_416 + 96] == mem[_416 + 124 len 4]
                mem[mem[64] + 4] = _344
                mem[mem[64] + 36] = _398
                mem[mem[64] + 68] = msg.sender
                require ext_code.size(stor11[stor9[address(arg1)]])
                call stor11[stor9[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                     gas gas_remaining wei
                    args _344, _398, msg.sender
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _458 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_458] == mem[_458]
                require ext_code.size(stor11[stor9[address(arg1)]])
                staticcall stor11[stor9[address(arg1)]].bondInfo(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _482 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 128
                require mem[_482] == mem[_482]
                require mem[_482 + 32] == mem[_482 + 32]
                require mem[_482 + 64] == mem[_482 + 92 len 4]
                require mem[_482 + 96] == mem[_482 + 124 len 4]
                if mem[_482] < _422:
                    revert with 'NH{q', 17
                if mem[_482] - _422 < arg3:
                    revert with 0, 'insufficient profit, either ROI plummeted or your slippage is too tight'
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(arg1))
                staticcall address(arg1).0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _536 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _542 = mem[_536]
                require mem[_536] == mem[_536]
                if mem[_536] <= 0:
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(stor1)
                    staticcall stor1.0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _570 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _584 = mem[_570]
                    require mem[_570] == mem[_570]
                    if mem[_570] > 0:
                        mem[mem[64] + 4] = msg.sender
                        mem[mem[64] + 36] = _584
                        require ext_code.size(stor1)
                        call stor1.0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _584
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _624 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_624] == bool(mem[_624])
                else:
                    mem[mem[64] + 4] = msg.sender
                    mem[mem[64] + 36] = _542
                    require ext_code.size(address(arg1))
                    call address(arg1).0xa9059cbb with:
                         gas gas_remaining wei
                        args msg.sender, _542
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _578 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_578] == bool(mem[_578])
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(stor1)
                    staticcall stor1.0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _625 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _637 = mem[_625]
                    require mem[_625] == mem[_625]
                    if mem[_625] > 0:
                        mem[mem[64] + 4] = msg.sender
                        mem[mem[64] + 36] = _637
                        require ext_code.size(stor1)
                        call stor1.0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _637
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _656 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_656] == bool(mem[_656])
            else:
                mem[mem[64] + 4] = stor3
                mem[mem[64] + 36] = _219
                require ext_code.size(address(arg1))
                call address(arg1).approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor3, _219
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _249 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_249] == bool(mem[_249])
                mem[mem[64] + 4] = stor3
                mem[mem[64] + 36] = _231
                require ext_code.size(stor1)
                call stor1.approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor3, _231
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _273 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_273] == bool(mem[_273])
                if block.timestamp > -61:
                    revert with 'NH{q', 17
                mem[mem[64] + 68] = _231
                mem[mem[64] + 100] = _219
                mem[mem[64] + 132] = 0
                mem[mem[64] + 164] = 0
                mem[mem[64] + 196] = this.address
                mem[mem[64] + 228] = block.timestamp + 60
                require ext_code.size(stor3)
                call stor3.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                     gas gas_remaining wei
                    args stor1, address(arg1), _231, _219, 0, 0, address(this.address), block.timestamp + 60
                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _297 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 96
                require mem[_297] == mem[_297]
                require mem[_297 + 32] == mem[_297 + 32]
                require mem[_297 + 64] == mem[_297 + 64]
                mem[0] = address(arg1)
                mem[32] = 9
                mem[mem[64] + 4] = this.address
                require ext_code.size(stor9[address(arg1)])
                staticcall stor9[address(arg1)].0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _339 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _345 = mem[_339]
                require mem[_339] == mem[_339]
                mem[0] = stor9[address(arg1)]
                mem[32] = 11
                mem[mem[64] + 4] = stor11[stor9[address(arg1)]]
                mem[mem[64] + 36] = _345
                require ext_code.size(stor9[address(arg1)])
                call stor9[address(arg1)].approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor11[stor9[address(arg1)]], _345
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _369 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_369] == bool(mem[_369])
                require ext_code.size(stor11[stor9[address(arg1)]])
                staticcall stor11[stor9[address(arg1)]].bondPrice() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _393 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _399 = mem[_393]
                require mem[_393] == mem[_393]
                require ext_code.size(stor11[stor9[address(arg1)]])
                staticcall stor11[stor9[address(arg1)]].bondInfo(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _417 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 128
                _423 = mem[_417]
                require mem[_417] == mem[_417]
                require mem[_417 + 32] == mem[_417 + 32]
                require mem[_417 + 64] == mem[_417 + 92 len 4]
                require mem[_417 + 96] == mem[_417 + 124 len 4]
                mem[mem[64] + 4] = _345
                mem[mem[64] + 36] = _399
                mem[mem[64] + 68] = msg.sender
                require ext_code.size(stor11[stor9[address(arg1)]])
                call stor11[stor9[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                     gas gas_remaining wei
                    args _345, _399, msg.sender
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _459 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_459] == mem[_459]
                require ext_code.size(stor11[stor9[address(arg1)]])
                staticcall stor11[stor9[address(arg1)]].bondInfo(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _483 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 128
                require mem[_483] == mem[_483]
                require mem[_483 + 32] == mem[_483 + 32]
                require mem[_483 + 64] == mem[_483 + 92 len 4]
                require mem[_483 + 96] == mem[_483 + 124 len 4]
                if mem[_483] < _423:
                    revert with 'NH{q', 17
                if mem[_483] - _423 < arg3:
                    revert with 0, 'insufficient profit, either ROI plummeted or your slippage is too tight'
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(arg1))
                staticcall address(arg1).0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _537 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _543 = mem[_537]
                require mem[_537] == mem[_537]
                if mem[_537] <= 0:
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(stor1)
                    staticcall stor1.0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _572 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _585 = mem[_572]
                    require mem[_572] == mem[_572]
                    if mem[_572] > 0:
                        mem[mem[64] + 4] = msg.sender
                        mem[mem[64] + 36] = _585
                        require ext_code.size(stor1)
                        call stor1.0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _585
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _626 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_626] == bool(mem[_626])
                else:
                    mem[mem[64] + 4] = msg.sender
                    mem[mem[64] + 36] = _543
                    require ext_code.size(address(arg1))
                    call address(arg1).0xa9059cbb with:
                         gas gas_remaining wei
                        args msg.sender, _543
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _579 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_579] == bool(mem[_579])
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(stor1)
                    staticcall stor1.0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _627 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _639 = mem[_627]
                    require mem[_627] == mem[_627]
                    if mem[_627] > 0:
                        mem[mem[64] + 4] = msg.sender
                        mem[mem[64] + 36] = _639
                        require ext_code.size(stor1)
                        call stor1.0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _639
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _657 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_657] == bool(mem[_657])
        else:
            if ext_call.return_data[12 len 20] != address(arg1):
                revert with 0, 'bad LP token'
            if address(ext_call.return_data[0]) != stor1:
                revert with 0, 'bad LP token'
            if Mask(112, 0, ext_call.return_data[0]) > 0x20d135b66ae990fc484cea55e38a936bcf497445394d4cc984add428823e4d:
                revert with 'NH{q', 17
            if 1000 * Mask(112, 0, ext_call.return_data[0]) and arg2 > -1 / 1000 * Mask(112, 0, ext_call.return_data[0]):
                revert with 'NH{q', 17
            if arg2 / 2 > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                revert with 'NH{q', 17
            if 1994 * arg2 / 2 > (-1997 * Mask(112, 0, ext_call.return_data[0])) - 1:
                revert with 'NH{q', 17
            if arg2 / 2 > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                revert with 'NH{q', 17
            if 997 * arg2 / 2 and arg2 / 2 > -1 / 997 * arg2 / 2:
                revert with 'NH{q', 17
            if 997 * arg2 / 2 * arg2 / 2 > (-1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) - 1:
                revert with 'NH{q', 17
            if not (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])):
                revert with 'NH{q', 18
            if (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                revert with 'NH{q', 17
            if 1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) > (-1997 * Mask(112, 0, ext_call.return_data[0])) - 1:
                revert with 'NH{q', 17
            if (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                revert with 'NH{q', 17
            if 997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) and (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) > -1 / 997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])):
                revert with 'NH{q', 17
            if 997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) > (-1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) - 1:
                revert with 'NH{q', 17
            if not (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])):
                revert with 'NH{q', 18
            if (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                revert with 'NH{q', 17
            if 1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) > (-1997 * Mask(112, 0, ext_call.return_data[0])) - 1:
                revert with 'NH{q', 17
            if (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                revert with 'NH{q', 17
            if 997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) and (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) > -1 / 997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])):
                revert with 'NH{q', 17
            if 997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) > (-1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) - 1:
                revert with 'NH{q', 17
            if not (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])):
                revert with 'NH{q', 18
            require address(arg1)
            mem[(6 * ceil32(return_data.size)) + 100] = address(arg4)
            mem[(6 * ceil32(return_data.size)) + 132] = (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))
            require ext_code.size(stor1)
            call stor1.approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args address(arg4), (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))
            mem[(6 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == bool(ext_call.return_data[0])
            mem[(7 * ceil32(return_data.size)) + 96] = 3
            mem[(7 * ceil32(return_data.size)) + 128] = stor1
            mem[(7 * ceil32(return_data.size)) + 160] = address(arg5)
            mem[(7 * ceil32(return_data.size)) + 192] = address(arg1)
            if block.timestamp > -61:
                revert with 'NH{q', 17
            mem[(7 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
            mem[(7 * ceil32(return_data.size)) + 228] = (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))
            mem[(7 * ceil32(return_data.size)) + 260] = 0
            mem[(7 * ceil32(return_data.size)) + 292] = 160
            mem[(7 * ceil32(return_data.size)) + 388] = 3
            idx = 0
            s = (7 * ceil32(return_data.size)) + 128
            t = (7 * ceil32(return_data.size)) + 420
            while idx < 3:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[(7 * ceil32(return_data.size)) + 324] = this.address
            mem[(7 * ceil32(return_data.size)) + 356] = block.timestamp + 60
            require ext_code.size(address(arg4))
            call address(arg4).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                 gas gas_remaining wei
                args (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])), 0, 160, address(this.address), block.timestamp + 60, 3, mem[(7 * ceil32(return_data.size)) + 420 len 96]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[(7 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = (8 * ceil32(return_data.size)) + 224
            require return_data.size >= 32
            _92 = mem[(7 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32
            require mem[(7 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 <= test266151307()
            require (7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 255 < (7 * ceil32(return_data.size)) + return_data.size + 224
            _95 = mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 224]
            if mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 224] > test266151307():
                revert with 'NH{q', 65
            if (8 * ceil32(return_data.size)) + floor32(mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 224]) + 225 > test266151307() or floor32(mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 224]) + 1 < 0:
                revert with 'NH{q', 65
            mem[64] = (8 * ceil32(return_data.size)) + floor32(mem[(7 * ceil32(return_data.size)) + mem[(7 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, (997 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0])) * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * (997 * arg2 / 2 * arg2 / 2) + (1000 * Mask(112, 0, ext_call.return_data[0]) * arg2) / (1994 * arg2 / 2) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) + (1997 * Mask(112, 0, ext_call.return_data[0]))) >> 32 + 224]) + 225
            mem[(8 * ceil32(return_data.size)) + 224] = _95
            require _92 + (32 * _95) + 32 <= return_data.size
            idx = 0
            s = (7 * ceil32(return_data.size)) + _92 + 256
            t = (8 * ceil32(return_data.size)) + 256
            while idx < _95:
                require mem[s] == mem[s]
                mem[t] = mem[s]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[mem[64] + 4] = this.address
            require ext_code.size(address(arg1))
            staticcall address(arg1).0x70a08231 with:
                    gas gas_remaining wei
                   args address(this.address)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _215 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _218 = mem[_215]
            require mem[_215] == mem[_215]
            mem[mem[64] + 4] = this.address
            require ext_code.size(stor1)
            staticcall stor1.0x70a08231 with:
                    gas gas_remaining wei
                   args address(this.address)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _227 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _230 = mem[_227]
            require mem[_227] == mem[_227]
            if address(arg1) == stor2:
                mem[mem[64] + 4] = stor4
                mem[mem[64] + 36] = _218
                require ext_code.size(address(arg1))
                call address(arg1).approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor4, _218
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _246 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_246] == bool(mem[_246])
                mem[mem[64] + 4] = stor4
                mem[mem[64] + 36] = _230
                require ext_code.size(stor1)
                call stor1.approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor4, _230
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _270 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_270] == bool(mem[_270])
                if block.timestamp > -61:
                    revert with 'NH{q', 17
                mem[mem[64] + 68] = _230
                mem[mem[64] + 100] = _218
                mem[mem[64] + 132] = 0
                mem[mem[64] + 164] = 0
                mem[mem[64] + 196] = this.address
                mem[mem[64] + 228] = block.timestamp + 60
                require ext_code.size(stor4)
                call stor4.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                     gas gas_remaining wei
                    args stor1, address(arg1), _230, _218, 0, 0, address(this.address), block.timestamp + 60
                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _294 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 96
                require mem[_294] == mem[_294]
                require mem[_294 + 32] == mem[_294 + 32]
                require mem[_294 + 64] == mem[_294 + 64]
                mem[0] = address(arg1)
                mem[32] = 9
                mem[mem[64] + 4] = this.address
                require ext_code.size(stor9[address(arg1)])
                staticcall stor9[address(arg1)].0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _336 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _342 = mem[_336]
                require mem[_336] == mem[_336]
                mem[0] = stor9[address(arg1)]
                mem[32] = 11
                mem[mem[64] + 4] = stor11[stor9[address(arg1)]]
                mem[mem[64] + 36] = _342
                require ext_code.size(stor9[address(arg1)])
                call stor9[address(arg1)].approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor11[stor9[address(arg1)]], _342
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _366 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_366] == bool(mem[_366])
                require ext_code.size(stor11[stor9[address(arg1)]])
                staticcall stor11[stor9[address(arg1)]].bondPrice() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _390 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _396 = mem[_390]
                require mem[_390] == mem[_390]
                require ext_code.size(stor11[stor9[address(arg1)]])
                staticcall stor11[stor9[address(arg1)]].bondInfo(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _414 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 128
                _420 = mem[_414]
                require mem[_414] == mem[_414]
                require mem[_414 + 32] == mem[_414 + 32]
                require mem[_414 + 64] == mem[_414 + 92 len 4]
                require mem[_414 + 96] == mem[_414 + 124 len 4]
                mem[mem[64] + 4] = _342
                mem[mem[64] + 36] = _396
                mem[mem[64] + 68] = msg.sender
                require ext_code.size(stor11[stor9[address(arg1)]])
                call stor11[stor9[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                     gas gas_remaining wei
                    args _342, _396, msg.sender
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _456 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_456] == mem[_456]
                require ext_code.size(stor11[stor9[address(arg1)]])
                staticcall stor11[stor9[address(arg1)]].bondInfo(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _480 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 128
                require mem[_480] == mem[_480]
                require mem[_480 + 32] == mem[_480 + 32]
                require mem[_480 + 64] == mem[_480 + 92 len 4]
                require mem[_480 + 96] == mem[_480 + 124 len 4]
                if mem[_480] < _420:
                    revert with 'NH{q', 17
                if mem[_480] - _420 < arg3:
                    revert with 0, 'insufficient profit, either ROI plummeted or your slippage is too tight'
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(arg1))
                staticcall address(arg1).0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _534 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _540 = mem[_534]
                require mem[_534] == mem[_534]
                if mem[_534] <= 0:
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(stor1)
                    staticcall stor1.0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _566 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _582 = mem[_566]
                    require mem[_566] == mem[_566]
                    if mem[_566] > 0:
                        mem[mem[64] + 4] = msg.sender
                        mem[mem[64] + 36] = _582
                        require ext_code.size(stor1)
                        call stor1.0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _582
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _620 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_620] == bool(mem[_620])
                else:
                    mem[mem[64] + 4] = msg.sender
                    mem[mem[64] + 36] = _540
                    require ext_code.size(address(arg1))
                    call address(arg1).0xa9059cbb with:
                         gas gas_remaining wei
                        args msg.sender, _540
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _576 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_576] == bool(mem[_576])
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(stor1)
                    staticcall stor1.0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _621 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _633 = mem[_621]
                    require mem[_621] == mem[_621]
                    if mem[_621] > 0:
                        mem[mem[64] + 4] = msg.sender
                        mem[mem[64] + 36] = _633
                        require ext_code.size(stor1)
                        call stor1.0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _633
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _654 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_654] == bool(mem[_654])
            else:
                mem[mem[64] + 4] = stor3
                mem[mem[64] + 36] = _218
                require ext_code.size(address(arg1))
                call address(arg1).approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor3, _218
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _247 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_247] == bool(mem[_247])
                mem[mem[64] + 4] = stor3
                mem[mem[64] + 36] = _230
                require ext_code.size(stor1)
                call stor1.approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor3, _230
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _271 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_271] == bool(mem[_271])
                if block.timestamp > -61:
                    revert with 'NH{q', 17
                mem[mem[64] + 68] = _230
                mem[mem[64] + 100] = _218
                mem[mem[64] + 132] = 0
                mem[mem[64] + 164] = 0
                mem[mem[64] + 196] = this.address
                mem[mem[64] + 228] = block.timestamp + 60
                require ext_code.size(stor3)
                call stor3.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                     gas gas_remaining wei
                    args stor1, address(arg1), _230, _218, 0, 0, address(this.address), block.timestamp + 60
                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _295 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 96
                require mem[_295] == mem[_295]
                require mem[_295 + 32] == mem[_295 + 32]
                require mem[_295 + 64] == mem[_295 + 64]
                mem[0] = address(arg1)
                mem[32] = 9
                mem[mem[64] + 4] = this.address
                require ext_code.size(stor9[address(arg1)])
                staticcall stor9[address(arg1)].0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _337 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _343 = mem[_337]
                require mem[_337] == mem[_337]
                mem[0] = stor9[address(arg1)]
                mem[32] = 11
                mem[mem[64] + 4] = stor11[stor9[address(arg1)]]
                mem[mem[64] + 36] = _343
                require ext_code.size(stor9[address(arg1)])
                call stor9[address(arg1)].approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor11[stor9[address(arg1)]], _343
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _367 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_367] == bool(mem[_367])
                require ext_code.size(stor11[stor9[address(arg1)]])
                staticcall stor11[stor9[address(arg1)]].bondPrice() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _391 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _397 = mem[_391]
                require mem[_391] == mem[_391]
                require ext_code.size(stor11[stor9[address(arg1)]])
                staticcall stor11[stor9[address(arg1)]].bondInfo(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _415 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 128
                _421 = mem[_415]
                require mem[_415] == mem[_415]
                require mem[_415 + 32] == mem[_415 + 32]
                require mem[_415 + 64] == mem[_415 + 92 len 4]
                require mem[_415 + 96] == mem[_415 + 124 len 4]
                mem[mem[64] + 4] = _343
                mem[mem[64] + 36] = _397
                mem[mem[64] + 68] = msg.sender
                require ext_code.size(stor11[stor9[address(arg1)]])
                call stor11[stor9[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                     gas gas_remaining wei
                    args _343, _397, msg.sender
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _457 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_457] == mem[_457]
                require ext_code.size(stor11[stor9[address(arg1)]])
                staticcall stor11[stor9[address(arg1)]].bondInfo(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _481 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 128
                require mem[_481] == mem[_481]
                require mem[_481 + 32] == mem[_481 + 32]
                require mem[_481 + 64] == mem[_481 + 92 len 4]
                require mem[_481 + 96] == mem[_481 + 124 len 4]
                if mem[_481] < _421:
                    revert with 'NH{q', 17
                if mem[_481] - _421 < arg3:
                    revert with 0, 'insufficient profit, either ROI plummeted or your slippage is too tight'
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(arg1))
                staticcall address(arg1).0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _535 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _541 = mem[_535]
                require mem[_535] == mem[_535]
                if mem[_535] <= 0:
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(stor1)
                    staticcall stor1.0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _568 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _583 = mem[_568]
                    require mem[_568] == mem[_568]
                    if mem[_568] > 0:
                        mem[mem[64] + 4] = msg.sender
                        mem[mem[64] + 36] = _583
                        require ext_code.size(stor1)
                        call stor1.0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _583
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _622 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_622] == bool(mem[_622])
                else:
                    mem[mem[64] + 4] = msg.sender
                    mem[mem[64] + 36] = _541
                    require ext_code.size(address(arg1))
                    call address(arg1).0xa9059cbb with:
                         gas gas_remaining wei
                        args msg.sender, _541
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _577 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_577] == bool(mem[_577])
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(stor1)
                    staticcall stor1.0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _623 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _635 = mem[_623]
                    require mem[_623] == mem[_623]
                    if mem[_623] > 0:
                        mem[mem[64] + 4] = msg.sender
                        mem[mem[64] + 36] = _635
                        require ext_code.size(stor1)
                        call stor1.0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _635
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _655 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_655] == bool(mem[_655])
}

function sub_029c4aea(?) payable {
    require calldata.size - 4 >= 96
    require arg1 == address(arg1)
    require arg2 == arg2
    require arg3 == arg3
    mem[100] = msg.sender
    mem[132] = this.address
    mem[164] = arg2
    require ext_code.size(stor1)
    call stor1.0x23b872dd with:
         gas gas_remaining wei
        args msg.sender, address(this.address), arg2
    mem[96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    require stor2
    if stor2 == stor2:
        mem[ceil32(return_data.size) + 100] = stor4
        mem[ceil32(return_data.size) + 132] = arg2
        require ext_code.size(stor1)
        call stor1.approve(address arg1, uint256 arg2) with:
             gas gas_remaining wei
            args stor4, arg2
        mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == bool(ext_call.return_data[0])
        mem[(2 * ceil32(return_data.size)) + 96] = 2
        mem[(2 * ceil32(return_data.size)) + 128] = stor1
        mem[(2 * ceil32(return_data.size)) + 160] = stor2
        if block.timestamp > -61:
            revert with 'NH{q', 17
        mem[(2 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
        mem[(2 * ceil32(return_data.size)) + 196] = arg2
        mem[(2 * ceil32(return_data.size)) + 228] = 0
        mem[(2 * ceil32(return_data.size)) + 260] = 160
        mem[(2 * ceil32(return_data.size)) + 356] = 2
        idx = 0
        s = (2 * ceil32(return_data.size)) + 128
        t = (2 * ceil32(return_data.size)) + 388
        while idx < 2:
            mem[t] = mem[s + 12 len 20]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        mem[(2 * ceil32(return_data.size)) + 292] = this.address
        mem[(2 * ceil32(return_data.size)) + 324] = block.timestamp + 60
        require ext_code.size(stor4)
        call stor4.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
             gas gas_remaining wei
            args arg2, 0, 160, address(this.address), block.timestamp + 60, 2, mem[(2 * ceil32(return_data.size)) + 388 len 64]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        mem[(2 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = (4 * ceil32(return_data.size)) + 192
        require return_data.size >= 32
        _65 = mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32
        require mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 <= test266151307()
        require (2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 223 < (2 * ceil32(return_data.size)) + return_data.size + 192
        _67 = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192]
        if mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192] > test266151307():
            revert with 'NH{q', 65
        if (4 * ceil32(return_data.size)) + floor32(mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 193 > test266151307() or floor32(mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 1 < 0:
            revert with 'NH{q', 65
        mem[64] = (4 * ceil32(return_data.size)) + floor32(mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 193
        mem[(4 * ceil32(return_data.size)) + 192] = _67
        require _65 + (32 * _67) + 32 <= return_data.size
        idx = 0
        s = (2 * ceil32(return_data.size)) + _65 + 224
        t = (4 * ceil32(return_data.size)) + 224
        while idx < _67:
            require mem[s] == mem[s]
            mem[t] = mem[s]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        mem[0] = address(arg1)
        mem[32] = 10
        require stor10[address(arg1)]
        require ext_code.size(stor10[address(arg1)])
        staticcall stor10[address(arg1)].getReserves() with:
                gas gas_remaining wei
        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _151 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 96
        _153 = mem[_151]
        require mem[_151] == mem[_151 + 18 len 14]
        _155 = mem[_151 + 32]
        require mem[_151 + 32] == mem[_151 + 50 len 14]
        require mem[_151 + 64] == mem[_151 + 92 len 4]
        require ext_code.size(stor10[address(arg1)])
        staticcall stor10[address(arg1)].token0() with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _163 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _165 = mem[_163]
        require mem[_163] == mem[_163 + 12 len 20]
        require ext_code.size(stor10[address(arg1)])
        staticcall stor10[address(arg1)].token1() with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _171 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        require mem[_171] == mem[_171 + 12 len 20]
        if address(_165) != address(arg1):
            if mem[_171 + 12 len 20] != address(arg1):
                revert with 0, 'bad LP token'
            if address(_165) != stor2:
                revert with 0, 'bad LP token'
            mem[mem[64] + 4] = this.address
            require ext_code.size(stor2)
            staticcall stor2.0x70a08231 with:
                    gas gas_remaining wei
                   args address(this.address)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _205 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _211 = mem[_205]
            require mem[_205] == mem[_205]
            if Mask(112, 0, _153) > 0x20d135b66ae990fc484cea55e38a936bcf497445394d4cc984add428823e4d:
                revert with 'NH{q', 17
            if 1000 * Mask(112, 0, _153) and mem[_205] > -1 / 1000 * Mask(112, 0, _153):
                revert with 'NH{q', 17
            if mem[_205] / 2 > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                revert with 'NH{q', 17
            if 1994 * mem[_205] / 2 > (-1997 * Mask(112, 0, _153)) - 1:
                revert with 'NH{q', 17
            if mem[_205] / 2 > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                revert with 'NH{q', 17
            if 997 * mem[_205] / 2 and mem[_205] / 2 > -1 / 997 * mem[_205] / 2:
                revert with 'NH{q', 17
            if 997 * mem[_205] / 2 * mem[_205] / 2 > (-1000 * Mask(112, 0, _153) * mem[_205]) - 1:
                revert with 'NH{q', 17
            if not (1994 * mem[_205] / 2) + (1997 * Mask(112, 0, _153)):
                revert with 'NH{q', 18
            if (997 * mem[_205] / 2 * mem[_205] / 2) + (1000 * Mask(112, 0, _153) * mem[_205]) / (1994 * mem[_205] / 2) + (1997 * Mask(112, 0, _153)) > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                revert with 'NH{q', 17
            if 1994 * (997 * mem[_205] / 2 * mem[_205] / 2) + (1000 * Mask(112, 0, _153) * mem[_205]) / (1994 * mem[_205] / 2) + (1997 * Mask(112, 0, _153)) > (-1997 * Mask(112, 0, _153)) - 1:
                revert with 'NH{q', 17
            if (997 * mem[_205] / 2 * mem[_205] / 2) + (1000 * Mask(112, 0, _153) * mem[_205]) / (1994 * mem[_205] / 2) + (1997 * Mask(112, 0, _153)) > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                revert with 'NH{q', 17
            if 997 * (997 * mem[_205] / 2 * mem[_205] / 2) + (1000 * Mask(112, 0, _153) * mem[_205]) / (1994 * mem[_205] / 2) + (1997 * Mask(112, 0, _153)) and (997 * mem[_205] / 2 * mem[_205] / 2) + (1000 * Mask(112, 0, _153) * mem[_205]) / (1994 * mem[_205] / 2) + (1997 * Mask(112, 0, _153)) > -1 / 997 * (997 * mem[_205] / 2 * mem[_205] / 2) + (1000 * Mask(112, 0, _153) * mem[_205]) / (1994 * mem[_205] / 2) + (1997 * Mask(112, 0, _153)):
                revert with 'NH{q', 17
            if 997 * (997 * mem[_205] / 2 * mem[_205] / 2) + (1000 * Mask(112, 0, _153) * mem[_205]) / (1994 * mem[_205] / 2) + (1997 * Mask(112, 0, _153)) * (997 * mem[_205] / 2 * mem[_205] / 2) + (1000 * Mask(112, 0, _153) * mem[_205]) / (1994 * mem[_205] / 2) + (1997 * Mask(112, 0, _153)) > (-1000 * Mask(112, 0, _153) * mem[_205]) - 1:
                revert with 'NH{q', 17
            if not (1994 * (997 * mem[_205] / 2 * mem[_205] / 2) + (1000 * Mask(112, 0, _153) * mem[_205]) / (1994 * mem[_205] / 2) + (1997 * Mask(112, 0, _153))) + (1997 * Mask(112, 0, _153)):
                revert with 'NH{q', 18
            if (997 * (997 * mem[_205] / 2 * mem[_205] / 2) + (1000 * Mask(112, 0, _153) * mem[_205]) / (1994 * mem[_205] / 2) + (1997 * Mask(112, 0, _153)) * (997 * mem[_205] / 2 * mem[_205] / 2) + (1000 * Mask(112, 0, _153) * mem[_205]) / (1994 * mem[_205] / 2) + (1997 * Mask(112, 0, _153))) + (1000 * Mask(112, 0, _153) * mem[_205]) / (1994 * (997 * mem[_205] / 2 * mem[_205] / 2) + (1000 * Mask(112, 0, _153) * mem[_205]) / (1994 * mem[_205] / 2) + (1997 * Mask(112, 0, _153))) + (1997 * Mask(112, 0, _153)) > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                revert with 'NH{q', 17
            if 1994 * (997 * (997 * mem[_205] / 2 * mem[_205] / 2) + (1000 * Mask(112, 0, _153) * mem[_205]) / (1994 * mem[_205] / 2) + (1997 * Mask(112, 0, _153)) * (997 * mem[_205] / 2 * mem[_205] / 2) + (1000 * Mask(112, 0, _153) * mem[_205]) / (1994 * mem[_205] / 2) + (1997 * Mask(112, 0, _153))) + (1000 * Mask(112, 0, _153) * mem[_205]) / (1994 * (997 * mem[_205] / 2 * mem[_205] / 2) + (1000 * Mask(112, 0, _153) * mem[_205]) / (1994 * mem[_205] / 2) + (1997 * Mask(112, 0, _153))) + (1997 * Mask(112, 0, _153)) > (-1997 * Mask(112, 0, _153)) - 1:
                revert with 'NH{q', 17
            if (997 * (997 * mem[_205] / 2 * mem[_205] / 2) + (1000 * Mask(112, 0, _153) * mem[_205]) / (1994 * mem[_205] / 2) + (1997 * Mask(112, 0, _153)) * (997 * mem[_205] / 2 * mem[_205] / 2) + (1000 * Mask(112, 0, _153) * mem[_205]) / (1994 * mem[_205] / 2) + (1997 * Mask(112, 0, _153))) + (1000 * Mask(112, 0, _153) * mem[_205]) / (1994 * (997 * mem[_205] / 2 * mem[_205] / 2) + (1000 * Mask(112, 0, _153) * mem[_205]) / (1994 * mem[_205] / 2) + (1997 * Mask(112, 0, _153))) + (1997 * Mask(112, 0, _153)) > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                revert with 'NH{q', 17
            if 997 * (997 * (997 * mem[_205] / 2 * mem[_205] / 2) + (1000 * Mask(112, 0, _153) * mem[_205]) / (1994 * mem[_205] / 2) + (1997 * Mask(112, 0, _153)) * (997 * mem[_205] / 2 * mem[_205] / 2) + (1000 * Mask(112, 0, _153) * mem[_205]) / (1994 * mem[_205] / 2) + (1997 * Mask(112, 0, _153))) + (1000 * Mask(112, 0, _153) * mem[_205]) / (1994 * (997 * mem[_205] / 2 * mem[_205] / 2) + (1000 * Mask(112, 0, _153) * mem[_205]) / (1994 * mem[_205] / 2) + (1997 * Mask(112, 0, _153))) + (1997 * Mask(112, 0, _153)) and (997 * (997 * mem[_205] / 2 * mem[_205] / 2) + (1000 * Mask(112, 0, _153) * mem[_205]) / (1994 * mem[_205] / 2) + (1997 * Mask(112, 0, _153)) * (997 * mem[_205] / 2 * mem[_205] / 2) + (1000 * Mask(112, 0, _153) * mem[_205]) / (1994 * mem[_205] / 2) + (1997 * Mask(112, 0, _153))) + (1000 * Mask(112, 0, _153) * mem[_205]) / (1994 * (997 * mem[_205] / 2 * mem[_205] / 2) + (1000 * Mask(112, 0, _153) * mem[_205]) / (1994 * mem[_205] / 2) + (1997 * Mask(112, 0, _153))) + (1997 * Mask(112, 0, _153)) > -1 / 997 * (997 * (997 * mem[_205] / 2 * mem[_205] / 2) + (1000 * Mask(112, 0, _153) * mem[_205]) / (1994 * mem[_205] / 2) + (1997 * Mask(112, 0, _153)) * (997 * mem[_205] / 2 * mem[_205] / 2) + (1000 * Mask(112, 0, _153) * mem[_205]) / (1994 * mem[_205] / 2) + (1997 * Mask(112, 0, _153))) + (1000 * Mask(112, 0, _153) * mem[_205]) / (1994 * (997 * mem[_205] / 2 * mem[_205] / 2) + (1000 * Mask(112, 0, _153) * mem[_205]) / (1994 * mem[_205] / 2) + (1997 * Mask(112, 0, _153))) + (1997 * Mask(112, 0, _153)):
                revert with 'NH{q', 17
            if 997 * (997 * (997 * mem[_205] / 2 * mem[_205] / 2) + (1000 * Mask(112, 0, _153) * mem[_205]) / (1994 * mem[_205] / 2) + (1997 * Mask(112, 0, _153)) * (997 * mem[_205] / 2 * mem[_205] / 2) + (1000 * Mask(112, 0, _153) * mem[_205]) / (1994 * mem[_205] / 2) + (1997 * Mask(112, 0, _153))) + (1000 * Mask(112, 0, _153) * mem[_205]) / (1994 * (997 * mem[_205] / 2 * mem[_205] / 2) + (1000 * Mask(112, 0, _153) * mem[_205]) / (1994 * mem[_205] / 2) + (1997 * Mask(112, 0, _153))) + (1997 * Mask(112, 0, _153)) * (997 * (997 * mem[_205] / 2 * mem[_205] / 2) + (1000 * Mask(112, 0, _153) * mem[_205]) / (1994 * mem[_205] / 2) + (1997 * Mask(112, 0, _153)) * (997 * mem[_205] / 2 * mem[_205] / 2) + (1000 * Mask(112, 0, _153) * mem[_205]) / (1994 * mem[_205] / 2) + (1997 * Mask(112, 0, _153))) + (1000 * Mask(112, 0, _153) * mem[_205]) / (1994 * (997 * mem[_205] / 2 * mem[_205] / 2) + (1000 * Mask(112, 0, _153) * mem[_205]) / (1994 * mem[_205] / 2) + (1997 * Mask(112, 0, _153))) + (1997 * Mask(112, 0, _153)) > (-1000 * Mask(112, 0, _153) * mem[_205]) - 1:
                revert with 'NH{q', 17
            if not (1994 * (997 * (997 * mem[_205] / 2 * mem[_205] / 2) + (1000 * Mask(112, 0, _153) * mem[_205]) / (1994 * mem[_205] / 2) + (1997 * Mask(112, 0, _153)) * (997 * mem[_205] / 2 * mem[_205] / 2) + (1000 * Mask(112, 0, _153) * mem[_205]) / (1994 * mem[_205] / 2) + (1997 * Mask(112, 0, _153))) + (1000 * Mask(112, 0, _153) * mem[_205]) / (1994 * (997 * mem[_205] / 2 * mem[_205] / 2) + (1000 * Mask(112, 0, _153) * mem[_205]) / (1994 * mem[_205] / 2) + (1997 * Mask(112, 0, _153))) + (1997 * Mask(112, 0, _153))) + (1997 * Mask(112, 0, _153)):
                revert with 'NH{q', 18
            require address(arg1)
            mem[mem[64] + 4] = stor4
            mem[mem[64] + 36] = (997 * (997 * (997 * _211 / 2 * _211 / 2) + (1000 * Mask(112, 0, _153) * _211) / (1994 * _211 / 2) + (1997 * Mask(112, 0, _153)) * (997 * _211 / 2 * _211 / 2) + (1000 * Mask(112, 0, _153) * _211) / (1994 * _211 / 2) + (1997 * Mask(112, 0, _153))) + (1000 * Mask(112, 0, _153) * _211) / (1994 * (997 * _211 / 2 * _211 / 2) + (1000 * Mask(112, 0, _153) * _211) / (1994 * _211 / 2) + (1997 * Mask(112, 0, _153))) + (1997 * Mask(112, 0, _153)) * (997 * (997 * _211 / 2 * _211 / 2) + (1000 * Mask(112, 0, _153) * _211) / (1994 * _211 / 2) + (1997 * Mask(112, 0, _153)) * (997 * _211 / 2 * _211 / 2) + (1000 * Mask(112, 0, _153) * _211) / (1994 * _211 / 2) + (1997 * Mask(112, 0, _153))) + (1000 * Mask(112, 0, _153) * _211) / (1994 * (997 * _211 / 2 * _211 / 2) + (1000 * Mask(112, 0, _153) * _211) / (1994 * _211 / 2) + (1997 * Mask(112, 0, _153))) + (1997 * Mask(112, 0, _153))) + (1000 * Mask(112, 0, _153) * _211) / (1994 * (997 * (997 * _211 / 2 * _211 / 2) + (1000 * Mask(112, 0, _153) * _211) / (1994 * _211 / 2) + (1997 * Mask(112, 0, _153)) * (997 * _211 / 2 * _211 / 2) + (1000 * Mask(112, 0, _153) * _211) / (1994 * _211 / 2) + (1997 * Mask(112, 0, _153))) + (1000 * Mask(112, 0, _153) * _211) / (1994 * (997 * _211 / 2 * _211 / 2) + (1000 * Mask(112, 0, _153) * _211) / (1994 * _211 / 2) + (1997 * Mask(112, 0, _153))) + (1997 * Mask(112, 0, _153))) + (1997 * Mask(112, 0, _153))
            require ext_code.size(stor2)
            call stor2.approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args stor4, (997 * (997 * (997 * _211 / 2 * _211 / 2) + (1000 * Mask(112, 0, _153) * _211) / (1994 * _211 / 2) + (1997 * Mask(112, 0, _153)) * (997 * _211 / 2 * _211 / 2) + (1000 * Mask(112, 0, _153) * _211) / (1994 * _211 / 2) + (1997 * Mask(112, 0, _153))) + (1000 * Mask(112, 0, _153) * _211) / (1994 * (997 * _211 / 2 * _211 / 2) + (1000 * Mask(112, 0, _153) * _211) / (1994 * _211 / 2) + (1997 * Mask(112, 0, _153))) + (1997 * Mask(112, 0, _153)) * (997 * (997 * _211 / 2 * _211 / 2) + (1000 * Mask(112, 0, _153) * _211) / (1994 * _211 / 2) + (1997 * Mask(112, 0, _153)) * (997 * _211 / 2 * _211 / 2) + (1000 * Mask(112, 0, _153) * _211) / (1994 * _211 / 2) + (1997 * Mask(112, 0, _153))) + (1000 * Mask(112, 0, _153) * _211) / (1994 * (997 * _211 / 2 * _211 / 2) + (1000 * Mask(112, 0, _153) * _211) / (1994 * _211 / 2) + (1997 * Mask(112, 0, _153))) + (1997 * Mask(112, 0, _153))) + (1000 * Mask(112, 0, _153) * _211) / (1994 * (997 * (997 * _211 / 2 * _211 / 2) + (1000 * Mask(112, 0, _153) * _211) / (1994 * _211 / 2) + (1997 * Mask(112, 0, _153)) * (997 * _211 / 2 * _211 / 2) + (1000 * Mask(112, 0, _153) * _211) / (1994 * _211 / 2) + (1997 * Mask(112, 0, _153))) + (1000 * Mask(112, 0, _153) * _211) / (1994 * (997 * _211 / 2 * _211 / 2) + (1000 * Mask(112, 0, _153) * _211) / (1994 * _211 / 2) + (1997 * Mask(112, 0, _153))) + (1997 * Mask(112, 0, _153))) + (1997 * Mask(112, 0, _153))
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _229 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_229] == bool(mem[_229])
            _243 = mem[64]
            mem[mem[64]] = 2
            mem[64] = mem[64] + 96
            if 0 >= mem[_243]:
                revert with 'NH{q', 50
            mem[_243 + 32] = stor2
            if 1 >= mem[_243]:
                revert with 'NH{q', 50
            mem[_243 + 64] = address(arg1)
            if block.timestamp > -61:
                revert with 'NH{q', 17
            mem[_243 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
            mem[_243 + 100] = (997 * (997 * (997 * _211 / 2 * _211 / 2) + (1000 * Mask(112, 0, _153) * _211) / (1994 * _211 / 2) + (1997 * Mask(112, 0, _153)) * (997 * _211 / 2 * _211 / 2) + (1000 * Mask(112, 0, _153) * _211) / (1994 * _211 / 2) + (1997 * Mask(112, 0, _153))) + (1000 * Mask(112, 0, _153) * _211) / (1994 * (997 * _211 / 2 * _211 / 2) + (1000 * Mask(112, 0, _153) * _211) / (1994 * _211 / 2) + (1997 * Mask(112, 0, _153))) + (1997 * Mask(112, 0, _153)) * (997 * (997 * _211 / 2 * _211 / 2) + (1000 * Mask(112, 0, _153) * _211) / (1994 * _211 / 2) + (1997 * Mask(112, 0, _153)) * (997 * _211 / 2 * _211 / 2) + (1000 * Mask(112, 0, _153) * _211) / (1994 * _211 / 2) + (1997 * Mask(112, 0, _153))) + (1000 * Mask(112, 0, _153) * _211) / (1994 * (997 * _211 / 2 * _211 / 2) + (1000 * Mask(112, 0, _153) * _211) / (1994 * _211 / 2) + (1997 * Mask(112, 0, _153))) + (1997 * Mask(112, 0, _153))) + (1000 * Mask(112, 0, _153) * _211) / (1994 * (997 * (997 * _211 / 2 * _211 / 2) + (1000 * Mask(112, 0, _153) * _211) / (1994 * _211 / 2) + (1997 * Mask(112, 0, _153)) * (997 * _211 / 2 * _211 / 2) + (1000 * Mask(112, 0, _153) * _211) / (1994 * _211 / 2) + (1997 * Mask(112, 0, _153))) + (1000 * Mask(112, 0, _153) * _211) / (1994 * (997 * _211 / 2 * _211 / 2) + (1000 * Mask(112, 0, _153) * _211) / (1994 * _211 / 2) + (1997 * Mask(112, 0, _153))) + (1997 * Mask(112, 0, _153))) + (1997 * Mask(112, 0, _153))
            mem[_243 + 132] = 0
            mem[_243 + 164] = 160
            mem[_243 + 260] = mem[_243]
            idx = 0
            s = _243 + 32
            t = _243 + 292
            while idx < mem[_243]:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[_243 + 196] = this.address
            mem[_243 + 228] = block.timestamp + 60
            require ext_code.size(stor4)
            call stor4.mem[mem[64] len 4] with:
                 gas gas_remaining wei
                args mem[mem[64] + 4 len _243 + (32 * mem[_243]) + -mem[64] + 288]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _391 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _397 = mem[_391]
            require mem[_391] <= test266151307()
            require _391 + mem[_391] + 31 < _391 + return_data.size
            _403 = mem[_391 + mem[_391]]
            if mem[_391 + mem[_391]] > test266151307():
                revert with 'NH{q', 65
            if _391 + ceil32(return_data.size) + floor32(mem[_391 + mem[_391]]) + 1 > test266151307() or floor32(mem[_391 + mem[_391]]) + 1 < 0:
                revert with 'NH{q', 65
            mem[64] = _391 + ceil32(return_data.size) + floor32(mem[_391 + mem[_391]]) + 1
            mem[_391 + ceil32(return_data.size)] = _403
            require _397 + (32 * _403) + 32 <= return_data.size
            idx = 0
            s = _391 + _397 + 32
            t = _391 + ceil32(return_data.size) + 32
            while idx < _403:
                require mem[s] == mem[s]
                mem[t] = mem[s]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[mem[64] + 4] = this.address
            require ext_code.size(address(arg1))
            staticcall address(arg1).0x70a08231 with:
                    gas gas_remaining wei
                   args address(this.address)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _571 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _577 = mem[_571]
            require mem[_571] == mem[_571]
            mem[mem[64] + 4] = this.address
            require ext_code.size(stor2)
            staticcall stor2.0x70a08231 with:
                    gas gas_remaining wei
                   args address(this.address)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _595 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _601 = mem[_595]
            require mem[_595] == mem[_595]
            mem[mem[64] + 4] = stor4
            mem[mem[64] + 36] = _577
            require ext_code.size(address(arg1))
            call address(arg1).approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args stor4, _577
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _619 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_619] == bool(mem[_619])
            mem[mem[64] + 4] = stor4
            mem[mem[64] + 36] = _601
            require ext_code.size(stor2)
            call stor2.approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args stor4, _601
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _643 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_643] == bool(mem[_643])
            if block.timestamp > -61:
                revert with 'NH{q', 17
            mem[mem[64] + 68] = _601
            mem[mem[64] + 100] = _577
            mem[mem[64] + 132] = 0
            mem[mem[64] + 164] = 0
            mem[mem[64] + 196] = this.address
            mem[mem[64] + 228] = block.timestamp + 60
            require ext_code.size(stor4)
            call stor4.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                 gas gas_remaining wei
                args stor2, address(arg1), _601, _577, 0, 0, address(this.address), block.timestamp + 60
            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _667 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 96
            require mem[_667] == mem[_667]
            require mem[_667 + 32] == mem[_667 + 32]
            require mem[_667 + 64] == mem[_667 + 64]
            mem[0] = address(arg1)
            mem[32] = 10
            mem[mem[64] + 4] = this.address
            require ext_code.size(stor10[address(arg1)])
            staticcall stor10[address(arg1)].0x70a08231 with:
                    gas gas_remaining wei
                   args address(this.address)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _709 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _715 = mem[_709]
            require mem[_709] == mem[_709]
            mem[0] = stor10[address(arg1)]
            mem[32] = 11
            mem[mem[64] + 4] = stor11[stor10[address(arg1)]]
            mem[mem[64] + 36] = _715
            require ext_code.size(stor10[address(arg1)])
            call stor10[address(arg1)].approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args stor11[stor10[address(arg1)]], _715
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _739 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_739] == bool(mem[_739])
            require ext_code.size(stor11[stor10[address(arg1)]])
            staticcall stor11[stor10[address(arg1)]].bondPrice() with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _763 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _769 = mem[_763]
            require mem[_763] == mem[_763]
            require ext_code.size(stor11[stor10[address(arg1)]])
            staticcall stor11[stor10[address(arg1)]].bondInfo(address arg1) with:
                    gas gas_remaining wei
                   args msg.sender
            mem[mem[64] len 128] = ext_call.return_data[0 len 128]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _787 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 128
            _793 = mem[_787]
            require mem[_787] == mem[_787]
            require mem[_787 + 32] == mem[_787 + 32]
            require mem[_787 + 64] == mem[_787 + 92 len 4]
            require mem[_787 + 96] == mem[_787 + 124 len 4]
            mem[mem[64] + 4] = _715
            mem[mem[64] + 36] = _769
            mem[mem[64] + 68] = msg.sender
            require ext_code.size(stor11[stor10[address(arg1)]])
            call stor11[stor10[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                 gas gas_remaining wei
                args _715, _769, msg.sender
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _829 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_829] == mem[_829]
            require ext_code.size(stor11[stor10[address(arg1)]])
            staticcall stor11[stor10[address(arg1)]].bondInfo(address arg1) with:
                    gas gas_remaining wei
                   args msg.sender
            mem[mem[64] len 128] = ext_call.return_data[0 len 128]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _853 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 128
            require mem[_853] == mem[_853]
            require mem[_853 + 32] == mem[_853 + 32]
            require mem[_853 + 64] == mem[_853 + 92 len 4]
            require mem[_853 + 96] == mem[_853 + 124 len 4]
            if mem[_853] < _793:
                revert with 'NH{q', 17
            if mem[_853] - _793 < arg3:
                revert with 0, 'insufficient profit, either ROI plummeted or your slippage is too tight'
            mem[mem[64] + 4] = this.address
            require ext_code.size(address(arg1))
            staticcall address(arg1).0x70a08231 with:
                    gas gas_remaining wei
                   args address(this.address)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _907 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _913 = mem[_907]
            require mem[_907] == mem[_907]
            if mem[_907] <= 0:
                mem[mem[64] + 4] = this.address
                require ext_code.size(stor2)
                staticcall stor2.0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _937 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _955 = mem[_937]
                require mem[_937] == mem[_937]
                if mem[_937] > 0:
                    mem[mem[64] + 4] = msg.sender
                    mem[mem[64] + 36] = _955
                    require ext_code.size(stor2)
                    call stor2.0xa9059cbb with:
                         gas gas_remaining wei
                        args msg.sender, _955
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _991 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_991] == bool(mem[_991])
            else:
                mem[mem[64] + 4] = msg.sender
                mem[mem[64] + 36] = _913
                require ext_code.size(address(arg1))
                call address(arg1).0xa9059cbb with:
                     gas gas_remaining wei
                    args msg.sender, _913
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _949 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_949] == bool(mem[_949])
                mem[mem[64] + 4] = this.address
                require ext_code.size(stor2)
                staticcall stor2.0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _992 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _1004 = mem[_992]
                require mem[_992] == mem[_992]
                if mem[_992] > 0:
                    mem[mem[64] + 4] = msg.sender
                    mem[mem[64] + 36] = _1004
                    require ext_code.size(stor2)
                    call stor2.0xa9059cbb with:
                         gas gas_remaining wei
                        args msg.sender, _1004
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1027 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_1027] == bool(mem[_1027])
        else:
            if mem[_171 + 12 len 20] == stor2:
                mem[mem[64] + 4] = this.address
                require ext_code.size(stor2)
                staticcall stor2.0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _198 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _206 = mem[_198]
                require mem[_198] == mem[_198]
                if Mask(112, 0, _155) > 0x20d135b66ae990fc484cea55e38a936bcf497445394d4cc984add428823e4d:
                    revert with 'NH{q', 17
                if 1000 * Mask(112, 0, _155) and mem[_198] > -1 / 1000 * Mask(112, 0, _155):
                    revert with 'NH{q', 17
                if mem[_198] / 2 > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                    revert with 'NH{q', 17
                if 1994 * mem[_198] / 2 > (-1997 * Mask(112, 0, _155)) - 1:
                    revert with 'NH{q', 17
                if mem[_198] / 2 > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                    revert with 'NH{q', 17
                if 997 * mem[_198] / 2 and mem[_198] / 2 > -1 / 997 * mem[_198] / 2:
                    revert with 'NH{q', 17
                if 997 * mem[_198] / 2 * mem[_198] / 2 > (-1000 * Mask(112, 0, _155) * mem[_198]) - 1:
                    revert with 'NH{q', 17
                if not (1994 * mem[_198] / 2) + (1997 * Mask(112, 0, _155)):
                    revert with 'NH{q', 18
                if (997 * mem[_198] / 2 * mem[_198] / 2) + (1000 * Mask(112, 0, _155) * mem[_198]) / (1994 * mem[_198] / 2) + (1997 * Mask(112, 0, _155)) > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                    revert with 'NH{q', 17
                if 1994 * (997 * mem[_198] / 2 * mem[_198] / 2) + (1000 * Mask(112, 0, _155) * mem[_198]) / (1994 * mem[_198] / 2) + (1997 * Mask(112, 0, _155)) > (-1997 * Mask(112, 0, _155)) - 1:
                    revert with 'NH{q', 17
                if (997 * mem[_198] / 2 * mem[_198] / 2) + (1000 * Mask(112, 0, _155) * mem[_198]) / (1994 * mem[_198] / 2) + (1997 * Mask(112, 0, _155)) > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                    revert with 'NH{q', 17
                if 997 * (997 * mem[_198] / 2 * mem[_198] / 2) + (1000 * Mask(112, 0, _155) * mem[_198]) / (1994 * mem[_198] / 2) + (1997 * Mask(112, 0, _155)) and (997 * mem[_198] / 2 * mem[_198] / 2) + (1000 * Mask(112, 0, _155) * mem[_198]) / (1994 * mem[_198] / 2) + (1997 * Mask(112, 0, _155)) > -1 / 997 * (997 * mem[_198] / 2 * mem[_198] / 2) + (1000 * Mask(112, 0, _155) * mem[_198]) / (1994 * mem[_198] / 2) + (1997 * Mask(112, 0, _155)):
                    revert with 'NH{q', 17
                if 997 * (997 * mem[_198] / 2 * mem[_198] / 2) + (1000 * Mask(112, 0, _155) * mem[_198]) / (1994 * mem[_198] / 2) + (1997 * Mask(112, 0, _155)) * (997 * mem[_198] / 2 * mem[_198] / 2) + (1000 * Mask(112, 0, _155) * mem[_198]) / (1994 * mem[_198] / 2) + (1997 * Mask(112, 0, _155)) > (-1000 * Mask(112, 0, _155) * mem[_198]) - 1:
                    revert with 'NH{q', 17
                if not (1994 * (997 * mem[_198] / 2 * mem[_198] / 2) + (1000 * Mask(112, 0, _155) * mem[_198]) / (1994 * mem[_198] / 2) + (1997 * Mask(112, 0, _155))) + (1997 * Mask(112, 0, _155)):
                    revert with 'NH{q', 18
                if (997 * (997 * mem[_198] / 2 * mem[_198] / 2) + (1000 * Mask(112, 0, _155) * mem[_198]) / (1994 * mem[_198] / 2) + (1997 * Mask(112, 0, _155)) * (997 * mem[_198] / 2 * mem[_198] / 2) + (1000 * Mask(112, 0, _155) * mem[_198]) / (1994 * mem[_198] / 2) + (1997 * Mask(112, 0, _155))) + (1000 * Mask(112, 0, _155) * mem[_198]) / (1994 * (997 * mem[_198] / 2 * mem[_198] / 2) + (1000 * Mask(112, 0, _155) * mem[_198]) / (1994 * mem[_198] / 2) + (1997 * Mask(112, 0, _155))) + (1997 * Mask(112, 0, _155)) > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                    revert with 'NH{q', 17
                if 1994 * (997 * (997 * mem[_198] / 2 * mem[_198] / 2) + (1000 * Mask(112, 0, _155) * mem[_198]) / (1994 * mem[_198] / 2) + (1997 * Mask(112, 0, _155)) * (997 * mem[_198] / 2 * mem[_198] / 2) + (1000 * Mask(112, 0, _155) * mem[_198]) / (1994 * mem[_198] / 2) + (1997 * Mask(112, 0, _155))) + (1000 * Mask(112, 0, _155) * mem[_198]) / (1994 * (997 * mem[_198] / 2 * mem[_198] / 2) + (1000 * Mask(112, 0, _155) * mem[_198]) / (1994 * mem[_198] / 2) + (1997 * Mask(112, 0, _155))) + (1997 * Mask(112, 0, _155)) > (-1997 * Mask(112, 0, _155)) - 1:
                    revert with 'NH{q', 17
                if (997 * (997 * mem[_198] / 2 * mem[_198] / 2) + (1000 * Mask(112, 0, _155) * mem[_198]) / (1994 * mem[_198] / 2) + (1997 * Mask(112, 0, _155)) * (997 * mem[_198] / 2 * mem[_198] / 2) + (1000 * Mask(112, 0, _155) * mem[_198]) / (1994 * mem[_198] / 2) + (1997 * Mask(112, 0, _155))) + (1000 * Mask(112, 0, _155) * mem[_198]) / (1994 * (997 * mem[_198] / 2 * mem[_198] / 2) + (1000 * Mask(112, 0, _155) * mem[_198]) / (1994 * mem[_198] / 2) + (1997 * Mask(112, 0, _155))) + (1997 * Mask(112, 0, _155)) > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                    revert with 'NH{q', 17
                if 997 * (997 * (997 * mem[_198] / 2 * mem[_198] / 2) + (1000 * Mask(112, 0, _155) * mem[_198]) / (1994 * mem[_198] / 2) + (1997 * Mask(112, 0, _155)) * (997 * mem[_198] / 2 * mem[_198] / 2) + (1000 * Mask(112, 0, _155) * mem[_198]) / (1994 * mem[_198] / 2) + (1997 * Mask(112, 0, _155))) + (1000 * Mask(112, 0, _155) * mem[_198]) / (1994 * (997 * mem[_198] / 2 * mem[_198] / 2) + (1000 * Mask(112, 0, _155) * mem[_198]) / (1994 * mem[_198] / 2) + (1997 * Mask(112, 0, _155))) + (1997 * Mask(112, 0, _155)) and (997 * (997 * mem[_198] / 2 * mem[_198] / 2) + (1000 * Mask(112, 0, _155) * mem[_198]) / (1994 * mem[_198] / 2) + (1997 * Mask(112, 0, _155)) * (997 * mem[_198] / 2 * mem[_198] / 2) + (1000 * Mask(112, 0, _155) * mem[_198]) / (1994 * mem[_198] / 2) + (1997 * Mask(112, 0, _155))) + (1000 * Mask(112, 0, _155) * mem[_198]) / (1994 * (997 * mem[_198] / 2 * mem[_198] / 2) + (1000 * Mask(112, 0, _155) * mem[_198]) / (1994 * mem[_198] / 2) + (1997 * Mask(112, 0, _155))) + (1997 * Mask(112, 0, _155)) > -1 / 997 * (997 * (997 * mem[_198] / 2 * mem[_198] / 2) + (1000 * Mask(112, 0, _155) * mem[_198]) / (1994 * mem[_198] / 2) + (1997 * Mask(112, 0, _155)) * (997 * mem[_198] / 2 * mem[_198] / 2) + (1000 * Mask(112, 0, _155) * mem[_198]) / (1994 * mem[_198] / 2) + (1997 * Mask(112, 0, _155))) + (1000 * Mask(112, 0, _155) * mem[_198]) / (1994 * (997 * mem[_198] / 2 * mem[_198] / 2) + (1000 * Mask(112, 0, _155) * mem[_198]) / (1994 * mem[_198] / 2) + (1997 * Mask(112, 0, _155))) + (1997 * Mask(112, 0, _155)):
                    revert with 'NH{q', 17
                if 997 * (997 * (997 * mem[_198] / 2 * mem[_198] / 2) + (1000 * Mask(112, 0, _155) * mem[_198]) / (1994 * mem[_198] / 2) + (1997 * Mask(112, 0, _155)) * (997 * mem[_198] / 2 * mem[_198] / 2) + (1000 * Mask(112, 0, _155) * mem[_198]) / (1994 * mem[_198] / 2) + (1997 * Mask(112, 0, _155))) + (1000 * Mask(112, 0, _155) * mem[_198]) / (1994 * (997 * mem[_198] / 2 * mem[_198] / 2) + (1000 * Mask(112, 0, _155) * mem[_198]) / (1994 * mem[_198] / 2) + (1997 * Mask(112, 0, _155))) + (1997 * Mask(112, 0, _155)) * (997 * (997 * mem[_198] / 2 * mem[_198] / 2) + (1000 * Mask(112, 0, _155) * mem[_198]) / (1994 * mem[_198] / 2) + (1997 * Mask(112, 0, _155)) * (997 * mem[_198] / 2 * mem[_198] / 2) + (1000 * Mask(112, 0, _155) * mem[_198]) / (1994 * mem[_198] / 2) + (1997 * Mask(112, 0, _155))) + (1000 * Mask(112, 0, _155) * mem[_198]) / (1994 * (997 * mem[_198] / 2 * mem[_198] / 2) + (1000 * Mask(112, 0, _155) * mem[_198]) / (1994 * mem[_198] / 2) + (1997 * Mask(112, 0, _155))) + (1997 * Mask(112, 0, _155)) > (-1000 * Mask(112, 0, _155) * mem[_198]) - 1:
                    revert with 'NH{q', 17
                if not (1994 * (997 * (997 * mem[_198] / 2 * mem[_198] / 2) + (1000 * Mask(112, 0, _155) * mem[_198]) / (1994 * mem[_198] / 2) + (1997 * Mask(112, 0, _155)) * (997 * mem[_198] / 2 * mem[_198] / 2) + (1000 * Mask(112, 0, _155) * mem[_198]) / (1994 * mem[_198] / 2) + (1997 * Mask(112, 0, _155))) + (1000 * Mask(112, 0, _155) * mem[_198]) / (1994 * (997 * mem[_198] / 2 * mem[_198] / 2) + (1000 * Mask(112, 0, _155) * mem[_198]) / (1994 * mem[_198] / 2) + (1997 * Mask(112, 0, _155))) + (1997 * Mask(112, 0, _155))) + (1997 * Mask(112, 0, _155)):
                    revert with 'NH{q', 18
                require address(arg1)
                mem[mem[64] + 4] = stor4
                mem[mem[64] + 36] = (997 * (997 * (997 * _206 / 2 * _206 / 2) + (1000 * Mask(112, 0, _155) * _206) / (1994 * _206 / 2) + (1997 * Mask(112, 0, _155)) * (997 * _206 / 2 * _206 / 2) + (1000 * Mask(112, 0, _155) * _206) / (1994 * _206 / 2) + (1997 * Mask(112, 0, _155))) + (1000 * Mask(112, 0, _155) * _206) / (1994 * (997 * _206 / 2 * _206 / 2) + (1000 * Mask(112, 0, _155) * _206) / (1994 * _206 / 2) + (1997 * Mask(112, 0, _155))) + (1997 * Mask(112, 0, _155)) * (997 * (997 * _206 / 2 * _206 / 2) + (1000 * Mask(112, 0, _155) * _206) / (1994 * _206 / 2) + (1997 * Mask(112, 0, _155)) * (997 * _206 / 2 * _206 / 2) + (1000 * Mask(112, 0, _155) * _206) / (1994 * _206 / 2) + (1997 * Mask(112, 0, _155))) + (1000 * Mask(112, 0, _155) * _206) / (1994 * (997 * _206 / 2 * _206 / 2) + (1000 * Mask(112, 0, _155) * _206) / (1994 * _206 / 2) + (1997 * Mask(112, 0, _155))) + (1997 * Mask(112, 0, _155))) + (1000 * Mask(112, 0, _155) * _206) / (1994 * (997 * (997 * _206 / 2 * _206 / 2) + (1000 * Mask(112, 0, _155) * _206) / (1994 * _206 / 2) + (1997 * Mask(112, 0, _155)) * (997 * _206 / 2 * _206 / 2) + (1000 * Mask(112, 0, _155) * _206) / (1994 * _206 / 2) + (1997 * Mask(112, 0, _155))) + (1000 * Mask(112, 0, _155) * _206) / (1994 * (997 * _206 / 2 * _206 / 2) + (1000 * Mask(112, 0, _155) * _206) / (1994 * _206 / 2) + (1997 * Mask(112, 0, _155))) + (1997 * Mask(112, 0, _155))) + (1997 * Mask(112, 0, _155))
                require ext_code.size(stor2)
                call stor2.approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor4, (997 * (997 * (997 * _206 / 2 * _206 / 2) + (1000 * Mask(112, 0, _155) * _206) / (1994 * _206 / 2) + (1997 * Mask(112, 0, _155)) * (997 * _206 / 2 * _206 / 2) + (1000 * Mask(112, 0, _155) * _206) / (1994 * _206 / 2) + (1997 * Mask(112, 0, _155))) + (1000 * Mask(112, 0, _155) * _206) / (1994 * (997 * _206 / 2 * _206 / 2) + (1000 * Mask(112, 0, _155) * _206) / (1994 * _206 / 2) + (1997 * Mask(112, 0, _155))) + (1997 * Mask(112, 0, _155)) * (997 * (997 * _206 / 2 * _206 / 2) + (1000 * Mask(112, 0, _155) * _206) / (1994 * _206 / 2) + (1997 * Mask(112, 0, _155)) * (997 * _206 / 2 * _206 / 2) + (1000 * Mask(112, 0, _155) * _206) / (1994 * _206 / 2) + (1997 * Mask(112, 0, _155))) + (1000 * Mask(112, 0, _155) * _206) / (1994 * (997 * _206 / 2 * _206 / 2) + (1000 * Mask(112, 0, _155) * _206) / (1994 * _206 / 2) + (1997 * Mask(112, 0, _155))) + (1997 * Mask(112, 0, _155))) + (1000 * Mask(112, 0, _155) * _206) / (1994 * (997 * (997 * _206 / 2 * _206 / 2) + (1000 * Mask(112, 0, _155) * _206) / (1994 * _206 / 2) + (1997 * Mask(112, 0, _155)) * (997 * _206 / 2 * _206 / 2) + (1000 * Mask(112, 0, _155) * _206) / (1994 * _206 / 2) + (1997 * Mask(112, 0, _155))) + (1000 * Mask(112, 0, _155) * _206) / (1994 * (997 * _206 / 2 * _206 / 2) + (1000 * Mask(112, 0, _155) * _206) / (1994 * _206 / 2) + (1997 * Mask(112, 0, _155))) + (1997 * Mask(112, 0, _155))) + (1997 * Mask(112, 0, _155))
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _223 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_223] == bool(mem[_223])
                _239 = mem[64]
                mem[mem[64]] = 2
                mem[64] = mem[64] + 96
                if 0 >= mem[_239]:
                    revert with 'NH{q', 50
                mem[_239 + 32] = stor2
                if 1 >= mem[_239]:
                    revert with 'NH{q', 50
                mem[_239 + 64] = address(arg1)
                if block.timestamp > -61:
                    revert with 'NH{q', 17
                mem[_239 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                mem[_239 + 100] = (997 * (997 * (997 * _206 / 2 * _206 / 2) + (1000 * Mask(112, 0, _155) * _206) / (1994 * _206 / 2) + (1997 * Mask(112, 0, _155)) * (997 * _206 / 2 * _206 / 2) + (1000 * Mask(112, 0, _155) * _206) / (1994 * _206 / 2) + (1997 * Mask(112, 0, _155))) + (1000 * Mask(112, 0, _155) * _206) / (1994 * (997 * _206 / 2 * _206 / 2) + (1000 * Mask(112, 0, _155) * _206) / (1994 * _206 / 2) + (1997 * Mask(112, 0, _155))) + (1997 * Mask(112, 0, _155)) * (997 * (997 * _206 / 2 * _206 / 2) + (1000 * Mask(112, 0, _155) * _206) / (1994 * _206 / 2) + (1997 * Mask(112, 0, _155)) * (997 * _206 / 2 * _206 / 2) + (1000 * Mask(112, 0, _155) * _206) / (1994 * _206 / 2) + (1997 * Mask(112, 0, _155))) + (1000 * Mask(112, 0, _155) * _206) / (1994 * (997 * _206 / 2 * _206 / 2) + (1000 * Mask(112, 0, _155) * _206) / (1994 * _206 / 2) + (1997 * Mask(112, 0, _155))) + (1997 * Mask(112, 0, _155))) + (1000 * Mask(112, 0, _155) * _206) / (1994 * (997 * (997 * _206 / 2 * _206 / 2) + (1000 * Mask(112, 0, _155) * _206) / (1994 * _206 / 2) + (1997 * Mask(112, 0, _155)) * (997 * _206 / 2 * _206 / 2) + (1000 * Mask(112, 0, _155) * _206) / (1994 * _206 / 2) + (1997 * Mask(112, 0, _155))) + (1000 * Mask(112, 0, _155) * _206) / (1994 * (997 * _206 / 2 * _206 / 2) + (1000 * Mask(112, 0, _155) * _206) / (1994 * _206 / 2) + (1997 * Mask(112, 0, _155))) + (1997 * Mask(112, 0, _155))) + (1997 * Mask(112, 0, _155))
                mem[_239 + 132] = 0
                mem[_239 + 164] = 160
                mem[_239 + 260] = mem[_239]
                idx = 0
                s = _239 + 32
                t = _239 + 292
                while idx < mem[_239]:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[_239 + 196] = this.address
                mem[_239 + 228] = block.timestamp + 60
                require ext_code.size(stor4)
                call stor4.mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len _239 + (32 * mem[_239]) + -mem[64] + 288]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _393 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _399 = mem[_393]
                require mem[_393] <= test266151307()
                require _393 + mem[_393] + 31 < _393 + return_data.size
                _405 = mem[_393 + mem[_393]]
                if mem[_393 + mem[_393]] > test266151307():
                    revert with 'NH{q', 65
                if _393 + ceil32(return_data.size) + floor32(mem[_393 + mem[_393]]) + 1 > test266151307() or floor32(mem[_393 + mem[_393]]) + 1 < 0:
                    revert with 'NH{q', 65
                mem[64] = _393 + ceil32(return_data.size) + floor32(mem[_393 + mem[_393]]) + 1
                mem[_393 + ceil32(return_data.size)] = _405
                require _399 + (32 * _405) + 32 <= return_data.size
                idx = 0
                s = _393 + _399 + 32
                t = _393 + ceil32(return_data.size) + 32
                while idx < _405:
                    require mem[s] == mem[s]
                    mem[t] = mem[s]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(arg1))
                staticcall address(arg1).0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _573 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _579 = mem[_573]
                require mem[_573] == mem[_573]
                mem[mem[64] + 4] = this.address
                require ext_code.size(stor2)
                staticcall stor2.0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _597 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _603 = mem[_597]
                require mem[_597] == mem[_597]
                mem[mem[64] + 4] = stor4
                mem[mem[64] + 36] = _579
                require ext_code.size(address(arg1))
                call address(arg1).approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor4, _579
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _621 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_621] == bool(mem[_621])
                mem[mem[64] + 4] = stor4
                mem[mem[64] + 36] = _603
                require ext_code.size(stor2)
                call stor2.approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor4, _603
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _645 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_645] == bool(mem[_645])
                if block.timestamp > -61:
                    revert with 'NH{q', 17
                mem[mem[64] + 68] = _603
                mem[mem[64] + 100] = _579
                mem[mem[64] + 132] = 0
                mem[mem[64] + 164] = 0
                mem[mem[64] + 196] = this.address
                mem[mem[64] + 228] = block.timestamp + 60
                require ext_code.size(stor4)
                call stor4.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                     gas gas_remaining wei
                    args stor2, address(arg1), _603, _579, 0, 0, address(this.address), block.timestamp + 60
                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _669 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 96
                require mem[_669] == mem[_669]
                require mem[_669 + 32] == mem[_669 + 32]
                require mem[_669 + 64] == mem[_669 + 64]
                mem[0] = address(arg1)
                mem[32] = 10
                mem[mem[64] + 4] = this.address
                require ext_code.size(stor10[address(arg1)])
                staticcall stor10[address(arg1)].0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _711 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _717 = mem[_711]
                require mem[_711] == mem[_711]
                mem[0] = stor10[address(arg1)]
                mem[32] = 11
                mem[mem[64] + 4] = stor11[stor10[address(arg1)]]
                mem[mem[64] + 36] = _717
                require ext_code.size(stor10[address(arg1)])
                call stor10[address(arg1)].approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor11[stor10[address(arg1)]], _717
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _741 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_741] == bool(mem[_741])
                require ext_code.size(stor11[stor10[address(arg1)]])
                staticcall stor11[stor10[address(arg1)]].bondPrice() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _765 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _771 = mem[_765]
                require mem[_765] == mem[_765]
                require ext_code.size(stor11[stor10[address(arg1)]])
                staticcall stor11[stor10[address(arg1)]].bondInfo(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _789 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 128
                _795 = mem[_789]
                require mem[_789] == mem[_789]
                require mem[_789 + 32] == mem[_789 + 32]
                require mem[_789 + 64] == mem[_789 + 92 len 4]
                require mem[_789 + 96] == mem[_789 + 124 len 4]
                mem[mem[64] + 4] = _717
                mem[mem[64] + 36] = _771
                mem[mem[64] + 68] = msg.sender
                require ext_code.size(stor11[stor10[address(arg1)]])
                call stor11[stor10[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                     gas gas_remaining wei
                    args _717, _771, msg.sender
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _831 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_831] == mem[_831]
                require ext_code.size(stor11[stor10[address(arg1)]])
                staticcall stor11[stor10[address(arg1)]].bondInfo(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _855 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 128
                require mem[_855] == mem[_855]
                require mem[_855 + 32] == mem[_855 + 32]
                require mem[_855 + 64] == mem[_855 + 92 len 4]
                require mem[_855 + 96] == mem[_855 + 124 len 4]
                if mem[_855] < _795:
                    revert with 'NH{q', 17
                if mem[_855] - _795 < arg3:
                    revert with 0, 'insufficient profit, either ROI plummeted or your slippage is too tight'
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(arg1))
                staticcall address(arg1).0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _909 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _915 = mem[_909]
                require mem[_909] == mem[_909]
                if mem[_909] <= 0:
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(stor2)
                    staticcall stor2.0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _941 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _957 = mem[_941]
                    require mem[_941] == mem[_941]
                    if mem[_941] > 0:
                        mem[mem[64] + 4] = msg.sender
                        mem[mem[64] + 36] = _957
                        require ext_code.size(stor2)
                        call stor2.0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _957
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _995 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_995] == bool(mem[_995])
                else:
                    mem[mem[64] + 4] = msg.sender
                    mem[mem[64] + 36] = _915
                    require ext_code.size(address(arg1))
                    call address(arg1).0xa9059cbb with:
                         gas gas_remaining wei
                        args msg.sender, _915
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _951 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_951] == bool(mem[_951])
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(stor2)
                    staticcall stor2.0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _996 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1008 = mem[_996]
                    require mem[_996] == mem[_996]
                    if mem[_996] > 0:
                        mem[mem[64] + 4] = msg.sender
                        mem[mem[64] + 36] = _1008
                        require ext_code.size(stor2)
                        call stor2.0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _1008
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1029 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_1029] == bool(mem[_1029])
            else:
                if mem[_171 + 12 len 20] != address(arg1):
                    revert with 0, 'bad LP token'
                if address(_165) != stor2:
                    revert with 0, 'bad LP token'
                mem[mem[64] + 4] = this.address
                require ext_code.size(stor2)
                staticcall stor2.0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _209 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _213 = mem[_209]
                require mem[_209] == mem[_209]
                if Mask(112, 0, _153) > 0x20d135b66ae990fc484cea55e38a936bcf497445394d4cc984add428823e4d:
                    revert with 'NH{q', 17
                if 1000 * Mask(112, 0, _153) and mem[_209] > -1 / 1000 * Mask(112, 0, _153):
                    revert with 'NH{q', 17
                if mem[_209] / 2 > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                    revert with 'NH{q', 17
                if 1994 * mem[_209] / 2 > (-1997 * Mask(112, 0, _153)) - 1:
                    revert with 'NH{q', 17
                if mem[_209] / 2 > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                    revert with 'NH{q', 17
                if 997 * mem[_209] / 2 and mem[_209] / 2 > -1 / 997 * mem[_209] / 2:
                    revert with 'NH{q', 17
                if 997 * mem[_209] / 2 * mem[_209] / 2 > (-1000 * Mask(112, 0, _153) * mem[_209]) - 1:
                    revert with 'NH{q', 17
                if not (1994 * mem[_209] / 2) + (1997 * Mask(112, 0, _153)):
                    revert with 'NH{q', 18
                if (997 * mem[_209] / 2 * mem[_209] / 2) + (1000 * Mask(112, 0, _153) * mem[_209]) / (1994 * mem[_209] / 2) + (1997 * Mask(112, 0, _153)) > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                    revert with 'NH{q', 17
                if 1994 * (997 * mem[_209] / 2 * mem[_209] / 2) + (1000 * Mask(112, 0, _153) * mem[_209]) / (1994 * mem[_209] / 2) + (1997 * Mask(112, 0, _153)) > (-1997 * Mask(112, 0, _153)) - 1:
                    revert with 'NH{q', 17
                if (997 * mem[_209] / 2 * mem[_209] / 2) + (1000 * Mask(112, 0, _153) * mem[_209]) / (1994 * mem[_209] / 2) + (1997 * Mask(112, 0, _153)) > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                    revert with 'NH{q', 17
                if 997 * (997 * mem[_209] / 2 * mem[_209] / 2) + (1000 * Mask(112, 0, _153) * mem[_209]) / (1994 * mem[_209] / 2) + (1997 * Mask(112, 0, _153)) and (997 * mem[_209] / 2 * mem[_209] / 2) + (1000 * Mask(112, 0, _153) * mem[_209]) / (1994 * mem[_209] / 2) + (1997 * Mask(112, 0, _153)) > -1 / 997 * (997 * mem[_209] / 2 * mem[_209] / 2) + (1000 * Mask(112, 0, _153) * mem[_209]) / (1994 * mem[_209] / 2) + (1997 * Mask(112, 0, _153)):
                    revert with 'NH{q', 17
                if 997 * (997 * mem[_209] / 2 * mem[_209] / 2) + (1000 * Mask(112, 0, _153) * mem[_209]) / (1994 * mem[_209] / 2) + (1997 * Mask(112, 0, _153)) * (997 * mem[_209] / 2 * mem[_209] / 2) + (1000 * Mask(112, 0, _153) * mem[_209]) / (1994 * mem[_209] / 2) + (1997 * Mask(112, 0, _153)) > (-1000 * Mask(112, 0, _153) * mem[_209]) - 1:
                    revert with 'NH{q', 17
                if not (1994 * (997 * mem[_209] / 2 * mem[_209] / 2) + (1000 * Mask(112, 0, _153) * mem[_209]) / (1994 * mem[_209] / 2) + (1997 * Mask(112, 0, _153))) + (1997 * Mask(112, 0, _153)):
                    revert with 'NH{q', 18
                if (997 * (997 * mem[_209] / 2 * mem[_209] / 2) + (1000 * Mask(112, 0, _153) * mem[_209]) / (1994 * mem[_209] / 2) + (1997 * Mask(112, 0, _153)) * (997 * mem[_209] / 2 * mem[_209] / 2) + (1000 * Mask(112, 0, _153) * mem[_209]) / (1994 * mem[_209] / 2) + (1997 * Mask(112, 0, _153))) + (1000 * Mask(112, 0, _153) * mem[_209]) / (1994 * (997 * mem[_209] / 2 * mem[_209] / 2) + (1000 * Mask(112, 0, _153) * mem[_209]) / (1994 * mem[_209] / 2) + (1997 * Mask(112, 0, _153))) + (1997 * Mask(112, 0, _153)) > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                    revert with 'NH{q', 17
                if 1994 * (997 * (997 * mem[_209] / 2 * mem[_209] / 2) + (1000 * Mask(112, 0, _153) * mem[_209]) / (1994 * mem[_209] / 2) + (1997 * Mask(112, 0, _153)) * (997 * mem[_209] / 2 * mem[_209] / 2) + (1000 * Mask(112, 0, _153) * mem[_209]) / (1994 * mem[_209] / 2) + (1997 * Mask(112, 0, _153))) + (1000 * Mask(112, 0, _153) * mem[_209]) / (1994 * (997 * mem[_209] / 2 * mem[_209] / 2) + (1000 * Mask(112, 0, _153) * mem[_209]) / (1994 * mem[_209] / 2) + (1997 * Mask(112, 0, _153))) + (1997 * Mask(112, 0, _153)) > (-1997 * Mask(112, 0, _153)) - 1:
                    revert with 'NH{q', 17
                if (997 * (997 * mem[_209] / 2 * mem[_209] / 2) + (1000 * Mask(112, 0, _153) * mem[_209]) / (1994 * mem[_209] / 2) + (1997 * Mask(112, 0, _153)) * (997 * mem[_209] / 2 * mem[_209] / 2) + (1000 * Mask(112, 0, _153) * mem[_209]) / (1994 * mem[_209] / 2) + (1997 * Mask(112, 0, _153))) + (1000 * Mask(112, 0, _153) * mem[_209]) / (1994 * (997 * mem[_209] / 2 * mem[_209] / 2) + (1000 * Mask(112, 0, _153) * mem[_209]) / (1994 * mem[_209] / 2) + (1997 * Mask(112, 0, _153))) + (1997 * Mask(112, 0, _153)) > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                    revert with 'NH{q', 17
                if 997 * (997 * (997 * mem[_209] / 2 * mem[_209] / 2) + (1000 * Mask(112, 0, _153) * mem[_209]) / (1994 * mem[_209] / 2) + (1997 * Mask(112, 0, _153)) * (997 * mem[_209] / 2 * mem[_209] / 2) + (1000 * Mask(112, 0, _153) * mem[_209]) / (1994 * mem[_209] / 2) + (1997 * Mask(112, 0, _153))) + (1000 * Mask(112, 0, _153) * mem[_209]) / (1994 * (997 * mem[_209] / 2 * mem[_209] / 2) + (1000 * Mask(112, 0, _153) * mem[_209]) / (1994 * mem[_209] / 2) + (1997 * Mask(112, 0, _153))) + (1997 * Mask(112, 0, _153)) and (997 * (997 * mem[_209] / 2 * mem[_209] / 2) + (1000 * Mask(112, 0, _153) * mem[_209]) / (1994 * mem[_209] / 2) + (1997 * Mask(112, 0, _153)) * (997 * mem[_209] / 2 * mem[_209] / 2) + (1000 * Mask(112, 0, _153) * mem[_209]) / (1994 * mem[_209] / 2) + (1997 * Mask(112, 0, _153))) + (1000 * Mask(112, 0, _153) * mem[_209]) / (1994 * (997 * mem[_209] / 2 * mem[_209] / 2) + (1000 * Mask(112, 0, _153) * mem[_209]) / (1994 * mem[_209] / 2) + (1997 * Mask(112, 0, _153))) + (1997 * Mask(112, 0, _153)) > -1 / 997 * (997 * (997 * mem[_209] / 2 * mem[_209] / 2) + (1000 * Mask(112, 0, _153) * mem[_209]) / (1994 * mem[_209] / 2) + (1997 * Mask(112, 0, _153)) * (997 * mem[_209] / 2 * mem[_209] / 2) + (1000 * Mask(112, 0, _153) * mem[_209]) / (1994 * mem[_209] / 2) + (1997 * Mask(112, 0, _153))) + (1000 * Mask(112, 0, _153) * mem[_209]) / (1994 * (997 * mem[_209] / 2 * mem[_209] / 2) + (1000 * Mask(112, 0, _153) * mem[_209]) / (1994 * mem[_209] / 2) + (1997 * Mask(112, 0, _153))) + (1997 * Mask(112, 0, _153)):
                    revert with 'NH{q', 17
                if 997 * (997 * (997 * mem[_209] / 2 * mem[_209] / 2) + (1000 * Mask(112, 0, _153) * mem[_209]) / (1994 * mem[_209] / 2) + (1997 * Mask(112, 0, _153)) * (997 * mem[_209] / 2 * mem[_209] / 2) + (1000 * Mask(112, 0, _153) * mem[_209]) / (1994 * mem[_209] / 2) + (1997 * Mask(112, 0, _153))) + (1000 * Mask(112, 0, _153) * mem[_209]) / (1994 * (997 * mem[_209] / 2 * mem[_209] / 2) + (1000 * Mask(112, 0, _153) * mem[_209]) / (1994 * mem[_209] / 2) + (1997 * Mask(112, 0, _153))) + (1997 * Mask(112, 0, _153)) * (997 * (997 * mem[_209] / 2 * mem[_209] / 2) + (1000 * Mask(112, 0, _153) * mem[_209]) / (1994 * mem[_209] / 2) + (1997 * Mask(112, 0, _153)) * (997 * mem[_209] / 2 * mem[_209] / 2) + (1000 * Mask(112, 0, _153) * mem[_209]) / (1994 * mem[_209] / 2) + (1997 * Mask(112, 0, _153))) + (1000 * Mask(112, 0, _153) * mem[_209]) / (1994 * (997 * mem[_209] / 2 * mem[_209] / 2) + (1000 * Mask(112, 0, _153) * mem[_209]) / (1994 * mem[_209] / 2) + (1997 * Mask(112, 0, _153))) + (1997 * Mask(112, 0, _153)) > (-1000 * Mask(112, 0, _153) * mem[_209]) - 1:
                    revert with 'NH{q', 17
                if not (1994 * (997 * (997 * mem[_209] / 2 * mem[_209] / 2) + (1000 * Mask(112, 0, _153) * mem[_209]) / (1994 * mem[_209] / 2) + (1997 * Mask(112, 0, _153)) * (997 * mem[_209] / 2 * mem[_209] / 2) + (1000 * Mask(112, 0, _153) * mem[_209]) / (1994 * mem[_209] / 2) + (1997 * Mask(112, 0, _153))) + (1000 * Mask(112, 0, _153) * mem[_209]) / (1994 * (997 * mem[_209] / 2 * mem[_209] / 2) + (1000 * Mask(112, 0, _153) * mem[_209]) / (1994 * mem[_209] / 2) + (1997 * Mask(112, 0, _153))) + (1997 * Mask(112, 0, _153))) + (1997 * Mask(112, 0, _153)):
                    revert with 'NH{q', 18
                require address(arg1)
                mem[mem[64] + 4] = stor4
                mem[mem[64] + 36] = (997 * (997 * (997 * _213 / 2 * _213 / 2) + (1000 * Mask(112, 0, _153) * _213) / (1994 * _213 / 2) + (1997 * Mask(112, 0, _153)) * (997 * _213 / 2 * _213 / 2) + (1000 * Mask(112, 0, _153) * _213) / (1994 * _213 / 2) + (1997 * Mask(112, 0, _153))) + (1000 * Mask(112, 0, _153) * _213) / (1994 * (997 * _213 / 2 * _213 / 2) + (1000 * Mask(112, 0, _153) * _213) / (1994 * _213 / 2) + (1997 * Mask(112, 0, _153))) + (1997 * Mask(112, 0, _153)) * (997 * (997 * _213 / 2 * _213 / 2) + (1000 * Mask(112, 0, _153) * _213) / (1994 * _213 / 2) + (1997 * Mask(112, 0, _153)) * (997 * _213 / 2 * _213 / 2) + (1000 * Mask(112, 0, _153) * _213) / (1994 * _213 / 2) + (1997 * Mask(112, 0, _153))) + (1000 * Mask(112, 0, _153) * _213) / (1994 * (997 * _213 / 2 * _213 / 2) + (1000 * Mask(112, 0, _153) * _213) / (1994 * _213 / 2) + (1997 * Mask(112, 0, _153))) + (1997 * Mask(112, 0, _153))) + (1000 * Mask(112, 0, _153) * _213) / (1994 * (997 * (997 * _213 / 2 * _213 / 2) + (1000 * Mask(112, 0, _153) * _213) / (1994 * _213 / 2) + (1997 * Mask(112, 0, _153)) * (997 * _213 / 2 * _213 / 2) + (1000 * Mask(112, 0, _153) * _213) / (1994 * _213 / 2) + (1997 * Mask(112, 0, _153))) + (1000 * Mask(112, 0, _153) * _213) / (1994 * (997 * _213 / 2 * _213 / 2) + (1000 * Mask(112, 0, _153) * _213) / (1994 * _213 / 2) + (1997 * Mask(112, 0, _153))) + (1997 * Mask(112, 0, _153))) + (1997 * Mask(112, 0, _153))
                require ext_code.size(stor2)
                call stor2.approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor4, (997 * (997 * (997 * _213 / 2 * _213 / 2) + (1000 * Mask(112, 0, _153) * _213) / (1994 * _213 / 2) + (1997 * Mask(112, 0, _153)) * (997 * _213 / 2 * _213 / 2) + (1000 * Mask(112, 0, _153) * _213) / (1994 * _213 / 2) + (1997 * Mask(112, 0, _153))) + (1000 * Mask(112, 0, _153) * _213) / (1994 * (997 * _213 / 2 * _213 / 2) + (1000 * Mask(112, 0, _153) * _213) / (1994 * _213 / 2) + (1997 * Mask(112, 0, _153))) + (1997 * Mask(112, 0, _153)) * (997 * (997 * _213 / 2 * _213 / 2) + (1000 * Mask(112, 0, _153) * _213) / (1994 * _213 / 2) + (1997 * Mask(112, 0, _153)) * (997 * _213 / 2 * _213 / 2) + (1000 * Mask(112, 0, _153) * _213) / (1994 * _213 / 2) + (1997 * Mask(112, 0, _153))) + (1000 * Mask(112, 0, _153) * _213) / (1994 * (997 * _213 / 2 * _213 / 2) + (1000 * Mask(112, 0, _153) * _213) / (1994 * _213 / 2) + (1997 * Mask(112, 0, _153))) + (1997 * Mask(112, 0, _153))) + (1000 * Mask(112, 0, _153) * _213) / (1994 * (997 * (997 * _213 / 2 * _213 / 2) + (1000 * Mask(112, 0, _153) * _213) / (1994 * _213 / 2) + (1997 * Mask(112, 0, _153)) * (997 * _213 / 2 * _213 / 2) + (1000 * Mask(112, 0, _153) * _213) / (1994 * _213 / 2) + (1997 * Mask(112, 0, _153))) + (1000 * Mask(112, 0, _153) * _213) / (1994 * (997 * _213 / 2 * _213 / 2) + (1000 * Mask(112, 0, _153) * _213) / (1994 * _213 / 2) + (1997 * Mask(112, 0, _153))) + (1997 * Mask(112, 0, _153))) + (1997 * Mask(112, 0, _153))
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _233 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_233] == bool(mem[_233])
                _247 = mem[64]
                mem[mem[64]] = 2
                mem[64] = mem[64] + 96
                if 0 >= mem[_247]:
                    revert with 'NH{q', 50
                mem[_247 + 32] = stor2
                if 1 >= mem[_247]:
                    revert with 'NH{q', 50
                mem[_247 + 64] = address(arg1)
                if block.timestamp > -61:
                    revert with 'NH{q', 17
                mem[_247 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                mem[_247 + 100] = (997 * (997 * (997 * _213 / 2 * _213 / 2) + (1000 * Mask(112, 0, _153) * _213) / (1994 * _213 / 2) + (1997 * Mask(112, 0, _153)) * (997 * _213 / 2 * _213 / 2) + (1000 * Mask(112, 0, _153) * _213) / (1994 * _213 / 2) + (1997 * Mask(112, 0, _153))) + (1000 * Mask(112, 0, _153) * _213) / (1994 * (997 * _213 / 2 * _213 / 2) + (1000 * Mask(112, 0, _153) * _213) / (1994 * _213 / 2) + (1997 * Mask(112, 0, _153))) + (1997 * Mask(112, 0, _153)) * (997 * (997 * _213 / 2 * _213 / 2) + (1000 * Mask(112, 0, _153) * _213) / (1994 * _213 / 2) + (1997 * Mask(112, 0, _153)) * (997 * _213 / 2 * _213 / 2) + (1000 * Mask(112, 0, _153) * _213) / (1994 * _213 / 2) + (1997 * Mask(112, 0, _153))) + (1000 * Mask(112, 0, _153) * _213) / (1994 * (997 * _213 / 2 * _213 / 2) + (1000 * Mask(112, 0, _153) * _213) / (1994 * _213 / 2) + (1997 * Mask(112, 0, _153))) + (1997 * Mask(112, 0, _153))) + (1000 * Mask(112, 0, _153) * _213) / (1994 * (997 * (997 * _213 / 2 * _213 / 2) + (1000 * Mask(112, 0, _153) * _213) / (1994 * _213 / 2) + (1997 * Mask(112, 0, _153)) * (997 * _213 / 2 * _213 / 2) + (1000 * Mask(112, 0, _153) * _213) / (1994 * _213 / 2) + (1997 * Mask(112, 0, _153))) + (1000 * Mask(112, 0, _153) * _213) / (1994 * (997 * _213 / 2 * _213 / 2) + (1000 * Mask(112, 0, _153) * _213) / (1994 * _213 / 2) + (1997 * Mask(112, 0, _153))) + (1997 * Mask(112, 0, _153))) + (1997 * Mask(112, 0, _153))
                mem[_247 + 132] = 0
                mem[_247 + 164] = 160
                mem[_247 + 260] = mem[_247]
                idx = 0
                s = _247 + 32
                t = _247 + 292
                while idx < mem[_247]:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[_247 + 196] = this.address
                mem[_247 + 228] = block.timestamp + 60
                require ext_code.size(stor4)
                call stor4.mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len _247 + (32 * mem[_247]) + -mem[64] + 288]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _392 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _398 = mem[_392]
                require mem[_392] <= test266151307()
                require _392 + mem[_392] + 31 < _392 + return_data.size
                _404 = mem[_392 + mem[_392]]
                if mem[_392 + mem[_392]] > test266151307():
                    revert with 'NH{q', 65
                if _392 + ceil32(return_data.size) + floor32(mem[_392 + mem[_392]]) + 1 > test266151307() or floor32(mem[_392 + mem[_392]]) + 1 < 0:
                    revert with 'NH{q', 65
                mem[64] = _392 + ceil32(return_data.size) + floor32(mem[_392 + mem[_392]]) + 1
                mem[_392 + ceil32(return_data.size)] = _404
                require _398 + (32 * _404) + 32 <= return_data.size
                idx = 0
                s = _392 + _398 + 32
                t = _392 + ceil32(return_data.size) + 32
                while idx < _404:
                    require mem[s] == mem[s]
                    mem[t] = mem[s]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(arg1))
                staticcall address(arg1).0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _572 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _578 = mem[_572]
                require mem[_572] == mem[_572]
                mem[mem[64] + 4] = this.address
                require ext_code.size(stor2)
                staticcall stor2.0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _596 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _602 = mem[_596]
                require mem[_596] == mem[_596]
                mem[mem[64] + 4] = stor4
                mem[mem[64] + 36] = _578
                require ext_code.size(address(arg1))
                call address(arg1).approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor4, _578
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _620 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_620] == bool(mem[_620])
                mem[mem[64] + 4] = stor4
                mem[mem[64] + 36] = _602
                require ext_code.size(stor2)
                call stor2.approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor4, _602
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _644 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_644] == bool(mem[_644])
                if block.timestamp > -61:
                    revert with 'NH{q', 17
                mem[mem[64] + 68] = _602
                mem[mem[64] + 100] = _578
                mem[mem[64] + 132] = 0
                mem[mem[64] + 164] = 0
                mem[mem[64] + 196] = this.address
                mem[mem[64] + 228] = block.timestamp + 60
                require ext_code.size(stor4)
                call stor4.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                     gas gas_remaining wei
                    args stor2, address(arg1), _602, _578, 0, 0, address(this.address), block.timestamp + 60
                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _668 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 96
                require mem[_668] == mem[_668]
                require mem[_668 + 32] == mem[_668 + 32]
                require mem[_668 + 64] == mem[_668 + 64]
                mem[0] = address(arg1)
                mem[32] = 10
                mem[mem[64] + 4] = this.address
                require ext_code.size(stor10[address(arg1)])
                staticcall stor10[address(arg1)].0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _710 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _716 = mem[_710]
                require mem[_710] == mem[_710]
                mem[0] = stor10[address(arg1)]
                mem[32] = 11
                mem[mem[64] + 4] = stor11[stor10[address(arg1)]]
                mem[mem[64] + 36] = _716
                require ext_code.size(stor10[address(arg1)])
                call stor10[address(arg1)].approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor11[stor10[address(arg1)]], _716
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _740 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_740] == bool(mem[_740])
                require ext_code.size(stor11[stor10[address(arg1)]])
                staticcall stor11[stor10[address(arg1)]].bondPrice() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _764 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _770 = mem[_764]
                require mem[_764] == mem[_764]
                require ext_code.size(stor11[stor10[address(arg1)]])
                staticcall stor11[stor10[address(arg1)]].bondInfo(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _788 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 128
                _794 = mem[_788]
                require mem[_788] == mem[_788]
                require mem[_788 + 32] == mem[_788 + 32]
                require mem[_788 + 64] == mem[_788 + 92 len 4]
                require mem[_788 + 96] == mem[_788 + 124 len 4]
                mem[mem[64] + 4] = _716
                mem[mem[64] + 36] = _770
                mem[mem[64] + 68] = msg.sender
                require ext_code.size(stor11[stor10[address(arg1)]])
                call stor11[stor10[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                     gas gas_remaining wei
                    args _716, _770, msg.sender
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _830 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_830] == mem[_830]
                require ext_code.size(stor11[stor10[address(arg1)]])
                staticcall stor11[stor10[address(arg1)]].bondInfo(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _854 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 128
                require mem[_854] == mem[_854]
                require mem[_854 + 32] == mem[_854 + 32]
                require mem[_854 + 64] == mem[_854 + 92 len 4]
                require mem[_854 + 96] == mem[_854 + 124 len 4]
                if mem[_854] < _794:
                    revert with 'NH{q', 17
                if mem[_854] - _794 < arg3:
                    revert with 0, 'insufficient profit, either ROI plummeted or your slippage is too tight'
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(arg1))
                staticcall address(arg1).0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _908 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _914 = mem[_908]
                require mem[_908] == mem[_908]
                if mem[_908] <= 0:
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(stor2)
                    staticcall stor2.0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _939 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _956 = mem[_939]
                    require mem[_939] == mem[_939]
                    if mem[_939] > 0:
                        mem[mem[64] + 4] = msg.sender
                        mem[mem[64] + 36] = _956
                        require ext_code.size(stor2)
                        call stor2.0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _956
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _993 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_993] == bool(mem[_993])
                else:
                    mem[mem[64] + 4] = msg.sender
                    mem[mem[64] + 36] = _914
                    require ext_code.size(address(arg1))
                    call address(arg1).0xa9059cbb with:
                         gas gas_remaining wei
                        args msg.sender, _914
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _950 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_950] == bool(mem[_950])
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(stor2)
                    staticcall stor2.0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _994 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1006 = mem[_994]
                    require mem[_994] == mem[_994]
                    if mem[_994] > 0:
                        mem[mem[64] + 4] = msg.sender
                        mem[mem[64] + 36] = _1006
                        require ext_code.size(stor2)
                        call stor2.0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _1006
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1028 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_1028] == bool(mem[_1028])
    else:
        mem[ceil32(return_data.size) + 100] = stor3
        mem[ceil32(return_data.size) + 132] = arg2
        require ext_code.size(stor1)
        call stor1.approve(address arg1, uint256 arg2) with:
             gas gas_remaining wei
            args stor3, arg2
        mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == bool(ext_call.return_data[0])
        mem[(2 * ceil32(return_data.size)) + 96] = 2
        mem[(2 * ceil32(return_data.size)) + 128] = stor1
        mem[(2 * ceil32(return_data.size)) + 160] = stor2
        if block.timestamp > -61:
            revert with 'NH{q', 17
        mem[(2 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
        mem[(2 * ceil32(return_data.size)) + 196] = arg2
        mem[(2 * ceil32(return_data.size)) + 228] = 0
        mem[(2 * ceil32(return_data.size)) + 260] = 160
        mem[(2 * ceil32(return_data.size)) + 356] = 2
        idx = 0
        s = (2 * ceil32(return_data.size)) + 128
        t = (2 * ceil32(return_data.size)) + 388
        while idx < 2:
            mem[t] = mem[s + 12 len 20]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        mem[(2 * ceil32(return_data.size)) + 292] = this.address
        mem[(2 * ceil32(return_data.size)) + 324] = block.timestamp + 60
        require ext_code.size(stor3)
        call stor3.swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
             gas gas_remaining wei
            args arg2, 0, 160, address(this.address), block.timestamp + 60, 2, mem[(2 * ceil32(return_data.size)) + 388 len 64]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        mem[(2 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = (4 * ceil32(return_data.size)) + 192
        require return_data.size >= 32
        _66 = mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32
        require mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 <= test266151307()
        require (2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 223 < (2 * ceil32(return_data.size)) + return_data.size + 192
        _68 = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192]
        if mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192] > test266151307():
            revert with 'NH{q', 65
        if (4 * ceil32(return_data.size)) + floor32(mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 193 > test266151307() or floor32(mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 1 < 0:
            revert with 'NH{q', 65
        mem[64] = (4 * ceil32(return_data.size)) + floor32(mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg2) >> 32 + 192]) + 193
        mem[(4 * ceil32(return_data.size)) + 192] = _68
        require _66 + (32 * _68) + 32 <= return_data.size
        idx = 0
        s = (2 * ceil32(return_data.size)) + _66 + 224
        t = (4 * ceil32(return_data.size)) + 224
        while idx < _68:
            require mem[s] == mem[s]
            mem[t] = mem[s]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        mem[0] = address(arg1)
        mem[32] = 10
        require stor10[address(arg1)]
        require ext_code.size(stor10[address(arg1)])
        staticcall stor10[address(arg1)].getReserves() with:
                gas gas_remaining wei
        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _152 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 96
        _154 = mem[_152]
        require mem[_152] == mem[_152 + 18 len 14]
        _156 = mem[_152 + 32]
        require mem[_152 + 32] == mem[_152 + 50 len 14]
        require mem[_152 + 64] == mem[_152 + 92 len 4]
        require ext_code.size(stor10[address(arg1)])
        staticcall stor10[address(arg1)].token0() with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _164 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _166 = mem[_164]
        require mem[_164] == mem[_164 + 12 len 20]
        require ext_code.size(stor10[address(arg1)])
        staticcall stor10[address(arg1)].token1() with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _172 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        require mem[_172] == mem[_172 + 12 len 20]
        if address(_166) != address(arg1):
            if mem[_172 + 12 len 20] != address(arg1):
                revert with 0, 'bad LP token'
            if address(_166) != stor2:
                revert with 0, 'bad LP token'
            mem[mem[64] + 4] = this.address
            require ext_code.size(stor2)
            staticcall stor2.0x70a08231 with:
                    gas gas_remaining wei
                   args address(this.address)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _207 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _212 = mem[_207]
            require mem[_207] == mem[_207]
            if Mask(112, 0, _154) > 0x20d135b66ae990fc484cea55e38a936bcf497445394d4cc984add428823e4d:
                revert with 'NH{q', 17
            if 1000 * Mask(112, 0, _154) and mem[_207] > -1 / 1000 * Mask(112, 0, _154):
                revert with 'NH{q', 17
            if mem[_207] / 2 > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                revert with 'NH{q', 17
            if 1994 * mem[_207] / 2 > (-1997 * Mask(112, 0, _154)) - 1:
                revert with 'NH{q', 17
            if mem[_207] / 2 > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                revert with 'NH{q', 17
            if 997 * mem[_207] / 2 and mem[_207] / 2 > -1 / 997 * mem[_207] / 2:
                revert with 'NH{q', 17
            if 997 * mem[_207] / 2 * mem[_207] / 2 > (-1000 * Mask(112, 0, _154) * mem[_207]) - 1:
                revert with 'NH{q', 17
            if not (1994 * mem[_207] / 2) + (1997 * Mask(112, 0, _154)):
                revert with 'NH{q', 18
            if (997 * mem[_207] / 2 * mem[_207] / 2) + (1000 * Mask(112, 0, _154) * mem[_207]) / (1994 * mem[_207] / 2) + (1997 * Mask(112, 0, _154)) > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                revert with 'NH{q', 17
            if 1994 * (997 * mem[_207] / 2 * mem[_207] / 2) + (1000 * Mask(112, 0, _154) * mem[_207]) / (1994 * mem[_207] / 2) + (1997 * Mask(112, 0, _154)) > (-1997 * Mask(112, 0, _154)) - 1:
                revert with 'NH{q', 17
            if (997 * mem[_207] / 2 * mem[_207] / 2) + (1000 * Mask(112, 0, _154) * mem[_207]) / (1994 * mem[_207] / 2) + (1997 * Mask(112, 0, _154)) > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                revert with 'NH{q', 17
            if 997 * (997 * mem[_207] / 2 * mem[_207] / 2) + (1000 * Mask(112, 0, _154) * mem[_207]) / (1994 * mem[_207] / 2) + (1997 * Mask(112, 0, _154)) and (997 * mem[_207] / 2 * mem[_207] / 2) + (1000 * Mask(112, 0, _154) * mem[_207]) / (1994 * mem[_207] / 2) + (1997 * Mask(112, 0, _154)) > -1 / 997 * (997 * mem[_207] / 2 * mem[_207] / 2) + (1000 * Mask(112, 0, _154) * mem[_207]) / (1994 * mem[_207] / 2) + (1997 * Mask(112, 0, _154)):
                revert with 'NH{q', 17
            if 997 * (997 * mem[_207] / 2 * mem[_207] / 2) + (1000 * Mask(112, 0, _154) * mem[_207]) / (1994 * mem[_207] / 2) + (1997 * Mask(112, 0, _154)) * (997 * mem[_207] / 2 * mem[_207] / 2) + (1000 * Mask(112, 0, _154) * mem[_207]) / (1994 * mem[_207] / 2) + (1997 * Mask(112, 0, _154)) > (-1000 * Mask(112, 0, _154) * mem[_207]) - 1:
                revert with 'NH{q', 17
            if not (1994 * (997 * mem[_207] / 2 * mem[_207] / 2) + (1000 * Mask(112, 0, _154) * mem[_207]) / (1994 * mem[_207] / 2) + (1997 * Mask(112, 0, _154))) + (1997 * Mask(112, 0, _154)):
                revert with 'NH{q', 18
            if (997 * (997 * mem[_207] / 2 * mem[_207] / 2) + (1000 * Mask(112, 0, _154) * mem[_207]) / (1994 * mem[_207] / 2) + (1997 * Mask(112, 0, _154)) * (997 * mem[_207] / 2 * mem[_207] / 2) + (1000 * Mask(112, 0, _154) * mem[_207]) / (1994 * mem[_207] / 2) + (1997 * Mask(112, 0, _154))) + (1000 * Mask(112, 0, _154) * mem[_207]) / (1994 * (997 * mem[_207] / 2 * mem[_207] / 2) + (1000 * Mask(112, 0, _154) * mem[_207]) / (1994 * mem[_207] / 2) + (1997 * Mask(112, 0, _154))) + (1997 * Mask(112, 0, _154)) > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                revert with 'NH{q', 17
            if 1994 * (997 * (997 * mem[_207] / 2 * mem[_207] / 2) + (1000 * Mask(112, 0, _154) * mem[_207]) / (1994 * mem[_207] / 2) + (1997 * Mask(112, 0, _154)) * (997 * mem[_207] / 2 * mem[_207] / 2) + (1000 * Mask(112, 0, _154) * mem[_207]) / (1994 * mem[_207] / 2) + (1997 * Mask(112, 0, _154))) + (1000 * Mask(112, 0, _154) * mem[_207]) / (1994 * (997 * mem[_207] / 2 * mem[_207] / 2) + (1000 * Mask(112, 0, _154) * mem[_207]) / (1994 * mem[_207] / 2) + (1997 * Mask(112, 0, _154))) + (1997 * Mask(112, 0, _154)) > (-1997 * Mask(112, 0, _154)) - 1:
                revert with 'NH{q', 17
            if (997 * (997 * mem[_207] / 2 * mem[_207] / 2) + (1000 * Mask(112, 0, _154) * mem[_207]) / (1994 * mem[_207] / 2) + (1997 * Mask(112, 0, _154)) * (997 * mem[_207] / 2 * mem[_207] / 2) + (1000 * Mask(112, 0, _154) * mem[_207]) / (1994 * mem[_207] / 2) + (1997 * Mask(112, 0, _154))) + (1000 * Mask(112, 0, _154) * mem[_207]) / (1994 * (997 * mem[_207] / 2 * mem[_207] / 2) + (1000 * Mask(112, 0, _154) * mem[_207]) / (1994 * mem[_207] / 2) + (1997 * Mask(112, 0, _154))) + (1997 * Mask(112, 0, _154)) > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                revert with 'NH{q', 17
            if 997 * (997 * (997 * mem[_207] / 2 * mem[_207] / 2) + (1000 * Mask(112, 0, _154) * mem[_207]) / (1994 * mem[_207] / 2) + (1997 * Mask(112, 0, _154)) * (997 * mem[_207] / 2 * mem[_207] / 2) + (1000 * Mask(112, 0, _154) * mem[_207]) / (1994 * mem[_207] / 2) + (1997 * Mask(112, 0, _154))) + (1000 * Mask(112, 0, _154) * mem[_207]) / (1994 * (997 * mem[_207] / 2 * mem[_207] / 2) + (1000 * Mask(112, 0, _154) * mem[_207]) / (1994 * mem[_207] / 2) + (1997 * Mask(112, 0, _154))) + (1997 * Mask(112, 0, _154)) and (997 * (997 * mem[_207] / 2 * mem[_207] / 2) + (1000 * Mask(112, 0, _154) * mem[_207]) / (1994 * mem[_207] / 2) + (1997 * Mask(112, 0, _154)) * (997 * mem[_207] / 2 * mem[_207] / 2) + (1000 * Mask(112, 0, _154) * mem[_207]) / (1994 * mem[_207] / 2) + (1997 * Mask(112, 0, _154))) + (1000 * Mask(112, 0, _154) * mem[_207]) / (1994 * (997 * mem[_207] / 2 * mem[_207] / 2) + (1000 * Mask(112, 0, _154) * mem[_207]) / (1994 * mem[_207] / 2) + (1997 * Mask(112, 0, _154))) + (1997 * Mask(112, 0, _154)) > -1 / 997 * (997 * (997 * mem[_207] / 2 * mem[_207] / 2) + (1000 * Mask(112, 0, _154) * mem[_207]) / (1994 * mem[_207] / 2) + (1997 * Mask(112, 0, _154)) * (997 * mem[_207] / 2 * mem[_207] / 2) + (1000 * Mask(112, 0, _154) * mem[_207]) / (1994 * mem[_207] / 2) + (1997 * Mask(112, 0, _154))) + (1000 * Mask(112, 0, _154) * mem[_207]) / (1994 * (997 * mem[_207] / 2 * mem[_207] / 2) + (1000 * Mask(112, 0, _154) * mem[_207]) / (1994 * mem[_207] / 2) + (1997 * Mask(112, 0, _154))) + (1997 * Mask(112, 0, _154)):
                revert with 'NH{q', 17
            if 997 * (997 * (997 * mem[_207] / 2 * mem[_207] / 2) + (1000 * Mask(112, 0, _154) * mem[_207]) / (1994 * mem[_207] / 2) + (1997 * Mask(112, 0, _154)) * (997 * mem[_207] / 2 * mem[_207] / 2) + (1000 * Mask(112, 0, _154) * mem[_207]) / (1994 * mem[_207] / 2) + (1997 * Mask(112, 0, _154))) + (1000 * Mask(112, 0, _154) * mem[_207]) / (1994 * (997 * mem[_207] / 2 * mem[_207] / 2) + (1000 * Mask(112, 0, _154) * mem[_207]) / (1994 * mem[_207] / 2) + (1997 * Mask(112, 0, _154))) + (1997 * Mask(112, 0, _154)) * (997 * (997 * mem[_207] / 2 * mem[_207] / 2) + (1000 * Mask(112, 0, _154) * mem[_207]) / (1994 * mem[_207] / 2) + (1997 * Mask(112, 0, _154)) * (997 * mem[_207] / 2 * mem[_207] / 2) + (1000 * Mask(112, 0, _154) * mem[_207]) / (1994 * mem[_207] / 2) + (1997 * Mask(112, 0, _154))) + (1000 * Mask(112, 0, _154) * mem[_207]) / (1994 * (997 * mem[_207] / 2 * mem[_207] / 2) + (1000 * Mask(112, 0, _154) * mem[_207]) / (1994 * mem[_207] / 2) + (1997 * Mask(112, 0, _154))) + (1997 * Mask(112, 0, _154)) > (-1000 * Mask(112, 0, _154) * mem[_207]) - 1:
                revert with 'NH{q', 17
            if not (1994 * (997 * (997 * mem[_207] / 2 * mem[_207] / 2) + (1000 * Mask(112, 0, _154) * mem[_207]) / (1994 * mem[_207] / 2) + (1997 * Mask(112, 0, _154)) * (997 * mem[_207] / 2 * mem[_207] / 2) + (1000 * Mask(112, 0, _154) * mem[_207]) / (1994 * mem[_207] / 2) + (1997 * Mask(112, 0, _154))) + (1000 * Mask(112, 0, _154) * mem[_207]) / (1994 * (997 * mem[_207] / 2 * mem[_207] / 2) + (1000 * Mask(112, 0, _154) * mem[_207]) / (1994 * mem[_207] / 2) + (1997 * Mask(112, 0, _154))) + (1997 * Mask(112, 0, _154))) + (1997 * Mask(112, 0, _154)):
                revert with 'NH{q', 18
            require address(arg1)
            mem[mem[64] + 4] = stor4
            mem[mem[64] + 36] = (997 * (997 * (997 * _212 / 2 * _212 / 2) + (1000 * Mask(112, 0, _154) * _212) / (1994 * _212 / 2) + (1997 * Mask(112, 0, _154)) * (997 * _212 / 2 * _212 / 2) + (1000 * Mask(112, 0, _154) * _212) / (1994 * _212 / 2) + (1997 * Mask(112, 0, _154))) + (1000 * Mask(112, 0, _154) * _212) / (1994 * (997 * _212 / 2 * _212 / 2) + (1000 * Mask(112, 0, _154) * _212) / (1994 * _212 / 2) + (1997 * Mask(112, 0, _154))) + (1997 * Mask(112, 0, _154)) * (997 * (997 * _212 / 2 * _212 / 2) + (1000 * Mask(112, 0, _154) * _212) / (1994 * _212 / 2) + (1997 * Mask(112, 0, _154)) * (997 * _212 / 2 * _212 / 2) + (1000 * Mask(112, 0, _154) * _212) / (1994 * _212 / 2) + (1997 * Mask(112, 0, _154))) + (1000 * Mask(112, 0, _154) * _212) / (1994 * (997 * _212 / 2 * _212 / 2) + (1000 * Mask(112, 0, _154) * _212) / (1994 * _212 / 2) + (1997 * Mask(112, 0, _154))) + (1997 * Mask(112, 0, _154))) + (1000 * Mask(112, 0, _154) * _212) / (1994 * (997 * (997 * _212 / 2 * _212 / 2) + (1000 * Mask(112, 0, _154) * _212) / (1994 * _212 / 2) + (1997 * Mask(112, 0, _154)) * (997 * _212 / 2 * _212 / 2) + (1000 * Mask(112, 0, _154) * _212) / (1994 * _212 / 2) + (1997 * Mask(112, 0, _154))) + (1000 * Mask(112, 0, _154) * _212) / (1994 * (997 * _212 / 2 * _212 / 2) + (1000 * Mask(112, 0, _154) * _212) / (1994 * _212 / 2) + (1997 * Mask(112, 0, _154))) + (1997 * Mask(112, 0, _154))) + (1997 * Mask(112, 0, _154))
            require ext_code.size(stor2)
            call stor2.approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args stor4, (997 * (997 * (997 * _212 / 2 * _212 / 2) + (1000 * Mask(112, 0, _154) * _212) / (1994 * _212 / 2) + (1997 * Mask(112, 0, _154)) * (997 * _212 / 2 * _212 / 2) + (1000 * Mask(112, 0, _154) * _212) / (1994 * _212 / 2) + (1997 * Mask(112, 0, _154))) + (1000 * Mask(112, 0, _154) * _212) / (1994 * (997 * _212 / 2 * _212 / 2) + (1000 * Mask(112, 0, _154) * _212) / (1994 * _212 / 2) + (1997 * Mask(112, 0, _154))) + (1997 * Mask(112, 0, _154)) * (997 * (997 * _212 / 2 * _212 / 2) + (1000 * Mask(112, 0, _154) * _212) / (1994 * _212 / 2) + (1997 * Mask(112, 0, _154)) * (997 * _212 / 2 * _212 / 2) + (1000 * Mask(112, 0, _154) * _212) / (1994 * _212 / 2) + (1997 * Mask(112, 0, _154))) + (1000 * Mask(112, 0, _154) * _212) / (1994 * (997 * _212 / 2 * _212 / 2) + (1000 * Mask(112, 0, _154) * _212) / (1994 * _212 / 2) + (1997 * Mask(112, 0, _154))) + (1997 * Mask(112, 0, _154))) + (1000 * Mask(112, 0, _154) * _212) / (1994 * (997 * (997 * _212 / 2 * _212 / 2) + (1000 * Mask(112, 0, _154) * _212) / (1994 * _212 / 2) + (1997 * Mask(112, 0, _154)) * (997 * _212 / 2 * _212 / 2) + (1000 * Mask(112, 0, _154) * _212) / (1994 * _212 / 2) + (1997 * Mask(112, 0, _154))) + (1000 * Mask(112, 0, _154) * _212) / (1994 * (997 * _212 / 2 * _212 / 2) + (1000 * Mask(112, 0, _154) * _212) / (1994 * _212 / 2) + (1997 * Mask(112, 0, _154))) + (1997 * Mask(112, 0, _154))) + (1997 * Mask(112, 0, _154))
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _231 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_231] == bool(mem[_231])
            _245 = mem[64]
            mem[mem[64]] = 2
            mem[64] = mem[64] + 96
            if 0 >= mem[_245]:
                revert with 'NH{q', 50
            mem[_245 + 32] = stor2
            if 1 >= mem[_245]:
                revert with 'NH{q', 50
            mem[_245 + 64] = address(arg1)
            if block.timestamp > -61:
                revert with 'NH{q', 17
            mem[_245 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
            mem[_245 + 100] = (997 * (997 * (997 * _212 / 2 * _212 / 2) + (1000 * Mask(112, 0, _154) * _212) / (1994 * _212 / 2) + (1997 * Mask(112, 0, _154)) * (997 * _212 / 2 * _212 / 2) + (1000 * Mask(112, 0, _154) * _212) / (1994 * _212 / 2) + (1997 * Mask(112, 0, _154))) + (1000 * Mask(112, 0, _154) * _212) / (1994 * (997 * _212 / 2 * _212 / 2) + (1000 * Mask(112, 0, _154) * _212) / (1994 * _212 / 2) + (1997 * Mask(112, 0, _154))) + (1997 * Mask(112, 0, _154)) * (997 * (997 * _212 / 2 * _212 / 2) + (1000 * Mask(112, 0, _154) * _212) / (1994 * _212 / 2) + (1997 * Mask(112, 0, _154)) * (997 * _212 / 2 * _212 / 2) + (1000 * Mask(112, 0, _154) * _212) / (1994 * _212 / 2) + (1997 * Mask(112, 0, _154))) + (1000 * Mask(112, 0, _154) * _212) / (1994 * (997 * _212 / 2 * _212 / 2) + (1000 * Mask(112, 0, _154) * _212) / (1994 * _212 / 2) + (1997 * Mask(112, 0, _154))) + (1997 * Mask(112, 0, _154))) + (1000 * Mask(112, 0, _154) * _212) / (1994 * (997 * (997 * _212 / 2 * _212 / 2) + (1000 * Mask(112, 0, _154) * _212) / (1994 * _212 / 2) + (1997 * Mask(112, 0, _154)) * (997 * _212 / 2 * _212 / 2) + (1000 * Mask(112, 0, _154) * _212) / (1994 * _212 / 2) + (1997 * Mask(112, 0, _154))) + (1000 * Mask(112, 0, _154) * _212) / (1994 * (997 * _212 / 2 * _212 / 2) + (1000 * Mask(112, 0, _154) * _212) / (1994 * _212 / 2) + (1997 * Mask(112, 0, _154))) + (1997 * Mask(112, 0, _154))) + (1997 * Mask(112, 0, _154))
            mem[_245 + 132] = 0
            mem[_245 + 164] = 160
            mem[_245 + 260] = mem[_245]
            idx = 0
            s = _245 + 32
            t = _245 + 292
            while idx < mem[_245]:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[_245 + 196] = this.address
            mem[_245 + 228] = block.timestamp + 60
            require ext_code.size(stor4)
            call stor4.mem[mem[64] len 4] with:
                 gas gas_remaining wei
                args mem[mem[64] + 4 len _245 + (32 * mem[_245]) + -mem[64] + 288]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _394 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _400 = mem[_394]
            require mem[_394] <= test266151307()
            require _394 + mem[_394] + 31 < _394 + return_data.size
            _406 = mem[_394 + mem[_394]]
            if mem[_394 + mem[_394]] > test266151307():
                revert with 'NH{q', 65
            if _394 + ceil32(return_data.size) + floor32(mem[_394 + mem[_394]]) + 1 > test266151307() or floor32(mem[_394 + mem[_394]]) + 1 < 0:
                revert with 'NH{q', 65
            mem[64] = _394 + ceil32(return_data.size) + floor32(mem[_394 + mem[_394]]) + 1
            mem[_394 + ceil32(return_data.size)] = _406
            require _400 + (32 * _406) + 32 <= return_data.size
            idx = 0
            s = _394 + _400 + 32
            t = _394 + ceil32(return_data.size) + 32
            while idx < _406:
                require mem[s] == mem[s]
                mem[t] = mem[s]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[mem[64] + 4] = this.address
            require ext_code.size(address(arg1))
            staticcall address(arg1).0x70a08231 with:
                    gas gas_remaining wei
                   args address(this.address)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _574 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _580 = mem[_574]
            require mem[_574] == mem[_574]
            mem[mem[64] + 4] = this.address
            require ext_code.size(stor2)
            staticcall stor2.0x70a08231 with:
                    gas gas_remaining wei
                   args address(this.address)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _598 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _604 = mem[_598]
            require mem[_598] == mem[_598]
            mem[mem[64] + 4] = stor4
            mem[mem[64] + 36] = _580
            require ext_code.size(address(arg1))
            call address(arg1).approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args stor4, _580
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _622 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_622] == bool(mem[_622])
            mem[mem[64] + 4] = stor4
            mem[mem[64] + 36] = _604
            require ext_code.size(stor2)
            call stor2.approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args stor4, _604
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _646 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_646] == bool(mem[_646])
            if block.timestamp > -61:
                revert with 'NH{q', 17
            mem[mem[64] + 68] = _604
            mem[mem[64] + 100] = _580
            mem[mem[64] + 132] = 0
            mem[mem[64] + 164] = 0
            mem[mem[64] + 196] = this.address
            mem[mem[64] + 228] = block.timestamp + 60
            require ext_code.size(stor4)
            call stor4.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                 gas gas_remaining wei
                args stor2, address(arg1), _604, _580, 0, 0, address(this.address), block.timestamp + 60
            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _670 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 96
            require mem[_670] == mem[_670]
            require mem[_670 + 32] == mem[_670 + 32]
            require mem[_670 + 64] == mem[_670 + 64]
            mem[0] = address(arg1)
            mem[32] = 10
            mem[mem[64] + 4] = this.address
            require ext_code.size(stor10[address(arg1)])
            staticcall stor10[address(arg1)].0x70a08231 with:
                    gas gas_remaining wei
                   args address(this.address)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _712 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _718 = mem[_712]
            require mem[_712] == mem[_712]
            mem[0] = stor10[address(arg1)]
            mem[32] = 11
            mem[mem[64] + 4] = stor11[stor10[address(arg1)]]
            mem[mem[64] + 36] = _718
            require ext_code.size(stor10[address(arg1)])
            call stor10[address(arg1)].approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args stor11[stor10[address(arg1)]], _718
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _742 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_742] == bool(mem[_742])
            require ext_code.size(stor11[stor10[address(arg1)]])
            staticcall stor11[stor10[address(arg1)]].bondPrice() with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _766 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _772 = mem[_766]
            require mem[_766] == mem[_766]
            require ext_code.size(stor11[stor10[address(arg1)]])
            staticcall stor11[stor10[address(arg1)]].bondInfo(address arg1) with:
                    gas gas_remaining wei
                   args msg.sender
            mem[mem[64] len 128] = ext_call.return_data[0 len 128]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _790 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 128
            _796 = mem[_790]
            require mem[_790] == mem[_790]
            require mem[_790 + 32] == mem[_790 + 32]
            require mem[_790 + 64] == mem[_790 + 92 len 4]
            require mem[_790 + 96] == mem[_790 + 124 len 4]
            mem[mem[64] + 4] = _718
            mem[mem[64] + 36] = _772
            mem[mem[64] + 68] = msg.sender
            require ext_code.size(stor11[stor10[address(arg1)]])
            call stor11[stor10[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                 gas gas_remaining wei
                args _718, _772, msg.sender
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _832 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_832] == mem[_832]
            require ext_code.size(stor11[stor10[address(arg1)]])
            staticcall stor11[stor10[address(arg1)]].bondInfo(address arg1) with:
                    gas gas_remaining wei
                   args msg.sender
            mem[mem[64] len 128] = ext_call.return_data[0 len 128]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _856 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 128
            require mem[_856] == mem[_856]
            require mem[_856 + 32] == mem[_856 + 32]
            require mem[_856 + 64] == mem[_856 + 92 len 4]
            require mem[_856 + 96] == mem[_856 + 124 len 4]
            if mem[_856] < _796:
                revert with 'NH{q', 17
            if mem[_856] - _796 < arg3:
                revert with 0, 'insufficient profit, either ROI plummeted or your slippage is too tight'
            mem[mem[64] + 4] = this.address
            require ext_code.size(address(arg1))
            staticcall address(arg1).0x70a08231 with:
                    gas gas_remaining wei
                   args address(this.address)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _910 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _916 = mem[_910]
            require mem[_910] == mem[_910]
            if mem[_910] <= 0:
                mem[mem[64] + 4] = this.address
                require ext_code.size(stor2)
                staticcall stor2.0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _943 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _958 = mem[_943]
                require mem[_943] == mem[_943]
                if mem[_943] > 0:
                    mem[mem[64] + 4] = msg.sender
                    mem[mem[64] + 36] = _958
                    require ext_code.size(stor2)
                    call stor2.0xa9059cbb with:
                         gas gas_remaining wei
                        args msg.sender, _958
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _997 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_997] == bool(mem[_997])
            else:
                mem[mem[64] + 4] = msg.sender
                mem[mem[64] + 36] = _916
                require ext_code.size(address(arg1))
                call address(arg1).0xa9059cbb with:
                     gas gas_remaining wei
                    args msg.sender, _916
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _952 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_952] == bool(mem[_952])
                mem[mem[64] + 4] = this.address
                require ext_code.size(stor2)
                staticcall stor2.0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _998 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _1010 = mem[_998]
                require mem[_998] == mem[_998]
                if mem[_998] > 0:
                    mem[mem[64] + 4] = msg.sender
                    mem[mem[64] + 36] = _1010
                    require ext_code.size(stor2)
                    call stor2.0xa9059cbb with:
                         gas gas_remaining wei
                        args msg.sender, _1010
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1030 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_1030] == bool(mem[_1030])
        else:
            if mem[_172 + 12 len 20] == stor2:
                mem[mem[64] + 4] = this.address
                require ext_code.size(stor2)
                staticcall stor2.0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _200 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _208 = mem[_200]
                require mem[_200] == mem[_200]
                if Mask(112, 0, _156) > 0x20d135b66ae990fc484cea55e38a936bcf497445394d4cc984add428823e4d:
                    revert with 'NH{q', 17
                if 1000 * Mask(112, 0, _156) and mem[_200] > -1 / 1000 * Mask(112, 0, _156):
                    revert with 'NH{q', 17
                if mem[_200] / 2 > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                    revert with 'NH{q', 17
                if 1994 * mem[_200] / 2 > (-1997 * Mask(112, 0, _156)) - 1:
                    revert with 'NH{q', 17
                if mem[_200] / 2 > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                    revert with 'NH{q', 17
                if 997 * mem[_200] / 2 and mem[_200] / 2 > -1 / 997 * mem[_200] / 2:
                    revert with 'NH{q', 17
                if 997 * mem[_200] / 2 * mem[_200] / 2 > (-1000 * Mask(112, 0, _156) * mem[_200]) - 1:
                    revert with 'NH{q', 17
                if not (1994 * mem[_200] / 2) + (1997 * Mask(112, 0, _156)):
                    revert with 'NH{q', 18
                if (997 * mem[_200] / 2 * mem[_200] / 2) + (1000 * Mask(112, 0, _156) * mem[_200]) / (1994 * mem[_200] / 2) + (1997 * Mask(112, 0, _156)) > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                    revert with 'NH{q', 17
                if 1994 * (997 * mem[_200] / 2 * mem[_200] / 2) + (1000 * Mask(112, 0, _156) * mem[_200]) / (1994 * mem[_200] / 2) + (1997 * Mask(112, 0, _156)) > (-1997 * Mask(112, 0, _156)) - 1:
                    revert with 'NH{q', 17
                if (997 * mem[_200] / 2 * mem[_200] / 2) + (1000 * Mask(112, 0, _156) * mem[_200]) / (1994 * mem[_200] / 2) + (1997 * Mask(112, 0, _156)) > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                    revert with 'NH{q', 17
                if 997 * (997 * mem[_200] / 2 * mem[_200] / 2) + (1000 * Mask(112, 0, _156) * mem[_200]) / (1994 * mem[_200] / 2) + (1997 * Mask(112, 0, _156)) and (997 * mem[_200] / 2 * mem[_200] / 2) + (1000 * Mask(112, 0, _156) * mem[_200]) / (1994 * mem[_200] / 2) + (1997 * Mask(112, 0, _156)) > -1 / 997 * (997 * mem[_200] / 2 * mem[_200] / 2) + (1000 * Mask(112, 0, _156) * mem[_200]) / (1994 * mem[_200] / 2) + (1997 * Mask(112, 0, _156)):
                    revert with 'NH{q', 17
                if 997 * (997 * mem[_200] / 2 * mem[_200] / 2) + (1000 * Mask(112, 0, _156) * mem[_200]) / (1994 * mem[_200] / 2) + (1997 * Mask(112, 0, _156)) * (997 * mem[_200] / 2 * mem[_200] / 2) + (1000 * Mask(112, 0, _156) * mem[_200]) / (1994 * mem[_200] / 2) + (1997 * Mask(112, 0, _156)) > (-1000 * Mask(112, 0, _156) * mem[_200]) - 1:
                    revert with 'NH{q', 17
                if not (1994 * (997 * mem[_200] / 2 * mem[_200] / 2) + (1000 * Mask(112, 0, _156) * mem[_200]) / (1994 * mem[_200] / 2) + (1997 * Mask(112, 0, _156))) + (1997 * Mask(112, 0, _156)):
                    revert with 'NH{q', 18
                if (997 * (997 * mem[_200] / 2 * mem[_200] / 2) + (1000 * Mask(112, 0, _156) * mem[_200]) / (1994 * mem[_200] / 2) + (1997 * Mask(112, 0, _156)) * (997 * mem[_200] / 2 * mem[_200] / 2) + (1000 * Mask(112, 0, _156) * mem[_200]) / (1994 * mem[_200] / 2) + (1997 * Mask(112, 0, _156))) + (1000 * Mask(112, 0, _156) * mem[_200]) / (1994 * (997 * mem[_200] / 2 * mem[_200] / 2) + (1000 * Mask(112, 0, _156) * mem[_200]) / (1994 * mem[_200] / 2) + (1997 * Mask(112, 0, _156))) + (1997 * Mask(112, 0, _156)) > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                    revert with 'NH{q', 17
                if 1994 * (997 * (997 * mem[_200] / 2 * mem[_200] / 2) + (1000 * Mask(112, 0, _156) * mem[_200]) / (1994 * mem[_200] / 2) + (1997 * Mask(112, 0, _156)) * (997 * mem[_200] / 2 * mem[_200] / 2) + (1000 * Mask(112, 0, _156) * mem[_200]) / (1994 * mem[_200] / 2) + (1997 * Mask(112, 0, _156))) + (1000 * Mask(112, 0, _156) * mem[_200]) / (1994 * (997 * mem[_200] / 2 * mem[_200] / 2) + (1000 * Mask(112, 0, _156) * mem[_200]) / (1994 * mem[_200] / 2) + (1997 * Mask(112, 0, _156))) + (1997 * Mask(112, 0, _156)) > (-1997 * Mask(112, 0, _156)) - 1:
                    revert with 'NH{q', 17
                if (997 * (997 * mem[_200] / 2 * mem[_200] / 2) + (1000 * Mask(112, 0, _156) * mem[_200]) / (1994 * mem[_200] / 2) + (1997 * Mask(112, 0, _156)) * (997 * mem[_200] / 2 * mem[_200] / 2) + (1000 * Mask(112, 0, _156) * mem[_200]) / (1994 * mem[_200] / 2) + (1997 * Mask(112, 0, _156))) + (1000 * Mask(112, 0, _156) * mem[_200]) / (1994 * (997 * mem[_200] / 2 * mem[_200] / 2) + (1000 * Mask(112, 0, _156) * mem[_200]) / (1994 * mem[_200] / 2) + (1997 * Mask(112, 0, _156))) + (1997 * Mask(112, 0, _156)) > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                    revert with 'NH{q', 17
                if 997 * (997 * (997 * mem[_200] / 2 * mem[_200] / 2) + (1000 * Mask(112, 0, _156) * mem[_200]) / (1994 * mem[_200] / 2) + (1997 * Mask(112, 0, _156)) * (997 * mem[_200] / 2 * mem[_200] / 2) + (1000 * Mask(112, 0, _156) * mem[_200]) / (1994 * mem[_200] / 2) + (1997 * Mask(112, 0, _156))) + (1000 * Mask(112, 0, _156) * mem[_200]) / (1994 * (997 * mem[_200] / 2 * mem[_200] / 2) + (1000 * Mask(112, 0, _156) * mem[_200]) / (1994 * mem[_200] / 2) + (1997 * Mask(112, 0, _156))) + (1997 * Mask(112, 0, _156)) and (997 * (997 * mem[_200] / 2 * mem[_200] / 2) + (1000 * Mask(112, 0, _156) * mem[_200]) / (1994 * mem[_200] / 2) + (1997 * Mask(112, 0, _156)) * (997 * mem[_200] / 2 * mem[_200] / 2) + (1000 * Mask(112, 0, _156) * mem[_200]) / (1994 * mem[_200] / 2) + (1997 * Mask(112, 0, _156))) + (1000 * Mask(112, 0, _156) * mem[_200]) / (1994 * (997 * mem[_200] / 2 * mem[_200] / 2) + (1000 * Mask(112, 0, _156) * mem[_200]) / (1994 * mem[_200] / 2) + (1997 * Mask(112, 0, _156))) + (1997 * Mask(112, 0, _156)) > -1 / 997 * (997 * (997 * mem[_200] / 2 * mem[_200] / 2) + (1000 * Mask(112, 0, _156) * mem[_200]) / (1994 * mem[_200] / 2) + (1997 * Mask(112, 0, _156)) * (997 * mem[_200] / 2 * mem[_200] / 2) + (1000 * Mask(112, 0, _156) * mem[_200]) / (1994 * mem[_200] / 2) + (1997 * Mask(112, 0, _156))) + (1000 * Mask(112, 0, _156) * mem[_200]) / (1994 * (997 * mem[_200] / 2 * mem[_200] / 2) + (1000 * Mask(112, 0, _156) * mem[_200]) / (1994 * mem[_200] / 2) + (1997 * Mask(112, 0, _156))) + (1997 * Mask(112, 0, _156)):
                    revert with 'NH{q', 17
                if 997 * (997 * (997 * mem[_200] / 2 * mem[_200] / 2) + (1000 * Mask(112, 0, _156) * mem[_200]) / (1994 * mem[_200] / 2) + (1997 * Mask(112, 0, _156)) * (997 * mem[_200] / 2 * mem[_200] / 2) + (1000 * Mask(112, 0, _156) * mem[_200]) / (1994 * mem[_200] / 2) + (1997 * Mask(112, 0, _156))) + (1000 * Mask(112, 0, _156) * mem[_200]) / (1994 * (997 * mem[_200] / 2 * mem[_200] / 2) + (1000 * Mask(112, 0, _156) * mem[_200]) / (1994 * mem[_200] / 2) + (1997 * Mask(112, 0, _156))) + (1997 * Mask(112, 0, _156)) * (997 * (997 * mem[_200] / 2 * mem[_200] / 2) + (1000 * Mask(112, 0, _156) * mem[_200]) / (1994 * mem[_200] / 2) + (1997 * Mask(112, 0, _156)) * (997 * mem[_200] / 2 * mem[_200] / 2) + (1000 * Mask(112, 0, _156) * mem[_200]) / (1994 * mem[_200] / 2) + (1997 * Mask(112, 0, _156))) + (1000 * Mask(112, 0, _156) * mem[_200]) / (1994 * (997 * mem[_200] / 2 * mem[_200] / 2) + (1000 * Mask(112, 0, _156) * mem[_200]) / (1994 * mem[_200] / 2) + (1997 * Mask(112, 0, _156))) + (1997 * Mask(112, 0, _156)) > (-1000 * Mask(112, 0, _156) * mem[_200]) - 1:
                    revert with 'NH{q', 17
                if not (1994 * (997 * (997 * mem[_200] / 2 * mem[_200] / 2) + (1000 * Mask(112, 0, _156) * mem[_200]) / (1994 * mem[_200] / 2) + (1997 * Mask(112, 0, _156)) * (997 * mem[_200] / 2 * mem[_200] / 2) + (1000 * Mask(112, 0, _156) * mem[_200]) / (1994 * mem[_200] / 2) + (1997 * Mask(112, 0, _156))) + (1000 * Mask(112, 0, _156) * mem[_200]) / (1994 * (997 * mem[_200] / 2 * mem[_200] / 2) + (1000 * Mask(112, 0, _156) * mem[_200]) / (1994 * mem[_200] / 2) + (1997 * Mask(112, 0, _156))) + (1997 * Mask(112, 0, _156))) + (1997 * Mask(112, 0, _156)):
                    revert with 'NH{q', 18
                require address(arg1)
                mem[mem[64] + 4] = stor4
                mem[mem[64] + 36] = (997 * (997 * (997 * _208 / 2 * _208 / 2) + (1000 * Mask(112, 0, _156) * _208) / (1994 * _208 / 2) + (1997 * Mask(112, 0, _156)) * (997 * _208 / 2 * _208 / 2) + (1000 * Mask(112, 0, _156) * _208) / (1994 * _208 / 2) + (1997 * Mask(112, 0, _156))) + (1000 * Mask(112, 0, _156) * _208) / (1994 * (997 * _208 / 2 * _208 / 2) + (1000 * Mask(112, 0, _156) * _208) / (1994 * _208 / 2) + (1997 * Mask(112, 0, _156))) + (1997 * Mask(112, 0, _156)) * (997 * (997 * _208 / 2 * _208 / 2) + (1000 * Mask(112, 0, _156) * _208) / (1994 * _208 / 2) + (1997 * Mask(112, 0, _156)) * (997 * _208 / 2 * _208 / 2) + (1000 * Mask(112, 0, _156) * _208) / (1994 * _208 / 2) + (1997 * Mask(112, 0, _156))) + (1000 * Mask(112, 0, _156) * _208) / (1994 * (997 * _208 / 2 * _208 / 2) + (1000 * Mask(112, 0, _156) * _208) / (1994 * _208 / 2) + (1997 * Mask(112, 0, _156))) + (1997 * Mask(112, 0, _156))) + (1000 * Mask(112, 0, _156) * _208) / (1994 * (997 * (997 * _208 / 2 * _208 / 2) + (1000 * Mask(112, 0, _156) * _208) / (1994 * _208 / 2) + (1997 * Mask(112, 0, _156)) * (997 * _208 / 2 * _208 / 2) + (1000 * Mask(112, 0, _156) * _208) / (1994 * _208 / 2) + (1997 * Mask(112, 0, _156))) + (1000 * Mask(112, 0, _156) * _208) / (1994 * (997 * _208 / 2 * _208 / 2) + (1000 * Mask(112, 0, _156) * _208) / (1994 * _208 / 2) + (1997 * Mask(112, 0, _156))) + (1997 * Mask(112, 0, _156))) + (1997 * Mask(112, 0, _156))
                require ext_code.size(stor2)
                call stor2.approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor4, (997 * (997 * (997 * _208 / 2 * _208 / 2) + (1000 * Mask(112, 0, _156) * _208) / (1994 * _208 / 2) + (1997 * Mask(112, 0, _156)) * (997 * _208 / 2 * _208 / 2) + (1000 * Mask(112, 0, _156) * _208) / (1994 * _208 / 2) + (1997 * Mask(112, 0, _156))) + (1000 * Mask(112, 0, _156) * _208) / (1994 * (997 * _208 / 2 * _208 / 2) + (1000 * Mask(112, 0, _156) * _208) / (1994 * _208 / 2) + (1997 * Mask(112, 0, _156))) + (1997 * Mask(112, 0, _156)) * (997 * (997 * _208 / 2 * _208 / 2) + (1000 * Mask(112, 0, _156) * _208) / (1994 * _208 / 2) + (1997 * Mask(112, 0, _156)) * (997 * _208 / 2 * _208 / 2) + (1000 * Mask(112, 0, _156) * _208) / (1994 * _208 / 2) + (1997 * Mask(112, 0, _156))) + (1000 * Mask(112, 0, _156) * _208) / (1994 * (997 * _208 / 2 * _208 / 2) + (1000 * Mask(112, 0, _156) * _208) / (1994 * _208 / 2) + (1997 * Mask(112, 0, _156))) + (1997 * Mask(112, 0, _156))) + (1000 * Mask(112, 0, _156) * _208) / (1994 * (997 * (997 * _208 / 2 * _208 / 2) + (1000 * Mask(112, 0, _156) * _208) / (1994 * _208 / 2) + (1997 * Mask(112, 0, _156)) * (997 * _208 / 2 * _208 / 2) + (1000 * Mask(112, 0, _156) * _208) / (1994 * _208 / 2) + (1997 * Mask(112, 0, _156))) + (1000 * Mask(112, 0, _156) * _208) / (1994 * (997 * _208 / 2 * _208 / 2) + (1000 * Mask(112, 0, _156) * _208) / (1994 * _208 / 2) + (1997 * Mask(112, 0, _156))) + (1997 * Mask(112, 0, _156))) + (1997 * Mask(112, 0, _156))
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _224 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_224] == bool(mem[_224])
                _240 = mem[64]
                mem[mem[64]] = 2
                mem[64] = mem[64] + 96
                if 0 >= mem[_240]:
                    revert with 'NH{q', 50
                mem[_240 + 32] = stor2
                if 1 >= mem[_240]:
                    revert with 'NH{q', 50
                mem[_240 + 64] = address(arg1)
                if block.timestamp > -61:
                    revert with 'NH{q', 17
                mem[_240 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                mem[_240 + 100] = (997 * (997 * (997 * _208 / 2 * _208 / 2) + (1000 * Mask(112, 0, _156) * _208) / (1994 * _208 / 2) + (1997 * Mask(112, 0, _156)) * (997 * _208 / 2 * _208 / 2) + (1000 * Mask(112, 0, _156) * _208) / (1994 * _208 / 2) + (1997 * Mask(112, 0, _156))) + (1000 * Mask(112, 0, _156) * _208) / (1994 * (997 * _208 / 2 * _208 / 2) + (1000 * Mask(112, 0, _156) * _208) / (1994 * _208 / 2) + (1997 * Mask(112, 0, _156))) + (1997 * Mask(112, 0, _156)) * (997 * (997 * _208 / 2 * _208 / 2) + (1000 * Mask(112, 0, _156) * _208) / (1994 * _208 / 2) + (1997 * Mask(112, 0, _156)) * (997 * _208 / 2 * _208 / 2) + (1000 * Mask(112, 0, _156) * _208) / (1994 * _208 / 2) + (1997 * Mask(112, 0, _156))) + (1000 * Mask(112, 0, _156) * _208) / (1994 * (997 * _208 / 2 * _208 / 2) + (1000 * Mask(112, 0, _156) * _208) / (1994 * _208 / 2) + (1997 * Mask(112, 0, _156))) + (1997 * Mask(112, 0, _156))) + (1000 * Mask(112, 0, _156) * _208) / (1994 * (997 * (997 * _208 / 2 * _208 / 2) + (1000 * Mask(112, 0, _156) * _208) / (1994 * _208 / 2) + (1997 * Mask(112, 0, _156)) * (997 * _208 / 2 * _208 / 2) + (1000 * Mask(112, 0, _156) * _208) / (1994 * _208 / 2) + (1997 * Mask(112, 0, _156))) + (1000 * Mask(112, 0, _156) * _208) / (1994 * (997 * _208 / 2 * _208 / 2) + (1000 * Mask(112, 0, _156) * _208) / (1994 * _208 / 2) + (1997 * Mask(112, 0, _156))) + (1997 * Mask(112, 0, _156))) + (1997 * Mask(112, 0, _156))
                mem[_240 + 132] = 0
                mem[_240 + 164] = 160
                mem[_240 + 260] = mem[_240]
                idx = 0
                s = _240 + 32
                t = _240 + 292
                while idx < mem[_240]:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[_240 + 196] = this.address
                mem[_240 + 228] = block.timestamp + 60
                require ext_code.size(stor4)
                call stor4.mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len _240 + (32 * mem[_240]) + -mem[64] + 288]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _396 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _402 = mem[_396]
                require mem[_396] <= test266151307()
                require _396 + mem[_396] + 31 < _396 + return_data.size
                _408 = mem[_396 + mem[_396]]
                if mem[_396 + mem[_396]] > test266151307():
                    revert with 'NH{q', 65
                if _396 + ceil32(return_data.size) + floor32(mem[_396 + mem[_396]]) + 1 > test266151307() or floor32(mem[_396 + mem[_396]]) + 1 < 0:
                    revert with 'NH{q', 65
                mem[64] = _396 + ceil32(return_data.size) + floor32(mem[_396 + mem[_396]]) + 1
                mem[_396 + ceil32(return_data.size)] = _408
                require _402 + (32 * _408) + 32 <= return_data.size
                idx = 0
                s = _396 + _402 + 32
                t = _396 + ceil32(return_data.size) + 32
                while idx < _408:
                    require mem[s] == mem[s]
                    mem[t] = mem[s]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(arg1))
                staticcall address(arg1).0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _576 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _582 = mem[_576]
                require mem[_576] == mem[_576]
                mem[mem[64] + 4] = this.address
                require ext_code.size(stor2)
                staticcall stor2.0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _600 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _606 = mem[_600]
                require mem[_600] == mem[_600]
                mem[mem[64] + 4] = stor4
                mem[mem[64] + 36] = _582
                require ext_code.size(address(arg1))
                call address(arg1).approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor4, _582
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _624 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_624] == bool(mem[_624])
                mem[mem[64] + 4] = stor4
                mem[mem[64] + 36] = _606
                require ext_code.size(stor2)
                call stor2.approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor4, _606
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _648 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_648] == bool(mem[_648])
                if block.timestamp > -61:
                    revert with 'NH{q', 17
                mem[mem[64] + 68] = _606
                mem[mem[64] + 100] = _582
                mem[mem[64] + 132] = 0
                mem[mem[64] + 164] = 0
                mem[mem[64] + 196] = this.address
                mem[mem[64] + 228] = block.timestamp + 60
                require ext_code.size(stor4)
                call stor4.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                     gas gas_remaining wei
                    args stor2, address(arg1), _606, _582, 0, 0, address(this.address), block.timestamp + 60
                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _672 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 96
                require mem[_672] == mem[_672]
                require mem[_672 + 32] == mem[_672 + 32]
                require mem[_672 + 64] == mem[_672 + 64]
                mem[0] = address(arg1)
                mem[32] = 10
                mem[mem[64] + 4] = this.address
                require ext_code.size(stor10[address(arg1)])
                staticcall stor10[address(arg1)].0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _714 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _720 = mem[_714]
                require mem[_714] == mem[_714]
                mem[0] = stor10[address(arg1)]
                mem[32] = 11
                mem[mem[64] + 4] = stor11[stor10[address(arg1)]]
                mem[mem[64] + 36] = _720
                require ext_code.size(stor10[address(arg1)])
                call stor10[address(arg1)].approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor11[stor10[address(arg1)]], _720
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _744 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_744] == bool(mem[_744])
                require ext_code.size(stor11[stor10[address(arg1)]])
                staticcall stor11[stor10[address(arg1)]].bondPrice() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _768 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _774 = mem[_768]
                require mem[_768] == mem[_768]
                require ext_code.size(stor11[stor10[address(arg1)]])
                staticcall stor11[stor10[address(arg1)]].bondInfo(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _792 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 128
                _798 = mem[_792]
                require mem[_792] == mem[_792]
                require mem[_792 + 32] == mem[_792 + 32]
                require mem[_792 + 64] == mem[_792 + 92 len 4]
                require mem[_792 + 96] == mem[_792 + 124 len 4]
                mem[mem[64] + 4] = _720
                mem[mem[64] + 36] = _774
                mem[mem[64] + 68] = msg.sender
                require ext_code.size(stor11[stor10[address(arg1)]])
                call stor11[stor10[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                     gas gas_remaining wei
                    args _720, _774, msg.sender
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _834 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_834] == mem[_834]
                require ext_code.size(stor11[stor10[address(arg1)]])
                staticcall stor11[stor10[address(arg1)]].bondInfo(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _858 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 128
                require mem[_858] == mem[_858]
                require mem[_858 + 32] == mem[_858 + 32]
                require mem[_858 + 64] == mem[_858 + 92 len 4]
                require mem[_858 + 96] == mem[_858 + 124 len 4]
                if mem[_858] < _798:
                    revert with 'NH{q', 17
                if mem[_858] - _798 < arg3:
                    revert with 0, 'insufficient profit, either ROI plummeted or your slippage is too tight'
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(arg1))
                staticcall address(arg1).0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _912 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _918 = mem[_912]
                require mem[_912] == mem[_912]
                if mem[_912] <= 0:
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(stor2)
                    staticcall stor2.0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _947 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _960 = mem[_947]
                    require mem[_947] == mem[_947]
                    if mem[_947] > 0:
                        mem[mem[64] + 4] = msg.sender
                        mem[mem[64] + 36] = _960
                        require ext_code.size(stor2)
                        call stor2.0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _960
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1001 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_1001] == bool(mem[_1001])
                else:
                    mem[mem[64] + 4] = msg.sender
                    mem[mem[64] + 36] = _918
                    require ext_code.size(address(arg1))
                    call address(arg1).0xa9059cbb with:
                         gas gas_remaining wei
                        args msg.sender, _918
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _954 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_954] == bool(mem[_954])
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(stor2)
                    staticcall stor2.0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1002 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1014 = mem[_1002]
                    require mem[_1002] == mem[_1002]
                    if mem[_1002] > 0:
                        mem[mem[64] + 4] = msg.sender
                        mem[mem[64] + 36] = _1014
                        require ext_code.size(stor2)
                        call stor2.0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _1014
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1032 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_1032] == bool(mem[_1032])
            else:
                if mem[_172 + 12 len 20] != address(arg1):
                    revert with 0, 'bad LP token'
                if address(_166) != stor2:
                    revert with 0, 'bad LP token'
                mem[mem[64] + 4] = this.address
                require ext_code.size(stor2)
                staticcall stor2.0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _210 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _214 = mem[_210]
                require mem[_210] == mem[_210]
                if Mask(112, 0, _154) > 0x20d135b66ae990fc484cea55e38a936bcf497445394d4cc984add428823e4d:
                    revert with 'NH{q', 17
                if 1000 * Mask(112, 0, _154) and mem[_210] > -1 / 1000 * Mask(112, 0, _154):
                    revert with 'NH{q', 17
                if mem[_210] / 2 > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                    revert with 'NH{q', 17
                if 1994 * mem[_210] / 2 > (-1997 * Mask(112, 0, _154)) - 1:
                    revert with 'NH{q', 17
                if mem[_210] / 2 > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                    revert with 'NH{q', 17
                if 997 * mem[_210] / 2 and mem[_210] / 2 > -1 / 997 * mem[_210] / 2:
                    revert with 'NH{q', 17
                if 997 * mem[_210] / 2 * mem[_210] / 2 > (-1000 * Mask(112, 0, _154) * mem[_210]) - 1:
                    revert with 'NH{q', 17
                if not (1994 * mem[_210] / 2) + (1997 * Mask(112, 0, _154)):
                    revert with 'NH{q', 18
                if (997 * mem[_210] / 2 * mem[_210] / 2) + (1000 * Mask(112, 0, _154) * mem[_210]) / (1994 * mem[_210] / 2) + (1997 * Mask(112, 0, _154)) > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                    revert with 'NH{q', 17
                if 1994 * (997 * mem[_210] / 2 * mem[_210] / 2) + (1000 * Mask(112, 0, _154) * mem[_210]) / (1994 * mem[_210] / 2) + (1997 * Mask(112, 0, _154)) > (-1997 * Mask(112, 0, _154)) - 1:
                    revert with 'NH{q', 17
                if (997 * mem[_210] / 2 * mem[_210] / 2) + (1000 * Mask(112, 0, _154) * mem[_210]) / (1994 * mem[_210] / 2) + (1997 * Mask(112, 0, _154)) > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                    revert with 'NH{q', 17
                if 997 * (997 * mem[_210] / 2 * mem[_210] / 2) + (1000 * Mask(112, 0, _154) * mem[_210]) / (1994 * mem[_210] / 2) + (1997 * Mask(112, 0, _154)) and (997 * mem[_210] / 2 * mem[_210] / 2) + (1000 * Mask(112, 0, _154) * mem[_210]) / (1994 * mem[_210] / 2) + (1997 * Mask(112, 0, _154)) > -1 / 997 * (997 * mem[_210] / 2 * mem[_210] / 2) + (1000 * Mask(112, 0, _154) * mem[_210]) / (1994 * mem[_210] / 2) + (1997 * Mask(112, 0, _154)):
                    revert with 'NH{q', 17
                if 997 * (997 * mem[_210] / 2 * mem[_210] / 2) + (1000 * Mask(112, 0, _154) * mem[_210]) / (1994 * mem[_210] / 2) + (1997 * Mask(112, 0, _154)) * (997 * mem[_210] / 2 * mem[_210] / 2) + (1000 * Mask(112, 0, _154) * mem[_210]) / (1994 * mem[_210] / 2) + (1997 * Mask(112, 0, _154)) > (-1000 * Mask(112, 0, _154) * mem[_210]) - 1:
                    revert with 'NH{q', 17
                if not (1994 * (997 * mem[_210] / 2 * mem[_210] / 2) + (1000 * Mask(112, 0, _154) * mem[_210]) / (1994 * mem[_210] / 2) + (1997 * Mask(112, 0, _154))) + (1997 * Mask(112, 0, _154)):
                    revert with 'NH{q', 18
                if (997 * (997 * mem[_210] / 2 * mem[_210] / 2) + (1000 * Mask(112, 0, _154) * mem[_210]) / (1994 * mem[_210] / 2) + (1997 * Mask(112, 0, _154)) * (997 * mem[_210] / 2 * mem[_210] / 2) + (1000 * Mask(112, 0, _154) * mem[_210]) / (1994 * mem[_210] / 2) + (1997 * Mask(112, 0, _154))) + (1000 * Mask(112, 0, _154) * mem[_210]) / (1994 * (997 * mem[_210] / 2 * mem[_210] / 2) + (1000 * Mask(112, 0, _154) * mem[_210]) / (1994 * mem[_210] / 2) + (1997 * Mask(112, 0, _154))) + (1997 * Mask(112, 0, _154)) > 0x20ddd97c0522a9fb60cd6a8f472018a6631d03d9ff7c889a0feb7558127cca:
                    revert with 'NH{q', 17
                if 1994 * (997 * (997 * mem[_210] / 2 * mem[_210] / 2) + (1000 * Mask(112, 0, _154) * mem[_210]) / (1994 * mem[_210] / 2) + (1997 * Mask(112, 0, _154)) * (997 * mem[_210] / 2 * mem[_210] / 2) + (1000 * Mask(112, 0, _154) * mem[_210]) / (1994 * mem[_210] / 2) + (1997 * Mask(112, 0, _154))) + (1000 * Mask(112, 0, _154) * mem[_210]) / (1994 * (997 * mem[_210] / 2 * mem[_210] / 2) + (1000 * Mask(112, 0, _154) * mem[_210]) / (1994 * mem[_210] / 2) + (1997 * Mask(112, 0, _154))) + (1997 * Mask(112, 0, _154)) > (-1997 * Mask(112, 0, _154)) - 1:
                    revert with 'NH{q', 17
                if (997 * (997 * mem[_210] / 2 * mem[_210] / 2) + (1000 * Mask(112, 0, _154) * mem[_210]) / (1994 * mem[_210] / 2) + (1997 * Mask(112, 0, _154)) * (997 * mem[_210] / 2 * mem[_210] / 2) + (1000 * Mask(112, 0, _154) * mem[_210]) / (1994 * mem[_210] / 2) + (1997 * Mask(112, 0, _154))) + (1000 * Mask(112, 0, _154) * mem[_210]) / (1994 * (997 * mem[_210] / 2 * mem[_210] / 2) + (1000 * Mask(112, 0, _154) * mem[_210]) / (1994 * mem[_210] / 2) + (1997 * Mask(112, 0, _154))) + (1997 * Mask(112, 0, _154)) > 0x41bbb2f80a4553f6c19ad51e8e40314cc63a07b3fef911341fd6eab024f994:
                    revert with 'NH{q', 17
                if 997 * (997 * (997 * mem[_210] / 2 * mem[_210] / 2) + (1000 * Mask(112, 0, _154) * mem[_210]) / (1994 * mem[_210] / 2) + (1997 * Mask(112, 0, _154)) * (997 * mem[_210] / 2 * mem[_210] / 2) + (1000 * Mask(112, 0, _154) * mem[_210]) / (1994 * mem[_210] / 2) + (1997 * Mask(112, 0, _154))) + (1000 * Mask(112, 0, _154) * mem[_210]) / (1994 * (997 * mem[_210] / 2 * mem[_210] / 2) + (1000 * Mask(112, 0, _154) * mem[_210]) / (1994 * mem[_210] / 2) + (1997 * Mask(112, 0, _154))) + (1997 * Mask(112, 0, _154)) and (997 * (997 * mem[_210] / 2 * mem[_210] / 2) + (1000 * Mask(112, 0, _154) * mem[_210]) / (1994 * mem[_210] / 2) + (1997 * Mask(112, 0, _154)) * (997 * mem[_210] / 2 * mem[_210] / 2) + (1000 * Mask(112, 0, _154) * mem[_210]) / (1994 * mem[_210] / 2) + (1997 * Mask(112, 0, _154))) + (1000 * Mask(112, 0, _154) * mem[_210]) / (1994 * (997 * mem[_210] / 2 * mem[_210] / 2) + (1000 * Mask(112, 0, _154) * mem[_210]) / (1994 * mem[_210] / 2) + (1997 * Mask(112, 0, _154))) + (1997 * Mask(112, 0, _154)) > -1 / 997 * (997 * (997 * mem[_210] / 2 * mem[_210] / 2) + (1000 * Mask(112, 0, _154) * mem[_210]) / (1994 * mem[_210] / 2) + (1997 * Mask(112, 0, _154)) * (997 * mem[_210] / 2 * mem[_210] / 2) + (1000 * Mask(112, 0, _154) * mem[_210]) / (1994 * mem[_210] / 2) + (1997 * Mask(112, 0, _154))) + (1000 * Mask(112, 0, _154) * mem[_210]) / (1994 * (997 * mem[_210] / 2 * mem[_210] / 2) + (1000 * Mask(112, 0, _154) * mem[_210]) / (1994 * mem[_210] / 2) + (1997 * Mask(112, 0, _154))) + (1997 * Mask(112, 0, _154)):
                    revert with 'NH{q', 17
                if 997 * (997 * (997 * mem[_210] / 2 * mem[_210] / 2) + (1000 * Mask(112, 0, _154) * mem[_210]) / (1994 * mem[_210] / 2) + (1997 * Mask(112, 0, _154)) * (997 * mem[_210] / 2 * mem[_210] / 2) + (1000 * Mask(112, 0, _154) * mem[_210]) / (1994 * mem[_210] / 2) + (1997 * Mask(112, 0, _154))) + (1000 * Mask(112, 0, _154) * mem[_210]) / (1994 * (997 * mem[_210] / 2 * mem[_210] / 2) + (1000 * Mask(112, 0, _154) * mem[_210]) / (1994 * mem[_210] / 2) + (1997 * Mask(112, 0, _154))) + (1997 * Mask(112, 0, _154)) * (997 * (997 * mem[_210] / 2 * mem[_210] / 2) + (1000 * Mask(112, 0, _154) * mem[_210]) / (1994 * mem[_210] / 2) + (1997 * Mask(112, 0, _154)) * (997 * mem[_210] / 2 * mem[_210] / 2) + (1000 * Mask(112, 0, _154) * mem[_210]) / (1994 * mem[_210] / 2) + (1997 * Mask(112, 0, _154))) + (1000 * Mask(112, 0, _154) * mem[_210]) / (1994 * (997 * mem[_210] / 2 * mem[_210] / 2) + (1000 * Mask(112, 0, _154) * mem[_210]) / (1994 * mem[_210] / 2) + (1997 * Mask(112, 0, _154))) + (1997 * Mask(112, 0, _154)) > (-1000 * Mask(112, 0, _154) * mem[_210]) - 1:
                    revert with 'NH{q', 17
                if not (1994 * (997 * (997 * mem[_210] / 2 * mem[_210] / 2) + (1000 * Mask(112, 0, _154) * mem[_210]) / (1994 * mem[_210] / 2) + (1997 * Mask(112, 0, _154)) * (997 * mem[_210] / 2 * mem[_210] / 2) + (1000 * Mask(112, 0, _154) * mem[_210]) / (1994 * mem[_210] / 2) + (1997 * Mask(112, 0, _154))) + (1000 * Mask(112, 0, _154) * mem[_210]) / (1994 * (997 * mem[_210] / 2 * mem[_210] / 2) + (1000 * Mask(112, 0, _154) * mem[_210]) / (1994 * mem[_210] / 2) + (1997 * Mask(112, 0, _154))) + (1997 * Mask(112, 0, _154))) + (1997 * Mask(112, 0, _154)):
                    revert with 'NH{q', 18
                require address(arg1)
                mem[mem[64] + 4] = stor4
                mem[mem[64] + 36] = (997 * (997 * (997 * _214 / 2 * _214 / 2) + (1000 * Mask(112, 0, _154) * _214) / (1994 * _214 / 2) + (1997 * Mask(112, 0, _154)) * (997 * _214 / 2 * _214 / 2) + (1000 * Mask(112, 0, _154) * _214) / (1994 * _214 / 2) + (1997 * Mask(112, 0, _154))) + (1000 * Mask(112, 0, _154) * _214) / (1994 * (997 * _214 / 2 * _214 / 2) + (1000 * Mask(112, 0, _154) * _214) / (1994 * _214 / 2) + (1997 * Mask(112, 0, _154))) + (1997 * Mask(112, 0, _154)) * (997 * (997 * _214 / 2 * _214 / 2) + (1000 * Mask(112, 0, _154) * _214) / (1994 * _214 / 2) + (1997 * Mask(112, 0, _154)) * (997 * _214 / 2 * _214 / 2) + (1000 * Mask(112, 0, _154) * _214) / (1994 * _214 / 2) + (1997 * Mask(112, 0, _154))) + (1000 * Mask(112, 0, _154) * _214) / (1994 * (997 * _214 / 2 * _214 / 2) + (1000 * Mask(112, 0, _154) * _214) / (1994 * _214 / 2) + (1997 * Mask(112, 0, _154))) + (1997 * Mask(112, 0, _154))) + (1000 * Mask(112, 0, _154) * _214) / (1994 * (997 * (997 * _214 / 2 * _214 / 2) + (1000 * Mask(112, 0, _154) * _214) / (1994 * _214 / 2) + (1997 * Mask(112, 0, _154)) * (997 * _214 / 2 * _214 / 2) + (1000 * Mask(112, 0, _154) * _214) / (1994 * _214 / 2) + (1997 * Mask(112, 0, _154))) + (1000 * Mask(112, 0, _154) * _214) / (1994 * (997 * _214 / 2 * _214 / 2) + (1000 * Mask(112, 0, _154) * _214) / (1994 * _214 / 2) + (1997 * Mask(112, 0, _154))) + (1997 * Mask(112, 0, _154))) + (1997 * Mask(112, 0, _154))
                require ext_code.size(stor2)
                call stor2.approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor4, (997 * (997 * (997 * _214 / 2 * _214 / 2) + (1000 * Mask(112, 0, _154) * _214) / (1994 * _214 / 2) + (1997 * Mask(112, 0, _154)) * (997 * _214 / 2 * _214 / 2) + (1000 * Mask(112, 0, _154) * _214) / (1994 * _214 / 2) + (1997 * Mask(112, 0, _154))) + (1000 * Mask(112, 0, _154) * _214) / (1994 * (997 * _214 / 2 * _214 / 2) + (1000 * Mask(112, 0, _154) * _214) / (1994 * _214 / 2) + (1997 * Mask(112, 0, _154))) + (1997 * Mask(112, 0, _154)) * (997 * (997 * _214 / 2 * _214 / 2) + (1000 * Mask(112, 0, _154) * _214) / (1994 * _214 / 2) + (1997 * Mask(112, 0, _154)) * (997 * _214 / 2 * _214 / 2) + (1000 * Mask(112, 0, _154) * _214) / (1994 * _214 / 2) + (1997 * Mask(112, 0, _154))) + (1000 * Mask(112, 0, _154) * _214) / (1994 * (997 * _214 / 2 * _214 / 2) + (1000 * Mask(112, 0, _154) * _214) / (1994 * _214 / 2) + (1997 * Mask(112, 0, _154))) + (1997 * Mask(112, 0, _154))) + (1000 * Mask(112, 0, _154) * _214) / (1994 * (997 * (997 * _214 / 2 * _214 / 2) + (1000 * Mask(112, 0, _154) * _214) / (1994 * _214 / 2) + (1997 * Mask(112, 0, _154)) * (997 * _214 / 2 * _214 / 2) + (1000 * Mask(112, 0, _154) * _214) / (1994 * _214 / 2) + (1997 * Mask(112, 0, _154))) + (1000 * Mask(112, 0, _154) * _214) / (1994 * (997 * _214 / 2 * _214 / 2) + (1000 * Mask(112, 0, _154) * _214) / (1994 * _214 / 2) + (1997 * Mask(112, 0, _154))) + (1997 * Mask(112, 0, _154))) + (1997 * Mask(112, 0, _154))
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _234 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_234] == bool(mem[_234])
                _248 = mem[64]
                mem[mem[64]] = 2
                mem[64] = mem[64] + 96
                if 0 >= mem[_248]:
                    revert with 'NH{q', 50
                mem[_248 + 32] = stor2
                if 1 >= mem[_248]:
                    revert with 'NH{q', 50
                mem[_248 + 64] = address(arg1)
                if block.timestamp > -61:
                    revert with 'NH{q', 17
                mem[_248 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                mem[_248 + 100] = (997 * (997 * (997 * _214 / 2 * _214 / 2) + (1000 * Mask(112, 0, _154) * _214) / (1994 * _214 / 2) + (1997 * Mask(112, 0, _154)) * (997 * _214 / 2 * _214 / 2) + (1000 * Mask(112, 0, _154) * _214) / (1994 * _214 / 2) + (1997 * Mask(112, 0, _154))) + (1000 * Mask(112, 0, _154) * _214) / (1994 * (997 * _214 / 2 * _214 / 2) + (1000 * Mask(112, 0, _154) * _214) / (1994 * _214 / 2) + (1997 * Mask(112, 0, _154))) + (1997 * Mask(112, 0, _154)) * (997 * (997 * _214 / 2 * _214 / 2) + (1000 * Mask(112, 0, _154) * _214) / (1994 * _214 / 2) + (1997 * Mask(112, 0, _154)) * (997 * _214 / 2 * _214 / 2) + (1000 * Mask(112, 0, _154) * _214) / (1994 * _214 / 2) + (1997 * Mask(112, 0, _154))) + (1000 * Mask(112, 0, _154) * _214) / (1994 * (997 * _214 / 2 * _214 / 2) + (1000 * Mask(112, 0, _154) * _214) / (1994 * _214 / 2) + (1997 * Mask(112, 0, _154))) + (1997 * Mask(112, 0, _154))) + (1000 * Mask(112, 0, _154) * _214) / (1994 * (997 * (997 * _214 / 2 * _214 / 2) + (1000 * Mask(112, 0, _154) * _214) / (1994 * _214 / 2) + (1997 * Mask(112, 0, _154)) * (997 * _214 / 2 * _214 / 2) + (1000 * Mask(112, 0, _154) * _214) / (1994 * _214 / 2) + (1997 * Mask(112, 0, _154))) + (1000 * Mask(112, 0, _154) * _214) / (1994 * (997 * _214 / 2 * _214 / 2) + (1000 * Mask(112, 0, _154) * _214) / (1994 * _214 / 2) + (1997 * Mask(112, 0, _154))) + (1997 * Mask(112, 0, _154))) + (1997 * Mask(112, 0, _154))
                mem[_248 + 132] = 0
                mem[_248 + 164] = 160
                mem[_248 + 260] = mem[_248]
                idx = 0
                s = _248 + 32
                t = _248 + 292
                while idx < mem[_248]:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[_248 + 196] = this.address
                mem[_248 + 228] = block.timestamp + 60
                require ext_code.size(stor4)
                call stor4.mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len _248 + (32 * mem[_248]) + -mem[64] + 288]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _395 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _401 = mem[_395]
                require mem[_395] <= test266151307()
                require _395 + mem[_395] + 31 < _395 + return_data.size
                _407 = mem[_395 + mem[_395]]
                if mem[_395 + mem[_395]] > test266151307():
                    revert with 'NH{q', 65
                if _395 + ceil32(return_data.size) + floor32(mem[_395 + mem[_395]]) + 1 > test266151307() or floor32(mem[_395 + mem[_395]]) + 1 < 0:
                    revert with 'NH{q', 65
                mem[64] = _395 + ceil32(return_data.size) + floor32(mem[_395 + mem[_395]]) + 1
                mem[_395 + ceil32(return_data.size)] = _407
                require _401 + (32 * _407) + 32 <= return_data.size
                idx = 0
                s = _395 + _401 + 32
                t = _395 + ceil32(return_data.size) + 32
                while idx < _407:
                    require mem[s] == mem[s]
                    mem[t] = mem[s]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(arg1))
                staticcall address(arg1).0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _575 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _581 = mem[_575]
                require mem[_575] == mem[_575]
                mem[mem[64] + 4] = this.address
                require ext_code.size(stor2)
                staticcall stor2.0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _599 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _605 = mem[_599]
                require mem[_599] == mem[_599]
                mem[mem[64] + 4] = stor4
                mem[mem[64] + 36] = _581
                require ext_code.size(address(arg1))
                call address(arg1).approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor4, _581
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _623 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_623] == bool(mem[_623])
                mem[mem[64] + 4] = stor4
                mem[mem[64] + 36] = _605
                require ext_code.size(stor2)
                call stor2.approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor4, _605
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _647 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_647] == bool(mem[_647])
                if block.timestamp > -61:
                    revert with 'NH{q', 17
                mem[mem[64] + 68] = _605
                mem[mem[64] + 100] = _581
                mem[mem[64] + 132] = 0
                mem[mem[64] + 164] = 0
                mem[mem[64] + 196] = this.address
                mem[mem[64] + 228] = block.timestamp + 60
                require ext_code.size(stor4)
                call stor4.addLiquidity(address arg1, address arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, address arg7, uint256 arg8) with:
                     gas gas_remaining wei
                    args stor2, address(arg1), _605, _581, 0, 0, address(this.address), block.timestamp + 60
                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _671 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 96
                require mem[_671] == mem[_671]
                require mem[_671 + 32] == mem[_671 + 32]
                require mem[_671 + 64] == mem[_671 + 64]
                mem[0] = address(arg1)
                mem[32] = 10
                mem[mem[64] + 4] = this.address
                require ext_code.size(stor10[address(arg1)])
                staticcall stor10[address(arg1)].0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _713 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _719 = mem[_713]
                require mem[_713] == mem[_713]
                mem[0] = stor10[address(arg1)]
                mem[32] = 11
                mem[mem[64] + 4] = stor11[stor10[address(arg1)]]
                mem[mem[64] + 36] = _719
                require ext_code.size(stor10[address(arg1)])
                call stor10[address(arg1)].approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args stor11[stor10[address(arg1)]], _719
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _743 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_743] == bool(mem[_743])
                require ext_code.size(stor11[stor10[address(arg1)]])
                staticcall stor11[stor10[address(arg1)]].bondPrice() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _767 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _773 = mem[_767]
                require mem[_767] == mem[_767]
                require ext_code.size(stor11[stor10[address(arg1)]])
                staticcall stor11[stor10[address(arg1)]].bondInfo(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _791 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 128
                _797 = mem[_791]
                require mem[_791] == mem[_791]
                require mem[_791 + 32] == mem[_791 + 32]
                require mem[_791 + 64] == mem[_791 + 92 len 4]
                require mem[_791 + 96] == mem[_791 + 124 len 4]
                mem[mem[64] + 4] = _719
                mem[mem[64] + 36] = _773
                mem[mem[64] + 68] = msg.sender
                require ext_code.size(stor11[stor10[address(arg1)]])
                call stor11[stor10[address(arg1)]].deposit(uint256 arg1, uint256 arg2, address arg3) with:
                     gas gas_remaining wei
                    args _719, _773, msg.sender
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _833 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_833] == mem[_833]
                require ext_code.size(stor11[stor10[address(arg1)]])
                staticcall stor11[stor10[address(arg1)]].bondInfo(address arg1) with:
                        gas gas_remaining wei
                       args msg.sender
                mem[mem[64] len 128] = ext_call.return_data[0 len 128]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _857 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 128
                require mem[_857] == mem[_857]
                require mem[_857 + 32] == mem[_857 + 32]
                require mem[_857 + 64] == mem[_857 + 92 len 4]
                require mem[_857 + 96] == mem[_857 + 124 len 4]
                if mem[_857] < _797:
                    revert with 'NH{q', 17
                if mem[_857] - _797 < arg3:
                    revert with 0, 'insufficient profit, either ROI plummeted or your slippage is too tight'
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(arg1))
                staticcall address(arg1).0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _911 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _917 = mem[_911]
                require mem[_911] == mem[_911]
                if mem[_911] <= 0:
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(stor2)
                    staticcall stor2.0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _945 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _959 = mem[_945]
                    require mem[_945] == mem[_945]
                    if mem[_945] > 0:
                        mem[mem[64] + 4] = msg.sender
                        mem[mem[64] + 36] = _959
                        require ext_code.size(stor2)
                        call stor2.0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _959
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _999 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_999] == bool(mem[_999])
                else:
                    mem[mem[64] + 4] = msg.sender
                    mem[mem[64] + 36] = _917
                    require ext_code.size(address(arg1))
                    call address(arg1).0xa9059cbb with:
                         gas gas_remaining wei
                        args msg.sender, _917
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _953 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_953] == bool(mem[_953])
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(stor2)
                    staticcall stor2.0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1000 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1012 = mem[_1000]
                    require mem[_1000] == mem[_1000]
                    if mem[_1000] > 0:
                        mem[mem[64] + 4] = msg.sender
                        mem[mem[64] + 36] = _1012
                        require ext_code.size(stor2)
                        call stor2.0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, _1012
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1031 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_1031] == bool(mem[_1031])
}



}

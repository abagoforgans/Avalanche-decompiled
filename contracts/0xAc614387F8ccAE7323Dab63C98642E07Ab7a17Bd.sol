contract main {




// =====================  Runtime code  =====================


#
#  - set(uint256 arg1, uint256 arg2)
#  - withdraw(uint256 arg1, uint256 arg2)
#  - deposit(uint256 arg1, uint256 arg2)
#
address owner;
uint256 stor1;
array of struct multLP;
mapping of uint256 stor3;
address bxhAddress;
uint256 bxhPerBlock;
array of struct poolInfo;
mapping of struct userInfo;
mapping of uint256 poolCorrespond;
mapping of uint256 lpOfPid;
uint8 paused;
uint256 stor10;
uint256 totalAllocPoint;
uint256 startBlock;
address multLpChefAddress;
address multLpTokenAddress;
uint256 decayPeriod;
uint256 decayRatio;
array of uint256 decayTable;
array of uint256 stor111414077815863400510004064629973595961579173665589224203503662149373724986688;
array of uint256 stor111414077815863400510004064629973595961579173665589224203503662149373724986689;
array of uint256 stor111414077815863400510004064629973595961579173665589224203503662149373724986690;
array of uint256 stor111414077815863400510004064629973595961579173665589224203503662149373724986691;
array of uint256 stor111414077815863400510004064629973595961579173665589224203503662149373724986692;

function poolLength() payable {
    return poolInfo.length
}

function poolInfo(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 < poolInfo.length
    return poolInfo[arg1].field_0, 
           poolInfo[arg1].field_256,
           poolInfo[arg1].field_512,
           poolInfo[arg1].field_768,
           poolInfo[arg1].field_1024,
           poolInfo[arg1].field_1280
}

function totalAllocPoint() payable {
    return totalAllocPoint
}

function bxh() payable {
    return bxhAddress
}

function getMultLPAddress(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if arg1 > multLP.length - 1:
        revert with 0, 'not find this multLP'
    if arg1 >= multLP.length:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    34,
                    0xfe456e756d657261626c655365743a20696e646578206f7574206f6620626f756e64,
                    mem[198 len 30]
    return multLP[arg1].field_0
}

function startBlock() payable {
    return startBlock
}

function decayPeriod() payable {
    return decayPeriod
}

function paused() payable {
    return bool(uint8(paused))
}

function decayRatio() payable {
    return decayRatio
}

function multLpToken() payable {
    return multLpTokenAddress
}

function isMultLP(address arg1) payable {
    require calldata.size - 4 >= 32
    return bool(stor3[address(arg1)])
}

function owner() payable {
    return owner
}

function userInfo(uint256 arg1, address arg2) payable {
    require calldata.size - 4 >= 64
    return userInfo[arg1][arg2].field_0, userInfo[arg1][arg2].field_256, userInfo[arg1][arg2].field_512
}

function bxhPerBlock() payable {
    return bxhPerBlock
}

function LpOfPid(address arg1) payable {
    require calldata.size - 4 >= 32
    return lpOfPid[arg1]
}

function poolCorrespond(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    return poolCorrespond[arg1]
}

function multLpChef() payable {
    return multLpChefAddress
}

function getMultLPLength() payable {
    return multLP.length
}

function decayTable(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 < decayTable.length
    return decayTable[arg1]
}

function _fallback() payable {
    revert
}

function renounceOwnership() payable {
    if owner != msg.sender:
        revert with 0, 'wOwnable: caller is not the owne'
    emit OwnershipTransferred(owner, 0);
    owner = 0
}

function setPause() payable {
    if owner != msg.sender:
        revert with 0, 'wOwnable: caller is not the owne'
    uint256(stor10) = not uint8(paused) or Mask(248, 8, uint256(stor10))
}

function setDecayPeriod(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'wOwnable: caller is not the owne'
    decayPeriod = arg1
}

function setDecayRatio(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'wOwnable: caller is not the owne'
    if arg1 >= 1000:
        revert with 0, 'ratio should less than 1000'
    decayRatio = arg1
}

function checkPoolDuplicate(address arg1) payable {
    require calldata.size - 4 >= 32
    idx = 0
    while idx < poolInfo.length:
        mem[0] = 6
        if poolInfo[idx].field_0 == arg1:
            revert with 0, 'add: existing pool?'
        idx = idx + 1
        continue 
}

function setPoolCorr(uint256 arg1, uint256 arg2) payable {
    require calldata.size - 4 >= 64
    if owner != msg.sender:
        revert with 0, 'wOwnable: caller is not the owne'
    if arg1 > poolInfo.length - 1:
        revert with 0, 'not find this pool'
    poolCorrespond[arg1] = arg2
}

function setMultLP(address arg1, address arg2) payable {
    require calldata.size - 4 >= 64
    if owner != msg.sender:
        revert with 0, 'wOwnable: caller is not the owne'
    if not arg1:
        revert with 0, 'is the zero address'
    if not arg2:
        revert with 0, 'is the zero address'
    multLpTokenAddress = arg1
    multLpChefAddress = arg2
}

function phase(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if 0 == decayPeriod:
        return 0
    if arg1 <= startBlock:
        return 0
    if startBlock > arg1:
        revert with 0, 'SafeMath: subtraction overflow'
    if 1 > arg1 - startBlock:
        revert with 0, 'SafeMath: subtraction overflow'
    if decayPeriod <= 0:
        revert with 0, 'SafeMath: division by zero'
    require decayPeriod
    return (arg1 + -startBlock - 1 / decayPeriod)
}

function transferOwnership(address arg1) payable {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'wOwnable: caller is not the owne'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    38,
                    0x734f776e61626c653a206e6577206f776e657220697320746865207a65726f20616464726573,
                    mem[202 len 26]
    emit OwnershipTransferred(owner, arg1);
    owner = arg1
}

function addMultLP(address arg1) payable {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'wOwnable: caller is not the owne'
    if not arg1:
        revert with 0, 'LP is the zero address'
    require ext_code.size(arg1)
    call arg1.approve(address arg1, uint256 arg2) with:
         gas gas_remaining wei
        args multLpChefAddress, -1
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if stor3[address(arg1)]:
        return 0
    multLP.length++
    multLP[multLP.length].field_0 = arg1
    multLP[multLP.length].field_160 = 0
    stor3[address(arg1)] = multLP.length
    return 1
}

function rewardV(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if 0 == decayPeriod:
        if 0 >= decayTable.length:
            revert with 0, 'phase not ready'
        return decayTable
    if arg1 <= startBlock:
        if 0 >= decayTable.length:
            revert with 0, 'phase not ready'
        return decayTable
    if startBlock > arg1:
        revert with 0, 'SafeMath: subtraction overflow'
    if 1 > arg1 - startBlock:
        revert with 0, 'SafeMath: subtraction overflow'
    if decayPeriod <= 0:
        revert with 0, 'SafeMath: division by zero'
    require decayPeriod
    if arg1 + -startBlock - 1 / decayPeriod >= decayTable.length:
        revert with 0, 'phase not ready'
    return decayTable[arg1 + -stor12 - 1 / stor15]
}

function replaceMultLP(address arg1, address arg2) payable {
    require calldata.size - 4 >= 64
    if owner != msg.sender:
        revert with 0, 'wOwnable: caller is not the owne'
    if not arg1:
        revert with 0, 'is the zero address'
    if not arg2:
        revert with 0, 'is the zero address'
    if bool(uint8(paused)) != 1:
        revert with 0, 'No mining suspension'
    multLpTokenAddress = arg1
    multLpChefAddress = arg2
    idx = multLP.length
    while idx:
        if 0 >= multLP.length:
            revert with 0, 32, 34, 0xfe456e756d657261626c655365743a20696e646578206f7574206f6620626f756e64, mem[198 len 30]
        mem[96] = 0x5312ea8e00000000000000000000000000000000000000000000000000000000
        mem[100] = poolCorrespond[stor9[address(stor2.field_0)]]
        require ext_code.size(multLpChefAddress)
        call multLpChefAddress.0x5312ea8e with:
             gas gas_remaining wei
            args poolCorrespond[stor9[address(stor2.field_0)]]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        mem[0] = address(multLP.field_0)
        mem[32] = 3
        if stor3[address(stor2.field_0)]:
            require multLP.length - 1 < multLP.length
            require stor3[address(stor2.field_0)] - 1 < multLP.length
            multLP[stor3[address(multLP.field_0)]].field_0 = multLP[multLP.length].field_0
            stor3[stor2[stor2.length].field_0] = stor3[address(stor2.field_0)]
            require multLP.length
            multLP[multLP.length].field_0 = 0
            multLP.length--
            mem[0] = address(multLP.field_0)
            mem[32] = 3
            stor3[address(stor2.field_0)] = 0
        idx = idx - 1
        continue 
}

function emergencyWithdraw(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if uint8(paused):
        revert with 0, 'Mining has been suspended'
    if stor1 == 2:
        revert with 0, 'ReentrancyGuard: reentrant call'
    stor1 = 2
    require arg1 < poolInfo.length
    require arg1 < poolInfo.length
    if not stor3[stor6[arg1].field_0]:
    else:
        require ext_code.size(multLpTokenAddress)
        staticcall multLpTokenAddress.0x70a08231 with:
                gas gas_remaining wei
               args this.address
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_code.size(multLpChefAddress)
        call multLpChefAddress.0x441a3e70 with:
             gas gas_remaining wei
            args poolCorrespond[arg1], userInfo[arg1][address(msg.sender)].field_0
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require ext_code.size(multLpTokenAddress)
        staticcall multLpTokenAddress.0x70a08231 with:
                gas gas_remaining wei
               args this.address
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if ext_call.return_data[0] > ext_call.return_data[0]:
            revert with 0, 'SafeMath: subtraction overflow'
        if poolInfo[arg1].field_1280 <= 0:
            revert with 0, 'SafeMath: division by zero'
        require poolInfo[arg1].field_1280
        if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_1024 < poolInfo[arg1].field_1024:
            revert with 0, 'SafeMath: addition overflow'
        poolInfo[arg1].field_1024 += 0 / poolInfo[arg1].field_1280
    userInfo[arg1][address(msg.sender)].field_0 = 0
    userInfo[arg1][address(msg.sender)].field_256 = 0
    if eth.balance(this.address) < 0:
        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[366 len 26]
    if not ext_code.size(poolInfo[arg1].field_0):
        revert with 0, 'Address: call to non-contract'
    mem[260 len 64] = unknown_0xa9059cbb(?????), msg.sender, userInfo[arg1][address(msg.sender)].field_32
    mem[324 len 0] = 0
    call poolInfo[arg1].field_0 with:
       funct uint32(msg.sender)
         gas gas_remaining wei
        args userInfo[arg1][address(msg.sender)].field_0, mem[324 len 4]
    if not return_data.size:
        if not ext_call.success:
            revert with unknown_0xa9059cbb(?????), msg.sender, userInfo[arg1][address(msg.sender)].field_0
        if not unknown_0xa9059cbb(?????), Mask(224, 32, msg.sender) >> 32:
            revert with 0, 32, 42, 0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565, mem[370 len 22]
    else:
        mem[292 len return_data.size] = ext_call.return_data[0 len return_data.size]
        if not ext_call.success:
            if return_data.size:
                revert with ext_call.return_data[0 len return_data.size]
            revert with 0, 'SafeERC20: low-level call failed'
        if return_data.size:
            require return_data.size >= 32
            if not mem[292]:
                revert with 0, 
                            32,
                            42,
                            0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                            mem[ceil32(return_data.size) + 371 len 22]
    if userInfo[arg1][address(msg.sender)].field_0 > poolInfo[arg1].field_1280:
        revert with 0, 'SafeMath: subtraction overflow'
    poolInfo[arg1].field_1280 -= userInfo[arg1][address(msg.sender)].field_0
    emit EmergencyWithdraw(userInfo[arg1][address(msg.sender)].field_0, msg.sender, arg1);
    stor1 = 1
}

function batchPrepareRewardTable(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if arg1 >= 64:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    40,
                    0x6c7370617265436f756e7420746f6f206c61726765202c206d757374206c657373207468616e2036,
                    mem[204 len 24]
    if 0 == decayPeriod:
        if arg1 < 0:
            revert with 0, 'SafeMath: addition overflow'
        if arg1 >= decayTable.length:
            if arg1 < 0:
                revert with 0, 'SafeMath: addition overflow'
            if decayTable.length > arg1:
                revert with 0, 'SafeMath: subtraction overflow'
            idx = 0
            while idx <= arg1 - decayTable.length:
                require decayTable.length - 1 < decayTable.length
                if not decayTable[decayTable.length]:
                    decayTable.length++
                    mem[0] = 17
                    decayTable[decayTable.length] = 0
                else:
                    if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    decayTable.length++
                    mem[0] = 17
                    decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                idx = idx + 1
                continue 
        if 0 < decayTable.length:
            return decayTable
    else:
        if block.number <= startBlock:
            if arg1 < 0:
                revert with 0, 'SafeMath: addition overflow'
            if arg1 >= decayTable.length:
                if arg1 < 0:
                    revert with 0, 'SafeMath: addition overflow'
                if decayTable.length > arg1:
                    revert with 0, 'SafeMath: subtraction overflow'
                idx = 0
                while idx <= arg1 - decayTable.length:
                    require decayTable.length - 1 < decayTable.length
                    if not decayTable[decayTable.length]:
                        decayTable.length++
                        mem[0] = 17
                        decayTable[decayTable.length] = 0
                    else:
                        if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        decayTable.length++
                        mem[0] = 17
                        decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                    idx = idx + 1
                    continue 
            if 0 < decayTable.length:
                return decayTable
        else:
            if startBlock > block.number:
                revert with 0, 'SafeMath: subtraction overflow'
            if 1 > block.number - startBlock:
                revert with 0, 'SafeMath: subtraction overflow'
            if decayPeriod <= 0:
                revert with 0, 'SafeMath: division by zero'
            if decayPeriod:
                if arg1 + (block.number + -startBlock - 1 / decayPeriod) < block.number + -startBlock - 1 / decayPeriod:
                    revert with 0, 'SafeMath: addition overflow'
                if arg1 + (block.number + -startBlock - 1 / decayPeriod) >= decayTable.length:
                    if arg1 + (block.number + -startBlock - 1 / decayPeriod) < block.number + -startBlock - 1 / decayPeriod:
                        revert with 0, 'SafeMath: addition overflow'
                    if decayTable.length > arg1 + (block.number + -startBlock - 1 / decayPeriod):
                        revert with 0, 'SafeMath: subtraction overflow'
                    idx = 0
                    while idx <= arg1 + (block.number + -startBlock - 1 / decayPeriod) - decayTable.length:
                        require decayTable.length - 1 < decayTable.length
                        if not decayTable[decayTable.length]:
                            decayTable.length++
                            mem[0] = 17
                            decayTable[decayTable.length] = 0
                        else:
                            if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            decayTable.length++
                            mem[0] = 17
                            decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                        idx = idx + 1
                        continue 
                if block.number + -startBlock - 1 / decayPeriod < decayTable.length:
                    return decayTable[block.number + -stor12 - 1 / stor15]
    revert
}

function getBXHBlockRewardV(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if 0 == decayPeriod:
        if 0 == decayPeriod:
            if 0 >= decayTable.length:
                revert with 0, 'phase not ready'
            if arg1 > block.number:
                revert with 0, 'SafeMath: subtraction overflow'
            if not block.number - arg1:
                return 0
            if (block.number * decayTable) - (arg1 * decayTable) / block.number - arg1 != decayTable:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if (block.number * decayTable) - (arg1 * decayTable) < 0:
                revert with 0, 'SafeMath: addition overflow'
            return ((block.number * decayTable) - (arg1 * decayTable))
        if block.number <= startBlock:
            if 0 >= decayTable.length:
                revert with 0, 'phase not ready'
            if arg1 > block.number:
                revert with 0, 'SafeMath: subtraction overflow'
            if not block.number - arg1:
                return 0
            if (block.number * decayTable) - (arg1 * decayTable) / block.number - arg1 != decayTable:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if (block.number * decayTable) - (arg1 * decayTable) < 0:
                revert with 0, 'SafeMath: addition overflow'
            return ((block.number * decayTable) - (arg1 * decayTable))
        if startBlock > block.number:
            revert with 0, 'SafeMath: subtraction overflow'
        if 1 > block.number - startBlock:
            revert with 0, 'SafeMath: subtraction overflow'
        if decayPeriod <= 0:
            revert with 0, 'SafeMath: division by zero'
        require decayPeriod
        if block.number + -startBlock - 1 / decayPeriod >= decayTable.length:
            revert with 0, 'phase not ready'
        if arg1 > block.number:
            revert with 0, 'SafeMath: subtraction overflow'
        if not block.number - arg1:
            return 0
        if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (arg1 * decayTable[block.number + -stor12 - 1 / stor15]) / block.number - arg1 != decayTable[block.number + -stor12 - 1 / stor15]:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        33,
                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[197 len 31]
        if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (arg1 * decayTable[block.number + -stor12 - 1 / stor15]) < 0:
            revert with 0, 'SafeMath: addition overflow'
        return ((block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (arg1 * decayTable[block.number + -stor12 - 1 / stor15]))
    if arg1 <= startBlock:
        if 0 == decayPeriod:
            if 0 == decayPeriod:
                if 0 >= decayTable.length:
                    revert with 0, 'phase not ready'
                if arg1 > block.number:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not block.number - arg1:
                    return 0
                if (block.number * decayTable) - (arg1 * decayTable) / block.number - arg1 != decayTable:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if (block.number * decayTable) - (arg1 * decayTable) < 0:
                    revert with 0, 'SafeMath: addition overflow'
                return ((block.number * decayTable) - (arg1 * decayTable))
            if block.number <= startBlock:
                if 0 >= decayTable.length:
                    revert with 0, 'phase not ready'
                if arg1 > block.number:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not block.number - arg1:
                    return 0
                if (block.number * decayTable) - (arg1 * decayTable) / block.number - arg1 != decayTable:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if (block.number * decayTable) - (arg1 * decayTable) < 0:
                    revert with 0, 'SafeMath: addition overflow'
                return ((block.number * decayTable) - (arg1 * decayTable))
            if startBlock > block.number:
                revert with 0, 'SafeMath: subtraction overflow'
            if 1 > block.number - startBlock:
                revert with 0, 'SafeMath: subtraction overflow'
            if decayPeriod <= 0:
                revert with 0, 'SafeMath: division by zero'
            require decayPeriod
            if block.number + -startBlock - 1 / decayPeriod >= decayTable.length:
                revert with 0, 'phase not ready'
            if arg1 > block.number:
                revert with 0, 'SafeMath: subtraction overflow'
            if not block.number - arg1:
                return 0
            if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (arg1 * decayTable[block.number + -stor12 - 1 / stor15]) / block.number - arg1 != decayTable[block.number + -stor12 - 1 / stor15]:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (arg1 * decayTable[block.number + -stor12 - 1 / stor15]) < 0:
                revert with 0, 'SafeMath: addition overflow'
            return ((block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (arg1 * decayTable[block.number + -stor12 - 1 / stor15]))
        if block.number <= startBlock:
            if 0 == decayPeriod:
                if 0 >= decayTable.length:
                    revert with 0, 'phase not ready'
                if arg1 > block.number:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not block.number - arg1:
                    return 0
                if (block.number * decayTable) - (arg1 * decayTable) / block.number - arg1 != decayTable:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if (block.number * decayTable) - (arg1 * decayTable) < 0:
                    revert with 0, 'SafeMath: addition overflow'
                return ((block.number * decayTable) - (arg1 * decayTable))
            if block.number <= startBlock:
                if 0 >= decayTable.length:
                    revert with 0, 'phase not ready'
                if arg1 > block.number:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not block.number - arg1:
                    return 0
                if (block.number * decayTable) - (arg1 * decayTable) / block.number - arg1 != decayTable:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if (block.number * decayTable) - (arg1 * decayTable) < 0:
                    revert with 0, 'SafeMath: addition overflow'
                return ((block.number * decayTable) - (arg1 * decayTable))
            if startBlock > block.number:
                revert with 0, 'SafeMath: subtraction overflow'
            if 1 > block.number - startBlock:
                revert with 0, 'SafeMath: subtraction overflow'
            if decayPeriod <= 0:
                revert with 0, 'SafeMath: division by zero'
            require decayPeriod
            if block.number + -startBlock - 1 / decayPeriod >= decayTable.length:
                revert with 0, 'phase not ready'
            if arg1 > block.number:
                revert with 0, 'SafeMath: subtraction overflow'
            if not block.number - arg1:
                return 0
            if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (arg1 * decayTable[block.number + -stor12 - 1 / stor15]) / block.number - arg1 != decayTable[block.number + -stor12 - 1 / stor15]:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (arg1 * decayTable[block.number + -stor12 - 1 / stor15]) < 0:
                revert with 0, 'SafeMath: addition overflow'
            return ((block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (arg1 * decayTable[block.number + -stor12 - 1 / stor15]))
        if startBlock > block.number:
            revert with 0, 'SafeMath: subtraction overflow'
        if 1 > block.number - startBlock:
            revert with 0, 'SafeMath: subtraction overflow'
        if decayPeriod <= 0:
            revert with 0, 'SafeMath: division by zero'
        require decayPeriod
        idx = 0
        s = arg1
        while idx < block.number + -startBlock - 1 / decayPeriod:
            if not idx + 1:
                if startBlock < 0:
                    revert with 0, 'SafeMath: addition overflow'
                if decayPeriod != 0:
                    if startBlock > startBlock:
                        revert with 0, 'SafeMath: subtraction overflow'
                if 0 >= decayTable.length:
                    revert with 0, 'phase not ready'
                mem[0] = 17
                if s > startBlock:
                    revert with 0, 'SafeMath: subtraction overflow'
                if startBlock - s:
                    if (startBlock * decayTable) - (s * decayTable) / startBlock - s != decayTable:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if (startBlock * decayTable) - (s * decayTable) < 0:
                        revert with 0, 'SafeMath: addition overflow'
                idx = idx + 1
                s = startBlock
                continue 
            if decayPeriod + (idx * decayPeriod) / idx + 1 != decayPeriod:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if startBlock < 0:
                revert with 0, 'SafeMath: addition overflow'
            if 0 == decayPeriod:
                if 0 >= decayTable.length:
                    revert with 0, 'phase not ready'
                mem[0] = 17
                if s > startBlock + decayPeriod + (idx * decayPeriod):
                    revert with 0, 'SafeMath: subtraction overflow'
                if startBlock + decayPeriod + (idx * decayPeriod) - s:
                    if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) / startBlock + decayPeriod + (idx * decayPeriod) - s != decayTable:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) < 0:
                        revert with 0, 'SafeMath: addition overflow'
            else:
                if startBlock + decayPeriod + (idx * decayPeriod) <= startBlock:
                    if 0 >= decayTable.length:
                        revert with 0, 'phase not ready'
                    mem[0] = 17
                    if s > startBlock + decayPeriod + (idx * decayPeriod):
                        revert with 0, 'SafeMath: subtraction overflow'
                    if startBlock + decayPeriod + (idx * decayPeriod) - s:
                        if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) / startBlock + decayPeriod + (idx * decayPeriod) - s != decayTable:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) < 0:
                            revert with 0, 'SafeMath: addition overflow'
                else:
                    if startBlock > startBlock + decayPeriod + (idx * decayPeriod):
                        revert with 0, 'SafeMath: subtraction overflow'
                    if 1 > decayPeriod + (idx * decayPeriod):
                        revert with 0, 'SafeMath: subtraction overflow'
                    if decayPeriod <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require decayPeriod
                    if decayPeriod + (idx * decayPeriod) - 1 / decayPeriod >= decayTable.length:
                        revert with 0, 'phase not ready'
                    mem[0] = 17
                    if s > startBlock + decayPeriod + (idx * decayPeriod):
                        revert with 0, 'SafeMath: subtraction overflow'
                    if startBlock + decayPeriod + (idx * decayPeriod) - s:
                        if (startBlock * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (idx * decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) - (s * decayTable[stor15 + (idx * stor15) - 1 / stor15]) / startBlock + decayPeriod + (idx * decayPeriod) - s != decayTable[stor15 + (idx * stor15) - 1 / stor15]:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if (startBlock * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (idx * decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) - (s * decayTable[stor15 + (idx * stor15) - 1 / stor15]) < 0:
                            revert with 0, 'SafeMath: addition overflow'
            idx = idx + 1
            s = startBlock + decayPeriod + (idx * decayPeriod)
            continue 
    else:
        if startBlock > arg1:
            revert with 0, 'SafeMath: subtraction overflow'
        if 1 > arg1 - startBlock:
            revert with 0, 'SafeMath: subtraction overflow'
        if decayPeriod <= 0:
            revert with 0, 'SafeMath: division by zero'
        require decayPeriod
        if 0 == decayPeriod:
            idx = arg1 + -startBlock - 1 / decayPeriod
            s = arg1
            while idx < 0:
                if not idx + 1:
                    if startBlock < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    if decayPeriod != 0:
                        if startBlock > startBlock:
                            revert with 0, 'SafeMath: subtraction overflow'
                    if 0 >= decayTable.length:
                        revert with 0, 'phase not ready'
                    mem[0] = 17
                    if s > startBlock:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if startBlock - s:
                        if (startBlock * decayTable) - (s * decayTable) / startBlock - s != decayTable:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if (startBlock * decayTable) - (s * decayTable) < 0:
                            revert with 0, 'SafeMath: addition overflow'
                    idx = idx + 1
                    s = startBlock
                    continue 
                if decayPeriod + (idx * decayPeriod) / idx + 1 != decayPeriod:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if startBlock < 0:
                    revert with 0, 'SafeMath: addition overflow'
                if 0 == decayPeriod:
                    if 0 >= decayTable.length:
                        revert with 0, 'phase not ready'
                    mem[0] = 17
                    if s > startBlock + decayPeriod + (idx * decayPeriod):
                        revert with 0, 'SafeMath: subtraction overflow'
                    if startBlock + decayPeriod + (idx * decayPeriod) - s:
                        if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) / startBlock + decayPeriod + (idx * decayPeriod) - s != decayTable:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) < 0:
                            revert with 0, 'SafeMath: addition overflow'
                else:
                    if startBlock + decayPeriod + (idx * decayPeriod) <= startBlock:
                        if 0 >= decayTable.length:
                            revert with 0, 'phase not ready'
                        mem[0] = 17
                        if s > startBlock + decayPeriod + (idx * decayPeriod):
                            revert with 0, 'SafeMath: subtraction overflow'
                        if startBlock + decayPeriod + (idx * decayPeriod) - s:
                            if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) / startBlock + decayPeriod + (idx * decayPeriod) - s != decayTable:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) < 0:
                                revert with 0, 'SafeMath: addition overflow'
                    else:
                        if startBlock > startBlock + decayPeriod + (idx * decayPeriod):
                            revert with 0, 'SafeMath: subtraction overflow'
                        if 1 > decayPeriod + (idx * decayPeriod):
                            revert with 0, 'SafeMath: subtraction overflow'
                        if decayPeriod <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require decayPeriod
                        if decayPeriod + (idx * decayPeriod) - 1 / decayPeriod >= decayTable.length:
                            revert with 0, 'phase not ready'
                        mem[0] = 17
                        if s > startBlock + decayPeriod + (idx * decayPeriod):
                            revert with 0, 'SafeMath: subtraction overflow'
                        if startBlock + decayPeriod + (idx * decayPeriod) - s:
                            if (startBlock * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (idx * decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) - (s * decayTable[stor15 + (idx * stor15) - 1 / stor15]) / startBlock + decayPeriod + (idx * decayPeriod) - s != decayTable[stor15 + (idx * stor15) - 1 / stor15]:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if (startBlock * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (idx * decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) - (s * decayTable[stor15 + (idx * stor15) - 1 / stor15]) < 0:
                                revert with 0, 'SafeMath: addition overflow'
                idx = idx + 1
                s = startBlock + decayPeriod + (idx * decayPeriod)
                continue 
        else:
            if block.number <= startBlock:
                idx = arg1 + -startBlock - 1 / decayPeriod
                s = arg1
                while idx < 0:
                    if not idx + 1:
                        if startBlock < 0:
                            revert with 0, 'SafeMath: addition overflow'
                        if decayPeriod != 0:
                            if startBlock > startBlock:
                                revert with 0, 'SafeMath: subtraction overflow'
                        if 0 >= decayTable.length:
                            revert with 0, 'phase not ready'
                        mem[0] = 17
                        if s > startBlock:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if startBlock - s:
                            if (startBlock * decayTable) - (s * decayTable) / startBlock - s != decayTable:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if (startBlock * decayTable) - (s * decayTable) < 0:
                                revert with 0, 'SafeMath: addition overflow'
                        idx = idx + 1
                        s = startBlock
                        continue 
                    if decayPeriod + (idx * decayPeriod) / idx + 1 != decayPeriod:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if startBlock < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    if 0 == decayPeriod:
                        if 0 >= decayTable.length:
                            revert with 0, 'phase not ready'
                        mem[0] = 17
                        if s > startBlock + decayPeriod + (idx * decayPeriod):
                            revert with 0, 'SafeMath: subtraction overflow'
                        if startBlock + decayPeriod + (idx * decayPeriod) - s:
                            if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) / startBlock + decayPeriod + (idx * decayPeriod) - s != decayTable:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) < 0:
                                revert with 0, 'SafeMath: addition overflow'
                    else:
                        if startBlock + decayPeriod + (idx * decayPeriod) <= startBlock:
                            if 0 >= decayTable.length:
                                revert with 0, 'phase not ready'
                            mem[0] = 17
                            if s > startBlock + decayPeriod + (idx * decayPeriod):
                                revert with 0, 'SafeMath: subtraction overflow'
                            if startBlock + decayPeriod + (idx * decayPeriod) - s:
                                if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) / startBlock + decayPeriod + (idx * decayPeriod) - s != decayTable:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                        else:
                            if startBlock > startBlock + decayPeriod + (idx * decayPeriod):
                                revert with 0, 'SafeMath: subtraction overflow'
                            if 1 > decayPeriod + (idx * decayPeriod):
                                revert with 0, 'SafeMath: subtraction overflow'
                            if decayPeriod <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require decayPeriod
                            if decayPeriod + (idx * decayPeriod) - 1 / decayPeriod >= decayTable.length:
                                revert with 0, 'phase not ready'
                            mem[0] = 17
                            if s > startBlock + decayPeriod + (idx * decayPeriod):
                                revert with 0, 'SafeMath: subtraction overflow'
                            if startBlock + decayPeriod + (idx * decayPeriod) - s:
                                if (startBlock * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (idx * decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) - (s * decayTable[stor15 + (idx * stor15) - 1 / stor15]) / startBlock + decayPeriod + (idx * decayPeriod) - s != decayTable[stor15 + (idx * stor15) - 1 / stor15]:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                if (startBlock * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (idx * decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) - (s * decayTable[stor15 + (idx * stor15) - 1 / stor15]) < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                    idx = idx + 1
                    s = startBlock + decayPeriod + (idx * decayPeriod)
                    continue 
            else:
                if startBlock > block.number:
                    revert with 0, 'SafeMath: subtraction overflow'
                if 1 > block.number - startBlock:
                    revert with 0, 'SafeMath: subtraction overflow'
                if decayPeriod <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require decayPeriod
                idx = arg1 + -startBlock - 1 / decayPeriod
                s = arg1
                while idx < block.number + -startBlock - 1 / decayPeriod:
                    if not idx + 1:
                        if startBlock < 0:
                            revert with 0, 'SafeMath: addition overflow'
                        if decayPeriod != 0:
                            if startBlock > startBlock:
                                revert with 0, 'SafeMath: subtraction overflow'
                        if 0 >= decayTable.length:
                            revert with 0, 'phase not ready'
                        mem[0] = 17
                        if s > startBlock:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if startBlock - s:
                            if (startBlock * decayTable) - (s * decayTable) / startBlock - s != decayTable:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if (startBlock * decayTable) - (s * decayTable) < 0:
                                revert with 0, 'SafeMath: addition overflow'
                        idx = idx + 1
                        s = startBlock
                        continue 
                    if decayPeriod + (idx * decayPeriod) / idx + 1 != decayPeriod:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if startBlock < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    if 0 == decayPeriod:
                        if 0 >= decayTable.length:
                            revert with 0, 'phase not ready'
                        mem[0] = 17
                        if s > startBlock + decayPeriod + (idx * decayPeriod):
                            revert with 0, 'SafeMath: subtraction overflow'
                        if startBlock + decayPeriod + (idx * decayPeriod) - s:
                            if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) / startBlock + decayPeriod + (idx * decayPeriod) - s != decayTable:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) < 0:
                                revert with 0, 'SafeMath: addition overflow'
                    else:
                        if startBlock + decayPeriod + (idx * decayPeriod) <= startBlock:
                            if 0 >= decayTable.length:
                                revert with 0, 'phase not ready'
                            mem[0] = 17
                            if s > startBlock + decayPeriod + (idx * decayPeriod):
                                revert with 0, 'SafeMath: subtraction overflow'
                            if startBlock + decayPeriod + (idx * decayPeriod) - s:
                                if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) / startBlock + decayPeriod + (idx * decayPeriod) - s != decayTable:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                        else:
                            if startBlock > startBlock + decayPeriod + (idx * decayPeriod):
                                revert with 0, 'SafeMath: subtraction overflow'
                            if 1 > decayPeriod + (idx * decayPeriod):
                                revert with 0, 'SafeMath: subtraction overflow'
                            if decayPeriod <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require decayPeriod
                            if decayPeriod + (idx * decayPeriod) - 1 / decayPeriod >= decayTable.length:
                                revert with 0, 'phase not ready'
                            mem[0] = 17
                            if s > startBlock + decayPeriod + (idx * decayPeriod):
                                revert with 0, 'SafeMath: subtraction overflow'
                            if startBlock + decayPeriod + (idx * decayPeriod) - s:
                                if (startBlock * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (idx * decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) - (s * decayTable[stor15 + (idx * stor15) - 1 / stor15]) / startBlock + decayPeriod + (idx * decayPeriod) - s != decayTable[stor15 + (idx * stor15) - 1 / stor15]:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                if (startBlock * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (idx * decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) - (s * decayTable[stor15 + (idx * stor15) - 1 / stor15]) < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                    idx = idx + 1
                    s = startBlock + decayPeriod + (idx * decayPeriod)
                    continue 
    if 0 == decayPeriod:
        if 0 >= decayTable.length:
            revert with 0, 'phase not ready'
        if s > block.number:
            revert with 0, 'SafeMath: subtraction overflow'
        if not block.number - s:
            return 0
        if (block.number * decayTable) - (s * decayTable) / block.number - s != decayTable:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        33,
                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[197 len 31]
        if (block.number * decayTable) - (s * decayTable) < 0:
            revert with 0, 'SafeMath: addition overflow'
        return ((block.number * decayTable) - (s * decayTable))
    if block.number <= startBlock:
        if 0 >= decayTable.length:
            revert with 0, 'phase not ready'
        if s > block.number:
            revert with 0, 'SafeMath: subtraction overflow'
        if not block.number - s:
            return 0
        if (block.number * decayTable) - (s * decayTable) / block.number - s != decayTable:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        33,
                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[197 len 31]
        if (block.number * decayTable) - (s * decayTable) < 0:
            revert with 0, 'SafeMath: addition overflow'
        return ((block.number * decayTable) - (s * decayTable))
    if startBlock > block.number:
        revert with 0, 'SafeMath: subtraction overflow'
    if 1 > block.number - startBlock:
        revert with 0, 'SafeMath: subtraction overflow'
    if decayPeriod <= 0:
        revert with 0, 'SafeMath: division by zero'
    require decayPeriod
    if block.number + -startBlock - 1 / decayPeriod >= decayTable.length:
        revert with 0, 'phase not ready'
    if s > block.number:
        revert with 0, 'SafeMath: subtraction overflow'
    if not block.number - s:
        return 0
    if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (s * decayTable[block.number + -stor12 - 1 / stor15]) / block.number - s != decayTable[block.number + -stor12 - 1 / stor15]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    33,
                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                    mem[197 len 31]
    if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (s * decayTable[block.number + -stor12 - 1 / stor15]) < 0:
        revert with 0, 'SafeMath: addition overflow'
    return ((block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (s * decayTable[block.number + -stor12 - 1 / stor15]))
}

function safeGetBXHBlockReward(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if 0 == decayPeriod:
        if 0 == decayPeriod:
            if 0 >= decayTable.length:
                require decayTable.length - 1 < decayTable.length
                if not decayTable[decayTable.length]:
                    decayTable.length++
                    decayTable[decayTable.length] = 0
                else:
                    if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    decayTable.length++
                    decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                require 0 < decayTable.length
            if arg1 > block.number:
                revert with 0, 'SafeMath: subtraction overflow'
            if not block.number - arg1:
                return 0
            if (block.number * decayTable) - (arg1 * decayTable) / block.number - arg1 != decayTable:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if (block.number * decayTable) - (arg1 * decayTable) < 0:
                revert with 0, 'SafeMath: addition overflow'
            return ((block.number * decayTable) - (arg1 * decayTable))
        if block.number <= startBlock:
            if 0 >= decayTable.length:
                require decayTable.length - 1 < decayTable.length
                if not decayTable[decayTable.length]:
                    decayTable.length++
                    decayTable[decayTable.length] = 0
                else:
                    if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    decayTable.length++
                    decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                require 0 < decayTable.length
            if arg1 > block.number:
                revert with 0, 'SafeMath: subtraction overflow'
            if not block.number - arg1:
                return 0
            if (block.number * decayTable) - (arg1 * decayTable) / block.number - arg1 != decayTable:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if (block.number * decayTable) - (arg1 * decayTable) < 0:
                revert with 0, 'SafeMath: addition overflow'
            return ((block.number * decayTable) - (arg1 * decayTable))
        if startBlock > block.number:
            revert with 0, 'SafeMath: subtraction overflow'
        if 1 > block.number - startBlock:
            revert with 0, 'SafeMath: subtraction overflow'
        if decayPeriod <= 0:
            revert with 0, 'SafeMath: division by zero'
        require decayPeriod
        if block.number + -startBlock - 1 / decayPeriod >= decayTable.length:
            require decayTable.length - 1 < decayTable.length
            if not decayTable[decayTable.length]:
                decayTable.length++
                decayTable[decayTable.length] = 0
            else:
                if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                decayTable.length++
                decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
            require block.number + -startBlock - 1 / decayPeriod < decayTable.length
        if arg1 > block.number:
            revert with 0, 'SafeMath: subtraction overflow'
        if not block.number - arg1:
            return 0
        if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (arg1 * decayTable[block.number + -stor12 - 1 / stor15]) / block.number - arg1 != decayTable[block.number + -stor12 - 1 / stor15]:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        33,
                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[197 len 31]
        if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (arg1 * decayTable[block.number + -stor12 - 1 / stor15]) < 0:
            revert with 0, 'SafeMath: addition overflow'
        return ((block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (arg1 * decayTable[block.number + -stor12 - 1 / stor15]))
    if arg1 <= startBlock:
        if 0 == decayPeriod:
            if 0 == decayPeriod:
                if 0 >= decayTable.length:
                    require decayTable.length - 1 < decayTable.length
                    if not decayTable[decayTable.length]:
                        decayTable.length++
                        decayTable[decayTable.length] = 0
                    else:
                        if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        decayTable.length++
                        decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                    require 0 < decayTable.length
                if arg1 > block.number:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not block.number - arg1:
                    return 0
                if (block.number * decayTable) - (arg1 * decayTable) / block.number - arg1 != decayTable:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if (block.number * decayTable) - (arg1 * decayTable) < 0:
                    revert with 0, 'SafeMath: addition overflow'
                return ((block.number * decayTable) - (arg1 * decayTable))
            if block.number <= startBlock:
                if 0 >= decayTable.length:
                    require decayTable.length - 1 < decayTable.length
                    if not decayTable[decayTable.length]:
                        decayTable.length++
                        decayTable[decayTable.length] = 0
                    else:
                        if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        decayTable.length++
                        decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                    require 0 < decayTable.length
                if arg1 > block.number:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not block.number - arg1:
                    return 0
                if (block.number * decayTable) - (arg1 * decayTable) / block.number - arg1 != decayTable:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if (block.number * decayTable) - (arg1 * decayTable) < 0:
                    revert with 0, 'SafeMath: addition overflow'
                return ((block.number * decayTable) - (arg1 * decayTable))
            if startBlock > block.number:
                revert with 0, 'SafeMath: subtraction overflow'
            if 1 > block.number - startBlock:
                revert with 0, 'SafeMath: subtraction overflow'
            if decayPeriod <= 0:
                revert with 0, 'SafeMath: division by zero'
            require decayPeriod
            if block.number + -startBlock - 1 / decayPeriod >= decayTable.length:
                require decayTable.length - 1 < decayTable.length
                if not decayTable[decayTable.length]:
                    decayTable.length++
                    decayTable[decayTable.length] = 0
                else:
                    if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    decayTable.length++
                    decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                require block.number + -startBlock - 1 / decayPeriod < decayTable.length
            if arg1 > block.number:
                revert with 0, 'SafeMath: subtraction overflow'
            if not block.number - arg1:
                return 0
            if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (arg1 * decayTable[block.number + -stor12 - 1 / stor15]) / block.number - arg1 != decayTable[block.number + -stor12 - 1 / stor15]:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (arg1 * decayTable[block.number + -stor12 - 1 / stor15]) < 0:
                revert with 0, 'SafeMath: addition overflow'
            return ((block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (arg1 * decayTable[block.number + -stor12 - 1 / stor15]))
        if block.number <= startBlock:
            if 0 == decayPeriod:
                if 0 >= decayTable.length:
                    require decayTable.length - 1 < decayTable.length
                    if not decayTable[decayTable.length]:
                        decayTable.length++
                        decayTable[decayTable.length] = 0
                    else:
                        if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        decayTable.length++
                        decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                    require 0 < decayTable.length
                if arg1 > block.number:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not block.number - arg1:
                    return 0
                if (block.number * decayTable) - (arg1 * decayTable) / block.number - arg1 != decayTable:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if (block.number * decayTable) - (arg1 * decayTable) < 0:
                    revert with 0, 'SafeMath: addition overflow'
                return ((block.number * decayTable) - (arg1 * decayTable))
            if block.number <= startBlock:
                if 0 >= decayTable.length:
                    require decayTable.length - 1 < decayTable.length
                    if not decayTable[decayTable.length]:
                        decayTable.length++
                        decayTable[decayTable.length] = 0
                    else:
                        if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        decayTable.length++
                        decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                    require 0 < decayTable.length
                if arg1 > block.number:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not block.number - arg1:
                    return 0
                if (block.number * decayTable) - (arg1 * decayTable) / block.number - arg1 != decayTable:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if (block.number * decayTable) - (arg1 * decayTable) < 0:
                    revert with 0, 'SafeMath: addition overflow'
                return ((block.number * decayTable) - (arg1 * decayTable))
            if startBlock > block.number:
                revert with 0, 'SafeMath: subtraction overflow'
            if 1 > block.number - startBlock:
                revert with 0, 'SafeMath: subtraction overflow'
            if decayPeriod <= 0:
                revert with 0, 'SafeMath: division by zero'
            require decayPeriod
            if block.number + -startBlock - 1 / decayPeriod >= decayTable.length:
                require decayTable.length - 1 < decayTable.length
                if not decayTable[decayTable.length]:
                    decayTable.length++
                    decayTable[decayTable.length] = 0
                else:
                    if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    decayTable.length++
                    decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                require block.number + -startBlock - 1 / decayPeriod < decayTable.length
            if arg1 > block.number:
                revert with 0, 'SafeMath: subtraction overflow'
            if not block.number - arg1:
                return 0
            if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (arg1 * decayTable[block.number + -stor12 - 1 / stor15]) / block.number - arg1 != decayTable[block.number + -stor12 - 1 / stor15]:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (arg1 * decayTable[block.number + -stor12 - 1 / stor15]) < 0:
                revert with 0, 'SafeMath: addition overflow'
            return ((block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (arg1 * decayTable[block.number + -stor12 - 1 / stor15]))
        if startBlock > block.number:
            revert with 0, 'SafeMath: subtraction overflow'
        if 1 > block.number - startBlock:
            revert with 0, 'SafeMath: subtraction overflow'
        if decayPeriod <= 0:
            revert with 0, 'SafeMath: division by zero'
        require decayPeriod
        idx = 0
        s = arg1
        while idx < block.number + -startBlock - 1 / decayPeriod:
            if not idx + 1:
                if startBlock < 0:
                    revert with 0, 'SafeMath: addition overflow'
                if decayPeriod != 0:
                    if startBlock > startBlock:
                        revert with 0, 'SafeMath: subtraction overflow'
                if 0 >= decayTable.length:
                    require decayTable.length - 1 < decayTable.length
                    if not decayTable[decayTable.length]:
                        decayTable.length++
                        decayTable[decayTable.length] = 0
                    else:
                        if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        decayTable.length++
                        decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                    require 0 < decayTable.length
                mem[0] = 17
                if s > startBlock:
                    revert with 0, 'SafeMath: subtraction overflow'
                if startBlock - s:
                    if (startBlock * decayTable) - (s * decayTable) / startBlock - s != decayTable:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if (startBlock * decayTable) - (s * decayTable) < 0:
                        revert with 0, 'SafeMath: addition overflow'
                idx = idx + 1
                s = startBlock
                continue 
            if decayPeriod + (idx * decayPeriod) / idx + 1 != decayPeriod:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if startBlock < 0:
                revert with 0, 'SafeMath: addition overflow'
            if 0 == decayPeriod:
                if 0 >= decayTable.length:
                    require decayTable.length - 1 < decayTable.length
                    if not decayTable[decayTable.length]:
                        decayTable.length++
                        decayTable[decayTable.length] = 0
                    else:
                        if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        decayTable.length++
                        decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                    require 0 < decayTable.length
                mem[0] = 17
                if s > startBlock + decayPeriod + (idx * decayPeriod):
                    revert with 0, 'SafeMath: subtraction overflow'
                if startBlock + decayPeriod + (idx * decayPeriod) - s:
                    if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) / startBlock + decayPeriod + (idx * decayPeriod) - s != decayTable:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) < 0:
                        revert with 0, 'SafeMath: addition overflow'
            else:
                if startBlock + decayPeriod + (idx * decayPeriod) <= startBlock:
                    if 0 >= decayTable.length:
                        require decayTable.length - 1 < decayTable.length
                        if not decayTable[decayTable.length]:
                            decayTable.length++
                            decayTable[decayTable.length] = 0
                        else:
                            if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            decayTable.length++
                            decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                        require 0 < decayTable.length
                    mem[0] = 17
                    if s > startBlock + decayPeriod + (idx * decayPeriod):
                        revert with 0, 'SafeMath: subtraction overflow'
                    if startBlock + decayPeriod + (idx * decayPeriod) - s:
                        if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) / startBlock + decayPeriod + (idx * decayPeriod) - s != decayTable:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) < 0:
                            revert with 0, 'SafeMath: addition overflow'
                else:
                    if startBlock > startBlock + decayPeriod + (idx * decayPeriod):
                        revert with 0, 'SafeMath: subtraction overflow'
                    if 1 > decayPeriod + (idx * decayPeriod):
                        revert with 0, 'SafeMath: subtraction overflow'
                    if decayPeriod <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require decayPeriod
                    if decayPeriod + (idx * decayPeriod) - 1 / decayPeriod >= decayTable.length:
                        require decayTable.length - 1 < decayTable.length
                        if not decayTable[decayTable.length]:
                            decayTable.length++
                            decayTable[decayTable.length] = 0
                        else:
                            if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            decayTable.length++
                            decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                        require decayPeriod + (idx * decayPeriod) - 1 / decayPeriod < decayTable.length
                    mem[0] = 17
                    if s > startBlock + decayPeriod + (idx * decayPeriod):
                        revert with 0, 'SafeMath: subtraction overflow'
                    if startBlock + decayPeriod + (idx * decayPeriod) - s:
                        if (startBlock * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (idx * decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) - (s * decayTable[stor15 + (idx * stor15) - 1 / stor15]) / startBlock + decayPeriod + (idx * decayPeriod) - s != decayTable[stor15 + (idx * stor15) - 1 / stor15]:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if (startBlock * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (idx * decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) - (s * decayTable[stor15 + (idx * stor15) - 1 / stor15]) < 0:
                            revert with 0, 'SafeMath: addition overflow'
            idx = idx + 1
            s = startBlock + decayPeriod + (idx * decayPeriod)
            continue 
    else:
        if startBlock > arg1:
            revert with 0, 'SafeMath: subtraction overflow'
        if 1 > arg1 - startBlock:
            revert with 0, 'SafeMath: subtraction overflow'
        if decayPeriod <= 0:
            revert with 0, 'SafeMath: division by zero'
        require decayPeriod
        if 0 == decayPeriod:
            idx = arg1 + -startBlock - 1 / decayPeriod
            s = arg1
            while idx < 0:
                if not idx + 1:
                    if startBlock < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    if decayPeriod != 0:
                        if startBlock > startBlock:
                            revert with 0, 'SafeMath: subtraction overflow'
                    if 0 >= decayTable.length:
                        require decayTable.length - 1 < decayTable.length
                        if not decayTable[decayTable.length]:
                            decayTable.length++
                            decayTable[decayTable.length] = 0
                        else:
                            if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            decayTable.length++
                            decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                        require 0 < decayTable.length
                    mem[0] = 17
                    if s > startBlock:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if startBlock - s:
                        if (startBlock * decayTable) - (s * decayTable) / startBlock - s != decayTable:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if (startBlock * decayTable) - (s * decayTable) < 0:
                            revert with 0, 'SafeMath: addition overflow'
                    idx = idx + 1
                    s = startBlock
                    continue 
                if decayPeriod + (idx * decayPeriod) / idx + 1 != decayPeriod:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if startBlock < 0:
                    revert with 0, 'SafeMath: addition overflow'
                if 0 == decayPeriod:
                    if 0 >= decayTable.length:
                        require decayTable.length - 1 < decayTable.length
                        if not decayTable[decayTable.length]:
                            decayTable.length++
                            decayTable[decayTable.length] = 0
                        else:
                            if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            decayTable.length++
                            decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                        require 0 < decayTable.length
                    mem[0] = 17
                    if s > startBlock + decayPeriod + (idx * decayPeriod):
                        revert with 0, 'SafeMath: subtraction overflow'
                    if startBlock + decayPeriod + (idx * decayPeriod) - s:
                        if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) / startBlock + decayPeriod + (idx * decayPeriod) - s != decayTable:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) < 0:
                            revert with 0, 'SafeMath: addition overflow'
                else:
                    if startBlock + decayPeriod + (idx * decayPeriod) <= startBlock:
                        if 0 >= decayTable.length:
                            require decayTable.length - 1 < decayTable.length
                            if not decayTable[decayTable.length]:
                                decayTable.length++
                                decayTable[decayTable.length] = 0
                            else:
                                if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                decayTable.length++
                                decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                            require 0 < decayTable.length
                        mem[0] = 17
                        if s > startBlock + decayPeriod + (idx * decayPeriod):
                            revert with 0, 'SafeMath: subtraction overflow'
                        if startBlock + decayPeriod + (idx * decayPeriod) - s:
                            if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) / startBlock + decayPeriod + (idx * decayPeriod) - s != decayTable:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) < 0:
                                revert with 0, 'SafeMath: addition overflow'
                    else:
                        if startBlock > startBlock + decayPeriod + (idx * decayPeriod):
                            revert with 0, 'SafeMath: subtraction overflow'
                        if 1 > decayPeriod + (idx * decayPeriod):
                            revert with 0, 'SafeMath: subtraction overflow'
                        if decayPeriod <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require decayPeriod
                        if decayPeriod + (idx * decayPeriod) - 1 / decayPeriod >= decayTable.length:
                            require decayTable.length - 1 < decayTable.length
                            if not decayTable[decayTable.length]:
                                decayTable.length++
                                decayTable[decayTable.length] = 0
                            else:
                                if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                decayTable.length++
                                decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                            require decayPeriod + (idx * decayPeriod) - 1 / decayPeriod < decayTable.length
                        mem[0] = 17
                        if s > startBlock + decayPeriod + (idx * decayPeriod):
                            revert with 0, 'SafeMath: subtraction overflow'
                        if startBlock + decayPeriod + (idx * decayPeriod) - s:
                            if (startBlock * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (idx * decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) - (s * decayTable[stor15 + (idx * stor15) - 1 / stor15]) / startBlock + decayPeriod + (idx * decayPeriod) - s != decayTable[stor15 + (idx * stor15) - 1 / stor15]:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if (startBlock * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (idx * decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) - (s * decayTable[stor15 + (idx * stor15) - 1 / stor15]) < 0:
                                revert with 0, 'SafeMath: addition overflow'
                idx = idx + 1
                s = startBlock + decayPeriod + (idx * decayPeriod)
                continue 
        else:
            if block.number <= startBlock:
                idx = arg1 + -startBlock - 1 / decayPeriod
                s = arg1
                while idx < 0:
                    if not idx + 1:
                        if startBlock < 0:
                            revert with 0, 'SafeMath: addition overflow'
                        if decayPeriod != 0:
                            if startBlock > startBlock:
                                revert with 0, 'SafeMath: subtraction overflow'
                        if 0 >= decayTable.length:
                            require decayTable.length - 1 < decayTable.length
                            if not decayTable[decayTable.length]:
                                decayTable.length++
                                decayTable[decayTable.length] = 0
                            else:
                                if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                decayTable.length++
                                decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                            require 0 < decayTable.length
                        mem[0] = 17
                        if s > startBlock:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if startBlock - s:
                            if (startBlock * decayTable) - (s * decayTable) / startBlock - s != decayTable:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if (startBlock * decayTable) - (s * decayTable) < 0:
                                revert with 0, 'SafeMath: addition overflow'
                        idx = idx + 1
                        s = startBlock
                        continue 
                    if decayPeriod + (idx * decayPeriod) / idx + 1 != decayPeriod:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if startBlock < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    if 0 == decayPeriod:
                        if 0 >= decayTable.length:
                            require decayTable.length - 1 < decayTable.length
                            if not decayTable[decayTable.length]:
                                decayTable.length++
                                decayTable[decayTable.length] = 0
                            else:
                                if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                decayTable.length++
                                decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                            require 0 < decayTable.length
                        mem[0] = 17
                        if s > startBlock + decayPeriod + (idx * decayPeriod):
                            revert with 0, 'SafeMath: subtraction overflow'
                        if startBlock + decayPeriod + (idx * decayPeriod) - s:
                            if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) / startBlock + decayPeriod + (idx * decayPeriod) - s != decayTable:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) < 0:
                                revert with 0, 'SafeMath: addition overflow'
                    else:
                        if startBlock + decayPeriod + (idx * decayPeriod) <= startBlock:
                            if 0 >= decayTable.length:
                                require decayTable.length - 1 < decayTable.length
                                if not decayTable[decayTable.length]:
                                    decayTable.length++
                                    decayTable[decayTable.length] = 0
                                else:
                                    if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                    32,
                                                    33,
                                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[197 len 31]
                                    decayTable.length++
                                    decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                require 0 < decayTable.length
                            mem[0] = 17
                            if s > startBlock + decayPeriod + (idx * decayPeriod):
                                revert with 0, 'SafeMath: subtraction overflow'
                            if startBlock + decayPeriod + (idx * decayPeriod) - s:
                                if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) / startBlock + decayPeriod + (idx * decayPeriod) - s != decayTable:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                        else:
                            if startBlock > startBlock + decayPeriod + (idx * decayPeriod):
                                revert with 0, 'SafeMath: subtraction overflow'
                            if 1 > decayPeriod + (idx * decayPeriod):
                                revert with 0, 'SafeMath: subtraction overflow'
                            if decayPeriod <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require decayPeriod
                            if decayPeriod + (idx * decayPeriod) - 1 / decayPeriod >= decayTable.length:
                                require decayTable.length - 1 < decayTable.length
                                if not decayTable[decayTable.length]:
                                    decayTable.length++
                                    decayTable[decayTable.length] = 0
                                else:
                                    if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                    32,
                                                    33,
                                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[197 len 31]
                                    decayTable.length++
                                    decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                require decayPeriod + (idx * decayPeriod) - 1 / decayPeriod < decayTable.length
                            mem[0] = 17
                            if s > startBlock + decayPeriod + (idx * decayPeriod):
                                revert with 0, 'SafeMath: subtraction overflow'
                            if startBlock + decayPeriod + (idx * decayPeriod) - s:
                                if (startBlock * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (idx * decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) - (s * decayTable[stor15 + (idx * stor15) - 1 / stor15]) / startBlock + decayPeriod + (idx * decayPeriod) - s != decayTable[stor15 + (idx * stor15) - 1 / stor15]:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                if (startBlock * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (idx * decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) - (s * decayTable[stor15 + (idx * stor15) - 1 / stor15]) < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                    idx = idx + 1
                    s = startBlock + decayPeriod + (idx * decayPeriod)
                    continue 
            else:
                if startBlock > block.number:
                    revert with 0, 'SafeMath: subtraction overflow'
                if 1 > block.number - startBlock:
                    revert with 0, 'SafeMath: subtraction overflow'
                if decayPeriod <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require decayPeriod
                idx = arg1 + -startBlock - 1 / decayPeriod
                s = arg1
                while idx < block.number + -startBlock - 1 / decayPeriod:
                    if not idx + 1:
                        if startBlock < 0:
                            revert with 0, 'SafeMath: addition overflow'
                        if decayPeriod != 0:
                            if startBlock > startBlock:
                                revert with 0, 'SafeMath: subtraction overflow'
                        if 0 >= decayTable.length:
                            require decayTable.length - 1 < decayTable.length
                            if not decayTable[decayTable.length]:
                                decayTable.length++
                                decayTable[decayTable.length] = 0
                            else:
                                if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                decayTable.length++
                                decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                            require 0 < decayTable.length
                        mem[0] = 17
                        if s > startBlock:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if startBlock - s:
                            if (startBlock * decayTable) - (s * decayTable) / startBlock - s != decayTable:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if (startBlock * decayTable) - (s * decayTable) < 0:
                                revert with 0, 'SafeMath: addition overflow'
                        idx = idx + 1
                        s = startBlock
                        continue 
                    if decayPeriod + (idx * decayPeriod) / idx + 1 != decayPeriod:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if startBlock < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    if 0 == decayPeriod:
                        if 0 >= decayTable.length:
                            require decayTable.length - 1 < decayTable.length
                            if not decayTable[decayTable.length]:
                                decayTable.length++
                                decayTable[decayTable.length] = 0
                            else:
                                if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                decayTable.length++
                                decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                            require 0 < decayTable.length
                        mem[0] = 17
                        if s > startBlock + decayPeriod + (idx * decayPeriod):
                            revert with 0, 'SafeMath: subtraction overflow'
                        if startBlock + decayPeriod + (idx * decayPeriod) - s:
                            if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) / startBlock + decayPeriod + (idx * decayPeriod) - s != decayTable:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) < 0:
                                revert with 0, 'SafeMath: addition overflow'
                    else:
                        if startBlock + decayPeriod + (idx * decayPeriod) <= startBlock:
                            if 0 >= decayTable.length:
                                require decayTable.length - 1 < decayTable.length
                                if not decayTable[decayTable.length]:
                                    decayTable.length++
                                    decayTable[decayTable.length] = 0
                                else:
                                    if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                    32,
                                                    33,
                                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[197 len 31]
                                    decayTable.length++
                                    decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                require 0 < decayTable.length
                            mem[0] = 17
                            if s > startBlock + decayPeriod + (idx * decayPeriod):
                                revert with 0, 'SafeMath: subtraction overflow'
                            if startBlock + decayPeriod + (idx * decayPeriod) - s:
                                if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) / startBlock + decayPeriod + (idx * decayPeriod) - s != decayTable:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                        else:
                            if startBlock > startBlock + decayPeriod + (idx * decayPeriod):
                                revert with 0, 'SafeMath: subtraction overflow'
                            if 1 > decayPeriod + (idx * decayPeriod):
                                revert with 0, 'SafeMath: subtraction overflow'
                            if decayPeriod <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require decayPeriod
                            if decayPeriod + (idx * decayPeriod) - 1 / decayPeriod >= decayTable.length:
                                require decayTable.length - 1 < decayTable.length
                                if not decayTable[decayTable.length]:
                                    decayTable.length++
                                    decayTable[decayTable.length] = 0
                                else:
                                    if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                    32,
                                                    33,
                                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[197 len 31]
                                    decayTable.length++
                                    decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                require decayPeriod + (idx * decayPeriod) - 1 / decayPeriod < decayTable.length
                            mem[0] = 17
                            if s > startBlock + decayPeriod + (idx * decayPeriod):
                                revert with 0, 'SafeMath: subtraction overflow'
                            if startBlock + decayPeriod + (idx * decayPeriod) - s:
                                if (startBlock * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (idx * decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) - (s * decayTable[stor15 + (idx * stor15) - 1 / stor15]) / startBlock + decayPeriod + (idx * decayPeriod) - s != decayTable[stor15 + (idx * stor15) - 1 / stor15]:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                if (startBlock * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (idx * decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) - (s * decayTable[stor15 + (idx * stor15) - 1 / stor15]) < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                    idx = idx + 1
                    s = startBlock + decayPeriod + (idx * decayPeriod)
                    continue 
    if 0 == decayPeriod:
        if 0 >= decayTable.length:
            require decayTable.length - 1 < decayTable.length
            if not decayTable[decayTable.length]:
                decayTable.length++
                decayTable[decayTable.length] = 0
            else:
                if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                decayTable.length++
                decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
            require 0 < decayTable.length
        if s > block.number:
            revert with 0, 'SafeMath: subtraction overflow'
        if not block.number - s:
            return 0
        if (block.number * decayTable) - (s * decayTable) / block.number - s != decayTable:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        33,
                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[197 len 31]
        if (block.number * decayTable) - (s * decayTable) < 0:
            revert with 0, 'SafeMath: addition overflow'
        return ((block.number * decayTable) - (s * decayTable))
    if block.number <= startBlock:
        if 0 >= decayTable.length:
            require decayTable.length - 1 < decayTable.length
            if not decayTable[decayTable.length]:
                decayTable.length++
                decayTable[decayTable.length] = 0
            else:
                if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                decayTable.length++
                decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
            require 0 < decayTable.length
        if s > block.number:
            revert with 0, 'SafeMath: subtraction overflow'
        if not block.number - s:
            return 0
        if (block.number * decayTable) - (s * decayTable) / block.number - s != decayTable:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        33,
                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[197 len 31]
        if (block.number * decayTable) - (s * decayTable) < 0:
            revert with 0, 'SafeMath: addition overflow'
        return ((block.number * decayTable) - (s * decayTable))
    if startBlock > block.number:
        revert with 0, 'SafeMath: subtraction overflow'
    if 1 > block.number - startBlock:
        revert with 0, 'SafeMath: subtraction overflow'
    if decayPeriod <= 0:
        revert with 0, 'SafeMath: division by zero'
    require decayPeriod
    if block.number + -startBlock - 1 / decayPeriod >= decayTable.length:
        require decayTable.length - 1 < decayTable.length
        if not decayTable[decayTable.length]:
            decayTable.length++
            decayTable[decayTable.length] = 0
        else:
            if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            decayTable.length++
            decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
        require block.number + -startBlock - 1 / decayPeriod < decayTable.length
    if s > block.number:
        revert with 0, 'SafeMath: subtraction overflow'
    if not block.number - s:
        return 0
    if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (s * decayTable[block.number + -stor12 - 1 / stor15]) / block.number - s != decayTable[block.number + -stor12 - 1 / stor15]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    33,
                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                    mem[197 len 31]
    if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (s * decayTable[block.number + -stor12 - 1 / stor15]) < 0:
        revert with 0, 'SafeMath: addition overflow'
    return ((block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (s * decayTable[block.number + -stor12 - 1 / stor15]))
}

function massUpdatePools() payable {
    idx = 0
    while idx < poolInfo.length:
        mem[0] = 6
        if block.number > poolInfo[idx].field_512:
            mem[0] = poolInfo[idx].field_0
            mem[32] = 3
            if stor3[stor6[idx].field_0]:
                if not poolInfo[idx].field_1280:
                    poolInfo[idx].field_512 = block.number
                else:
                    if 0 == decayPeriod:
                        if 0 == decayPeriod:
                            if 0 >= decayTable.length:
                                require decayTable.length - 1 < decayTable.length
                                if not decayTable[decayTable.length]:
                                    decayTable.length++
                                    decayTable[decayTable.length] = 0
                                else:
                                    if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                    decayTable.length++
                                    decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                require 0 < decayTable.length
                            mem[0] = 17
                            if poolInfo[idx].field_512 > block.number:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if block.number - poolInfo[idx].field_512:
                                if (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) / block.number - poolInfo[idx].field_512 != decayTable:
                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                if (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) > 0:
                                    if not (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable):
                                        if totalAllocPoint <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalAllocPoint
                                        mem[100] = this.address
                                        mem[132] = 0 / totalAllocPoint
                                        require ext_code.size(bxhAddress)
                                        call bxhAddress.mint(address arg1, uint256 arg2) with:
                                             gas gas_remaining wei
                                            args this.address, 0 / totalAllocPoint
                                        mem[96] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0]:
                                            if not 0 / totalAllocPoint:
                                                if poolInfo[idx].field_1280 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require poolInfo[idx].field_1280
                                                if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                            else:
                                                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if poolInfo[idx].field_1280 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require poolInfo[idx].field_1280
                                                if (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1280
                                    else:
                                        if (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) != poolInfo[idx].field_256:
                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                        if totalAllocPoint <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalAllocPoint
                                        mem[100] = this.address
                                        mem[132] = (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                        require ext_code.size(bxhAddress)
                                        call bxhAddress.mint(address arg1, uint256 arg2) with:
                                             gas gas_remaining wei
                                            args this.address, (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                        mem[96] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0]:
                                            if not (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint:
                                                if poolInfo[idx].field_1280 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require poolInfo[idx].field_1280
                                                if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                            else:
                                                if 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if poolInfo[idx].field_1280 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require poolInfo[idx].field_1280
                                                if (10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_1280
                                    poolInfo[idx].field_512 = block.number
                        else:
                            if block.number <= startBlock:
                                if 0 >= decayTable.length:
                                    require decayTable.length - 1 < decayTable.length
                                    if not decayTable[decayTable.length]:
                                        decayTable.length++
                                        decayTable[decayTable.length] = 0
                                    else:
                                        if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                        decayTable.length++
                                        decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                    require 0 < decayTable.length
                                mem[0] = 17
                                if poolInfo[idx].field_512 > block.number:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if block.number - poolInfo[idx].field_512:
                                    if (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) / block.number - poolInfo[idx].field_512 != decayTable:
                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                    if (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) > 0:
                                        if not (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable):
                                            if totalAllocPoint <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalAllocPoint
                                            mem[100] = this.address
                                            mem[132] = 0 / totalAllocPoint
                                            require ext_code.size(bxhAddress)
                                            call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                 gas gas_remaining wei
                                                args this.address, 0 / totalAllocPoint
                                            mem[96] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if ext_call.return_data[0]:
                                                if not 0 / totalAllocPoint:
                                                    if poolInfo[idx].field_1280 <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require poolInfo[idx].field_1280
                                                    if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                else:
                                                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if poolInfo[idx].field_1280 <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require poolInfo[idx].field_1280
                                                    if (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1280
                                        else:
                                            if (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) != poolInfo[idx].field_256:
                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            if totalAllocPoint <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalAllocPoint
                                            mem[100] = this.address
                                            mem[132] = (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                            require ext_code.size(bxhAddress)
                                            call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                 gas gas_remaining wei
                                                args this.address, (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                            mem[96] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if ext_call.return_data[0]:
                                                if not (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint:
                                                    if poolInfo[idx].field_1280 <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require poolInfo[idx].field_1280
                                                    if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                else:
                                                    if 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if poolInfo[idx].field_1280 <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require poolInfo[idx].field_1280
                                                    if (10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_1280
                                        poolInfo[idx].field_512 = block.number
                            else:
                                if startBlock > block.number:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if 1 > block.number - startBlock:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if decayPeriod <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require decayPeriod
                                if block.number + -startBlock - 1 / decayPeriod >= decayTable.length:
                                    require decayTable.length - 1 < decayTable.length
                                    if not decayTable[decayTable.length]:
                                        decayTable.length++
                                        decayTable[decayTable.length] = 0
                                    else:
                                        if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                        decayTable.length++
                                        decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                    require block.number + -startBlock - 1 / decayPeriod < decayTable.length
                                mem[0] = 17
                                if poolInfo[idx].field_512 > block.number:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if block.number - poolInfo[idx].field_512:
                                    if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) / block.number - poolInfo[idx].field_512 != decayTable[block.number + -stor12 - 1 / stor15]:
                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                    if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) > 0:
                                        if not (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15]):
                                            if totalAllocPoint <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalAllocPoint
                                            mem[100] = this.address
                                            mem[132] = 0 / totalAllocPoint
                                            require ext_code.size(bxhAddress)
                                            call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                 gas gas_remaining wei
                                                args this.address, 0 / totalAllocPoint
                                            mem[96] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if ext_call.return_data[0]:
                                                if not 0 / totalAllocPoint:
                                                    if poolInfo[idx].field_1280 <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require poolInfo[idx].field_1280
                                                    if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                else:
                                                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if poolInfo[idx].field_1280 <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require poolInfo[idx].field_1280
                                                    if (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1280
                                        else:
                                            if (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) != poolInfo[idx].field_256:
                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            if totalAllocPoint <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalAllocPoint
                                            mem[100] = this.address
                                            mem[132] = (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint
                                            require ext_code.size(bxhAddress)
                                            call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                 gas gas_remaining wei
                                                args this.address, (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint
                                            mem[96] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if ext_call.return_data[0]:
                                                if not (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint:
                                                    if poolInfo[idx].field_1280 <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require poolInfo[idx].field_1280
                                                    if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                else:
                                                    if 10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint / (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if poolInfo[idx].field_1280 <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require poolInfo[idx].field_1280
                                                    if (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_1280
                                        poolInfo[idx].field_512 = block.number
                    else:
                        if poolInfo[idx].field_512 <= startBlock:
                            if 0 == decayPeriod:
                                if 0 == decayPeriod:
                                    if 0 >= decayTable.length:
                                        require decayTable.length - 1 < decayTable.length
                                        if not decayTable[decayTable.length]:
                                            decayTable.length++
                                            decayTable[decayTable.length] = 0
                                        else:
                                            if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            decayTable.length++
                                            decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                        require 0 < decayTable.length
                                    mem[0] = 17
                                    if poolInfo[idx].field_512 > block.number:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if block.number - poolInfo[idx].field_512:
                                        if (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) / block.number - poolInfo[idx].field_512 != decayTable:
                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                        if (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) > 0:
                                            if not (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable):
                                                if totalAllocPoint <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalAllocPoint
                                                mem[100] = this.address
                                                mem[132] = 0 / totalAllocPoint
                                                require ext_code.size(bxhAddress)
                                                call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args this.address, 0 / totalAllocPoint
                                                mem[96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if ext_call.return_data[0]:
                                                    if not 0 / totalAllocPoint:
                                                        if poolInfo[idx].field_1280 <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require poolInfo[idx].field_1280
                                                        if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                    else:
                                                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if poolInfo[idx].field_1280 <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require poolInfo[idx].field_1280
                                                        if (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1280
                                            else:
                                                if (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) != poolInfo[idx].field_256:
                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if totalAllocPoint <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalAllocPoint
                                                mem[100] = this.address
                                                mem[132] = (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                                require ext_code.size(bxhAddress)
                                                call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args this.address, (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                                mem[96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if ext_call.return_data[0]:
                                                    if not (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint:
                                                        if poolInfo[idx].field_1280 <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require poolInfo[idx].field_1280
                                                        if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                    else:
                                                        if 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if poolInfo[idx].field_1280 <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require poolInfo[idx].field_1280
                                                        if (10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_768 += 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_1280
                                            poolInfo[idx].field_512 = block.number
                                else:
                                    if block.number <= startBlock:
                                        if 0 >= decayTable.length:
                                            require decayTable.length - 1 < decayTable.length
                                            if not decayTable[decayTable.length]:
                                                decayTable.length++
                                                decayTable[decayTable.length] = 0
                                            else:
                                                if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                decayTable.length++
                                                decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                            require 0 < decayTable.length
                                        mem[0] = 17
                                        if poolInfo[idx].field_512 > block.number:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if block.number - poolInfo[idx].field_512:
                                            if (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) / block.number - poolInfo[idx].field_512 != decayTable:
                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            if (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) > 0:
                                                if not (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable):
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    mem[100] = this.address
                                                    mem[132] = 0 / totalAllocPoint
                                                    require ext_code.size(bxhAddress)
                                                    call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, 0 / totalAllocPoint
                                                    mem[96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if ext_call.return_data[0]:
                                                        if not 0 / totalAllocPoint:
                                                            if poolInfo[idx].field_1280 <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require poolInfo[idx].field_1280
                                                            if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                        else:
                                                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                            if poolInfo[idx].field_1280 <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require poolInfo[idx].field_1280
                                                            if (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1280
                                                else:
                                                    if (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) != poolInfo[idx].field_256:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    mem[100] = this.address
                                                    mem[132] = (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                                    require ext_code.size(bxhAddress)
                                                    call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                                    mem[96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if ext_call.return_data[0]:
                                                        if not (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint:
                                                            if poolInfo[idx].field_1280 <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require poolInfo[idx].field_1280
                                                            if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                        else:
                                                            if 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                            if poolInfo[idx].field_1280 <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require poolInfo[idx].field_1280
                                                            if (10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_768 += 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_1280
                                                poolInfo[idx].field_512 = block.number
                                    else:
                                        if startBlock > block.number:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if 1 > block.number - startBlock:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if decayPeriod <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require decayPeriod
                                        if block.number + -startBlock - 1 / decayPeriod >= decayTable.length:
                                            require decayTable.length - 1 < decayTable.length
                                            if not decayTable[decayTable.length]:
                                                decayTable.length++
                                                decayTable[decayTable.length] = 0
                                            else:
                                                if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                decayTable.length++
                                                decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                            require block.number + -startBlock - 1 / decayPeriod < decayTable.length
                                        mem[0] = 17
                                        if poolInfo[idx].field_512 > block.number:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if block.number - poolInfo[idx].field_512:
                                            if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) / block.number - poolInfo[idx].field_512 != decayTable[block.number + -stor12 - 1 / stor15]:
                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) > 0:
                                                if not (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15]):
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    mem[100] = this.address
                                                    mem[132] = 0 / totalAllocPoint
                                                    require ext_code.size(bxhAddress)
                                                    call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, 0 / totalAllocPoint
                                                    mem[96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if ext_call.return_data[0]:
                                                        if not 0 / totalAllocPoint:
                                                            if poolInfo[idx].field_1280 <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require poolInfo[idx].field_1280
                                                            if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                        else:
                                                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                            if poolInfo[idx].field_1280 <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require poolInfo[idx].field_1280
                                                            if (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1280
                                                else:
                                                    if (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) != poolInfo[idx].field_256:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    mem[100] = this.address
                                                    mem[132] = (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint
                                                    require ext_code.size(bxhAddress)
                                                    call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint
                                                    mem[96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if ext_call.return_data[0]:
                                                        if not (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint:
                                                            if poolInfo[idx].field_1280 <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require poolInfo[idx].field_1280
                                                            if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                        else:
                                                            if 10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint / (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                            if poolInfo[idx].field_1280 <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require poolInfo[idx].field_1280
                                                            if (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_768 += 10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_1280
                                                poolInfo[idx].field_512 = block.number
                            else:
                                if block.number <= startBlock:
                                    if 0 == decayPeriod:
                                        if 0 >= decayTable.length:
                                            require decayTable.length - 1 < decayTable.length
                                            if not decayTable[decayTable.length]:
                                                decayTable.length++
                                                decayTable[decayTable.length] = 0
                                            else:
                                                if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                decayTable.length++
                                                decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                            require 0 < decayTable.length
                                        mem[0] = 17
                                        if poolInfo[idx].field_512 > block.number:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if block.number - poolInfo[idx].field_512:
                                            if (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) / block.number - poolInfo[idx].field_512 != decayTable:
                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            if (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) > 0:
                                                if not (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable):
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    mem[100] = this.address
                                                    mem[132] = 0 / totalAllocPoint
                                                    require ext_code.size(bxhAddress)
                                                    call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, 0 / totalAllocPoint
                                                    mem[96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if ext_call.return_data[0]:
                                                        if not 0 / totalAllocPoint:
                                                            if poolInfo[idx].field_1280 <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require poolInfo[idx].field_1280
                                                            if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                        else:
                                                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                            if poolInfo[idx].field_1280 <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require poolInfo[idx].field_1280
                                                            if (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1280
                                                else:
                                                    if (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) != poolInfo[idx].field_256:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    mem[100] = this.address
                                                    mem[132] = (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                                    require ext_code.size(bxhAddress)
                                                    call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                                    mem[96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if ext_call.return_data[0]:
                                                        if not (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint:
                                                            if poolInfo[idx].field_1280 <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require poolInfo[idx].field_1280
                                                            if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                        else:
                                                            if 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                            if poolInfo[idx].field_1280 <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require poolInfo[idx].field_1280
                                                            if (10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_768 += 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_1280
                                                poolInfo[idx].field_512 = block.number
                                    else:
                                        if block.number <= startBlock:
                                            if 0 >= decayTable.length:
                                                require decayTable.length - 1 < decayTable.length
                                                if not decayTable[decayTable.length]:
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = 0
                                                else:
                                                    if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                require 0 < decayTable.length
                                            mem[0] = 17
                                            if poolInfo[idx].field_512 > block.number:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if block.number - poolInfo[idx].field_512:
                                                if (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) / block.number - poolInfo[idx].field_512 != decayTable:
                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) > 0:
                                                    if not (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable):
                                                        if totalAllocPoint <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require totalAllocPoint
                                                        mem[100] = this.address
                                                        mem[132] = 0 / totalAllocPoint
                                                        require ext_code.size(bxhAddress)
                                                        call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args this.address, 0 / totalAllocPoint
                                                        mem[96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if ext_call.return_data[0]:
                                                            if not 0 / totalAllocPoint:
                                                                if poolInfo[idx].field_1280 <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require poolInfo[idx].field_1280
                                                                if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                            else:
                                                                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                                if poolInfo[idx].field_1280 <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require poolInfo[idx].field_1280
                                                                if (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1280
                                                    else:
                                                        if (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) != poolInfo[idx].field_256:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if totalAllocPoint <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require totalAllocPoint
                                                        mem[100] = this.address
                                                        mem[132] = (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                                        require ext_code.size(bxhAddress)
                                                        call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args this.address, (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                                        mem[96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if ext_call.return_data[0]:
                                                            if not (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint:
                                                                if poolInfo[idx].field_1280 <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require poolInfo[idx].field_1280
                                                                if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                            else:
                                                                if 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                                if poolInfo[idx].field_1280 <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require poolInfo[idx].field_1280
                                                                if (10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_768 += 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_1280
                                                    poolInfo[idx].field_512 = block.number
                                        else:
                                            if startBlock > block.number:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if 1 > block.number - startBlock:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if decayPeriod <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require decayPeriod
                                            if block.number + -startBlock - 1 / decayPeriod >= decayTable.length:
                                                require decayTable.length - 1 < decayTable.length
                                                if not decayTable[decayTable.length]:
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = 0
                                                else:
                                                    if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                require block.number + -startBlock - 1 / decayPeriod < decayTable.length
                                            mem[0] = 17
                                            if poolInfo[idx].field_512 > block.number:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if block.number - poolInfo[idx].field_512:
                                                if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) / block.number - poolInfo[idx].field_512 != decayTable[block.number + -stor12 - 1 / stor15]:
                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) > 0:
                                                    if not (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15]):
                                                        if totalAllocPoint <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require totalAllocPoint
                                                        mem[100] = this.address
                                                        mem[132] = 0 / totalAllocPoint
                                                        require ext_code.size(bxhAddress)
                                                        call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args this.address, 0 / totalAllocPoint
                                                        mem[96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if ext_call.return_data[0]:
                                                            if not 0 / totalAllocPoint:
                                                                if poolInfo[idx].field_1280 <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require poolInfo[idx].field_1280
                                                                if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                            else:
                                                                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                                if poolInfo[idx].field_1280 <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require poolInfo[idx].field_1280
                                                                if (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1280
                                                    else:
                                                        if (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) != poolInfo[idx].field_256:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if totalAllocPoint <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require totalAllocPoint
                                                        mem[100] = this.address
                                                        mem[132] = (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint
                                                        require ext_code.size(bxhAddress)
                                                        call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args this.address, (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint
                                                        mem[96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if ext_call.return_data[0]:
                                                            if not (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint:
                                                                if poolInfo[idx].field_1280 <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require poolInfo[idx].field_1280
                                                                if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                            else:
                                                                if 10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint / (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                                if poolInfo[idx].field_1280 <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require poolInfo[idx].field_1280
                                                                if (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_768 += 10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_1280
                                                    poolInfo[idx].field_512 = block.number
                                else:
                                    if startBlock > block.number:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if 1 > block.number - startBlock:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if decayPeriod <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require decayPeriod
                                    s = 0
                                    t = poolInfo[idx].field_512
                                    while s < block.number + -startBlock - 1 / decayPeriod:
                                        if not s + 1:
                                            if startBlock < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if decayPeriod != 0:
                                                if startBlock > startBlock:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                            if 0 >= decayTable.length:
                                                require decayTable.length - 1 < decayTable.length
                                                if not decayTable[decayTable.length]:
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = 0
                                                else:
                                                    if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                require 0 < decayTable.length
                                            mem[0] = 17
                                            if t > startBlock:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if startBlock - t:
                                                if (startBlock * decayTable) - (t * decayTable) / startBlock - t != decayTable:
                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (startBlock * decayTable) - (t * decayTable) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                            s = s + 1
                                            t = startBlock
                                            continue 
                                        if decayPeriod + (s * decayPeriod) / s + 1 != decayPeriod:
                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                        if startBlock < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if 0 == decayPeriod:
                                            if 0 >= decayTable.length:
                                                require decayTable.length - 1 < decayTable.length
                                                if not decayTable[decayTable.length]:
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = 0
                                                else:
                                                    if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                require 0 < decayTable.length
                                            mem[0] = 17
                                            if t > startBlock + decayPeriod + (s * decayPeriod):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if startBlock + decayPeriod + (s * decayPeriod) - t:
                                                if (startBlock * decayTable) + (decayPeriod * decayTable) + (s * decayPeriod * decayTable) - (t * decayTable) / startBlock + decayPeriod + (s * decayPeriod) - t != decayTable:
                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (startBlock * decayTable) + (decayPeriod * decayTable) + (s * decayPeriod * decayTable) - (t * decayTable) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                        else:
                                            if startBlock + decayPeriod + (s * decayPeriod) <= startBlock:
                                                if 0 >= decayTable.length:
                                                    require decayTable.length - 1 < decayTable.length
                                                    if not decayTable[decayTable.length]:
                                                        decayTable.length++
                                                        decayTable[decayTable.length] = 0
                                                    else:
                                                        if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        decayTable.length++
                                                        decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                    require 0 < decayTable.length
                                                mem[0] = 17
                                                if t > startBlock + decayPeriod + (s * decayPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if startBlock + decayPeriod + (s * decayPeriod) - t:
                                                    if (startBlock * decayTable) + (decayPeriod * decayTable) + (s * decayPeriod * decayTable) - (t * decayTable) / startBlock + decayPeriod + (s * decayPeriod) - t != decayTable:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (startBlock * decayTable) + (decayPeriod * decayTable) + (s * decayPeriod * decayTable) - (t * decayTable) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                            else:
                                                if startBlock > startBlock + decayPeriod + (s * decayPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if 1 > decayPeriod + (s * decayPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if decayPeriod <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require decayPeriod
                                                if decayPeriod + (s * decayPeriod) - 1 / decayPeriod >= decayTable.length:
                                                    require decayTable.length - 1 < decayTable.length
                                                    if not decayTable[decayTable.length]:
                                                        decayTable.length++
                                                        decayTable[decayTable.length] = 0
                                                    else:
                                                        if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        decayTable.length++
                                                        decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                    require decayPeriod + (s * decayPeriod) - 1 / decayPeriod < decayTable.length
                                                mem[0] = 17
                                                if t > startBlock + decayPeriod + (s * decayPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if startBlock + decayPeriod + (s * decayPeriod) - t:
                                                    if (startBlock * decayTable[stor15 + (s * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (s * stor15) - 1 / stor15]) + (s * decayPeriod * decayTable[stor15 + (s * stor15) - 1 / stor15]) - (t * decayTable[stor15 + (s * stor15) - 1 / stor15]) / startBlock + decayPeriod + (s * decayPeriod) - t != decayTable[stor15 + (s * stor15) - 1 / stor15]:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (startBlock * decayTable[stor15 + (s * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (s * stor15) - 1 / stor15]) + (s * decayPeriod * decayTable[stor15 + (s * stor15) - 1 / stor15]) - (t * decayTable[stor15 + (s * stor15) - 1 / stor15]) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                        s = s + 1
                                        t = startBlock + decayPeriod + (s * decayPeriod)
                                        continue 
                                    if 0 == decayPeriod:
                                        if 0 >= decayTable.length:
                                            require decayTable.length - 1 < decayTable.length
                                            if not decayTable[decayTable.length]:
                                                decayTable.length++
                                                decayTable[decayTable.length] = 0
                                            else:
                                                if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                decayTable.length++
                                                decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                            require 0 < decayTable.length
                                        mem[0] = 17
                                        if t > block.number:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if block.number - t:
                                            if (block.number * decayTable) - (t * decayTable) / block.number - t != decayTable:
                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            if (block.number * decayTable) - (t * decayTable) < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (block.number * decayTable) - (t * decayTable) > 0:
                                                if not (block.number * decayTable) - (t * decayTable):
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    mem[100] = this.address
                                                    mem[132] = 0 / totalAllocPoint
                                                    require ext_code.size(bxhAddress)
                                                    call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, 0 / totalAllocPoint
                                                    mem[96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if ext_call.return_data[0]:
                                                        if not 0 / totalAllocPoint:
                                                            if poolInfo[idx].field_1280 <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require poolInfo[idx].field_1280
                                                            if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                        else:
                                                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                            if poolInfo[idx].field_1280 <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require poolInfo[idx].field_1280
                                                            if (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1280
                                                else:
                                                    if (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / (block.number * decayTable) - (t * decayTable) != poolInfo[idx].field_256:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    mem[100] = this.address
                                                    mem[132] = (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                                    require ext_code.size(bxhAddress)
                                                    call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                                    mem[96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if ext_call.return_data[0]:
                                                        if not (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint:
                                                            if poolInfo[idx].field_1280 <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require poolInfo[idx].field_1280
                                                            if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                        else:
                                                            if 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                            if poolInfo[idx].field_1280 <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require poolInfo[idx].field_1280
                                                            if (10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_768 += 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_1280
                                                poolInfo[idx].field_512 = block.number
                                    else:
                                        if block.number <= startBlock:
                                            if 0 >= decayTable.length:
                                                require decayTable.length - 1 < decayTable.length
                                                if not decayTable[decayTable.length]:
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = 0
                                                else:
                                                    if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                require 0 < decayTable.length
                                            mem[0] = 17
                                            if t > block.number:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if block.number - t:
                                                if (block.number * decayTable) - (t * decayTable) / block.number - t != decayTable:
                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (block.number * decayTable) - (t * decayTable) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if (block.number * decayTable) - (t * decayTable) > 0:
                                                    if not (block.number * decayTable) - (t * decayTable):
                                                        if totalAllocPoint <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require totalAllocPoint
                                                        mem[100] = this.address
                                                        mem[132] = 0 / totalAllocPoint
                                                        require ext_code.size(bxhAddress)
                                                        call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args this.address, 0 / totalAllocPoint
                                                        mem[96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if ext_call.return_data[0]:
                                                            if not 0 / totalAllocPoint:
                                                                if poolInfo[idx].field_1280 <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require poolInfo[idx].field_1280
                                                                if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                            else:
                                                                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                                if poolInfo[idx].field_1280 <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require poolInfo[idx].field_1280
                                                                if (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1280
                                                    else:
                                                        if (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / (block.number * decayTable) - (t * decayTable) != poolInfo[idx].field_256:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if totalAllocPoint <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require totalAllocPoint
                                                        mem[100] = this.address
                                                        mem[132] = (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                                        require ext_code.size(bxhAddress)
                                                        call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args this.address, (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                                        mem[96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if ext_call.return_data[0]:
                                                            if not (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint:
                                                                if poolInfo[idx].field_1280 <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require poolInfo[idx].field_1280
                                                                if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                            else:
                                                                if 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                                if poolInfo[idx].field_1280 <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require poolInfo[idx].field_1280
                                                                if (10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_768 += 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_1280
                                                    poolInfo[idx].field_512 = block.number
                                        else:
                                            if startBlock > block.number:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if 1 > block.number - startBlock:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if decayPeriod <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require decayPeriod
                                            if block.number + -startBlock - 1 / decayPeriod >= decayTable.length:
                                                require decayTable.length - 1 < decayTable.length
                                                if not decayTable[decayTable.length]:
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = 0
                                                else:
                                                    if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                require block.number + -startBlock - 1 / decayPeriod < decayTable.length
                                            mem[0] = 17
                                            if t > block.number:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if block.number - t:
                                                if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (t * decayTable[block.number + -stor12 - 1 / stor15]) / block.number - t != decayTable[block.number + -stor12 - 1 / stor15]:
                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (t * decayTable[block.number + -stor12 - 1 / stor15]) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (t * decayTable[block.number + -stor12 - 1 / stor15]) > 0:
                                                    if not (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (t * decayTable[block.number + -stor12 - 1 / stor15]):
                                                        if totalAllocPoint <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require totalAllocPoint
                                                        mem[100] = this.address
                                                        mem[132] = 0 / totalAllocPoint
                                                        require ext_code.size(bxhAddress)
                                                        call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args this.address, 0 / totalAllocPoint
                                                        mem[96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if ext_call.return_data[0]:
                                                            if not 0 / totalAllocPoint:
                                                                if poolInfo[idx].field_1280 <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require poolInfo[idx].field_1280
                                                                if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                            else:
                                                                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                                if poolInfo[idx].field_1280 <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require poolInfo[idx].field_1280
                                                                if (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1280
                                                    else:
                                                        if (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (t * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (t * decayTable[block.number + -stor12 - 1 / stor15]) != poolInfo[idx].field_256:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if totalAllocPoint <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require totalAllocPoint
                                                        mem[100] = this.address
                                                        mem[132] = (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (t * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint
                                                        require ext_code.size(bxhAddress)
                                                        call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args this.address, (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (t * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint
                                                        mem[96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if ext_call.return_data[0]:
                                                            if not (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (t * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint:
                                                                if poolInfo[idx].field_1280 <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require poolInfo[idx].field_1280
                                                                if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                            else:
                                                                if 10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (t * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint / (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (t * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                                if poolInfo[idx].field_1280 <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require poolInfo[idx].field_1280
                                                                if (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (t * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_768 += 10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (t * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_1280
                                                    poolInfo[idx].field_512 = block.number
                        else:
                            if startBlock > poolInfo[idx].field_512:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if 1 > poolInfo[idx].field_512 - startBlock:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if decayPeriod <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require decayPeriod
                            if 0 == decayPeriod:
                                s = poolInfo[idx].field_512 + -startBlock - 1 / decayPeriod
                                t = poolInfo[idx].field_512
                                while s < 0:
                                    if not s + 1:
                                        if startBlock < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if decayPeriod != 0:
                                            if startBlock > startBlock:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        if 0 >= decayTable.length:
                                            require decayTable.length - 1 < decayTable.length
                                            if not decayTable[decayTable.length]:
                                                decayTable.length++
                                                decayTable[decayTable.length] = 0
                                            else:
                                                if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                decayTable.length++
                                                decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                            require 0 < decayTable.length
                                        mem[0] = 17
                                        if t > startBlock:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if startBlock - t:
                                            if (startBlock * decayTable) - (t * decayTable) / startBlock - t != decayTable:
                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            if (startBlock * decayTable) - (t * decayTable) < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                        s = s + 1
                                        t = startBlock
                                        continue 
                                    if decayPeriod + (s * decayPeriod) / s + 1 != decayPeriod:
                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                    if startBlock < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if 0 == decayPeriod:
                                        if 0 >= decayTable.length:
                                            require decayTable.length - 1 < decayTable.length
                                            if not decayTable[decayTable.length]:
                                                decayTable.length++
                                                decayTable[decayTable.length] = 0
                                            else:
                                                if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                decayTable.length++
                                                decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                            require 0 < decayTable.length
                                        mem[0] = 17
                                        if t > startBlock + decayPeriod + (s * decayPeriod):
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if startBlock + decayPeriod + (s * decayPeriod) - t:
                                            if (startBlock * decayTable) + (decayPeriod * decayTable) + (s * decayPeriod * decayTable) - (t * decayTable) / startBlock + decayPeriod + (s * decayPeriod) - t != decayTable:
                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            if (startBlock * decayTable) + (decayPeriod * decayTable) + (s * decayPeriod * decayTable) - (t * decayTable) < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                    else:
                                        if startBlock + decayPeriod + (s * decayPeriod) <= startBlock:
                                            if 0 >= decayTable.length:
                                                require decayTable.length - 1 < decayTable.length
                                                if not decayTable[decayTable.length]:
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = 0
                                                else:
                                                    if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                require 0 < decayTable.length
                                            mem[0] = 17
                                            if t > startBlock + decayPeriod + (s * decayPeriod):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if startBlock + decayPeriod + (s * decayPeriod) - t:
                                                if (startBlock * decayTable) + (decayPeriod * decayTable) + (s * decayPeriod * decayTable) - (t * decayTable) / startBlock + decayPeriod + (s * decayPeriod) - t != decayTable:
                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (startBlock * decayTable) + (decayPeriod * decayTable) + (s * decayPeriod * decayTable) - (t * decayTable) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                        else:
                                            if startBlock > startBlock + decayPeriod + (s * decayPeriod):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if 1 > decayPeriod + (s * decayPeriod):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if decayPeriod <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require decayPeriod
                                            if decayPeriod + (s * decayPeriod) - 1 / decayPeriod >= decayTable.length:
                                                require decayTable.length - 1 < decayTable.length
                                                if not decayTable[decayTable.length]:
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = 0
                                                else:
                                                    if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                require decayPeriod + (s * decayPeriod) - 1 / decayPeriod < decayTable.length
                                            mem[0] = 17
                                            if t > startBlock + decayPeriod + (s * decayPeriod):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if startBlock + decayPeriod + (s * decayPeriod) - t:
                                                if (startBlock * decayTable[stor15 + (s * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (s * stor15) - 1 / stor15]) + (s * decayPeriod * decayTable[stor15 + (s * stor15) - 1 / stor15]) - (t * decayTable[stor15 + (s * stor15) - 1 / stor15]) / startBlock + decayPeriod + (s * decayPeriod) - t != decayTable[stor15 + (s * stor15) - 1 / stor15]:
                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (startBlock * decayTable[stor15 + (s * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (s * stor15) - 1 / stor15]) + (s * decayPeriod * decayTable[stor15 + (s * stor15) - 1 / stor15]) - (t * decayTable[stor15 + (s * stor15) - 1 / stor15]) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                    s = s + 1
                                    t = startBlock + decayPeriod + (s * decayPeriod)
                                    continue 
                            else:
                                if block.number <= startBlock:
                                    s = poolInfo[idx].field_512 + -startBlock - 1 / decayPeriod
                                    t = poolInfo[idx].field_512
                                    while s < 0:
                                        if not s + 1:
                                            if startBlock < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if decayPeriod != 0:
                                                if startBlock > startBlock:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                            if 0 >= decayTable.length:
                                                require decayTable.length - 1 < decayTable.length
                                                if not decayTable[decayTable.length]:
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = 0
                                                else:
                                                    if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                require 0 < decayTable.length
                                            mem[0] = 17
                                            if t > startBlock:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if startBlock - t:
                                                if (startBlock * decayTable) - (t * decayTable) / startBlock - t != decayTable:
                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (startBlock * decayTable) - (t * decayTable) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                            s = s + 1
                                            t = startBlock
                                            continue 
                                        if decayPeriod + (s * decayPeriod) / s + 1 != decayPeriod:
                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                        if startBlock < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if 0 == decayPeriod:
                                            if 0 >= decayTable.length:
                                                require decayTable.length - 1 < decayTable.length
                                                if not decayTable[decayTable.length]:
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = 0
                                                else:
                                                    if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                require 0 < decayTable.length
                                            mem[0] = 17
                                            if t > startBlock + decayPeriod + (s * decayPeriod):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if startBlock + decayPeriod + (s * decayPeriod) - t:
                                                if (startBlock * decayTable) + (decayPeriod * decayTable) + (s * decayPeriod * decayTable) - (t * decayTable) / startBlock + decayPeriod + (s * decayPeriod) - t != decayTable:
                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (startBlock * decayTable) + (decayPeriod * decayTable) + (s * decayPeriod * decayTable) - (t * decayTable) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                        else:
                                            if startBlock + decayPeriod + (s * decayPeriod) <= startBlock:
                                                if 0 >= decayTable.length:
                                                    require decayTable.length - 1 < decayTable.length
                                                    if not decayTable[decayTable.length]:
                                                        decayTable.length++
                                                        decayTable[decayTable.length] = 0
                                                    else:
                                                        if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        decayTable.length++
                                                        decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                    require 0 < decayTable.length
                                                mem[0] = 17
                                                if t > startBlock + decayPeriod + (s * decayPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if startBlock + decayPeriod + (s * decayPeriod) - t:
                                                    if (startBlock * decayTable) + (decayPeriod * decayTable) + (s * decayPeriod * decayTable) - (t * decayTable) / startBlock + decayPeriod + (s * decayPeriod) - t != decayTable:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (startBlock * decayTable) + (decayPeriod * decayTable) + (s * decayPeriod * decayTable) - (t * decayTable) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                            else:
                                                if startBlock > startBlock + decayPeriod + (s * decayPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if 1 > decayPeriod + (s * decayPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if decayPeriod <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require decayPeriod
                                                if decayPeriod + (s * decayPeriod) - 1 / decayPeriod >= decayTable.length:
                                                    require decayTable.length - 1 < decayTable.length
                                                    if not decayTable[decayTable.length]:
                                                        decayTable.length++
                                                        decayTable[decayTable.length] = 0
                                                    else:
                                                        if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        decayTable.length++
                                                        decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                    require decayPeriod + (s * decayPeriod) - 1 / decayPeriod < decayTable.length
                                                mem[0] = 17
                                                if t > startBlock + decayPeriod + (s * decayPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if startBlock + decayPeriod + (s * decayPeriod) - t:
                                                    if (startBlock * decayTable[stor15 + (s * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (s * stor15) - 1 / stor15]) + (s * decayPeriod * decayTable[stor15 + (s * stor15) - 1 / stor15]) - (t * decayTable[stor15 + (s * stor15) - 1 / stor15]) / startBlock + decayPeriod + (s * decayPeriod) - t != decayTable[stor15 + (s * stor15) - 1 / stor15]:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (startBlock * decayTable[stor15 + (s * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (s * stor15) - 1 / stor15]) + (s * decayPeriod * decayTable[stor15 + (s * stor15) - 1 / stor15]) - (t * decayTable[stor15 + (s * stor15) - 1 / stor15]) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                        s = s + 1
                                        t = startBlock + decayPeriod + (s * decayPeriod)
                                        continue 
                                else:
                                    if startBlock > block.number:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if 1 > block.number - startBlock:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if decayPeriod <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require decayPeriod
                                    s = poolInfo[idx].field_512 + -startBlock - 1 / decayPeriod
                                    t = poolInfo[idx].field_512
                                    while s < block.number + -startBlock - 1 / decayPeriod:
                                        if not s + 1:
                                            if startBlock < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if decayPeriod != 0:
                                                if startBlock > startBlock:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                            if 0 >= decayTable.length:
                                                require decayTable.length - 1 < decayTable.length
                                                if not decayTable[decayTable.length]:
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = 0
                                                else:
                                                    if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                require 0 < decayTable.length
                                            mem[0] = 17
                                            if t > startBlock:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if startBlock - t:
                                                if (startBlock * decayTable) - (t * decayTable) / startBlock - t != decayTable:
                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (startBlock * decayTable) - (t * decayTable) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                            s = s + 1
                                            t = startBlock
                                            continue 
                                        if decayPeriod + (s * decayPeriod) / s + 1 != decayPeriod:
                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                        if startBlock < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if 0 == decayPeriod:
                                            if 0 >= decayTable.length:
                                                require decayTable.length - 1 < decayTable.length
                                                if not decayTable[decayTable.length]:
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = 0
                                                else:
                                                    if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                require 0 < decayTable.length
                                            mem[0] = 17
                                            if t > startBlock + decayPeriod + (s * decayPeriod):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if startBlock + decayPeriod + (s * decayPeriod) - t:
                                                if (startBlock * decayTable) + (decayPeriod * decayTable) + (s * decayPeriod * decayTable) - (t * decayTable) / startBlock + decayPeriod + (s * decayPeriod) - t != decayTable:
                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (startBlock * decayTable) + (decayPeriod * decayTable) + (s * decayPeriod * decayTable) - (t * decayTable) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                        else:
                                            if startBlock + decayPeriod + (s * decayPeriod) <= startBlock:
                                                if 0 >= decayTable.length:
                                                    require decayTable.length - 1 < decayTable.length
                                                    if not decayTable[decayTable.length]:
                                                        decayTable.length++
                                                        decayTable[decayTable.length] = 0
                                                    else:
                                                        if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        decayTable.length++
                                                        decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                    require 0 < decayTable.length
                                                mem[0] = 17
                                                if t > startBlock + decayPeriod + (s * decayPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if startBlock + decayPeriod + (s * decayPeriod) - t:
                                                    if (startBlock * decayTable) + (decayPeriod * decayTable) + (s * decayPeriod * decayTable) - (t * decayTable) / startBlock + decayPeriod + (s * decayPeriod) - t != decayTable:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (startBlock * decayTable) + (decayPeriod * decayTable) + (s * decayPeriod * decayTable) - (t * decayTable) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                            else:
                                                if startBlock > startBlock + decayPeriod + (s * decayPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if 1 > decayPeriod + (s * decayPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if decayPeriod <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require decayPeriod
                                                if decayPeriod + (s * decayPeriod) - 1 / decayPeriod >= decayTable.length:
                                                    require decayTable.length - 1 < decayTable.length
                                                    if not decayTable[decayTable.length]:
                                                        decayTable.length++
                                                        decayTable[decayTable.length] = 0
                                                    else:
                                                        if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        decayTable.length++
                                                        decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                    require decayPeriod + (s * decayPeriod) - 1 / decayPeriod < decayTable.length
                                                mem[0] = 17
                                                if t > startBlock + decayPeriod + (s * decayPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if startBlock + decayPeriod + (s * decayPeriod) - t:
                                                    if (startBlock * decayTable[stor15 + (s * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (s * stor15) - 1 / stor15]) + (s * decayPeriod * decayTable[stor15 + (s * stor15) - 1 / stor15]) - (t * decayTable[stor15 + (s * stor15) - 1 / stor15]) / startBlock + decayPeriod + (s * decayPeriod) - t != decayTable[stor15 + (s * stor15) - 1 / stor15]:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (startBlock * decayTable[stor15 + (s * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (s * stor15) - 1 / stor15]) + (s * decayPeriod * decayTable[stor15 + (s * stor15) - 1 / stor15]) - (t * decayTable[stor15 + (s * stor15) - 1 / stor15]) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                        s = s + 1
                                        t = startBlock + decayPeriod + (s * decayPeriod)
                                        continue 
                            if 0 == decayPeriod:
                                if 0 >= decayTable.length:
                                    require decayTable.length - 1 < decayTable.length
                                    if not decayTable[decayTable.length]:
                                        decayTable.length++
                                        decayTable[decayTable.length] = 0
                                    else:
                                        if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                        decayTable.length++
                                        decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                    require 0 < decayTable.length
                                mem[0] = 17
                                if t > block.number:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if block.number - t:
                                    if (block.number * decayTable) - (t * decayTable) / block.number - t != decayTable:
                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                    if (block.number * decayTable) - (t * decayTable) < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (block.number * decayTable) - (t * decayTable) > 0:
                                        if not (block.number * decayTable) - (t * decayTable):
                                            if totalAllocPoint <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalAllocPoint
                                            mem[100] = this.address
                                            mem[132] = 0 / totalAllocPoint
                                            require ext_code.size(bxhAddress)
                                            call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                 gas gas_remaining wei
                                                args this.address, 0 / totalAllocPoint
                                            mem[96] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if ext_call.return_data[0]:
                                                if not 0 / totalAllocPoint:
                                                    if poolInfo[idx].field_1280 <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require poolInfo[idx].field_1280
                                                    if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                else:
                                                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if poolInfo[idx].field_1280 <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require poolInfo[idx].field_1280
                                                    if (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1280
                                        else:
                                            if (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / (block.number * decayTable) - (t * decayTable) != poolInfo[idx].field_256:
                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            if totalAllocPoint <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalAllocPoint
                                            mem[100] = this.address
                                            mem[132] = (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                            require ext_code.size(bxhAddress)
                                            call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                 gas gas_remaining wei
                                                args this.address, (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                            mem[96] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if ext_call.return_data[0]:
                                                if not (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint:
                                                    if poolInfo[idx].field_1280 <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require poolInfo[idx].field_1280
                                                    if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                else:
                                                    if 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if poolInfo[idx].field_1280 <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require poolInfo[idx].field_1280
                                                    if (10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_1280
                                        poolInfo[idx].field_512 = block.number
                            else:
                                if block.number <= startBlock:
                                    if 0 >= decayTable.length:
                                        require decayTable.length - 1 < decayTable.length
                                        if not decayTable[decayTable.length]:
                                            decayTable.length++
                                            decayTable[decayTable.length] = 0
                                        else:
                                            if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            decayTable.length++
                                            decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                        require 0 < decayTable.length
                                    mem[0] = 17
                                    if t > block.number:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if block.number - t:
                                        if (block.number * decayTable) - (t * decayTable) / block.number - t != decayTable:
                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                        if (block.number * decayTable) - (t * decayTable) < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (block.number * decayTable) - (t * decayTable) > 0:
                                            if not (block.number * decayTable) - (t * decayTable):
                                                if totalAllocPoint <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalAllocPoint
                                                mem[100] = this.address
                                                mem[132] = 0 / totalAllocPoint
                                                require ext_code.size(bxhAddress)
                                                call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args this.address, 0 / totalAllocPoint
                                                mem[96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if ext_call.return_data[0]:
                                                    if not 0 / totalAllocPoint:
                                                        if poolInfo[idx].field_1280 <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require poolInfo[idx].field_1280
                                                        if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                    else:
                                                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if poolInfo[idx].field_1280 <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require poolInfo[idx].field_1280
                                                        if (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1280
                                            else:
                                                if (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / (block.number * decayTable) - (t * decayTable) != poolInfo[idx].field_256:
                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if totalAllocPoint <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalAllocPoint
                                                mem[100] = this.address
                                                mem[132] = (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                                require ext_code.size(bxhAddress)
                                                call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args this.address, (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                                mem[96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if ext_call.return_data[0]:
                                                    if not (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint:
                                                        if poolInfo[idx].field_1280 <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require poolInfo[idx].field_1280
                                                        if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                    else:
                                                        if 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if poolInfo[idx].field_1280 <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require poolInfo[idx].field_1280
                                                        if (10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_768 += 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_1280
                                            poolInfo[idx].field_512 = block.number
                                else:
                                    if startBlock > block.number:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if 1 > block.number - startBlock:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if decayPeriod <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require decayPeriod
                                    if block.number + -startBlock - 1 / decayPeriod >= decayTable.length:
                                        require decayTable.length - 1 < decayTable.length
                                        if not decayTable[decayTable.length]:
                                            decayTable.length++
                                            decayTable[decayTable.length] = 0
                                        else:
                                            if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            decayTable.length++
                                            decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                        require block.number + -startBlock - 1 / decayPeriod < decayTable.length
                                    mem[0] = 17
                                    if t > block.number:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if block.number - t:
                                        if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (t * decayTable[block.number + -stor12 - 1 / stor15]) / block.number - t != decayTable[block.number + -stor12 - 1 / stor15]:
                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                        if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (t * decayTable[block.number + -stor12 - 1 / stor15]) < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (t * decayTable[block.number + -stor12 - 1 / stor15]) > 0:
                                            if not (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (t * decayTable[block.number + -stor12 - 1 / stor15]):
                                                if totalAllocPoint <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalAllocPoint
                                                mem[100] = this.address
                                                mem[132] = 0 / totalAllocPoint
                                                require ext_code.size(bxhAddress)
                                                call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args this.address, 0 / totalAllocPoint
                                                mem[96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if ext_call.return_data[0]:
                                                    if not 0 / totalAllocPoint:
                                                        if poolInfo[idx].field_1280 <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require poolInfo[idx].field_1280
                                                        if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                    else:
                                                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if poolInfo[idx].field_1280 <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require poolInfo[idx].field_1280
                                                        if (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1280
                                            else:
                                                if (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (t * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (t * decayTable[block.number + -stor12 - 1 / stor15]) != poolInfo[idx].field_256:
                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if totalAllocPoint <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalAllocPoint
                                                mem[100] = this.address
                                                mem[132] = (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (t * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint
                                                require ext_code.size(bxhAddress)
                                                call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args this.address, (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (t * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint
                                                mem[96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if ext_call.return_data[0]:
                                                    if not (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (t * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint:
                                                        if poolInfo[idx].field_1280 <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require poolInfo[idx].field_1280
                                                        if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                    else:
                                                        if 10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (t * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint / (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (t * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if poolInfo[idx].field_1280 <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require poolInfo[idx].field_1280
                                                        if (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (t * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_768 += 10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (t * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_1280
                                            poolInfo[idx].field_512 = block.number
            else:
                mem[100] = this.address
                require ext_code.size(poolInfo[idx].field_0)
                staticcall poolInfo[idx].field_0.0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                mem[96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if not ext_call.return_data[0]:
                    poolInfo[idx].field_512 = block.number
                else:
                    if 0 == decayPeriod:
                        if 0 == decayPeriod:
                            if 0 >= decayTable.length:
                                require decayTable.length - 1 < decayTable.length
                                if not decayTable[decayTable.length]:
                                    decayTable.length++
                                    decayTable[decayTable.length] = 0
                                else:
                                    if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                    decayTable.length++
                                    decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                require 0 < decayTable.length
                            mem[0] = 17
                            if poolInfo[idx].field_512 > block.number:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if block.number - poolInfo[idx].field_512:
                                if (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) / block.number - poolInfo[idx].field_512 != decayTable:
                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                if (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) > 0:
                                    if not (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable):
                                        if totalAllocPoint <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalAllocPoint
                                        mem[100] = this.address
                                        mem[132] = 0 / totalAllocPoint
                                        require ext_code.size(bxhAddress)
                                        call bxhAddress.mint(address arg1, uint256 arg2) with:
                                             gas gas_remaining wei
                                            args this.address, 0 / totalAllocPoint
                                        mem[96] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0]:
                                            if not 0 / totalAllocPoint:
                                                if ext_call.return_data[0] <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require ext_call.return_data[0]
                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                            else:
                                                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if ext_call.return_data[0] <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require ext_call.return_data[0]
                                                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                    else:
                                        if (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) != poolInfo[idx].field_256:
                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                        if totalAllocPoint <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalAllocPoint
                                        mem[100] = this.address
                                        mem[132] = (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                        require ext_code.size(bxhAddress)
                                        call bxhAddress.mint(address arg1, uint256 arg2) with:
                                             gas gas_remaining wei
                                            args this.address, (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                        mem[96] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0]:
                                            if not (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint:
                                                if ext_call.return_data[0] <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require ext_call.return_data[0]
                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                            else:
                                                if 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if ext_call.return_data[0] <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require ext_call.return_data[0]
                                                if (10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                                    poolInfo[idx].field_512 = block.number
                        else:
                            if block.number <= startBlock:
                                if 0 >= decayTable.length:
                                    require decayTable.length - 1 < decayTable.length
                                    if not decayTable[decayTable.length]:
                                        decayTable.length++
                                        decayTable[decayTable.length] = 0
                                    else:
                                        if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                        decayTable.length++
                                        decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                    require 0 < decayTable.length
                                mem[0] = 17
                                if poolInfo[idx].field_512 > block.number:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if block.number - poolInfo[idx].field_512:
                                    if (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) / block.number - poolInfo[idx].field_512 != decayTable:
                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                    if (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) > 0:
                                        if not (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable):
                                            if totalAllocPoint <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalAllocPoint
                                            mem[100] = this.address
                                            mem[132] = 0 / totalAllocPoint
                                            require ext_code.size(bxhAddress)
                                            call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                 gas gas_remaining wei
                                                args this.address, 0 / totalAllocPoint
                                            mem[96] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if ext_call.return_data[0]:
                                                if not 0 / totalAllocPoint:
                                                    if ext_call.return_data[0] <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require ext_call.return_data[0]
                                                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                else:
                                                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if ext_call.return_data[0] <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require ext_call.return_data[0]
                                                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                        else:
                                            if (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) != poolInfo[idx].field_256:
                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            if totalAllocPoint <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalAllocPoint
                                            mem[100] = this.address
                                            mem[132] = (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                            require ext_code.size(bxhAddress)
                                            call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                 gas gas_remaining wei
                                                args this.address, (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                            mem[96] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if ext_call.return_data[0]:
                                                if not (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint:
                                                    if ext_call.return_data[0] <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require ext_call.return_data[0]
                                                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                else:
                                                    if 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if ext_call.return_data[0] <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require ext_call.return_data[0]
                                                    if (10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                            else:
                                if startBlock > block.number:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if 1 > block.number - startBlock:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if decayPeriod <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require decayPeriod
                                if block.number + -startBlock - 1 / decayPeriod >= decayTable.length:
                                    require decayTable.length - 1 < decayTable.length
                                    if not decayTable[decayTable.length]:
                                        decayTable.length++
                                        decayTable[decayTable.length] = 0
                                    else:
                                        if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                        decayTable.length++
                                        decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                    require block.number + -startBlock - 1 / decayPeriod < decayTable.length
                                mem[0] = 17
                                if poolInfo[idx].field_512 > block.number:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if block.number - poolInfo[idx].field_512:
                                    if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) / block.number - poolInfo[idx].field_512 != decayTable[block.number + -stor12 - 1 / stor15]:
                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                    if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) > 0:
                                        if not (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15]):
                                            if totalAllocPoint <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalAllocPoint
                                            mem[100] = this.address
                                            mem[132] = 0 / totalAllocPoint
                                            require ext_code.size(bxhAddress)
                                            call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                 gas gas_remaining wei
                                                args this.address, 0 / totalAllocPoint
                                            mem[96] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if ext_call.return_data[0]:
                                                if not 0 / totalAllocPoint:
                                                    if ext_call.return_data[0] <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require ext_call.return_data[0]
                                                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                else:
                                                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if ext_call.return_data[0] <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require ext_call.return_data[0]
                                                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                        else:
                                            if (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) != poolInfo[idx].field_256:
                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            if totalAllocPoint <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalAllocPoint
                                            mem[100] = this.address
                                            mem[132] = (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint
                                            require ext_code.size(bxhAddress)
                                            call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                 gas gas_remaining wei
                                                args this.address, (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint
                                            mem[96] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if ext_call.return_data[0]:
                                                if not (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint:
                                                    if ext_call.return_data[0] <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require ext_call.return_data[0]
                                                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                else:
                                                    if 10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint / (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if ext_call.return_data[0] <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require ext_call.return_data[0]
                                                    if (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                    else:
                        if poolInfo[idx].field_512 <= startBlock:
                            if 0 == decayPeriod:
                                if 0 == decayPeriod:
                                    if 0 >= decayTable.length:
                                        require decayTable.length - 1 < decayTable.length
                                        if not decayTable[decayTable.length]:
                                            decayTable.length++
                                            decayTable[decayTable.length] = 0
                                        else:
                                            if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            decayTable.length++
                                            decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                        require 0 < decayTable.length
                                    mem[0] = 17
                                    if poolInfo[idx].field_512 > block.number:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if block.number - poolInfo[idx].field_512:
                                        if (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) / block.number - poolInfo[idx].field_512 != decayTable:
                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                        if (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) > 0:
                                            if not (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable):
                                                if totalAllocPoint <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalAllocPoint
                                                mem[100] = this.address
                                                mem[132] = 0 / totalAllocPoint
                                                require ext_code.size(bxhAddress)
                                                call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args this.address, 0 / totalAllocPoint
                                                mem[96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if ext_call.return_data[0]:
                                                    if not 0 / totalAllocPoint:
                                                        if ext_call.return_data[0] <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require ext_call.return_data[0]
                                                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                    else:
                                                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if ext_call.return_data[0] <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require ext_call.return_data[0]
                                                        if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                            else:
                                                if (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) != poolInfo[idx].field_256:
                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if totalAllocPoint <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalAllocPoint
                                                mem[100] = this.address
                                                mem[132] = (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                                require ext_code.size(bxhAddress)
                                                call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args this.address, (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                                mem[96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if ext_call.return_data[0]:
                                                    if not (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint:
                                                        if ext_call.return_data[0] <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require ext_call.return_data[0]
                                                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                    else:
                                                        if 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if ext_call.return_data[0] <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require ext_call.return_data[0]
                                                        if (10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_768 += 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                else:
                                    if block.number <= startBlock:
                                        if 0 >= decayTable.length:
                                            require decayTable.length - 1 < decayTable.length
                                            if not decayTable[decayTable.length]:
                                                decayTable.length++
                                                decayTable[decayTable.length] = 0
                                            else:
                                                if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                decayTable.length++
                                                decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                            require 0 < decayTable.length
                                        mem[0] = 17
                                        if poolInfo[idx].field_512 > block.number:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if block.number - poolInfo[idx].field_512:
                                            if (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) / block.number - poolInfo[idx].field_512 != decayTable:
                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            if (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) > 0:
                                                if not (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable):
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    mem[100] = this.address
                                                    mem[132] = 0 / totalAllocPoint
                                                    require ext_code.size(bxhAddress)
                                                    call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, 0 / totalAllocPoint
                                                    mem[96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if ext_call.return_data[0]:
                                                        if not 0 / totalAllocPoint:
                                                            if ext_call.return_data[0] <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require ext_call.return_data[0]
                                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                        else:
                                                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                            if ext_call.return_data[0] <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require ext_call.return_data[0]
                                                            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                                else:
                                                    if (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) != poolInfo[idx].field_256:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    mem[100] = this.address
                                                    mem[132] = (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                                    require ext_code.size(bxhAddress)
                                                    call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                                    mem[96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if ext_call.return_data[0]:
                                                        if not (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint:
                                                            if ext_call.return_data[0] <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require ext_call.return_data[0]
                                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                        else:
                                                            if 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                            if ext_call.return_data[0] <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require ext_call.return_data[0]
                                                            if (10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_768 += 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                    else:
                                        if startBlock > block.number:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if 1 > block.number - startBlock:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if decayPeriod <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require decayPeriod
                                        if block.number + -startBlock - 1 / decayPeriod >= decayTable.length:
                                            require decayTable.length - 1 < decayTable.length
                                            if not decayTable[decayTable.length]:
                                                decayTable.length++
                                                decayTable[decayTable.length] = 0
                                            else:
                                                if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                decayTable.length++
                                                decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                            require block.number + -startBlock - 1 / decayPeriod < decayTable.length
                                        mem[0] = 17
                                        if poolInfo[idx].field_512 > block.number:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if block.number - poolInfo[idx].field_512:
                                            if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) / block.number - poolInfo[idx].field_512 != decayTable[block.number + -stor12 - 1 / stor15]:
                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) > 0:
                                                if not (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15]):
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    mem[100] = this.address
                                                    mem[132] = 0 / totalAllocPoint
                                                    require ext_code.size(bxhAddress)
                                                    call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, 0 / totalAllocPoint
                                                    mem[96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if ext_call.return_data[0]:
                                                        if not 0 / totalAllocPoint:
                                                            if ext_call.return_data[0] <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require ext_call.return_data[0]
                                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                        else:
                                                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                            if ext_call.return_data[0] <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require ext_call.return_data[0]
                                                            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                                else:
                                                    if (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) != poolInfo[idx].field_256:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    mem[100] = this.address
                                                    mem[132] = (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint
                                                    require ext_code.size(bxhAddress)
                                                    call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint
                                                    mem[96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if ext_call.return_data[0]:
                                                        if not (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint:
                                                            if ext_call.return_data[0] <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require ext_call.return_data[0]
                                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                        else:
                                                            if 10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint / (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                            if ext_call.return_data[0] <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require ext_call.return_data[0]
                                                            if (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_768 += 10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                            else:
                                if block.number <= startBlock:
                                    if 0 == decayPeriod:
                                        if 0 >= decayTable.length:
                                            require decayTable.length - 1 < decayTable.length
                                            if not decayTable[decayTable.length]:
                                                decayTable.length++
                                                decayTable[decayTable.length] = 0
                                            else:
                                                if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                decayTable.length++
                                                decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                            require 0 < decayTable.length
                                        mem[0] = 17
                                        if poolInfo[idx].field_512 > block.number:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if block.number - poolInfo[idx].field_512:
                                            if (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) / block.number - poolInfo[idx].field_512 != decayTable:
                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            if (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) > 0:
                                                if not (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable):
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    mem[100] = this.address
                                                    mem[132] = 0 / totalAllocPoint
                                                    require ext_code.size(bxhAddress)
                                                    call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, 0 / totalAllocPoint
                                                    mem[96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if ext_call.return_data[0]:
                                                        if not 0 / totalAllocPoint:
                                                            if ext_call.return_data[0] <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require ext_call.return_data[0]
                                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                        else:
                                                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                            if ext_call.return_data[0] <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require ext_call.return_data[0]
                                                            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                                else:
                                                    if (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) != poolInfo[idx].field_256:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    mem[100] = this.address
                                                    mem[132] = (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                                    require ext_code.size(bxhAddress)
                                                    call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                                    mem[96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if ext_call.return_data[0]:
                                                        if not (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint:
                                                            if ext_call.return_data[0] <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require ext_call.return_data[0]
                                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                        else:
                                                            if 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                            if ext_call.return_data[0] <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require ext_call.return_data[0]
                                                            if (10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_768 += 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                    else:
                                        if block.number <= startBlock:
                                            if 0 >= decayTable.length:
                                                require decayTable.length - 1 < decayTable.length
                                                if not decayTable[decayTable.length]:
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = 0
                                                else:
                                                    if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                require 0 < decayTable.length
                                            mem[0] = 17
                                            if poolInfo[idx].field_512 > block.number:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if block.number - poolInfo[idx].field_512:
                                                if (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) / block.number - poolInfo[idx].field_512 != decayTable:
                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) > 0:
                                                    if not (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable):
                                                        if totalAllocPoint <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require totalAllocPoint
                                                        mem[100] = this.address
                                                        mem[132] = 0 / totalAllocPoint
                                                        require ext_code.size(bxhAddress)
                                                        call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args this.address, 0 / totalAllocPoint
                                                        mem[96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if ext_call.return_data[0]:
                                                            if not 0 / totalAllocPoint:
                                                                if ext_call.return_data[0] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require ext_call.return_data[0]
                                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                            else:
                                                                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                                if ext_call.return_data[0] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require ext_call.return_data[0]
                                                                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                                    else:
                                                        if (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) != poolInfo[idx].field_256:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if totalAllocPoint <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require totalAllocPoint
                                                        mem[100] = this.address
                                                        mem[132] = (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                                        require ext_code.size(bxhAddress)
                                                        call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args this.address, (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                                        mem[96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if ext_call.return_data[0]:
                                                            if not (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint:
                                                                if ext_call.return_data[0] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require ext_call.return_data[0]
                                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                            else:
                                                                if 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                                if ext_call.return_data[0] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require ext_call.return_data[0]
                                                                if (10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_768 += 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                                                    poolInfo[idx].field_512 = block.number
                                        else:
                                            if startBlock > block.number:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if 1 > block.number - startBlock:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if decayPeriod <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require decayPeriod
                                            if block.number + -startBlock - 1 / decayPeriod >= decayTable.length:
                                                require decayTable.length - 1 < decayTable.length
                                                if not decayTable[decayTable.length]:
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = 0
                                                else:
                                                    if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                require block.number + -startBlock - 1 / decayPeriod < decayTable.length
                                            mem[0] = 17
                                            if poolInfo[idx].field_512 > block.number:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if block.number - poolInfo[idx].field_512:
                                                if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) / block.number - poolInfo[idx].field_512 != decayTable[block.number + -stor12 - 1 / stor15]:
                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) > 0:
                                                    if not (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15]):
                                                        if totalAllocPoint <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require totalAllocPoint
                                                        mem[100] = this.address
                                                        mem[132] = 0 / totalAllocPoint
                                                        require ext_code.size(bxhAddress)
                                                        call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args this.address, 0 / totalAllocPoint
                                                        mem[96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if ext_call.return_data[0]:
                                                            if not 0 / totalAllocPoint:
                                                                if ext_call.return_data[0] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require ext_call.return_data[0]
                                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                            else:
                                                                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                                if ext_call.return_data[0] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require ext_call.return_data[0]
                                                                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                                    else:
                                                        if (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) != poolInfo[idx].field_256:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if totalAllocPoint <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require totalAllocPoint
                                                        mem[100] = this.address
                                                        mem[132] = (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint
                                                        require ext_code.size(bxhAddress)
                                                        call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args this.address, (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint
                                                        mem[96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if ext_call.return_data[0]:
                                                            if not (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint:
                                                                if ext_call.return_data[0] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require ext_call.return_data[0]
                                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                            else:
                                                                if 10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint / (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                                if ext_call.return_data[0] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require ext_call.return_data[0]
                                                                if (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_768 += 10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                                                    poolInfo[idx].field_512 = block.number
                                else:
                                    if startBlock > block.number:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if 1 > block.number - startBlock:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if decayPeriod <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require decayPeriod
                                    s = 0
                                    t = poolInfo[idx].field_512
                                    while s < block.number + -startBlock - 1 / decayPeriod:
                                        if not s + 1:
                                            if startBlock < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if decayPeriod != 0:
                                                if startBlock > startBlock:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                            if 0 >= decayTable.length:
                                                require decayTable.length - 1 < decayTable.length
                                                if not decayTable[decayTable.length]:
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = 0
                                                else:
                                                    if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                require 0 < decayTable.length
                                            mem[0] = 17
                                            if t > startBlock:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if startBlock - t:
                                                if (startBlock * decayTable) - (t * decayTable) / startBlock - t != decayTable:
                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (startBlock * decayTable) - (t * decayTable) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                            s = s + 1
                                            t = startBlock
                                            continue 
                                        if decayPeriod + (s * decayPeriod) / s + 1 != decayPeriod:
                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                        if startBlock < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if 0 == decayPeriod:
                                            if 0 >= decayTable.length:
                                                require decayTable.length - 1 < decayTable.length
                                                if not decayTable[decayTable.length]:
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = 0
                                                else:
                                                    if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                require 0 < decayTable.length
                                            mem[0] = 17
                                            if t > startBlock + decayPeriod + (s * decayPeriod):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if startBlock + decayPeriod + (s * decayPeriod) - t:
                                                if (startBlock * decayTable) + (decayPeriod * decayTable) + (s * decayPeriod * decayTable) - (t * decayTable) / startBlock + decayPeriod + (s * decayPeriod) - t != decayTable:
                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (startBlock * decayTable) + (decayPeriod * decayTable) + (s * decayPeriod * decayTable) - (t * decayTable) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                        else:
                                            if startBlock + decayPeriod + (s * decayPeriod) <= startBlock:
                                                if 0 >= decayTable.length:
                                                    require decayTable.length - 1 < decayTable.length
                                                    if not decayTable[decayTable.length]:
                                                        decayTable.length++
                                                        decayTable[decayTable.length] = 0
                                                    else:
                                                        if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        decayTable.length++
                                                        decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                    require 0 < decayTable.length
                                                mem[0] = 17
                                                if t > startBlock + decayPeriod + (s * decayPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if startBlock + decayPeriod + (s * decayPeriod) - t:
                                                    if (startBlock * decayTable) + (decayPeriod * decayTable) + (s * decayPeriod * decayTable) - (t * decayTable) / startBlock + decayPeriod + (s * decayPeriod) - t != decayTable:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (startBlock * decayTable) + (decayPeriod * decayTable) + (s * decayPeriod * decayTable) - (t * decayTable) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                            else:
                                                if startBlock > startBlock + decayPeriod + (s * decayPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if 1 > decayPeriod + (s * decayPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if decayPeriod <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require decayPeriod
                                                if decayPeriod + (s * decayPeriod) - 1 / decayPeriod >= decayTable.length:
                                                    require decayTable.length - 1 < decayTable.length
                                                    if not decayTable[decayTable.length]:
                                                        decayTable.length++
                                                        decayTable[decayTable.length] = 0
                                                    else:
                                                        if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        decayTable.length++
                                                        decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                    require decayPeriod + (s * decayPeriod) - 1 / decayPeriod < decayTable.length
                                                mem[0] = 17
                                                if t > startBlock + decayPeriod + (s * decayPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if startBlock + decayPeriod + (s * decayPeriod) - t:
                                                    if (startBlock * decayTable[stor15 + (s * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (s * stor15) - 1 / stor15]) + (s * decayPeriod * decayTable[stor15 + (s * stor15) - 1 / stor15]) - (t * decayTable[stor15 + (s * stor15) - 1 / stor15]) / startBlock + decayPeriod + (s * decayPeriod) - t != decayTable[stor15 + (s * stor15) - 1 / stor15]:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (startBlock * decayTable[stor15 + (s * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (s * stor15) - 1 / stor15]) + (s * decayPeriod * decayTable[stor15 + (s * stor15) - 1 / stor15]) - (t * decayTable[stor15 + (s * stor15) - 1 / stor15]) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                        s = s + 1
                                        t = startBlock + decayPeriod + (s * decayPeriod)
                                        continue 
                                    if 0 == decayPeriod:
                                        if 0 >= decayTable.length:
                                            require decayTable.length - 1 < decayTable.length
                                            if not decayTable[decayTable.length]:
                                                decayTable.length++
                                                decayTable[decayTable.length] = 0
                                            else:
                                                if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                decayTable.length++
                                                decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                            require 0 < decayTable.length
                                        mem[0] = 17
                                        if t > block.number:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if block.number - t:
                                            if (block.number * decayTable) - (t * decayTable) / block.number - t != decayTable:
                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            if (block.number * decayTable) - (t * decayTable) < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (block.number * decayTable) - (t * decayTable) > 0:
                                                if not (block.number * decayTable) - (t * decayTable):
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    mem[100] = this.address
                                                    mem[132] = 0 / totalAllocPoint
                                                    require ext_code.size(bxhAddress)
                                                    call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, 0 / totalAllocPoint
                                                    mem[96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if ext_call.return_data[0]:
                                                        if not 0 / totalAllocPoint:
                                                            if ext_call.return_data[0] <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require ext_call.return_data[0]
                                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                        else:
                                                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                            if ext_call.return_data[0] <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require ext_call.return_data[0]
                                                            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                                else:
                                                    if (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / (block.number * decayTable) - (t * decayTable) != poolInfo[idx].field_256:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    mem[100] = this.address
                                                    mem[132] = (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                                    require ext_code.size(bxhAddress)
                                                    call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                                    mem[96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if ext_call.return_data[0]:
                                                        if not (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint:
                                                            if ext_call.return_data[0] <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require ext_call.return_data[0]
                                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                        else:
                                                            if 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                            if ext_call.return_data[0] <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require ext_call.return_data[0]
                                                            if (10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_768 += 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                    else:
                                        if block.number <= startBlock:
                                            if 0 >= decayTable.length:
                                                require decayTable.length - 1 < decayTable.length
                                                if not decayTable[decayTable.length]:
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = 0
                                                else:
                                                    if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                require 0 < decayTable.length
                                            mem[0] = 17
                                            if t > block.number:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if block.number - t:
                                                if (block.number * decayTable) - (t * decayTable) / block.number - t != decayTable:
                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (block.number * decayTable) - (t * decayTable) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if (block.number * decayTable) - (t * decayTable) > 0:
                                                    if not (block.number * decayTable) - (t * decayTable):
                                                        if totalAllocPoint <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require totalAllocPoint
                                                        mem[100] = this.address
                                                        mem[132] = 0 / totalAllocPoint
                                                        require ext_code.size(bxhAddress)
                                                        call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args this.address, 0 / totalAllocPoint
                                                        mem[96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if ext_call.return_data[0]:
                                                            if not 0 / totalAllocPoint:
                                                                if ext_call.return_data[0] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require ext_call.return_data[0]
                                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                            else:
                                                                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                                if ext_call.return_data[0] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require ext_call.return_data[0]
                                                                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                                    else:
                                                        if (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / (block.number * decayTable) - (t * decayTable) != poolInfo[idx].field_256:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if totalAllocPoint <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require totalAllocPoint
                                                        mem[100] = this.address
                                                        mem[132] = (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                                        require ext_code.size(bxhAddress)
                                                        call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args this.address, (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                                        mem[96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if ext_call.return_data[0]:
                                                            if not (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint:
                                                                if ext_call.return_data[0] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require ext_call.return_data[0]
                                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                            else:
                                                                if 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                                if ext_call.return_data[0] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require ext_call.return_data[0]
                                                                if (10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_768 += 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                                                    poolInfo[idx].field_512 = block.number
                                        else:
                                            if startBlock > block.number:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if 1 > block.number - startBlock:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if decayPeriod <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require decayPeriod
                                            if block.number + -startBlock - 1 / decayPeriod >= decayTable.length:
                                                require decayTable.length - 1 < decayTable.length
                                                if not decayTable[decayTable.length]:
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = 0
                                                else:
                                                    if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                require block.number + -startBlock - 1 / decayPeriod < decayTable.length
                                            mem[0] = 17
                                            if t > block.number:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if block.number - t:
                                                if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (t * decayTable[block.number + -stor12 - 1 / stor15]) / block.number - t != decayTable[block.number + -stor12 - 1 / stor15]:
                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (t * decayTable[block.number + -stor12 - 1 / stor15]) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (t * decayTable[block.number + -stor12 - 1 / stor15]) > 0:
                                                    if not (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (t * decayTable[block.number + -stor12 - 1 / stor15]):
                                                        if totalAllocPoint <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require totalAllocPoint
                                                        mem[100] = this.address
                                                        mem[132] = 0 / totalAllocPoint
                                                        require ext_code.size(bxhAddress)
                                                        call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args this.address, 0 / totalAllocPoint
                                                        mem[96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if ext_call.return_data[0]:
                                                            if not 0 / totalAllocPoint:
                                                                if ext_call.return_data[0] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require ext_call.return_data[0]
                                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                            else:
                                                                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                                if ext_call.return_data[0] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require ext_call.return_data[0]
                                                                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                                    else:
                                                        if (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (t * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (t * decayTable[block.number + -stor12 - 1 / stor15]) != poolInfo[idx].field_256:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if totalAllocPoint <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require totalAllocPoint
                                                        mem[100] = this.address
                                                        mem[132] = (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (t * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint
                                                        require ext_code.size(bxhAddress)
                                                        call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args this.address, (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (t * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint
                                                        mem[96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if ext_call.return_data[0]:
                                                            if not (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (t * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint:
                                                                if ext_call.return_data[0] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require ext_call.return_data[0]
                                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                            else:
                                                                if 10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (t * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint / (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (t * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                                if ext_call.return_data[0] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require ext_call.return_data[0]
                                                                if (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (t * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_768 += 10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (t * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                                                    poolInfo[idx].field_512 = block.number
                        else:
                            if startBlock > poolInfo[idx].field_512:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if 1 > poolInfo[idx].field_512 - startBlock:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if decayPeriod <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require decayPeriod
                            if 0 == decayPeriod:
                                s = poolInfo[idx].field_512 + -startBlock - 1 / decayPeriod
                                t = poolInfo[idx].field_512
                                while s < 0:
                                    if not s + 1:
                                        if startBlock < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if decayPeriod != 0:
                                            if startBlock > startBlock:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        if 0 >= decayTable.length:
                                            require decayTable.length - 1 < decayTable.length
                                            if not decayTable[decayTable.length]:
                                                decayTable.length++
                                                decayTable[decayTable.length] = 0
                                            else:
                                                if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                decayTable.length++
                                                decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                            require 0 < decayTable.length
                                        mem[0] = 17
                                        if t > startBlock:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if startBlock - t:
                                            if (startBlock * decayTable) - (t * decayTable) / startBlock - t != decayTable:
                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            if (startBlock * decayTable) - (t * decayTable) < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                        s = s + 1
                                        t = startBlock
                                        continue 
                                    if decayPeriod + (s * decayPeriod) / s + 1 != decayPeriod:
                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                    if startBlock < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if 0 == decayPeriod:
                                        if 0 >= decayTable.length:
                                            require decayTable.length - 1 < decayTable.length
                                            if not decayTable[decayTable.length]:
                                                decayTable.length++
                                                decayTable[decayTable.length] = 0
                                            else:
                                                if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                decayTable.length++
                                                decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                            require 0 < decayTable.length
                                        mem[0] = 17
                                        if t > startBlock + decayPeriod + (s * decayPeriod):
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if startBlock + decayPeriod + (s * decayPeriod) - t:
                                            if (startBlock * decayTable) + (decayPeriod * decayTable) + (s * decayPeriod * decayTable) - (t * decayTable) / startBlock + decayPeriod + (s * decayPeriod) - t != decayTable:
                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            if (startBlock * decayTable) + (decayPeriod * decayTable) + (s * decayPeriod * decayTable) - (t * decayTable) < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                    else:
                                        if startBlock + decayPeriod + (s * decayPeriod) <= startBlock:
                                            if 0 >= decayTable.length:
                                                require decayTable.length - 1 < decayTable.length
                                                if not decayTable[decayTable.length]:
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = 0
                                                else:
                                                    if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                require 0 < decayTable.length
                                            mem[0] = 17
                                            if t > startBlock + decayPeriod + (s * decayPeriod):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if startBlock + decayPeriod + (s * decayPeriod) - t:
                                                if (startBlock * decayTable) + (decayPeriod * decayTable) + (s * decayPeriod * decayTable) - (t * decayTable) / startBlock + decayPeriod + (s * decayPeriod) - t != decayTable:
                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (startBlock * decayTable) + (decayPeriod * decayTable) + (s * decayPeriod * decayTable) - (t * decayTable) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                        else:
                                            if startBlock > startBlock + decayPeriod + (s * decayPeriod):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if 1 > decayPeriod + (s * decayPeriod):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if decayPeriod <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require decayPeriod
                                            if decayPeriod + (s * decayPeriod) - 1 / decayPeriod >= decayTable.length:
                                                require decayTable.length - 1 < decayTable.length
                                                if not decayTable[decayTable.length]:
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = 0
                                                else:
                                                    if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                require decayPeriod + (s * decayPeriod) - 1 / decayPeriod < decayTable.length
                                            mem[0] = 17
                                            if t > startBlock + decayPeriod + (s * decayPeriod):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if startBlock + decayPeriod + (s * decayPeriod) - t:
                                                if (startBlock * decayTable[stor15 + (s * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (s * stor15) - 1 / stor15]) + (s * decayPeriod * decayTable[stor15 + (s * stor15) - 1 / stor15]) - (t * decayTable[stor15 + (s * stor15) - 1 / stor15]) / startBlock + decayPeriod + (s * decayPeriod) - t != decayTable[stor15 + (s * stor15) - 1 / stor15]:
                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (startBlock * decayTable[stor15 + (s * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (s * stor15) - 1 / stor15]) + (s * decayPeriod * decayTable[stor15 + (s * stor15) - 1 / stor15]) - (t * decayTable[stor15 + (s * stor15) - 1 / stor15]) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                    s = s + 1
                                    t = startBlock + decayPeriod + (s * decayPeriod)
                                    continue 
                            else:
                                if block.number <= startBlock:
                                    s = poolInfo[idx].field_512 + -startBlock - 1 / decayPeriod
                                    t = poolInfo[idx].field_512
                                    while s < 0:
                                        if not s + 1:
                                            if startBlock < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if decayPeriod != 0:
                                                if startBlock > startBlock:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                            if 0 >= decayTable.length:
                                                require decayTable.length - 1 < decayTable.length
                                                if not decayTable[decayTable.length]:
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = 0
                                                else:
                                                    if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                require 0 < decayTable.length
                                            mem[0] = 17
                                            if t > startBlock:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if startBlock - t:
                                                if (startBlock * decayTable) - (t * decayTable) / startBlock - t != decayTable:
                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (startBlock * decayTable) - (t * decayTable) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                            s = s + 1
                                            t = startBlock
                                            continue 
                                        if decayPeriod + (s * decayPeriod) / s + 1 != decayPeriod:
                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                        if startBlock < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if 0 == decayPeriod:
                                            if 0 >= decayTable.length:
                                                require decayTable.length - 1 < decayTable.length
                                                if not decayTable[decayTable.length]:
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = 0
                                                else:
                                                    if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                require 0 < decayTable.length
                                            mem[0] = 17
                                            if t > startBlock + decayPeriod + (s * decayPeriod):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if startBlock + decayPeriod + (s * decayPeriod) - t:
                                                if (startBlock * decayTable) + (decayPeriod * decayTable) + (s * decayPeriod * decayTable) - (t * decayTable) / startBlock + decayPeriod + (s * decayPeriod) - t != decayTable:
                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (startBlock * decayTable) + (decayPeriod * decayTable) + (s * decayPeriod * decayTable) - (t * decayTable) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                        else:
                                            if startBlock + decayPeriod + (s * decayPeriod) <= startBlock:
                                                if 0 >= decayTable.length:
                                                    require decayTable.length - 1 < decayTable.length
                                                    if not decayTable[decayTable.length]:
                                                        decayTable.length++
                                                        decayTable[decayTable.length] = 0
                                                    else:
                                                        if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        decayTable.length++
                                                        decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                    require 0 < decayTable.length
                                                mem[0] = 17
                                                if t > startBlock + decayPeriod + (s * decayPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if startBlock + decayPeriod + (s * decayPeriod) - t:
                                                    if (startBlock * decayTable) + (decayPeriod * decayTable) + (s * decayPeriod * decayTable) - (t * decayTable) / startBlock + decayPeriod + (s * decayPeriod) - t != decayTable:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (startBlock * decayTable) + (decayPeriod * decayTable) + (s * decayPeriod * decayTable) - (t * decayTable) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                            else:
                                                if startBlock > startBlock + decayPeriod + (s * decayPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if 1 > decayPeriod + (s * decayPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if decayPeriod <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require decayPeriod
                                                if decayPeriod + (s * decayPeriod) - 1 / decayPeriod >= decayTable.length:
                                                    require decayTable.length - 1 < decayTable.length
                                                    if not decayTable[decayTable.length]:
                                                        decayTable.length++
                                                        decayTable[decayTable.length] = 0
                                                    else:
                                                        if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        decayTable.length++
                                                        decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                    require decayPeriod + (s * decayPeriod) - 1 / decayPeriod < decayTable.length
                                                mem[0] = 17
                                                if t > startBlock + decayPeriod + (s * decayPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if startBlock + decayPeriod + (s * decayPeriod) - t:
                                                    if (startBlock * decayTable[stor15 + (s * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (s * stor15) - 1 / stor15]) + (s * decayPeriod * decayTable[stor15 + (s * stor15) - 1 / stor15]) - (t * decayTable[stor15 + (s * stor15) - 1 / stor15]) / startBlock + decayPeriod + (s * decayPeriod) - t != decayTable[stor15 + (s * stor15) - 1 / stor15]:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (startBlock * decayTable[stor15 + (s * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (s * stor15) - 1 / stor15]) + (s * decayPeriod * decayTable[stor15 + (s * stor15) - 1 / stor15]) - (t * decayTable[stor15 + (s * stor15) - 1 / stor15]) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                        s = s + 1
                                        t = startBlock + decayPeriod + (s * decayPeriod)
                                        continue 
                                else:
                                    if startBlock > block.number:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if 1 > block.number - startBlock:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if decayPeriod <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require decayPeriod
                                    s = poolInfo[idx].field_512 + -startBlock - 1 / decayPeriod
                                    t = poolInfo[idx].field_512
                                    while s < block.number + -startBlock - 1 / decayPeriod:
                                        if not s + 1:
                                            if startBlock < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if decayPeriod != 0:
                                                if startBlock > startBlock:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                            if 0 >= decayTable.length:
                                                require decayTable.length - 1 < decayTable.length
                                                if not decayTable[decayTable.length]:
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = 0
                                                else:
                                                    if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                require 0 < decayTable.length
                                            mem[0] = 17
                                            if t > startBlock:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if startBlock - t:
                                                if (startBlock * decayTable) - (t * decayTable) / startBlock - t != decayTable:
                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (startBlock * decayTable) - (t * decayTable) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                            s = s + 1
                                            t = startBlock
                                            continue 
                                        if decayPeriod + (s * decayPeriod) / s + 1 != decayPeriod:
                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                        if startBlock < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if 0 == decayPeriod:
                                            if 0 >= decayTable.length:
                                                require decayTable.length - 1 < decayTable.length
                                                if not decayTable[decayTable.length]:
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = 0
                                                else:
                                                    if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                require 0 < decayTable.length
                                            mem[0] = 17
                                            if t > startBlock + decayPeriod + (s * decayPeriod):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if startBlock + decayPeriod + (s * decayPeriod) - t:
                                                if (startBlock * decayTable) + (decayPeriod * decayTable) + (s * decayPeriod * decayTable) - (t * decayTable) / startBlock + decayPeriod + (s * decayPeriod) - t != decayTable:
                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (startBlock * decayTable) + (decayPeriod * decayTable) + (s * decayPeriod * decayTable) - (t * decayTable) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                        else:
                                            if startBlock + decayPeriod + (s * decayPeriod) <= startBlock:
                                                if 0 >= decayTable.length:
                                                    require decayTable.length - 1 < decayTable.length
                                                    if not decayTable[decayTable.length]:
                                                        decayTable.length++
                                                        decayTable[decayTable.length] = 0
                                                    else:
                                                        if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        decayTable.length++
                                                        decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                    require 0 < decayTable.length
                                                mem[0] = 17
                                                if t > startBlock + decayPeriod + (s * decayPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if startBlock + decayPeriod + (s * decayPeriod) - t:
                                                    if (startBlock * decayTable) + (decayPeriod * decayTable) + (s * decayPeriod * decayTable) - (t * decayTable) / startBlock + decayPeriod + (s * decayPeriod) - t != decayTable:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (startBlock * decayTable) + (decayPeriod * decayTable) + (s * decayPeriod * decayTable) - (t * decayTable) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                            else:
                                                if startBlock > startBlock + decayPeriod + (s * decayPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if 1 > decayPeriod + (s * decayPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if decayPeriod <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require decayPeriod
                                                if decayPeriod + (s * decayPeriod) - 1 / decayPeriod >= decayTable.length:
                                                    require decayTable.length - 1 < decayTable.length
                                                    if not decayTable[decayTable.length]:
                                                        decayTable.length++
                                                        decayTable[decayTable.length] = 0
                                                    else:
                                                        if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        decayTable.length++
                                                        decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                    require decayPeriod + (s * decayPeriod) - 1 / decayPeriod < decayTable.length
                                                mem[0] = 17
                                                if t > startBlock + decayPeriod + (s * decayPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if startBlock + decayPeriod + (s * decayPeriod) - t:
                                                    if (startBlock * decayTable[stor15 + (s * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (s * stor15) - 1 / stor15]) + (s * decayPeriod * decayTable[stor15 + (s * stor15) - 1 / stor15]) - (t * decayTable[stor15 + (s * stor15) - 1 / stor15]) / startBlock + decayPeriod + (s * decayPeriod) - t != decayTable[stor15 + (s * stor15) - 1 / stor15]:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (startBlock * decayTable[stor15 + (s * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (s * stor15) - 1 / stor15]) + (s * decayPeriod * decayTable[stor15 + (s * stor15) - 1 / stor15]) - (t * decayTable[stor15 + (s * stor15) - 1 / stor15]) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                        s = s + 1
                                        t = startBlock + decayPeriod + (s * decayPeriod)
                                        continue 
                            if 0 == decayPeriod:
                                if 0 >= decayTable.length:
                                    require decayTable.length - 1 < decayTable.length
                                    if not decayTable[decayTable.length]:
                                        decayTable.length++
                                        decayTable[decayTable.length] = 0
                                    else:
                                        if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                        decayTable.length++
                                        decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                    require 0 < decayTable.length
                                mem[0] = 17
                                if t > block.number:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if block.number - t:
                                    if (block.number * decayTable) - (t * decayTable) / block.number - t != decayTable:
                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                    if (block.number * decayTable) - (t * decayTable) < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (block.number * decayTable) - (t * decayTable) > 0:
                                        if not (block.number * decayTable) - (t * decayTable):
                                            if totalAllocPoint <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalAllocPoint
                                            mem[100] = this.address
                                            mem[132] = 0 / totalAllocPoint
                                            require ext_code.size(bxhAddress)
                                            call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                 gas gas_remaining wei
                                                args this.address, 0 / totalAllocPoint
                                            mem[96] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if ext_call.return_data[0]:
                                                if not 0 / totalAllocPoint:
                                                    if ext_call.return_data[0] <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require ext_call.return_data[0]
                                                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                else:
                                                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if ext_call.return_data[0] <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require ext_call.return_data[0]
                                                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                        else:
                                            if (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / (block.number * decayTable) - (t * decayTable) != poolInfo[idx].field_256:
                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            if totalAllocPoint <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalAllocPoint
                                            mem[100] = this.address
                                            mem[132] = (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                            require ext_code.size(bxhAddress)
                                            call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                 gas gas_remaining wei
                                                args this.address, (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                            mem[96] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if ext_call.return_data[0]:
                                                if not (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint:
                                                    if ext_call.return_data[0] <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require ext_call.return_data[0]
                                                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                else:
                                                    if 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if ext_call.return_data[0] <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require ext_call.return_data[0]
                                                    if (10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                            else:
                                if block.number <= startBlock:
                                    if 0 >= decayTable.length:
                                        require decayTable.length - 1 < decayTable.length
                                        if not decayTable[decayTable.length]:
                                            decayTable.length++
                                            decayTable[decayTable.length] = 0
                                        else:
                                            if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            decayTable.length++
                                            decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                        require 0 < decayTable.length
                                    mem[0] = 17
                                    if t > block.number:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if block.number - t:
                                        if (block.number * decayTable) - (t * decayTable) / block.number - t != decayTable:
                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                        if (block.number * decayTable) - (t * decayTable) < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (block.number * decayTable) - (t * decayTable) > 0:
                                            if not (block.number * decayTable) - (t * decayTable):
                                                if totalAllocPoint <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalAllocPoint
                                                mem[100] = this.address
                                                mem[132] = 0 / totalAllocPoint
                                                require ext_code.size(bxhAddress)
                                                call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args this.address, 0 / totalAllocPoint
                                                mem[96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if ext_call.return_data[0]:
                                                    if not 0 / totalAllocPoint:
                                                        if ext_call.return_data[0] <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require ext_call.return_data[0]
                                                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                    else:
                                                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if ext_call.return_data[0] <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require ext_call.return_data[0]
                                                        if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                            else:
                                                if (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / (block.number * decayTable) - (t * decayTable) != poolInfo[idx].field_256:
                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if totalAllocPoint <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalAllocPoint
                                                mem[100] = this.address
                                                mem[132] = (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                                require ext_code.size(bxhAddress)
                                                call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args this.address, (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                                mem[96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if ext_call.return_data[0]:
                                                    if not (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint:
                                                        if ext_call.return_data[0] <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require ext_call.return_data[0]
                                                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                    else:
                                                        if 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if ext_call.return_data[0] <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require ext_call.return_data[0]
                                                        if (10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_768 += 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                else:
                                    if startBlock > block.number:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if 1 > block.number - startBlock:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if decayPeriod <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require decayPeriod
                                    if block.number + -startBlock - 1 / decayPeriod >= decayTable.length:
                                        require decayTable.length - 1 < decayTable.length
                                        if not decayTable[decayTable.length]:
                                            decayTable.length++
                                            decayTable[decayTable.length] = 0
                                        else:
                                            if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            decayTable.length++
                                            decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                        require block.number + -startBlock - 1 / decayPeriod < decayTable.length
                                    mem[0] = 17
                                    if t > block.number:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if block.number - t:
                                        if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (t * decayTable[block.number + -stor12 - 1 / stor15]) / block.number - t != decayTable[block.number + -stor12 - 1 / stor15]:
                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                        if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (t * decayTable[block.number + -stor12 - 1 / stor15]) < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (t * decayTable[block.number + -stor12 - 1 / stor15]) > 0:
                                            if not (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (t * decayTable[block.number + -stor12 - 1 / stor15]):
                                                if totalAllocPoint <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalAllocPoint
                                                mem[100] = this.address
                                                mem[132] = 0 / totalAllocPoint
                                                require ext_code.size(bxhAddress)
                                                call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args this.address, 0 / totalAllocPoint
                                                mem[96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if ext_call.return_data[0]:
                                                    if not 0 / totalAllocPoint:
                                                        if ext_call.return_data[0] <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require ext_call.return_data[0]
                                                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                    else:
                                                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if ext_call.return_data[0] <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require ext_call.return_data[0]
                                                        if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                            else:
                                                if (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (t * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (t * decayTable[block.number + -stor12 - 1 / stor15]) != poolInfo[idx].field_256:
                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if totalAllocPoint <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalAllocPoint
                                                mem[100] = this.address
                                                mem[132] = (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (t * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint
                                                require ext_code.size(bxhAddress)
                                                call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args this.address, (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (t * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint
                                                mem[96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if ext_call.return_data[0]:
                                                    if not (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (t * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint:
                                                        if ext_call.return_data[0] <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require ext_call.return_data[0]
                                                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                    else:
                                                        if 10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (t * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint / (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (t * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if ext_call.return_data[0] <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require ext_call.return_data[0]
                                                        if (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (t * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_768 += 10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (t * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
        idx = idx + 1
        continue 
}

function setBXHPerBlock(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'wOwnable: caller is not the owne'
    idx = 0
    while idx < poolInfo.length:
        mem[0] = 6
        if block.number > poolInfo[idx].field_512:
            mem[0] = poolInfo[idx].field_0
            mem[32] = 3
            if stor3[stor6[idx].field_0]:
                if not poolInfo[idx].field_1280:
                    poolInfo[idx].field_512 = block.number
                else:
                    if 0 == decayPeriod:
                        if 0 == decayPeriod:
                            if 0 >= decayTable.length:
                                require decayTable.length - 1 < decayTable.length
                                if not decayTable[decayTable.length]:
                                    decayTable.length++
                                    decayTable[decayTable.length] = 0
                                else:
                                    if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                    decayTable.length++
                                    decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                require 0 < decayTable.length
                            mem[0] = 17
                            if poolInfo[idx].field_512 > block.number:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if block.number - poolInfo[idx].field_512:
                                if (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) / block.number - poolInfo[idx].field_512 != decayTable:
                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                if (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) > 0:
                                    if not (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable):
                                        if totalAllocPoint <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalAllocPoint
                                        mem[100] = this.address
                                        mem[132] = 0 / totalAllocPoint
                                        require ext_code.size(bxhAddress)
                                        call bxhAddress.mint(address arg1, uint256 arg2) with:
                                             gas gas_remaining wei
                                            args this.address, 0 / totalAllocPoint
                                        mem[96] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0]:
                                            if not 0 / totalAllocPoint:
                                                if poolInfo[idx].field_1280 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require poolInfo[idx].field_1280
                                                if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                            else:
                                                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if poolInfo[idx].field_1280 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require poolInfo[idx].field_1280
                                                if (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1280
                                    else:
                                        if (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) != poolInfo[idx].field_256:
                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                        if totalAllocPoint <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalAllocPoint
                                        mem[100] = this.address
                                        mem[132] = (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                        require ext_code.size(bxhAddress)
                                        call bxhAddress.mint(address arg1, uint256 arg2) with:
                                             gas gas_remaining wei
                                            args this.address, (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                        mem[96] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0]:
                                            if not (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint:
                                                if poolInfo[idx].field_1280 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require poolInfo[idx].field_1280
                                                if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                            else:
                                                if 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if poolInfo[idx].field_1280 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require poolInfo[idx].field_1280
                                                if (10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_1280
                                    poolInfo[idx].field_512 = block.number
                        else:
                            if block.number <= startBlock:
                                if 0 >= decayTable.length:
                                    require decayTable.length - 1 < decayTable.length
                                    if not decayTable[decayTable.length]:
                                        decayTable.length++
                                        decayTable[decayTable.length] = 0
                                    else:
                                        if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                        decayTable.length++
                                        decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                    require 0 < decayTable.length
                                mem[0] = 17
                                if poolInfo[idx].field_512 > block.number:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if block.number - poolInfo[idx].field_512:
                                    if (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) / block.number - poolInfo[idx].field_512 != decayTable:
                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                    if (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) > 0:
                                        if not (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable):
                                            if totalAllocPoint <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalAllocPoint
                                            mem[100] = this.address
                                            mem[132] = 0 / totalAllocPoint
                                            require ext_code.size(bxhAddress)
                                            call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                 gas gas_remaining wei
                                                args this.address, 0 / totalAllocPoint
                                            mem[96] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if ext_call.return_data[0]:
                                                if not 0 / totalAllocPoint:
                                                    if poolInfo[idx].field_1280 <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require poolInfo[idx].field_1280
                                                    if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                else:
                                                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if poolInfo[idx].field_1280 <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require poolInfo[idx].field_1280
                                                    if (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1280
                                        else:
                                            if (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) != poolInfo[idx].field_256:
                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            if totalAllocPoint <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalAllocPoint
                                            mem[100] = this.address
                                            mem[132] = (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                            require ext_code.size(bxhAddress)
                                            call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                 gas gas_remaining wei
                                                args this.address, (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                            mem[96] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if ext_call.return_data[0]:
                                                if not (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint:
                                                    if poolInfo[idx].field_1280 <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require poolInfo[idx].field_1280
                                                    if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                else:
                                                    if 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if poolInfo[idx].field_1280 <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require poolInfo[idx].field_1280
                                                    if (10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_1280
                                        poolInfo[idx].field_512 = block.number
                            else:
                                if startBlock > block.number:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if 1 > block.number - startBlock:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if decayPeriod <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require decayPeriod
                                if block.number + -startBlock - 1 / decayPeriod >= decayTable.length:
                                    require decayTable.length - 1 < decayTable.length
                                    if not decayTable[decayTable.length]:
                                        decayTable.length++
                                        decayTable[decayTable.length] = 0
                                    else:
                                        if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                        decayTable.length++
                                        decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                    require block.number + -startBlock - 1 / decayPeriod < decayTable.length
                                mem[0] = 17
                                if poolInfo[idx].field_512 > block.number:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if block.number - poolInfo[idx].field_512:
                                    if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) / block.number - poolInfo[idx].field_512 != decayTable[block.number + -stor12 - 1 / stor15]:
                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                    if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) > 0:
                                        if not (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15]):
                                            if totalAllocPoint <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalAllocPoint
                                            mem[100] = this.address
                                            mem[132] = 0 / totalAllocPoint
                                            require ext_code.size(bxhAddress)
                                            call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                 gas gas_remaining wei
                                                args this.address, 0 / totalAllocPoint
                                            mem[96] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if ext_call.return_data[0]:
                                                if not 0 / totalAllocPoint:
                                                    if poolInfo[idx].field_1280 <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require poolInfo[idx].field_1280
                                                    if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                else:
                                                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if poolInfo[idx].field_1280 <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require poolInfo[idx].field_1280
                                                    if (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1280
                                        else:
                                            if (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) != poolInfo[idx].field_256:
                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            if totalAllocPoint <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalAllocPoint
                                            mem[100] = this.address
                                            mem[132] = (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint
                                            require ext_code.size(bxhAddress)
                                            call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                 gas gas_remaining wei
                                                args this.address, (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint
                                            mem[96] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if ext_call.return_data[0]:
                                                if not (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint:
                                                    if poolInfo[idx].field_1280 <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require poolInfo[idx].field_1280
                                                    if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                else:
                                                    if 10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint / (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if poolInfo[idx].field_1280 <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require poolInfo[idx].field_1280
                                                    if (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_1280
                                        poolInfo[idx].field_512 = block.number
                    else:
                        if poolInfo[idx].field_512 <= startBlock:
                            if 0 == decayPeriod:
                                if 0 == decayPeriod:
                                    if 0 >= decayTable.length:
                                        require decayTable.length - 1 < decayTable.length
                                        if not decayTable[decayTable.length]:
                                            decayTable.length++
                                            decayTable[decayTable.length] = 0
                                        else:
                                            if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            decayTable.length++
                                            decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                        require 0 < decayTable.length
                                    mem[0] = 17
                                    if poolInfo[idx].field_512 > block.number:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if block.number - poolInfo[idx].field_512:
                                        if (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) / block.number - poolInfo[idx].field_512 != decayTable:
                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                        if (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) > 0:
                                            if not (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable):
                                                if totalAllocPoint <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalAllocPoint
                                                mem[100] = this.address
                                                mem[132] = 0 / totalAllocPoint
                                                require ext_code.size(bxhAddress)
                                                call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args this.address, 0 / totalAllocPoint
                                                mem[96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if ext_call.return_data[0]:
                                                    if not 0 / totalAllocPoint:
                                                        if poolInfo[idx].field_1280 <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require poolInfo[idx].field_1280
                                                        if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                    else:
                                                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if poolInfo[idx].field_1280 <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require poolInfo[idx].field_1280
                                                        if (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1280
                                            else:
                                                if (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) != poolInfo[idx].field_256:
                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if totalAllocPoint <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalAllocPoint
                                                mem[100] = this.address
                                                mem[132] = (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                                require ext_code.size(bxhAddress)
                                                call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args this.address, (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                                mem[96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if ext_call.return_data[0]:
                                                    if not (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint:
                                                        if poolInfo[idx].field_1280 <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require poolInfo[idx].field_1280
                                                        if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                    else:
                                                        if 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if poolInfo[idx].field_1280 <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require poolInfo[idx].field_1280
                                                        if (10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_768 += 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_1280
                                            poolInfo[idx].field_512 = block.number
                                else:
                                    if block.number <= startBlock:
                                        if 0 >= decayTable.length:
                                            require decayTable.length - 1 < decayTable.length
                                            if not decayTable[decayTable.length]:
                                                decayTable.length++
                                                decayTable[decayTable.length] = 0
                                            else:
                                                if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                decayTable.length++
                                                decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                            require 0 < decayTable.length
                                        mem[0] = 17
                                        if poolInfo[idx].field_512 > block.number:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if block.number - poolInfo[idx].field_512:
                                            if (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) / block.number - poolInfo[idx].field_512 != decayTable:
                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            if (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) > 0:
                                                if not (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable):
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    mem[100] = this.address
                                                    mem[132] = 0 / totalAllocPoint
                                                    require ext_code.size(bxhAddress)
                                                    call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, 0 / totalAllocPoint
                                                    mem[96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if ext_call.return_data[0]:
                                                        if not 0 / totalAllocPoint:
                                                            if poolInfo[idx].field_1280 <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require poolInfo[idx].field_1280
                                                            if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                        else:
                                                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                            if poolInfo[idx].field_1280 <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require poolInfo[idx].field_1280
                                                            if (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1280
                                                else:
                                                    if (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) != poolInfo[idx].field_256:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    mem[100] = this.address
                                                    mem[132] = (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                                    require ext_code.size(bxhAddress)
                                                    call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                                    mem[96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if ext_call.return_data[0]:
                                                        if not (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint:
                                                            if poolInfo[idx].field_1280 <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require poolInfo[idx].field_1280
                                                            if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                        else:
                                                            if 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                            if poolInfo[idx].field_1280 <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require poolInfo[idx].field_1280
                                                            if (10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_768 += 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_1280
                                                poolInfo[idx].field_512 = block.number
                                    else:
                                        if startBlock > block.number:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if 1 > block.number - startBlock:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if decayPeriod <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require decayPeriod
                                        if block.number + -startBlock - 1 / decayPeriod >= decayTable.length:
                                            require decayTable.length - 1 < decayTable.length
                                            if not decayTable[decayTable.length]:
                                                decayTable.length++
                                                decayTable[decayTable.length] = 0
                                            else:
                                                if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                decayTable.length++
                                                decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                            require block.number + -startBlock - 1 / decayPeriod < decayTable.length
                                        mem[0] = 17
                                        if poolInfo[idx].field_512 > block.number:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if block.number - poolInfo[idx].field_512:
                                            if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) / block.number - poolInfo[idx].field_512 != decayTable[block.number + -stor12 - 1 / stor15]:
                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) > 0:
                                                if not (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15]):
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    mem[100] = this.address
                                                    mem[132] = 0 / totalAllocPoint
                                                    require ext_code.size(bxhAddress)
                                                    call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, 0 / totalAllocPoint
                                                    mem[96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if ext_call.return_data[0]:
                                                        if not 0 / totalAllocPoint:
                                                            if poolInfo[idx].field_1280 <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require poolInfo[idx].field_1280
                                                            if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                        else:
                                                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                            if poolInfo[idx].field_1280 <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require poolInfo[idx].field_1280
                                                            if (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1280
                                                else:
                                                    if (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) != poolInfo[idx].field_256:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    mem[100] = this.address
                                                    mem[132] = (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint
                                                    require ext_code.size(bxhAddress)
                                                    call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint
                                                    mem[96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if ext_call.return_data[0]:
                                                        if not (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint:
                                                            if poolInfo[idx].field_1280 <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require poolInfo[idx].field_1280
                                                            if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                        else:
                                                            if 10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint / (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                            if poolInfo[idx].field_1280 <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require poolInfo[idx].field_1280
                                                            if (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_768 += 10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_1280
                                                poolInfo[idx].field_512 = block.number
                            else:
                                if block.number <= startBlock:
                                    if 0 == decayPeriod:
                                        if 0 >= decayTable.length:
                                            require decayTable.length - 1 < decayTable.length
                                            if not decayTable[decayTable.length]:
                                                decayTable.length++
                                                decayTable[decayTable.length] = 0
                                            else:
                                                if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                decayTable.length++
                                                decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                            require 0 < decayTable.length
                                        mem[0] = 17
                                        if poolInfo[idx].field_512 > block.number:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if block.number - poolInfo[idx].field_512:
                                            if (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) / block.number - poolInfo[idx].field_512 != decayTable:
                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            if (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) > 0:
                                                if not (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable):
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    mem[100] = this.address
                                                    mem[132] = 0 / totalAllocPoint
                                                    require ext_code.size(bxhAddress)
                                                    call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, 0 / totalAllocPoint
                                                    mem[96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if ext_call.return_data[0]:
                                                        if not 0 / totalAllocPoint:
                                                            if poolInfo[idx].field_1280 <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require poolInfo[idx].field_1280
                                                            if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                        else:
                                                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                            if poolInfo[idx].field_1280 <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require poolInfo[idx].field_1280
                                                            if (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1280
                                                else:
                                                    if (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) != poolInfo[idx].field_256:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    mem[100] = this.address
                                                    mem[132] = (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                                    require ext_code.size(bxhAddress)
                                                    call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                                    mem[96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if ext_call.return_data[0]:
                                                        if not (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint:
                                                            if poolInfo[idx].field_1280 <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require poolInfo[idx].field_1280
                                                            if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                        else:
                                                            if 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                            if poolInfo[idx].field_1280 <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require poolInfo[idx].field_1280
                                                            if (10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_768 += 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_1280
                                                poolInfo[idx].field_512 = block.number
                                    else:
                                        if block.number <= startBlock:
                                            if 0 >= decayTable.length:
                                                require decayTable.length - 1 < decayTable.length
                                                if not decayTable[decayTable.length]:
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = 0
                                                else:
                                                    if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                require 0 < decayTable.length
                                            mem[0] = 17
                                            if poolInfo[idx].field_512 > block.number:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if block.number - poolInfo[idx].field_512:
                                                if (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) / block.number - poolInfo[idx].field_512 != decayTable:
                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) > 0:
                                                    if not (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable):
                                                        if totalAllocPoint <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require totalAllocPoint
                                                        mem[100] = this.address
                                                        mem[132] = 0 / totalAllocPoint
                                                        require ext_code.size(bxhAddress)
                                                        call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args this.address, 0 / totalAllocPoint
                                                        mem[96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if ext_call.return_data[0]:
                                                            if not 0 / totalAllocPoint:
                                                                if poolInfo[idx].field_1280 <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require poolInfo[idx].field_1280
                                                                if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                            else:
                                                                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                                if poolInfo[idx].field_1280 <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require poolInfo[idx].field_1280
                                                                if (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1280
                                                    else:
                                                        if (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) != poolInfo[idx].field_256:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if totalAllocPoint <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require totalAllocPoint
                                                        mem[100] = this.address
                                                        mem[132] = (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                                        require ext_code.size(bxhAddress)
                                                        call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args this.address, (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                                        mem[96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if ext_call.return_data[0]:
                                                            if not (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint:
                                                                if poolInfo[idx].field_1280 <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require poolInfo[idx].field_1280
                                                                if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                            else:
                                                                if 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                                if poolInfo[idx].field_1280 <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require poolInfo[idx].field_1280
                                                                if (10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_768 += 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_1280
                                                    poolInfo[idx].field_512 = block.number
                                        else:
                                            if startBlock > block.number:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if 1 > block.number - startBlock:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if decayPeriod <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require decayPeriod
                                            if block.number + -startBlock - 1 / decayPeriod >= decayTable.length:
                                                require decayTable.length - 1 < decayTable.length
                                                if not decayTable[decayTable.length]:
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = 0
                                                else:
                                                    if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                require block.number + -startBlock - 1 / decayPeriod < decayTable.length
                                            mem[0] = 17
                                            if poolInfo[idx].field_512 > block.number:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if block.number - poolInfo[idx].field_512:
                                                if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) / block.number - poolInfo[idx].field_512 != decayTable[block.number + -stor12 - 1 / stor15]:
                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) > 0:
                                                    if not (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15]):
                                                        if totalAllocPoint <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require totalAllocPoint
                                                        mem[100] = this.address
                                                        mem[132] = 0 / totalAllocPoint
                                                        require ext_code.size(bxhAddress)
                                                        call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args this.address, 0 / totalAllocPoint
                                                        mem[96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if ext_call.return_data[0]:
                                                            if not 0 / totalAllocPoint:
                                                                if poolInfo[idx].field_1280 <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require poolInfo[idx].field_1280
                                                                if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                            else:
                                                                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                                if poolInfo[idx].field_1280 <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require poolInfo[idx].field_1280
                                                                if (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1280
                                                    else:
                                                        if (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) != poolInfo[idx].field_256:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if totalAllocPoint <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require totalAllocPoint
                                                        mem[100] = this.address
                                                        mem[132] = (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint
                                                        require ext_code.size(bxhAddress)
                                                        call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args this.address, (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint
                                                        mem[96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if ext_call.return_data[0]:
                                                            if not (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint:
                                                                if poolInfo[idx].field_1280 <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require poolInfo[idx].field_1280
                                                                if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                            else:
                                                                if 10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint / (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                                if poolInfo[idx].field_1280 <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require poolInfo[idx].field_1280
                                                                if (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_768 += 10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_1280
                                                    poolInfo[idx].field_512 = block.number
                                else:
                                    if startBlock > block.number:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if 1 > block.number - startBlock:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if decayPeriod <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require decayPeriod
                                    s = 0
                                    t = poolInfo[idx].field_512
                                    while s < block.number + -startBlock - 1 / decayPeriod:
                                        if not s + 1:
                                            if startBlock < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if decayPeriod != 0:
                                                if startBlock > startBlock:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                            if 0 >= decayTable.length:
                                                require decayTable.length - 1 < decayTable.length
                                                if not decayTable[decayTable.length]:
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = 0
                                                else:
                                                    if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                require 0 < decayTable.length
                                            mem[0] = 17
                                            if t > startBlock:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if startBlock - t:
                                                if (startBlock * decayTable) - (t * decayTable) / startBlock - t != decayTable:
                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (startBlock * decayTable) - (t * decayTable) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                            s = s + 1
                                            t = startBlock
                                            continue 
                                        if decayPeriod + (s * decayPeriod) / s + 1 != decayPeriod:
                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                        if startBlock < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if 0 == decayPeriod:
                                            if 0 >= decayTable.length:
                                                require decayTable.length - 1 < decayTable.length
                                                if not decayTable[decayTable.length]:
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = 0
                                                else:
                                                    if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                require 0 < decayTable.length
                                            mem[0] = 17
                                            if t > startBlock + decayPeriod + (s * decayPeriod):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if startBlock + decayPeriod + (s * decayPeriod) - t:
                                                if (startBlock * decayTable) + (decayPeriod * decayTable) + (s * decayPeriod * decayTable) - (t * decayTable) / startBlock + decayPeriod + (s * decayPeriod) - t != decayTable:
                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (startBlock * decayTable) + (decayPeriod * decayTable) + (s * decayPeriod * decayTable) - (t * decayTable) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                        else:
                                            if startBlock + decayPeriod + (s * decayPeriod) <= startBlock:
                                                if 0 >= decayTable.length:
                                                    require decayTable.length - 1 < decayTable.length
                                                    if not decayTable[decayTable.length]:
                                                        decayTable.length++
                                                        decayTable[decayTable.length] = 0
                                                    else:
                                                        if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        decayTable.length++
                                                        decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                    require 0 < decayTable.length
                                                mem[0] = 17
                                                if t > startBlock + decayPeriod + (s * decayPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if startBlock + decayPeriod + (s * decayPeriod) - t:
                                                    if (startBlock * decayTable) + (decayPeriod * decayTable) + (s * decayPeriod * decayTable) - (t * decayTable) / startBlock + decayPeriod + (s * decayPeriod) - t != decayTable:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (startBlock * decayTable) + (decayPeriod * decayTable) + (s * decayPeriod * decayTable) - (t * decayTable) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                            else:
                                                if startBlock > startBlock + decayPeriod + (s * decayPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if 1 > decayPeriod + (s * decayPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if decayPeriod <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require decayPeriod
                                                if decayPeriod + (s * decayPeriod) - 1 / decayPeriod >= decayTable.length:
                                                    require decayTable.length - 1 < decayTable.length
                                                    if not decayTable[decayTable.length]:
                                                        decayTable.length++
                                                        decayTable[decayTable.length] = 0
                                                    else:
                                                        if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        decayTable.length++
                                                        decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                    require decayPeriod + (s * decayPeriod) - 1 / decayPeriod < decayTable.length
                                                mem[0] = 17
                                                if t > startBlock + decayPeriod + (s * decayPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if startBlock + decayPeriod + (s * decayPeriod) - t:
                                                    if (startBlock * decayTable[stor15 + (s * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (s * stor15) - 1 / stor15]) + (s * decayPeriod * decayTable[stor15 + (s * stor15) - 1 / stor15]) - (t * decayTable[stor15 + (s * stor15) - 1 / stor15]) / startBlock + decayPeriod + (s * decayPeriod) - t != decayTable[stor15 + (s * stor15) - 1 / stor15]:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (startBlock * decayTable[stor15 + (s * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (s * stor15) - 1 / stor15]) + (s * decayPeriod * decayTable[stor15 + (s * stor15) - 1 / stor15]) - (t * decayTable[stor15 + (s * stor15) - 1 / stor15]) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                        s = s + 1
                                        t = startBlock + decayPeriod + (s * decayPeriod)
                                        continue 
                                    if 0 == decayPeriod:
                                        if 0 >= decayTable.length:
                                            require decayTable.length - 1 < decayTable.length
                                            if not decayTable[decayTable.length]:
                                                decayTable.length++
                                                decayTable[decayTable.length] = 0
                                            else:
                                                if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                decayTable.length++
                                                decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                            require 0 < decayTable.length
                                        mem[0] = 17
                                        if t > block.number:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if block.number - t:
                                            if (block.number * decayTable) - (t * decayTable) / block.number - t != decayTable:
                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            if (block.number * decayTable) - (t * decayTable) < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (block.number * decayTable) - (t * decayTable) > 0:
                                                if not (block.number * decayTable) - (t * decayTable):
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    mem[100] = this.address
                                                    mem[132] = 0 / totalAllocPoint
                                                    require ext_code.size(bxhAddress)
                                                    call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, 0 / totalAllocPoint
                                                    mem[96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if ext_call.return_data[0]:
                                                        if not 0 / totalAllocPoint:
                                                            if poolInfo[idx].field_1280 <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require poolInfo[idx].field_1280
                                                            if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                        else:
                                                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                            if poolInfo[idx].field_1280 <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require poolInfo[idx].field_1280
                                                            if (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1280
                                                else:
                                                    if (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / (block.number * decayTable) - (t * decayTable) != poolInfo[idx].field_256:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    mem[100] = this.address
                                                    mem[132] = (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                                    require ext_code.size(bxhAddress)
                                                    call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                                    mem[96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if ext_call.return_data[0]:
                                                        if not (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint:
                                                            if poolInfo[idx].field_1280 <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require poolInfo[idx].field_1280
                                                            if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                        else:
                                                            if 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                            if poolInfo[idx].field_1280 <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require poolInfo[idx].field_1280
                                                            if (10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_768 += 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_1280
                                                poolInfo[idx].field_512 = block.number
                                    else:
                                        if block.number <= startBlock:
                                            if 0 >= decayTable.length:
                                                require decayTable.length - 1 < decayTable.length
                                                if not decayTable[decayTable.length]:
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = 0
                                                else:
                                                    if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                require 0 < decayTable.length
                                            mem[0] = 17
                                            if t > block.number:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if block.number - t:
                                                if (block.number * decayTable) - (t * decayTable) / block.number - t != decayTable:
                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (block.number * decayTable) - (t * decayTable) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if (block.number * decayTable) - (t * decayTable) > 0:
                                                    if not (block.number * decayTable) - (t * decayTable):
                                                        if totalAllocPoint <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require totalAllocPoint
                                                        mem[100] = this.address
                                                        mem[132] = 0 / totalAllocPoint
                                                        require ext_code.size(bxhAddress)
                                                        call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args this.address, 0 / totalAllocPoint
                                                        mem[96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if ext_call.return_data[0]:
                                                            if not 0 / totalAllocPoint:
                                                                if poolInfo[idx].field_1280 <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require poolInfo[idx].field_1280
                                                                if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                            else:
                                                                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                                if poolInfo[idx].field_1280 <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require poolInfo[idx].field_1280
                                                                if (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1280
                                                    else:
                                                        if (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / (block.number * decayTable) - (t * decayTable) != poolInfo[idx].field_256:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if totalAllocPoint <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require totalAllocPoint
                                                        mem[100] = this.address
                                                        mem[132] = (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                                        require ext_code.size(bxhAddress)
                                                        call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args this.address, (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                                        mem[96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if ext_call.return_data[0]:
                                                            if not (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint:
                                                                if poolInfo[idx].field_1280 <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require poolInfo[idx].field_1280
                                                                if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                            else:
                                                                if 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                                if poolInfo[idx].field_1280 <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require poolInfo[idx].field_1280
                                                                if (10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_768 += 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_1280
                                                    poolInfo[idx].field_512 = block.number
                                        else:
                                            if startBlock > block.number:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if 1 > block.number - startBlock:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if decayPeriod <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require decayPeriod
                                            if block.number + -startBlock - 1 / decayPeriod >= decayTable.length:
                                                require decayTable.length - 1 < decayTable.length
                                                if not decayTable[decayTable.length]:
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = 0
                                                else:
                                                    if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                require block.number + -startBlock - 1 / decayPeriod < decayTable.length
                                            mem[0] = 17
                                            if t > block.number:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if block.number - t:
                                                if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (t * decayTable[block.number + -stor12 - 1 / stor15]) / block.number - t != decayTable[block.number + -stor12 - 1 / stor15]:
                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (t * decayTable[block.number + -stor12 - 1 / stor15]) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (t * decayTable[block.number + -stor12 - 1 / stor15]) > 0:
                                                    if not (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (t * decayTable[block.number + -stor12 - 1 / stor15]):
                                                        if totalAllocPoint <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require totalAllocPoint
                                                        mem[100] = this.address
                                                        mem[132] = 0 / totalAllocPoint
                                                        require ext_code.size(bxhAddress)
                                                        call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args this.address, 0 / totalAllocPoint
                                                        mem[96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if ext_call.return_data[0]:
                                                            if not 0 / totalAllocPoint:
                                                                if poolInfo[idx].field_1280 <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require poolInfo[idx].field_1280
                                                                if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                            else:
                                                                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                                if poolInfo[idx].field_1280 <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require poolInfo[idx].field_1280
                                                                if (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1280
                                                    else:
                                                        if (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (t * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (t * decayTable[block.number + -stor12 - 1 / stor15]) != poolInfo[idx].field_256:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if totalAllocPoint <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require totalAllocPoint
                                                        mem[100] = this.address
                                                        mem[132] = (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (t * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint
                                                        require ext_code.size(bxhAddress)
                                                        call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args this.address, (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (t * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint
                                                        mem[96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if ext_call.return_data[0]:
                                                            if not (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (t * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint:
                                                                if poolInfo[idx].field_1280 <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require poolInfo[idx].field_1280
                                                                if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                            else:
                                                                if 10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (t * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint / (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (t * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                                if poolInfo[idx].field_1280 <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require poolInfo[idx].field_1280
                                                                if (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (t * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_768 += 10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (t * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_1280
                                                    poolInfo[idx].field_512 = block.number
                        else:
                            if startBlock > poolInfo[idx].field_512:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if 1 > poolInfo[idx].field_512 - startBlock:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if decayPeriod <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require decayPeriod
                            if 0 == decayPeriod:
                                s = poolInfo[idx].field_512 + -startBlock - 1 / decayPeriod
                                t = poolInfo[idx].field_512
                                while s < 0:
                                    if not s + 1:
                                        if startBlock < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if decayPeriod != 0:
                                            if startBlock > startBlock:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        if 0 >= decayTable.length:
                                            require decayTable.length - 1 < decayTable.length
                                            if not decayTable[decayTable.length]:
                                                decayTable.length++
                                                decayTable[decayTable.length] = 0
                                            else:
                                                if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                decayTable.length++
                                                decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                            require 0 < decayTable.length
                                        mem[0] = 17
                                        if t > startBlock:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if startBlock - t:
                                            if (startBlock * decayTable) - (t * decayTable) / startBlock - t != decayTable:
                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            if (startBlock * decayTable) - (t * decayTable) < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                        s = s + 1
                                        t = startBlock
                                        continue 
                                    if decayPeriod + (s * decayPeriod) / s + 1 != decayPeriod:
                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                    if startBlock < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if 0 == decayPeriod:
                                        if 0 >= decayTable.length:
                                            require decayTable.length - 1 < decayTable.length
                                            if not decayTable[decayTable.length]:
                                                decayTable.length++
                                                decayTable[decayTable.length] = 0
                                            else:
                                                if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                decayTable.length++
                                                decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                            require 0 < decayTable.length
                                        mem[0] = 17
                                        if t > startBlock + decayPeriod + (s * decayPeriod):
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if startBlock + decayPeriod + (s * decayPeriod) - t:
                                            if (startBlock * decayTable) + (decayPeriod * decayTable) + (s * decayPeriod * decayTable) - (t * decayTable) / startBlock + decayPeriod + (s * decayPeriod) - t != decayTable:
                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            if (startBlock * decayTable) + (decayPeriod * decayTable) + (s * decayPeriod * decayTable) - (t * decayTable) < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                    else:
                                        if startBlock + decayPeriod + (s * decayPeriod) <= startBlock:
                                            if 0 >= decayTable.length:
                                                require decayTable.length - 1 < decayTable.length
                                                if not decayTable[decayTable.length]:
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = 0
                                                else:
                                                    if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                require 0 < decayTable.length
                                            mem[0] = 17
                                            if t > startBlock + decayPeriod + (s * decayPeriod):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if startBlock + decayPeriod + (s * decayPeriod) - t:
                                                if (startBlock * decayTable) + (decayPeriod * decayTable) + (s * decayPeriod * decayTable) - (t * decayTable) / startBlock + decayPeriod + (s * decayPeriod) - t != decayTable:
                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (startBlock * decayTable) + (decayPeriod * decayTable) + (s * decayPeriod * decayTable) - (t * decayTable) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                        else:
                                            if startBlock > startBlock + decayPeriod + (s * decayPeriod):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if 1 > decayPeriod + (s * decayPeriod):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if decayPeriod <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require decayPeriod
                                            if decayPeriod + (s * decayPeriod) - 1 / decayPeriod >= decayTable.length:
                                                require decayTable.length - 1 < decayTable.length
                                                if not decayTable[decayTable.length]:
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = 0
                                                else:
                                                    if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                require decayPeriod + (s * decayPeriod) - 1 / decayPeriod < decayTable.length
                                            mem[0] = 17
                                            if t > startBlock + decayPeriod + (s * decayPeriod):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if startBlock + decayPeriod + (s * decayPeriod) - t:
                                                if (startBlock * decayTable[stor15 + (s * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (s * stor15) - 1 / stor15]) + (s * decayPeriod * decayTable[stor15 + (s * stor15) - 1 / stor15]) - (t * decayTable[stor15 + (s * stor15) - 1 / stor15]) / startBlock + decayPeriod + (s * decayPeriod) - t != decayTable[stor15 + (s * stor15) - 1 / stor15]:
                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (startBlock * decayTable[stor15 + (s * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (s * stor15) - 1 / stor15]) + (s * decayPeriod * decayTable[stor15 + (s * stor15) - 1 / stor15]) - (t * decayTable[stor15 + (s * stor15) - 1 / stor15]) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                    s = s + 1
                                    t = startBlock + decayPeriod + (s * decayPeriod)
                                    continue 
                            else:
                                if block.number <= startBlock:
                                    s = poolInfo[idx].field_512 + -startBlock - 1 / decayPeriod
                                    t = poolInfo[idx].field_512
                                    while s < 0:
                                        if not s + 1:
                                            if startBlock < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if decayPeriod != 0:
                                                if startBlock > startBlock:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                            if 0 >= decayTable.length:
                                                require decayTable.length - 1 < decayTable.length
                                                if not decayTable[decayTable.length]:
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = 0
                                                else:
                                                    if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                require 0 < decayTable.length
                                            mem[0] = 17
                                            if t > startBlock:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if startBlock - t:
                                                if (startBlock * decayTable) - (t * decayTable) / startBlock - t != decayTable:
                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (startBlock * decayTable) - (t * decayTable) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                            s = s + 1
                                            t = startBlock
                                            continue 
                                        if decayPeriod + (s * decayPeriod) / s + 1 != decayPeriod:
                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                        if startBlock < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if 0 == decayPeriod:
                                            if 0 >= decayTable.length:
                                                require decayTable.length - 1 < decayTable.length
                                                if not decayTable[decayTable.length]:
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = 0
                                                else:
                                                    if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                require 0 < decayTable.length
                                            mem[0] = 17
                                            if t > startBlock + decayPeriod + (s * decayPeriod):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if startBlock + decayPeriod + (s * decayPeriod) - t:
                                                if (startBlock * decayTable) + (decayPeriod * decayTable) + (s * decayPeriod * decayTable) - (t * decayTable) / startBlock + decayPeriod + (s * decayPeriod) - t != decayTable:
                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (startBlock * decayTable) + (decayPeriod * decayTable) + (s * decayPeriod * decayTable) - (t * decayTable) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                        else:
                                            if startBlock + decayPeriod + (s * decayPeriod) <= startBlock:
                                                if 0 >= decayTable.length:
                                                    require decayTable.length - 1 < decayTable.length
                                                    if not decayTable[decayTable.length]:
                                                        decayTable.length++
                                                        decayTable[decayTable.length] = 0
                                                    else:
                                                        if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        decayTable.length++
                                                        decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                    require 0 < decayTable.length
                                                mem[0] = 17
                                                if t > startBlock + decayPeriod + (s * decayPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if startBlock + decayPeriod + (s * decayPeriod) - t:
                                                    if (startBlock * decayTable) + (decayPeriod * decayTable) + (s * decayPeriod * decayTable) - (t * decayTable) / startBlock + decayPeriod + (s * decayPeriod) - t != decayTable:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (startBlock * decayTable) + (decayPeriod * decayTable) + (s * decayPeriod * decayTable) - (t * decayTable) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                            else:
                                                if startBlock > startBlock + decayPeriod + (s * decayPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if 1 > decayPeriod + (s * decayPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if decayPeriod <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require decayPeriod
                                                if decayPeriod + (s * decayPeriod) - 1 / decayPeriod >= decayTable.length:
                                                    require decayTable.length - 1 < decayTable.length
                                                    if not decayTable[decayTable.length]:
                                                        decayTable.length++
                                                        decayTable[decayTable.length] = 0
                                                    else:
                                                        if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        decayTable.length++
                                                        decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                    require decayPeriod + (s * decayPeriod) - 1 / decayPeriod < decayTable.length
                                                mem[0] = 17
                                                if t > startBlock + decayPeriod + (s * decayPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if startBlock + decayPeriod + (s * decayPeriod) - t:
                                                    if (startBlock * decayTable[stor15 + (s * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (s * stor15) - 1 / stor15]) + (s * decayPeriod * decayTable[stor15 + (s * stor15) - 1 / stor15]) - (t * decayTable[stor15 + (s * stor15) - 1 / stor15]) / startBlock + decayPeriod + (s * decayPeriod) - t != decayTable[stor15 + (s * stor15) - 1 / stor15]:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (startBlock * decayTable[stor15 + (s * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (s * stor15) - 1 / stor15]) + (s * decayPeriod * decayTable[stor15 + (s * stor15) - 1 / stor15]) - (t * decayTable[stor15 + (s * stor15) - 1 / stor15]) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                        s = s + 1
                                        t = startBlock + decayPeriod + (s * decayPeriod)
                                        continue 
                                else:
                                    if startBlock > block.number:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if 1 > block.number - startBlock:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if decayPeriod <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require decayPeriod
                                    s = poolInfo[idx].field_512 + -startBlock - 1 / decayPeriod
                                    t = poolInfo[idx].field_512
                                    while s < block.number + -startBlock - 1 / decayPeriod:
                                        if not s + 1:
                                            if startBlock < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if decayPeriod != 0:
                                                if startBlock > startBlock:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                            if 0 >= decayTable.length:
                                                require decayTable.length - 1 < decayTable.length
                                                if not decayTable[decayTable.length]:
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = 0
                                                else:
                                                    if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                require 0 < decayTable.length
                                            mem[0] = 17
                                            if t > startBlock:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if startBlock - t:
                                                if (startBlock * decayTable) - (t * decayTable) / startBlock - t != decayTable:
                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (startBlock * decayTable) - (t * decayTable) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                            s = s + 1
                                            t = startBlock
                                            continue 
                                        if decayPeriod + (s * decayPeriod) / s + 1 != decayPeriod:
                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                        if startBlock < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if 0 == decayPeriod:
                                            if 0 >= decayTable.length:
                                                require decayTable.length - 1 < decayTable.length
                                                if not decayTable[decayTable.length]:
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = 0
                                                else:
                                                    if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                require 0 < decayTable.length
                                            mem[0] = 17
                                            if t > startBlock + decayPeriod + (s * decayPeriod):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if startBlock + decayPeriod + (s * decayPeriod) - t:
                                                if (startBlock * decayTable) + (decayPeriod * decayTable) + (s * decayPeriod * decayTable) - (t * decayTable) / startBlock + decayPeriod + (s * decayPeriod) - t != decayTable:
                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (startBlock * decayTable) + (decayPeriod * decayTable) + (s * decayPeriod * decayTable) - (t * decayTable) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                        else:
                                            if startBlock + decayPeriod + (s * decayPeriod) <= startBlock:
                                                if 0 >= decayTable.length:
                                                    require decayTable.length - 1 < decayTable.length
                                                    if not decayTable[decayTable.length]:
                                                        decayTable.length++
                                                        decayTable[decayTable.length] = 0
                                                    else:
                                                        if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        decayTable.length++
                                                        decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                    require 0 < decayTable.length
                                                mem[0] = 17
                                                if t > startBlock + decayPeriod + (s * decayPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if startBlock + decayPeriod + (s * decayPeriod) - t:
                                                    if (startBlock * decayTable) + (decayPeriod * decayTable) + (s * decayPeriod * decayTable) - (t * decayTable) / startBlock + decayPeriod + (s * decayPeriod) - t != decayTable:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (startBlock * decayTable) + (decayPeriod * decayTable) + (s * decayPeriod * decayTable) - (t * decayTable) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                            else:
                                                if startBlock > startBlock + decayPeriod + (s * decayPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if 1 > decayPeriod + (s * decayPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if decayPeriod <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require decayPeriod
                                                if decayPeriod + (s * decayPeriod) - 1 / decayPeriod >= decayTable.length:
                                                    require decayTable.length - 1 < decayTable.length
                                                    if not decayTable[decayTable.length]:
                                                        decayTable.length++
                                                        decayTable[decayTable.length] = 0
                                                    else:
                                                        if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        decayTable.length++
                                                        decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                    require decayPeriod + (s * decayPeriod) - 1 / decayPeriod < decayTable.length
                                                mem[0] = 17
                                                if t > startBlock + decayPeriod + (s * decayPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if startBlock + decayPeriod + (s * decayPeriod) - t:
                                                    if (startBlock * decayTable[stor15 + (s * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (s * stor15) - 1 / stor15]) + (s * decayPeriod * decayTable[stor15 + (s * stor15) - 1 / stor15]) - (t * decayTable[stor15 + (s * stor15) - 1 / stor15]) / startBlock + decayPeriod + (s * decayPeriod) - t != decayTable[stor15 + (s * stor15) - 1 / stor15]:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (startBlock * decayTable[stor15 + (s * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (s * stor15) - 1 / stor15]) + (s * decayPeriod * decayTable[stor15 + (s * stor15) - 1 / stor15]) - (t * decayTable[stor15 + (s * stor15) - 1 / stor15]) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                        s = s + 1
                                        t = startBlock + decayPeriod + (s * decayPeriod)
                                        continue 
                            if 0 == decayPeriod:
                                if 0 >= decayTable.length:
                                    require decayTable.length - 1 < decayTable.length
                                    if not decayTable[decayTable.length]:
                                        decayTable.length++
                                        decayTable[decayTable.length] = 0
                                    else:
                                        if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                        decayTable.length++
                                        decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                    require 0 < decayTable.length
                                mem[0] = 17
                                if t > block.number:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if block.number - t:
                                    if (block.number * decayTable) - (t * decayTable) / block.number - t != decayTable:
                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                    if (block.number * decayTable) - (t * decayTable) < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (block.number * decayTable) - (t * decayTable) > 0:
                                        if not (block.number * decayTable) - (t * decayTable):
                                            if totalAllocPoint <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalAllocPoint
                                            mem[100] = this.address
                                            mem[132] = 0 / totalAllocPoint
                                            require ext_code.size(bxhAddress)
                                            call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                 gas gas_remaining wei
                                                args this.address, 0 / totalAllocPoint
                                            mem[96] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if ext_call.return_data[0]:
                                                if not 0 / totalAllocPoint:
                                                    if poolInfo[idx].field_1280 <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require poolInfo[idx].field_1280
                                                    if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                else:
                                                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if poolInfo[idx].field_1280 <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require poolInfo[idx].field_1280
                                                    if (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1280
                                        else:
                                            if (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / (block.number * decayTable) - (t * decayTable) != poolInfo[idx].field_256:
                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            if totalAllocPoint <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalAllocPoint
                                            mem[100] = this.address
                                            mem[132] = (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                            require ext_code.size(bxhAddress)
                                            call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                 gas gas_remaining wei
                                                args this.address, (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                            mem[96] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if ext_call.return_data[0]:
                                                if not (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint:
                                                    if poolInfo[idx].field_1280 <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require poolInfo[idx].field_1280
                                                    if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                else:
                                                    if 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if poolInfo[idx].field_1280 <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require poolInfo[idx].field_1280
                                                    if (10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_1280
                                        poolInfo[idx].field_512 = block.number
                            else:
                                if block.number <= startBlock:
                                    if 0 >= decayTable.length:
                                        require decayTable.length - 1 < decayTable.length
                                        if not decayTable[decayTable.length]:
                                            decayTable.length++
                                            decayTable[decayTable.length] = 0
                                        else:
                                            if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            decayTable.length++
                                            decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                        require 0 < decayTable.length
                                    mem[0] = 17
                                    if t > block.number:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if block.number - t:
                                        if (block.number * decayTable) - (t * decayTable) / block.number - t != decayTable:
                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                        if (block.number * decayTable) - (t * decayTable) < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (block.number * decayTable) - (t * decayTable) > 0:
                                            if not (block.number * decayTable) - (t * decayTable):
                                                if totalAllocPoint <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalAllocPoint
                                                mem[100] = this.address
                                                mem[132] = 0 / totalAllocPoint
                                                require ext_code.size(bxhAddress)
                                                call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args this.address, 0 / totalAllocPoint
                                                mem[96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if ext_call.return_data[0]:
                                                    if not 0 / totalAllocPoint:
                                                        if poolInfo[idx].field_1280 <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require poolInfo[idx].field_1280
                                                        if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                    else:
                                                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if poolInfo[idx].field_1280 <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require poolInfo[idx].field_1280
                                                        if (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1280
                                            else:
                                                if (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / (block.number * decayTable) - (t * decayTable) != poolInfo[idx].field_256:
                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if totalAllocPoint <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalAllocPoint
                                                mem[100] = this.address
                                                mem[132] = (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                                require ext_code.size(bxhAddress)
                                                call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args this.address, (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                                mem[96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if ext_call.return_data[0]:
                                                    if not (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint:
                                                        if poolInfo[idx].field_1280 <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require poolInfo[idx].field_1280
                                                        if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                    else:
                                                        if 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if poolInfo[idx].field_1280 <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require poolInfo[idx].field_1280
                                                        if (10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_768 += 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_1280
                                            poolInfo[idx].field_512 = block.number
                                else:
                                    if startBlock > block.number:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if 1 > block.number - startBlock:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if decayPeriod <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require decayPeriod
                                    if block.number + -startBlock - 1 / decayPeriod >= decayTable.length:
                                        require decayTable.length - 1 < decayTable.length
                                        if not decayTable[decayTable.length]:
                                            decayTable.length++
                                            decayTable[decayTable.length] = 0
                                        else:
                                            if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            decayTable.length++
                                            decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                        require block.number + -startBlock - 1 / decayPeriod < decayTable.length
                                    mem[0] = 17
                                    if t > block.number:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if block.number - t:
                                        if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (t * decayTable[block.number + -stor12 - 1 / stor15]) / block.number - t != decayTable[block.number + -stor12 - 1 / stor15]:
                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                        if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (t * decayTable[block.number + -stor12 - 1 / stor15]) < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (t * decayTable[block.number + -stor12 - 1 / stor15]) > 0:
                                            if not (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (t * decayTable[block.number + -stor12 - 1 / stor15]):
                                                if totalAllocPoint <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalAllocPoint
                                                mem[100] = this.address
                                                mem[132] = 0 / totalAllocPoint
                                                require ext_code.size(bxhAddress)
                                                call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args this.address, 0 / totalAllocPoint
                                                mem[96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if ext_call.return_data[0]:
                                                    if not 0 / totalAllocPoint:
                                                        if poolInfo[idx].field_1280 <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require poolInfo[idx].field_1280
                                                        if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                    else:
                                                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if poolInfo[idx].field_1280 <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require poolInfo[idx].field_1280
                                                        if (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1280
                                            else:
                                                if (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (t * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (t * decayTable[block.number + -stor12 - 1 / stor15]) != poolInfo[idx].field_256:
                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if totalAllocPoint <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalAllocPoint
                                                mem[100] = this.address
                                                mem[132] = (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (t * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint
                                                require ext_code.size(bxhAddress)
                                                call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args this.address, (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (t * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint
                                                mem[96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if ext_call.return_data[0]:
                                                    if not (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (t * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint:
                                                        if poolInfo[idx].field_1280 <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require poolInfo[idx].field_1280
                                                        if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                    else:
                                                        if 10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (t * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint / (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (t * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if poolInfo[idx].field_1280 <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require poolInfo[idx].field_1280
                                                        if (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (t * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_768 += 10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (t * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_1280
                                            poolInfo[idx].field_512 = block.number
            else:
                mem[100] = this.address
                require ext_code.size(poolInfo[idx].field_0)
                staticcall poolInfo[idx].field_0.0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                mem[96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if not ext_call.return_data[0]:
                    poolInfo[idx].field_512 = block.number
                else:
                    if 0 == decayPeriod:
                        if 0 == decayPeriod:
                            if 0 >= decayTable.length:
                                require decayTable.length - 1 < decayTable.length
                                if not decayTable[decayTable.length]:
                                    decayTable.length++
                                    decayTable[decayTable.length] = 0
                                else:
                                    if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                    decayTable.length++
                                    decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                require 0 < decayTable.length
                            mem[0] = 17
                            if poolInfo[idx].field_512 > block.number:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if block.number - poolInfo[idx].field_512:
                                if (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) / block.number - poolInfo[idx].field_512 != decayTable:
                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                if (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) > 0:
                                    if not (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable):
                                        if totalAllocPoint <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalAllocPoint
                                        mem[100] = this.address
                                        mem[132] = 0 / totalAllocPoint
                                        require ext_code.size(bxhAddress)
                                        call bxhAddress.mint(address arg1, uint256 arg2) with:
                                             gas gas_remaining wei
                                            args this.address, 0 / totalAllocPoint
                                        mem[96] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0]:
                                            if not 0 / totalAllocPoint:
                                                if ext_call.return_data[0] <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require ext_call.return_data[0]
                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                            else:
                                                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if ext_call.return_data[0] <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require ext_call.return_data[0]
                                                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                    else:
                                        if (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) != poolInfo[idx].field_256:
                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                        if totalAllocPoint <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalAllocPoint
                                        mem[100] = this.address
                                        mem[132] = (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                        require ext_code.size(bxhAddress)
                                        call bxhAddress.mint(address arg1, uint256 arg2) with:
                                             gas gas_remaining wei
                                            args this.address, (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                        mem[96] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0]:
                                            if not (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint:
                                                if ext_call.return_data[0] <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require ext_call.return_data[0]
                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                            else:
                                                if 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if ext_call.return_data[0] <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require ext_call.return_data[0]
                                                if (10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                                    poolInfo[idx].field_512 = block.number
                        else:
                            if block.number <= startBlock:
                                if 0 >= decayTable.length:
                                    require decayTable.length - 1 < decayTable.length
                                    if not decayTable[decayTable.length]:
                                        decayTable.length++
                                        decayTable[decayTable.length] = 0
                                    else:
                                        if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                        decayTable.length++
                                        decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                    require 0 < decayTable.length
                                mem[0] = 17
                                if poolInfo[idx].field_512 > block.number:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if block.number - poolInfo[idx].field_512:
                                    if (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) / block.number - poolInfo[idx].field_512 != decayTable:
                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                    if (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) > 0:
                                        if not (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable):
                                            if totalAllocPoint <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalAllocPoint
                                            mem[100] = this.address
                                            mem[132] = 0 / totalAllocPoint
                                            require ext_code.size(bxhAddress)
                                            call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                 gas gas_remaining wei
                                                args this.address, 0 / totalAllocPoint
                                            mem[96] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if ext_call.return_data[0]:
                                                if not 0 / totalAllocPoint:
                                                    if ext_call.return_data[0] <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require ext_call.return_data[0]
                                                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                else:
                                                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if ext_call.return_data[0] <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require ext_call.return_data[0]
                                                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                        else:
                                            if (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) != poolInfo[idx].field_256:
                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            if totalAllocPoint <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalAllocPoint
                                            mem[100] = this.address
                                            mem[132] = (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                            require ext_code.size(bxhAddress)
                                            call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                 gas gas_remaining wei
                                                args this.address, (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                            mem[96] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if ext_call.return_data[0]:
                                                if not (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint:
                                                    if ext_call.return_data[0] <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require ext_call.return_data[0]
                                                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                else:
                                                    if 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if ext_call.return_data[0] <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require ext_call.return_data[0]
                                                    if (10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                            else:
                                if startBlock > block.number:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if 1 > block.number - startBlock:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if decayPeriod <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require decayPeriod
                                if block.number + -startBlock - 1 / decayPeriod >= decayTable.length:
                                    require decayTable.length - 1 < decayTable.length
                                    if not decayTable[decayTable.length]:
                                        decayTable.length++
                                        decayTable[decayTable.length] = 0
                                    else:
                                        if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                        decayTable.length++
                                        decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                    require block.number + -startBlock - 1 / decayPeriod < decayTable.length
                                mem[0] = 17
                                if poolInfo[idx].field_512 > block.number:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if block.number - poolInfo[idx].field_512:
                                    if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) / block.number - poolInfo[idx].field_512 != decayTable[block.number + -stor12 - 1 / stor15]:
                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                    if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) > 0:
                                        if not (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15]):
                                            if totalAllocPoint <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalAllocPoint
                                            mem[100] = this.address
                                            mem[132] = 0 / totalAllocPoint
                                            require ext_code.size(bxhAddress)
                                            call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                 gas gas_remaining wei
                                                args this.address, 0 / totalAllocPoint
                                            mem[96] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if ext_call.return_data[0]:
                                                if not 0 / totalAllocPoint:
                                                    if ext_call.return_data[0] <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require ext_call.return_data[0]
                                                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                else:
                                                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if ext_call.return_data[0] <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require ext_call.return_data[0]
                                                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                        else:
                                            if (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) != poolInfo[idx].field_256:
                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            if totalAllocPoint <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalAllocPoint
                                            mem[100] = this.address
                                            mem[132] = (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint
                                            require ext_code.size(bxhAddress)
                                            call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                 gas gas_remaining wei
                                                args this.address, (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint
                                            mem[96] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if ext_call.return_data[0]:
                                                if not (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint:
                                                    if ext_call.return_data[0] <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require ext_call.return_data[0]
                                                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                else:
                                                    if 10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint / (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if ext_call.return_data[0] <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require ext_call.return_data[0]
                                                    if (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                    else:
                        if poolInfo[idx].field_512 <= startBlock:
                            if 0 == decayPeriod:
                                if 0 == decayPeriod:
                                    if 0 >= decayTable.length:
                                        require decayTable.length - 1 < decayTable.length
                                        if not decayTable[decayTable.length]:
                                            decayTable.length++
                                            decayTable[decayTable.length] = 0
                                        else:
                                            if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            decayTable.length++
                                            decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                        require 0 < decayTable.length
                                    mem[0] = 17
                                    if poolInfo[idx].field_512 > block.number:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if block.number - poolInfo[idx].field_512:
                                        if (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) / block.number - poolInfo[idx].field_512 != decayTable:
                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                        if (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) > 0:
                                            if not (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable):
                                                if totalAllocPoint <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalAllocPoint
                                                mem[100] = this.address
                                                mem[132] = 0 / totalAllocPoint
                                                require ext_code.size(bxhAddress)
                                                call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args this.address, 0 / totalAllocPoint
                                                mem[96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if ext_call.return_data[0]:
                                                    if not 0 / totalAllocPoint:
                                                        if ext_call.return_data[0] <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require ext_call.return_data[0]
                                                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                    else:
                                                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if ext_call.return_data[0] <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require ext_call.return_data[0]
                                                        if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                            else:
                                                if (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) != poolInfo[idx].field_256:
                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if totalAllocPoint <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalAllocPoint
                                                mem[100] = this.address
                                                mem[132] = (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                                require ext_code.size(bxhAddress)
                                                call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args this.address, (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                                mem[96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if ext_call.return_data[0]:
                                                    if not (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint:
                                                        if ext_call.return_data[0] <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require ext_call.return_data[0]
                                                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                    else:
                                                        if 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if ext_call.return_data[0] <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require ext_call.return_data[0]
                                                        if (10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_768 += 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                else:
                                    if block.number <= startBlock:
                                        if 0 >= decayTable.length:
                                            require decayTable.length - 1 < decayTable.length
                                            if not decayTable[decayTable.length]:
                                                decayTable.length++
                                                decayTable[decayTable.length] = 0
                                            else:
                                                if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                decayTable.length++
                                                decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                            require 0 < decayTable.length
                                        mem[0] = 17
                                        if poolInfo[idx].field_512 > block.number:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if block.number - poolInfo[idx].field_512:
                                            if (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) / block.number - poolInfo[idx].field_512 != decayTable:
                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            if (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) > 0:
                                                if not (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable):
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    mem[100] = this.address
                                                    mem[132] = 0 / totalAllocPoint
                                                    require ext_code.size(bxhAddress)
                                                    call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, 0 / totalAllocPoint
                                                    mem[96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if ext_call.return_data[0]:
                                                        if not 0 / totalAllocPoint:
                                                            if ext_call.return_data[0] <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require ext_call.return_data[0]
                                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                        else:
                                                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                            if ext_call.return_data[0] <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require ext_call.return_data[0]
                                                            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                                else:
                                                    if (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) != poolInfo[idx].field_256:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    mem[100] = this.address
                                                    mem[132] = (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                                    require ext_code.size(bxhAddress)
                                                    call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                                    mem[96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if ext_call.return_data[0]:
                                                        if not (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint:
                                                            if ext_call.return_data[0] <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require ext_call.return_data[0]
                                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                        else:
                                                            if 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                            if ext_call.return_data[0] <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require ext_call.return_data[0]
                                                            if (10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_768 += 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                    else:
                                        if startBlock > block.number:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if 1 > block.number - startBlock:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if decayPeriod <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require decayPeriod
                                        if block.number + -startBlock - 1 / decayPeriod >= decayTable.length:
                                            require decayTable.length - 1 < decayTable.length
                                            if not decayTable[decayTable.length]:
                                                decayTable.length++
                                                decayTable[decayTable.length] = 0
                                            else:
                                                if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                decayTable.length++
                                                decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                            require block.number + -startBlock - 1 / decayPeriod < decayTable.length
                                        mem[0] = 17
                                        if poolInfo[idx].field_512 > block.number:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if block.number - poolInfo[idx].field_512:
                                            if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) / block.number - poolInfo[idx].field_512 != decayTable[block.number + -stor12 - 1 / stor15]:
                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) > 0:
                                                if not (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15]):
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    mem[100] = this.address
                                                    mem[132] = 0 / totalAllocPoint
                                                    require ext_code.size(bxhAddress)
                                                    call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, 0 / totalAllocPoint
                                                    mem[96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if ext_call.return_data[0]:
                                                        if not 0 / totalAllocPoint:
                                                            if ext_call.return_data[0] <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require ext_call.return_data[0]
                                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                        else:
                                                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                            if ext_call.return_data[0] <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require ext_call.return_data[0]
                                                            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                                else:
                                                    if (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) != poolInfo[idx].field_256:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    mem[100] = this.address
                                                    mem[132] = (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint
                                                    require ext_code.size(bxhAddress)
                                                    call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint
                                                    mem[96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if ext_call.return_data[0]:
                                                        if not (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint:
                                                            if ext_call.return_data[0] <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require ext_call.return_data[0]
                                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                        else:
                                                            if 10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint / (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                            if ext_call.return_data[0] <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require ext_call.return_data[0]
                                                            if (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_768 += 10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                            else:
                                if block.number <= startBlock:
                                    if 0 == decayPeriod:
                                        if 0 >= decayTable.length:
                                            require decayTable.length - 1 < decayTable.length
                                            if not decayTable[decayTable.length]:
                                                decayTable.length++
                                                decayTable[decayTable.length] = 0
                                            else:
                                                if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                decayTable.length++
                                                decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                            require 0 < decayTable.length
                                        mem[0] = 17
                                        if poolInfo[idx].field_512 > block.number:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if block.number - poolInfo[idx].field_512:
                                            if (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) / block.number - poolInfo[idx].field_512 != decayTable:
                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            if (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) > 0:
                                                if not (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable):
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    mem[100] = this.address
                                                    mem[132] = 0 / totalAllocPoint
                                                    require ext_code.size(bxhAddress)
                                                    call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, 0 / totalAllocPoint
                                                    mem[96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if ext_call.return_data[0]:
                                                        if not 0 / totalAllocPoint:
                                                            if ext_call.return_data[0] <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require ext_call.return_data[0]
                                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                        else:
                                                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                            if ext_call.return_data[0] <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require ext_call.return_data[0]
                                                            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                                else:
                                                    if (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) != poolInfo[idx].field_256:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    mem[100] = this.address
                                                    mem[132] = (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                                    require ext_code.size(bxhAddress)
                                                    call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                                    mem[96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if ext_call.return_data[0]:
                                                        if not (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint:
                                                            if ext_call.return_data[0] <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require ext_call.return_data[0]
                                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                        else:
                                                            if 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                            if ext_call.return_data[0] <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require ext_call.return_data[0]
                                                            if (10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_768 += 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                    else:
                                        if block.number <= startBlock:
                                            if 0 >= decayTable.length:
                                                require decayTable.length - 1 < decayTable.length
                                                if not decayTable[decayTable.length]:
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = 0
                                                else:
                                                    if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                require 0 < decayTable.length
                                            mem[0] = 17
                                            if poolInfo[idx].field_512 > block.number:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if block.number - poolInfo[idx].field_512:
                                                if (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) / block.number - poolInfo[idx].field_512 != decayTable:
                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) > 0:
                                                    if not (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable):
                                                        if totalAllocPoint <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require totalAllocPoint
                                                        mem[100] = this.address
                                                        mem[132] = 0 / totalAllocPoint
                                                        require ext_code.size(bxhAddress)
                                                        call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args this.address, 0 / totalAllocPoint
                                                        mem[96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if ext_call.return_data[0]:
                                                            if not 0 / totalAllocPoint:
                                                                if ext_call.return_data[0] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require ext_call.return_data[0]
                                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                            else:
                                                                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                                if ext_call.return_data[0] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require ext_call.return_data[0]
                                                                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                                    else:
                                                        if (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) != poolInfo[idx].field_256:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if totalAllocPoint <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require totalAllocPoint
                                                        mem[100] = this.address
                                                        mem[132] = (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                                        require ext_code.size(bxhAddress)
                                                        call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args this.address, (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                                        mem[96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if ext_call.return_data[0]:
                                                            if not (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint:
                                                                if ext_call.return_data[0] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require ext_call.return_data[0]
                                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                            else:
                                                                if 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                                if ext_call.return_data[0] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require ext_call.return_data[0]
                                                                if (10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_768 += 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                                                    poolInfo[idx].field_512 = block.number
                                        else:
                                            if startBlock > block.number:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if 1 > block.number - startBlock:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if decayPeriod <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require decayPeriod
                                            if block.number + -startBlock - 1 / decayPeriod >= decayTable.length:
                                                require decayTable.length - 1 < decayTable.length
                                                if not decayTable[decayTable.length]:
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = 0
                                                else:
                                                    if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                require block.number + -startBlock - 1 / decayPeriod < decayTable.length
                                            mem[0] = 17
                                            if poolInfo[idx].field_512 > block.number:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if block.number - poolInfo[idx].field_512:
                                                if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) / block.number - poolInfo[idx].field_512 != decayTable[block.number + -stor12 - 1 / stor15]:
                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) > 0:
                                                    if not (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15]):
                                                        if totalAllocPoint <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require totalAllocPoint
                                                        mem[100] = this.address
                                                        mem[132] = 0 / totalAllocPoint
                                                        require ext_code.size(bxhAddress)
                                                        call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args this.address, 0 / totalAllocPoint
                                                        mem[96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if ext_call.return_data[0]:
                                                            if not 0 / totalAllocPoint:
                                                                if ext_call.return_data[0] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require ext_call.return_data[0]
                                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                            else:
                                                                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                                if ext_call.return_data[0] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require ext_call.return_data[0]
                                                                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                                    else:
                                                        if (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) != poolInfo[idx].field_256:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if totalAllocPoint <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require totalAllocPoint
                                                        mem[100] = this.address
                                                        mem[132] = (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint
                                                        require ext_code.size(bxhAddress)
                                                        call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args this.address, (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint
                                                        mem[96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if ext_call.return_data[0]:
                                                            if not (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint:
                                                                if ext_call.return_data[0] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require ext_call.return_data[0]
                                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                            else:
                                                                if 10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint / (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                                if ext_call.return_data[0] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require ext_call.return_data[0]
                                                                if (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_768 += 10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                                                    poolInfo[idx].field_512 = block.number
                                else:
                                    if startBlock > block.number:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if 1 > block.number - startBlock:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if decayPeriod <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require decayPeriod
                                    s = 0
                                    t = poolInfo[idx].field_512
                                    while s < block.number + -startBlock - 1 / decayPeriod:
                                        if not s + 1:
                                            if startBlock < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if decayPeriod != 0:
                                                if startBlock > startBlock:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                            if 0 >= decayTable.length:
                                                require decayTable.length - 1 < decayTable.length
                                                if not decayTable[decayTable.length]:
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = 0
                                                else:
                                                    if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                require 0 < decayTable.length
                                            mem[0] = 17
                                            if t > startBlock:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if startBlock - t:
                                                if (startBlock * decayTable) - (t * decayTable) / startBlock - t != decayTable:
                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (startBlock * decayTable) - (t * decayTable) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                            s = s + 1
                                            t = startBlock
                                            continue 
                                        if decayPeriod + (s * decayPeriod) / s + 1 != decayPeriod:
                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                        if startBlock < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if 0 == decayPeriod:
                                            if 0 >= decayTable.length:
                                                require decayTable.length - 1 < decayTable.length
                                                if not decayTable[decayTable.length]:
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = 0
                                                else:
                                                    if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                require 0 < decayTable.length
                                            mem[0] = 17
                                            if t > startBlock + decayPeriod + (s * decayPeriod):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if startBlock + decayPeriod + (s * decayPeriod) - t:
                                                if (startBlock * decayTable) + (decayPeriod * decayTable) + (s * decayPeriod * decayTable) - (t * decayTable) / startBlock + decayPeriod + (s * decayPeriod) - t != decayTable:
                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (startBlock * decayTable) + (decayPeriod * decayTable) + (s * decayPeriod * decayTable) - (t * decayTable) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                        else:
                                            if startBlock + decayPeriod + (s * decayPeriod) <= startBlock:
                                                if 0 >= decayTable.length:
                                                    require decayTable.length - 1 < decayTable.length
                                                    if not decayTable[decayTable.length]:
                                                        decayTable.length++
                                                        decayTable[decayTable.length] = 0
                                                    else:
                                                        if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        decayTable.length++
                                                        decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                    require 0 < decayTable.length
                                                mem[0] = 17
                                                if t > startBlock + decayPeriod + (s * decayPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if startBlock + decayPeriod + (s * decayPeriod) - t:
                                                    if (startBlock * decayTable) + (decayPeriod * decayTable) + (s * decayPeriod * decayTable) - (t * decayTable) / startBlock + decayPeriod + (s * decayPeriod) - t != decayTable:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (startBlock * decayTable) + (decayPeriod * decayTable) + (s * decayPeriod * decayTable) - (t * decayTable) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                            else:
                                                if startBlock > startBlock + decayPeriod + (s * decayPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if 1 > decayPeriod + (s * decayPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if decayPeriod <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require decayPeriod
                                                if decayPeriod + (s * decayPeriod) - 1 / decayPeriod >= decayTable.length:
                                                    require decayTable.length - 1 < decayTable.length
                                                    if not decayTable[decayTable.length]:
                                                        decayTable.length++
                                                        decayTable[decayTable.length] = 0
                                                    else:
                                                        if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        decayTable.length++
                                                        decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                    require decayPeriod + (s * decayPeriod) - 1 / decayPeriod < decayTable.length
                                                mem[0] = 17
                                                if t > startBlock + decayPeriod + (s * decayPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if startBlock + decayPeriod + (s * decayPeriod) - t:
                                                    if (startBlock * decayTable[stor15 + (s * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (s * stor15) - 1 / stor15]) + (s * decayPeriod * decayTable[stor15 + (s * stor15) - 1 / stor15]) - (t * decayTable[stor15 + (s * stor15) - 1 / stor15]) / startBlock + decayPeriod + (s * decayPeriod) - t != decayTable[stor15 + (s * stor15) - 1 / stor15]:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (startBlock * decayTable[stor15 + (s * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (s * stor15) - 1 / stor15]) + (s * decayPeriod * decayTable[stor15 + (s * stor15) - 1 / stor15]) - (t * decayTable[stor15 + (s * stor15) - 1 / stor15]) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                        s = s + 1
                                        t = startBlock + decayPeriod + (s * decayPeriod)
                                        continue 
                                    if 0 == decayPeriod:
                                        if 0 >= decayTable.length:
                                            require decayTable.length - 1 < decayTable.length
                                            if not decayTable[decayTable.length]:
                                                decayTable.length++
                                                decayTable[decayTable.length] = 0
                                            else:
                                                if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                decayTable.length++
                                                decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                            require 0 < decayTable.length
                                        mem[0] = 17
                                        if t > block.number:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if block.number - t:
                                            if (block.number * decayTable) - (t * decayTable) / block.number - t != decayTable:
                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            if (block.number * decayTable) - (t * decayTable) < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (block.number * decayTable) - (t * decayTable) > 0:
                                                if not (block.number * decayTable) - (t * decayTable):
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    mem[100] = this.address
                                                    mem[132] = 0 / totalAllocPoint
                                                    require ext_code.size(bxhAddress)
                                                    call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, 0 / totalAllocPoint
                                                    mem[96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if ext_call.return_data[0]:
                                                        if not 0 / totalAllocPoint:
                                                            if ext_call.return_data[0] <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require ext_call.return_data[0]
                                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                        else:
                                                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                            if ext_call.return_data[0] <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require ext_call.return_data[0]
                                                            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                                else:
                                                    if (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / (block.number * decayTable) - (t * decayTable) != poolInfo[idx].field_256:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    mem[100] = this.address
                                                    mem[132] = (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                                    require ext_code.size(bxhAddress)
                                                    call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                                    mem[96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if ext_call.return_data[0]:
                                                        if not (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint:
                                                            if ext_call.return_data[0] <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require ext_call.return_data[0]
                                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                        else:
                                                            if 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                            if ext_call.return_data[0] <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require ext_call.return_data[0]
                                                            if (10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_768 += 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                    else:
                                        if block.number <= startBlock:
                                            if 0 >= decayTable.length:
                                                require decayTable.length - 1 < decayTable.length
                                                if not decayTable[decayTable.length]:
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = 0
                                                else:
                                                    if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                require 0 < decayTable.length
                                            mem[0] = 17
                                            if t > block.number:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if block.number - t:
                                                if (block.number * decayTable) - (t * decayTable) / block.number - t != decayTable:
                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (block.number * decayTable) - (t * decayTable) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if (block.number * decayTable) - (t * decayTable) > 0:
                                                    if not (block.number * decayTable) - (t * decayTable):
                                                        if totalAllocPoint <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require totalAllocPoint
                                                        mem[100] = this.address
                                                        mem[132] = 0 / totalAllocPoint
                                                        require ext_code.size(bxhAddress)
                                                        call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args this.address, 0 / totalAllocPoint
                                                        mem[96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if ext_call.return_data[0]:
                                                            if not 0 / totalAllocPoint:
                                                                if ext_call.return_data[0] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require ext_call.return_data[0]
                                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                            else:
                                                                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                                if ext_call.return_data[0] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require ext_call.return_data[0]
                                                                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                                    else:
                                                        if (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / (block.number * decayTable) - (t * decayTable) != poolInfo[idx].field_256:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if totalAllocPoint <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require totalAllocPoint
                                                        mem[100] = this.address
                                                        mem[132] = (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                                        require ext_code.size(bxhAddress)
                                                        call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args this.address, (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                                        mem[96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if ext_call.return_data[0]:
                                                            if not (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint:
                                                                if ext_call.return_data[0] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require ext_call.return_data[0]
                                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                            else:
                                                                if 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                                if ext_call.return_data[0] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require ext_call.return_data[0]
                                                                if (10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_768 += 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                                                    poolInfo[idx].field_512 = block.number
                                        else:
                                            if startBlock > block.number:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if 1 > block.number - startBlock:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if decayPeriod <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require decayPeriod
                                            if block.number + -startBlock - 1 / decayPeriod >= decayTable.length:
                                                require decayTable.length - 1 < decayTable.length
                                                if not decayTable[decayTable.length]:
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = 0
                                                else:
                                                    if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                require block.number + -startBlock - 1 / decayPeriod < decayTable.length
                                            mem[0] = 17
                                            if t > block.number:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if block.number - t:
                                                if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (t * decayTable[block.number + -stor12 - 1 / stor15]) / block.number - t != decayTable[block.number + -stor12 - 1 / stor15]:
                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (t * decayTable[block.number + -stor12 - 1 / stor15]) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (t * decayTable[block.number + -stor12 - 1 / stor15]) > 0:
                                                    if not (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (t * decayTable[block.number + -stor12 - 1 / stor15]):
                                                        if totalAllocPoint <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require totalAllocPoint
                                                        mem[100] = this.address
                                                        mem[132] = 0 / totalAllocPoint
                                                        require ext_code.size(bxhAddress)
                                                        call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args this.address, 0 / totalAllocPoint
                                                        mem[96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if ext_call.return_data[0]:
                                                            if not 0 / totalAllocPoint:
                                                                if ext_call.return_data[0] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require ext_call.return_data[0]
                                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                            else:
                                                                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                                if ext_call.return_data[0] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require ext_call.return_data[0]
                                                                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                                    else:
                                                        if (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (t * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (t * decayTable[block.number + -stor12 - 1 / stor15]) != poolInfo[idx].field_256:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if totalAllocPoint <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require totalAllocPoint
                                                        mem[100] = this.address
                                                        mem[132] = (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (t * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint
                                                        require ext_code.size(bxhAddress)
                                                        call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args this.address, (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (t * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint
                                                        mem[96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if ext_call.return_data[0]:
                                                            if not (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (t * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint:
                                                                if ext_call.return_data[0] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require ext_call.return_data[0]
                                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                            else:
                                                                if 10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (t * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint / (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (t * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                                if ext_call.return_data[0] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require ext_call.return_data[0]
                                                                if (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (t * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_768 += 10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (t * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                                                    poolInfo[idx].field_512 = block.number
                        else:
                            if startBlock > poolInfo[idx].field_512:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if 1 > poolInfo[idx].field_512 - startBlock:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if decayPeriod <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require decayPeriod
                            if 0 == decayPeriod:
                                s = poolInfo[idx].field_512 + -startBlock - 1 / decayPeriod
                                t = poolInfo[idx].field_512
                                while s < 0:
                                    if not s + 1:
                                        if startBlock < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if decayPeriod != 0:
                                            if startBlock > startBlock:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        if 0 >= decayTable.length:
                                            require decayTable.length - 1 < decayTable.length
                                            if not decayTable[decayTable.length]:
                                                decayTable.length++
                                                decayTable[decayTable.length] = 0
                                            else:
                                                if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                decayTable.length++
                                                decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                            require 0 < decayTable.length
                                        mem[0] = 17
                                        if t > startBlock:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if startBlock - t:
                                            if (startBlock * decayTable) - (t * decayTable) / startBlock - t != decayTable:
                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            if (startBlock * decayTable) - (t * decayTable) < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                        s = s + 1
                                        t = startBlock
                                        continue 
                                    if decayPeriod + (s * decayPeriod) / s + 1 != decayPeriod:
                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                    if startBlock < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if 0 == decayPeriod:
                                        if 0 >= decayTable.length:
                                            require decayTable.length - 1 < decayTable.length
                                            if not decayTable[decayTable.length]:
                                                decayTable.length++
                                                decayTable[decayTable.length] = 0
                                            else:
                                                if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                decayTable.length++
                                                decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                            require 0 < decayTable.length
                                        mem[0] = 17
                                        if t > startBlock + decayPeriod + (s * decayPeriod):
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if startBlock + decayPeriod + (s * decayPeriod) - t:
                                            if (startBlock * decayTable) + (decayPeriod * decayTable) + (s * decayPeriod * decayTable) - (t * decayTable) / startBlock + decayPeriod + (s * decayPeriod) - t != decayTable:
                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            if (startBlock * decayTable) + (decayPeriod * decayTable) + (s * decayPeriod * decayTable) - (t * decayTable) < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                    else:
                                        if startBlock + decayPeriod + (s * decayPeriod) <= startBlock:
                                            if 0 >= decayTable.length:
                                                require decayTable.length - 1 < decayTable.length
                                                if not decayTable[decayTable.length]:
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = 0
                                                else:
                                                    if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                require 0 < decayTable.length
                                            mem[0] = 17
                                            if t > startBlock + decayPeriod + (s * decayPeriod):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if startBlock + decayPeriod + (s * decayPeriod) - t:
                                                if (startBlock * decayTable) + (decayPeriod * decayTable) + (s * decayPeriod * decayTable) - (t * decayTable) / startBlock + decayPeriod + (s * decayPeriod) - t != decayTable:
                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (startBlock * decayTable) + (decayPeriod * decayTable) + (s * decayPeriod * decayTable) - (t * decayTable) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                        else:
                                            if startBlock > startBlock + decayPeriod + (s * decayPeriod):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if 1 > decayPeriod + (s * decayPeriod):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if decayPeriod <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require decayPeriod
                                            if decayPeriod + (s * decayPeriod) - 1 / decayPeriod >= decayTable.length:
                                                require decayTable.length - 1 < decayTable.length
                                                if not decayTable[decayTable.length]:
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = 0
                                                else:
                                                    if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                require decayPeriod + (s * decayPeriod) - 1 / decayPeriod < decayTable.length
                                            mem[0] = 17
                                            if t > startBlock + decayPeriod + (s * decayPeriod):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if startBlock + decayPeriod + (s * decayPeriod) - t:
                                                if (startBlock * decayTable[stor15 + (s * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (s * stor15) - 1 / stor15]) + (s * decayPeriod * decayTable[stor15 + (s * stor15) - 1 / stor15]) - (t * decayTable[stor15 + (s * stor15) - 1 / stor15]) / startBlock + decayPeriod + (s * decayPeriod) - t != decayTable[stor15 + (s * stor15) - 1 / stor15]:
                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (startBlock * decayTable[stor15 + (s * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (s * stor15) - 1 / stor15]) + (s * decayPeriod * decayTable[stor15 + (s * stor15) - 1 / stor15]) - (t * decayTable[stor15 + (s * stor15) - 1 / stor15]) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                    s = s + 1
                                    t = startBlock + decayPeriod + (s * decayPeriod)
                                    continue 
                            else:
                                if block.number <= startBlock:
                                    s = poolInfo[idx].field_512 + -startBlock - 1 / decayPeriod
                                    t = poolInfo[idx].field_512
                                    while s < 0:
                                        if not s + 1:
                                            if startBlock < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if decayPeriod != 0:
                                                if startBlock > startBlock:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                            if 0 >= decayTable.length:
                                                require decayTable.length - 1 < decayTable.length
                                                if not decayTable[decayTable.length]:
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = 0
                                                else:
                                                    if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                require 0 < decayTable.length
                                            mem[0] = 17
                                            if t > startBlock:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if startBlock - t:
                                                if (startBlock * decayTable) - (t * decayTable) / startBlock - t != decayTable:
                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (startBlock * decayTable) - (t * decayTable) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                            s = s + 1
                                            t = startBlock
                                            continue 
                                        if decayPeriod + (s * decayPeriod) / s + 1 != decayPeriod:
                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                        if startBlock < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if 0 == decayPeriod:
                                            if 0 >= decayTable.length:
                                                require decayTable.length - 1 < decayTable.length
                                                if not decayTable[decayTable.length]:
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = 0
                                                else:
                                                    if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                require 0 < decayTable.length
                                            mem[0] = 17
                                            if t > startBlock + decayPeriod + (s * decayPeriod):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if startBlock + decayPeriod + (s * decayPeriod) - t:
                                                if (startBlock * decayTable) + (decayPeriod * decayTable) + (s * decayPeriod * decayTable) - (t * decayTable) / startBlock + decayPeriod + (s * decayPeriod) - t != decayTable:
                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (startBlock * decayTable) + (decayPeriod * decayTable) + (s * decayPeriod * decayTable) - (t * decayTable) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                        else:
                                            if startBlock + decayPeriod + (s * decayPeriod) <= startBlock:
                                                if 0 >= decayTable.length:
                                                    require decayTable.length - 1 < decayTable.length
                                                    if not decayTable[decayTable.length]:
                                                        decayTable.length++
                                                        decayTable[decayTable.length] = 0
                                                    else:
                                                        if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        decayTable.length++
                                                        decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                    require 0 < decayTable.length
                                                mem[0] = 17
                                                if t > startBlock + decayPeriod + (s * decayPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if startBlock + decayPeriod + (s * decayPeriod) - t:
                                                    if (startBlock * decayTable) + (decayPeriod * decayTable) + (s * decayPeriod * decayTable) - (t * decayTable) / startBlock + decayPeriod + (s * decayPeriod) - t != decayTable:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (startBlock * decayTable) + (decayPeriod * decayTable) + (s * decayPeriod * decayTable) - (t * decayTable) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                            else:
                                                if startBlock > startBlock + decayPeriod + (s * decayPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if 1 > decayPeriod + (s * decayPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if decayPeriod <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require decayPeriod
                                                if decayPeriod + (s * decayPeriod) - 1 / decayPeriod >= decayTable.length:
                                                    require decayTable.length - 1 < decayTable.length
                                                    if not decayTable[decayTable.length]:
                                                        decayTable.length++
                                                        decayTable[decayTable.length] = 0
                                                    else:
                                                        if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        decayTable.length++
                                                        decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                    require decayPeriod + (s * decayPeriod) - 1 / decayPeriod < decayTable.length
                                                mem[0] = 17
                                                if t > startBlock + decayPeriod + (s * decayPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if startBlock + decayPeriod + (s * decayPeriod) - t:
                                                    if (startBlock * decayTable[stor15 + (s * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (s * stor15) - 1 / stor15]) + (s * decayPeriod * decayTable[stor15 + (s * stor15) - 1 / stor15]) - (t * decayTable[stor15 + (s * stor15) - 1 / stor15]) / startBlock + decayPeriod + (s * decayPeriod) - t != decayTable[stor15 + (s * stor15) - 1 / stor15]:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (startBlock * decayTable[stor15 + (s * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (s * stor15) - 1 / stor15]) + (s * decayPeriod * decayTable[stor15 + (s * stor15) - 1 / stor15]) - (t * decayTable[stor15 + (s * stor15) - 1 / stor15]) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                        s = s + 1
                                        t = startBlock + decayPeriod + (s * decayPeriod)
                                        continue 
                                else:
                                    if startBlock > block.number:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if 1 > block.number - startBlock:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if decayPeriod <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require decayPeriod
                                    s = poolInfo[idx].field_512 + -startBlock - 1 / decayPeriod
                                    t = poolInfo[idx].field_512
                                    while s < block.number + -startBlock - 1 / decayPeriod:
                                        if not s + 1:
                                            if startBlock < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if decayPeriod != 0:
                                                if startBlock > startBlock:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                            if 0 >= decayTable.length:
                                                require decayTable.length - 1 < decayTable.length
                                                if not decayTable[decayTable.length]:
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = 0
                                                else:
                                                    if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                require 0 < decayTable.length
                                            mem[0] = 17
                                            if t > startBlock:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if startBlock - t:
                                                if (startBlock * decayTable) - (t * decayTable) / startBlock - t != decayTable:
                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (startBlock * decayTable) - (t * decayTable) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                            s = s + 1
                                            t = startBlock
                                            continue 
                                        if decayPeriod + (s * decayPeriod) / s + 1 != decayPeriod:
                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                        if startBlock < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if 0 == decayPeriod:
                                            if 0 >= decayTable.length:
                                                require decayTable.length - 1 < decayTable.length
                                                if not decayTable[decayTable.length]:
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = 0
                                                else:
                                                    if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                require 0 < decayTable.length
                                            mem[0] = 17
                                            if t > startBlock + decayPeriod + (s * decayPeriod):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if startBlock + decayPeriod + (s * decayPeriod) - t:
                                                if (startBlock * decayTable) + (decayPeriod * decayTable) + (s * decayPeriod * decayTable) - (t * decayTable) / startBlock + decayPeriod + (s * decayPeriod) - t != decayTable:
                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (startBlock * decayTable) + (decayPeriod * decayTable) + (s * decayPeriod * decayTable) - (t * decayTable) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                        else:
                                            if startBlock + decayPeriod + (s * decayPeriod) <= startBlock:
                                                if 0 >= decayTable.length:
                                                    require decayTable.length - 1 < decayTable.length
                                                    if not decayTable[decayTable.length]:
                                                        decayTable.length++
                                                        decayTable[decayTable.length] = 0
                                                    else:
                                                        if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        decayTable.length++
                                                        decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                    require 0 < decayTable.length
                                                mem[0] = 17
                                                if t > startBlock + decayPeriod + (s * decayPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if startBlock + decayPeriod + (s * decayPeriod) - t:
                                                    if (startBlock * decayTable) + (decayPeriod * decayTable) + (s * decayPeriod * decayTable) - (t * decayTable) / startBlock + decayPeriod + (s * decayPeriod) - t != decayTable:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (startBlock * decayTable) + (decayPeriod * decayTable) + (s * decayPeriod * decayTable) - (t * decayTable) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                            else:
                                                if startBlock > startBlock + decayPeriod + (s * decayPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if 1 > decayPeriod + (s * decayPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if decayPeriod <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require decayPeriod
                                                if decayPeriod + (s * decayPeriod) - 1 / decayPeriod >= decayTable.length:
                                                    require decayTable.length - 1 < decayTable.length
                                                    if not decayTable[decayTable.length]:
                                                        decayTable.length++
                                                        decayTable[decayTable.length] = 0
                                                    else:
                                                        if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        decayTable.length++
                                                        decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                    require decayPeriod + (s * decayPeriod) - 1 / decayPeriod < decayTable.length
                                                mem[0] = 17
                                                if t > startBlock + decayPeriod + (s * decayPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if startBlock + decayPeriod + (s * decayPeriod) - t:
                                                    if (startBlock * decayTable[stor15 + (s * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (s * stor15) - 1 / stor15]) + (s * decayPeriod * decayTable[stor15 + (s * stor15) - 1 / stor15]) - (t * decayTable[stor15 + (s * stor15) - 1 / stor15]) / startBlock + decayPeriod + (s * decayPeriod) - t != decayTable[stor15 + (s * stor15) - 1 / stor15]:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (startBlock * decayTable[stor15 + (s * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (s * stor15) - 1 / stor15]) + (s * decayPeriod * decayTable[stor15 + (s * stor15) - 1 / stor15]) - (t * decayTable[stor15 + (s * stor15) - 1 / stor15]) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                        s = s + 1
                                        t = startBlock + decayPeriod + (s * decayPeriod)
                                        continue 
                            if 0 == decayPeriod:
                                if 0 >= decayTable.length:
                                    require decayTable.length - 1 < decayTable.length
                                    if not decayTable[decayTable.length]:
                                        decayTable.length++
                                        decayTable[decayTable.length] = 0
                                    else:
                                        if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                        decayTable.length++
                                        decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                    require 0 < decayTable.length
                                mem[0] = 17
                                if t > block.number:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if block.number - t:
                                    if (block.number * decayTable) - (t * decayTable) / block.number - t != decayTable:
                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                    if (block.number * decayTable) - (t * decayTable) < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (block.number * decayTable) - (t * decayTable) > 0:
                                        if not (block.number * decayTable) - (t * decayTable):
                                            if totalAllocPoint <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalAllocPoint
                                            mem[100] = this.address
                                            mem[132] = 0 / totalAllocPoint
                                            require ext_code.size(bxhAddress)
                                            call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                 gas gas_remaining wei
                                                args this.address, 0 / totalAllocPoint
                                            mem[96] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if ext_call.return_data[0]:
                                                if not 0 / totalAllocPoint:
                                                    if ext_call.return_data[0] <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require ext_call.return_data[0]
                                                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                else:
                                                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if ext_call.return_data[0] <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require ext_call.return_data[0]
                                                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                        else:
                                            if (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / (block.number * decayTable) - (t * decayTable) != poolInfo[idx].field_256:
                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            if totalAllocPoint <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalAllocPoint
                                            mem[100] = this.address
                                            mem[132] = (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                            require ext_code.size(bxhAddress)
                                            call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                 gas gas_remaining wei
                                                args this.address, (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                            mem[96] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if ext_call.return_data[0]:
                                                if not (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint:
                                                    if ext_call.return_data[0] <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require ext_call.return_data[0]
                                                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                else:
                                                    if 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if ext_call.return_data[0] <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require ext_call.return_data[0]
                                                    if (10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                            else:
                                if block.number <= startBlock:
                                    if 0 >= decayTable.length:
                                        require decayTable.length - 1 < decayTable.length
                                        if not decayTable[decayTable.length]:
                                            decayTable.length++
                                            decayTable[decayTable.length] = 0
                                        else:
                                            if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            decayTable.length++
                                            decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                        require 0 < decayTable.length
                                    mem[0] = 17
                                    if t > block.number:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if block.number - t:
                                        if (block.number * decayTable) - (t * decayTable) / block.number - t != decayTable:
                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                        if (block.number * decayTable) - (t * decayTable) < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (block.number * decayTable) - (t * decayTable) > 0:
                                            if not (block.number * decayTable) - (t * decayTable):
                                                if totalAllocPoint <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalAllocPoint
                                                mem[100] = this.address
                                                mem[132] = 0 / totalAllocPoint
                                                require ext_code.size(bxhAddress)
                                                call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args this.address, 0 / totalAllocPoint
                                                mem[96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if ext_call.return_data[0]:
                                                    if not 0 / totalAllocPoint:
                                                        if ext_call.return_data[0] <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require ext_call.return_data[0]
                                                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                    else:
                                                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if ext_call.return_data[0] <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require ext_call.return_data[0]
                                                        if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                            else:
                                                if (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / (block.number * decayTable) - (t * decayTable) != poolInfo[idx].field_256:
                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if totalAllocPoint <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalAllocPoint
                                                mem[100] = this.address
                                                mem[132] = (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                                require ext_code.size(bxhAddress)
                                                call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args this.address, (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                                mem[96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if ext_call.return_data[0]:
                                                    if not (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint:
                                                        if ext_call.return_data[0] <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require ext_call.return_data[0]
                                                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                    else:
                                                        if 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if ext_call.return_data[0] <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require ext_call.return_data[0]
                                                        if (10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_768 += 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                else:
                                    if startBlock > block.number:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if 1 > block.number - startBlock:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if decayPeriod <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require decayPeriod
                                    if block.number + -startBlock - 1 / decayPeriod >= decayTable.length:
                                        require decayTable.length - 1 < decayTable.length
                                        if not decayTable[decayTable.length]:
                                            decayTable.length++
                                            decayTable[decayTable.length] = 0
                                        else:
                                            if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            decayTable.length++
                                            decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                        require block.number + -startBlock - 1 / decayPeriod < decayTable.length
                                    mem[0] = 17
                                    if t > block.number:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if block.number - t:
                                        if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (t * decayTable[block.number + -stor12 - 1 / stor15]) / block.number - t != decayTable[block.number + -stor12 - 1 / stor15]:
                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                        if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (t * decayTable[block.number + -stor12 - 1 / stor15]) < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (t * decayTable[block.number + -stor12 - 1 / stor15]) > 0:
                                            if not (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (t * decayTable[block.number + -stor12 - 1 / stor15]):
                                                if totalAllocPoint <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalAllocPoint
                                                mem[100] = this.address
                                                mem[132] = 0 / totalAllocPoint
                                                require ext_code.size(bxhAddress)
                                                call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args this.address, 0 / totalAllocPoint
                                                mem[96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if ext_call.return_data[0]:
                                                    if not 0 / totalAllocPoint:
                                                        if ext_call.return_data[0] <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require ext_call.return_data[0]
                                                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                    else:
                                                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if ext_call.return_data[0] <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require ext_call.return_data[0]
                                                        if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                            else:
                                                if (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (t * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (t * decayTable[block.number + -stor12 - 1 / stor15]) != poolInfo[idx].field_256:
                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if totalAllocPoint <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalAllocPoint
                                                mem[100] = this.address
                                                mem[132] = (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (t * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint
                                                require ext_code.size(bxhAddress)
                                                call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args this.address, (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (t * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint
                                                mem[96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if ext_call.return_data[0]:
                                                    if not (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (t * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint:
                                                        if ext_call.return_data[0] <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require ext_call.return_data[0]
                                                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                    else:
                                                        if 10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (t * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint / (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (t * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if ext_call.return_data[0] <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require ext_call.return_data[0]
                                                        if (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (t * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_768 += 10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (t * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
        idx = idx + 1
        continue 
    bxhPerBlock = arg1
}

function add(uint256 arg1, address arg2, bool arg3) payable {
    require calldata.size - 4 >= 96
    if owner != msg.sender:
        revert with 0, 'wOwnable: caller is not the owne'
    if not arg2:
        revert with 0, '_lpToken is the zero address'
    if arg3:
        idx = 0
        while idx < poolInfo.length:
            mem[0] = 6
            if block.number > poolInfo[idx].field_512:
                mem[0] = poolInfo[idx].field_0
                mem[32] = 3
                if stor3[stor6[idx].field_0]:
                    if not poolInfo[idx].field_1280:
                        poolInfo[idx].field_512 = block.number
                    else:
                        if 0 == decayPeriod:
                            if 0 == decayPeriod:
                                if 0 >= decayTable.length:
                                    require decayTable.length - 1 < decayTable.length
                                    if not decayTable[decayTable.length]:
                                        decayTable.length++
                                        decayTable[decayTable.length] = 0
                                    else:
                                        if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                        decayTable.length++
                                        decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                    require 0 < decayTable.length
                                mem[0] = 17
                                if poolInfo[idx].field_512 > block.number:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if block.number - poolInfo[idx].field_512:
                                    if (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) / block.number - poolInfo[idx].field_512 != decayTable:
                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                    if (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) > 0:
                                        if not (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable):
                                            if totalAllocPoint <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalAllocPoint
                                            mem[100] = this.address
                                            mem[132] = 0 / totalAllocPoint
                                            require ext_code.size(bxhAddress)
                                            call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                 gas gas_remaining wei
                                                args this.address, 0 / totalAllocPoint
                                            mem[96] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if ext_call.return_data[0]:
                                                if not 0 / totalAllocPoint:
                                                    if poolInfo[idx].field_1280 <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require poolInfo[idx].field_1280
                                                    if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                else:
                                                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if poolInfo[idx].field_1280 <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require poolInfo[idx].field_1280
                                                    if (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1280
                                        else:
                                            if (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) != poolInfo[idx].field_256:
                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            if totalAllocPoint <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalAllocPoint
                                            mem[100] = this.address
                                            mem[132] = (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                            require ext_code.size(bxhAddress)
                                            call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                 gas gas_remaining wei
                                                args this.address, (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                            mem[96] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if ext_call.return_data[0]:
                                                if not (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint:
                                                    if poolInfo[idx].field_1280 <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require poolInfo[idx].field_1280
                                                    if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                else:
                                                    if 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if poolInfo[idx].field_1280 <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require poolInfo[idx].field_1280
                                                    if (10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_1280
                                        poolInfo[idx].field_512 = block.number
                            else:
                                if block.number <= startBlock:
                                    if 0 >= decayTable.length:
                                        require decayTable.length - 1 < decayTable.length
                                        if not decayTable[decayTable.length]:
                                            decayTable.length++
                                            decayTable[decayTable.length] = 0
                                        else:
                                            if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            decayTable.length++
                                            decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                        require 0 < decayTable.length
                                    mem[0] = 17
                                    if poolInfo[idx].field_512 > block.number:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if block.number - poolInfo[idx].field_512:
                                        if (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) / block.number - poolInfo[idx].field_512 != decayTable:
                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                        if (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) > 0:
                                            if not (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable):
                                                if totalAllocPoint <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalAllocPoint
                                                mem[100] = this.address
                                                mem[132] = 0 / totalAllocPoint
                                                require ext_code.size(bxhAddress)
                                                call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args this.address, 0 / totalAllocPoint
                                                mem[96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if ext_call.return_data[0]:
                                                    if not 0 / totalAllocPoint:
                                                        if poolInfo[idx].field_1280 <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require poolInfo[idx].field_1280
                                                        if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                    else:
                                                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if poolInfo[idx].field_1280 <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require poolInfo[idx].field_1280
                                                        if (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1280
                                            else:
                                                if (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) != poolInfo[idx].field_256:
                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if totalAllocPoint <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalAllocPoint
                                                mem[100] = this.address
                                                mem[132] = (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                                require ext_code.size(bxhAddress)
                                                call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args this.address, (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                                mem[96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if ext_call.return_data[0]:
                                                    if not (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint:
                                                        if poolInfo[idx].field_1280 <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require poolInfo[idx].field_1280
                                                        if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                    else:
                                                        if 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if poolInfo[idx].field_1280 <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require poolInfo[idx].field_1280
                                                        if (10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_768 += 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_1280
                                            poolInfo[idx].field_512 = block.number
                                else:
                                    if startBlock > block.number:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if 1 > block.number - startBlock:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if decayPeriod <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require decayPeriod
                                    if block.number + -startBlock - 1 / decayPeriod >= decayTable.length:
                                        require decayTable.length - 1 < decayTable.length
                                        if not decayTable[decayTable.length]:
                                            decayTable.length++
                                            decayTable[decayTable.length] = 0
                                        else:
                                            if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            decayTable.length++
                                            decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                        require block.number + -startBlock - 1 / decayPeriod < decayTable.length
                                    mem[0] = 17
                                    if poolInfo[idx].field_512 > block.number:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if block.number - poolInfo[idx].field_512:
                                        if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) / block.number - poolInfo[idx].field_512 != decayTable[block.number + -stor12 - 1 / stor15]:
                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                        if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) > 0:
                                            if not (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15]):
                                                if totalAllocPoint <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalAllocPoint
                                                mem[100] = this.address
                                                mem[132] = 0 / totalAllocPoint
                                                require ext_code.size(bxhAddress)
                                                call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args this.address, 0 / totalAllocPoint
                                                mem[96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if ext_call.return_data[0]:
                                                    if not 0 / totalAllocPoint:
                                                        if poolInfo[idx].field_1280 <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require poolInfo[idx].field_1280
                                                        if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                    else:
                                                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if poolInfo[idx].field_1280 <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require poolInfo[idx].field_1280
                                                        if (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1280
                                            else:
                                                if (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) != poolInfo[idx].field_256:
                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if totalAllocPoint <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalAllocPoint
                                                mem[100] = this.address
                                                mem[132] = (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint
                                                require ext_code.size(bxhAddress)
                                                call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args this.address, (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint
                                                mem[96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if ext_call.return_data[0]:
                                                    if not (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint:
                                                        if poolInfo[idx].field_1280 <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require poolInfo[idx].field_1280
                                                        if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                    else:
                                                        if 10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint / (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if poolInfo[idx].field_1280 <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require poolInfo[idx].field_1280
                                                        if (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_768 += 10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_1280
                                            poolInfo[idx].field_512 = block.number
                        else:
                            if poolInfo[idx].field_512 <= startBlock:
                                if 0 == decayPeriod:
                                    if 0 == decayPeriod:
                                        if 0 >= decayTable.length:
                                            require decayTable.length - 1 < decayTable.length
                                            if not decayTable[decayTable.length]:
                                                decayTable.length++
                                                decayTable[decayTable.length] = 0
                                            else:
                                                if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                decayTable.length++
                                                decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                            require 0 < decayTable.length
                                        mem[0] = 17
                                        if poolInfo[idx].field_512 > block.number:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if block.number - poolInfo[idx].field_512:
                                            if (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) / block.number - poolInfo[idx].field_512 != decayTable:
                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            if (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) > 0:
                                                if not (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable):
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    mem[100] = this.address
                                                    mem[132] = 0 / totalAllocPoint
                                                    require ext_code.size(bxhAddress)
                                                    call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, 0 / totalAllocPoint
                                                    mem[96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if ext_call.return_data[0]:
                                                        if not 0 / totalAllocPoint:
                                                            if poolInfo[idx].field_1280 <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require poolInfo[idx].field_1280
                                                            if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                        else:
                                                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                            if poolInfo[idx].field_1280 <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require poolInfo[idx].field_1280
                                                            if (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1280
                                                else:
                                                    if (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) != poolInfo[idx].field_256:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    mem[100] = this.address
                                                    mem[132] = (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                                    require ext_code.size(bxhAddress)
                                                    call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                                    mem[96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if ext_call.return_data[0]:
                                                        if not (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint:
                                                            if poolInfo[idx].field_1280 <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require poolInfo[idx].field_1280
                                                            if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                        else:
                                                            if 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                            if poolInfo[idx].field_1280 <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require poolInfo[idx].field_1280
                                                            if (10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_768 += 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_1280
                                                poolInfo[idx].field_512 = block.number
                                    else:
                                        if block.number <= startBlock:
                                            if 0 >= decayTable.length:
                                                require decayTable.length - 1 < decayTable.length
                                                if not decayTable[decayTable.length]:
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = 0
                                                else:
                                                    if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                require 0 < decayTable.length
                                            mem[0] = 17
                                            if poolInfo[idx].field_512 > block.number:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if block.number - poolInfo[idx].field_512:
                                                if (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) / block.number - poolInfo[idx].field_512 != decayTable:
                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) > 0:
                                                    if not (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable):
                                                        if totalAllocPoint <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require totalAllocPoint
                                                        mem[100] = this.address
                                                        mem[132] = 0 / totalAllocPoint
                                                        require ext_code.size(bxhAddress)
                                                        call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args this.address, 0 / totalAllocPoint
                                                        mem[96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if ext_call.return_data[0]:
                                                            if not 0 / totalAllocPoint:
                                                                if poolInfo[idx].field_1280 <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require poolInfo[idx].field_1280
                                                                if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                            else:
                                                                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                                if poolInfo[idx].field_1280 <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require poolInfo[idx].field_1280
                                                                if (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1280
                                                    else:
                                                        if (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) != poolInfo[idx].field_256:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if totalAllocPoint <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require totalAllocPoint
                                                        mem[100] = this.address
                                                        mem[132] = (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                                        require ext_code.size(bxhAddress)
                                                        call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args this.address, (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                                        mem[96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if ext_call.return_data[0]:
                                                            if not (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint:
                                                                if poolInfo[idx].field_1280 <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require poolInfo[idx].field_1280
                                                                if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                            else:
                                                                if 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                                if poolInfo[idx].field_1280 <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require poolInfo[idx].field_1280
                                                                if (10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_768 += 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_1280
                                                    poolInfo[idx].field_512 = block.number
                                        else:
                                            if startBlock > block.number:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if 1 > block.number - startBlock:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if decayPeriod <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require decayPeriod
                                            if block.number + -startBlock - 1 / decayPeriod >= decayTable.length:
                                                require decayTable.length - 1 < decayTable.length
                                                if not decayTable[decayTable.length]:
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = 0
                                                else:
                                                    if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                require block.number + -startBlock - 1 / decayPeriod < decayTable.length
                                            mem[0] = 17
                                            if poolInfo[idx].field_512 > block.number:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if block.number - poolInfo[idx].field_512:
                                                if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) / block.number - poolInfo[idx].field_512 != decayTable[block.number + -stor12 - 1 / stor15]:
                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) > 0:
                                                    if not (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15]):
                                                        if totalAllocPoint <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require totalAllocPoint
                                                        mem[100] = this.address
                                                        mem[132] = 0 / totalAllocPoint
                                                        require ext_code.size(bxhAddress)
                                                        call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args this.address, 0 / totalAllocPoint
                                                        mem[96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if ext_call.return_data[0]:
                                                            if not 0 / totalAllocPoint:
                                                                if poolInfo[idx].field_1280 <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require poolInfo[idx].field_1280
                                                                if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                            else:
                                                                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                                if poolInfo[idx].field_1280 <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require poolInfo[idx].field_1280
                                                                if (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1280
                                                    else:
                                                        if (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) != poolInfo[idx].field_256:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if totalAllocPoint <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require totalAllocPoint
                                                        mem[100] = this.address
                                                        mem[132] = (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint
                                                        require ext_code.size(bxhAddress)
                                                        call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args this.address, (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint
                                                        mem[96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if ext_call.return_data[0]:
                                                            if not (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint:
                                                                if poolInfo[idx].field_1280 <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require poolInfo[idx].field_1280
                                                                if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                            else:
                                                                if 10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint / (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                                if poolInfo[idx].field_1280 <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require poolInfo[idx].field_1280
                                                                if (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_768 += 10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_1280
                                                    poolInfo[idx].field_512 = block.number
                                else:
                                    if block.number <= startBlock:
                                        if 0 == decayPeriod:
                                            if 0 >= decayTable.length:
                                                require decayTable.length - 1 < decayTable.length
                                                if not decayTable[decayTable.length]:
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = 0
                                                else:
                                                    if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                require 0 < decayTable.length
                                            mem[0] = 17
                                            if poolInfo[idx].field_512 > block.number:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if block.number - poolInfo[idx].field_512:
                                                if (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) / block.number - poolInfo[idx].field_512 != decayTable:
                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) > 0:
                                                    if not (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable):
                                                        if totalAllocPoint <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require totalAllocPoint
                                                        mem[100] = this.address
                                                        mem[132] = 0 / totalAllocPoint
                                                        require ext_code.size(bxhAddress)
                                                        call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args this.address, 0 / totalAllocPoint
                                                        mem[96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if ext_call.return_data[0]:
                                                            if not 0 / totalAllocPoint:
                                                                if poolInfo[idx].field_1280 <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require poolInfo[idx].field_1280
                                                                if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                            else:
                                                                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                                if poolInfo[idx].field_1280 <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require poolInfo[idx].field_1280
                                                                if (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1280
                                                    else:
                                                        if (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) != poolInfo[idx].field_256:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if totalAllocPoint <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require totalAllocPoint
                                                        mem[100] = this.address
                                                        mem[132] = (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                                        require ext_code.size(bxhAddress)
                                                        call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args this.address, (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                                        mem[96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if ext_call.return_data[0]:
                                                            if not (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint:
                                                                if poolInfo[idx].field_1280 <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require poolInfo[idx].field_1280
                                                                if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                            else:
                                                                if 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                                if poolInfo[idx].field_1280 <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require poolInfo[idx].field_1280
                                                                if (10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_768 += 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_1280
                                                    poolInfo[idx].field_512 = block.number
                                        else:
                                            if block.number <= startBlock:
                                                if 0 >= decayTable.length:
                                                    require decayTable.length - 1 < decayTable.length
                                                    if not decayTable[decayTable.length]:
                                                        decayTable.length++
                                                        decayTable[decayTable.length] = 0
                                                    else:
                                                        if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        decayTable.length++
                                                        decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                    require 0 < decayTable.length
                                                mem[0] = 17
                                                if poolInfo[idx].field_512 > block.number:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if block.number - poolInfo[idx].field_512:
                                                    if (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) / block.number - poolInfo[idx].field_512 != decayTable:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) > 0:
                                                        if not (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable):
                                                            if totalAllocPoint <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require totalAllocPoint
                                                            mem[100] = this.address
                                                            mem[132] = 0 / totalAllocPoint
                                                            require ext_code.size(bxhAddress)
                                                            call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                                 gas gas_remaining wei
                                                                args this.address, 0 / totalAllocPoint
                                                            mem[96] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if ext_call.return_data[0]:
                                                                if not 0 / totalAllocPoint:
                                                                    if poolInfo[idx].field_1280 <= 0:
                                                                        revert with 0, 'SafeMath: division by zero'
                                                                    require poolInfo[idx].field_1280
                                                                    if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                                else:
                                                                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                                    if poolInfo[idx].field_1280 <= 0:
                                                                        revert with 0, 'SafeMath: division by zero'
                                                                    require poolInfo[idx].field_1280
                                                                    if (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1280
                                                        else:
                                                            if (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) != poolInfo[idx].field_256:
                                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                            if totalAllocPoint <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require totalAllocPoint
                                                            mem[100] = this.address
                                                            mem[132] = (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                                            require ext_code.size(bxhAddress)
                                                            call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                                 gas gas_remaining wei
                                                                args this.address, (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                                            mem[96] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if ext_call.return_data[0]:
                                                                if not (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint:
                                                                    if poolInfo[idx].field_1280 <= 0:
                                                                        revert with 0, 'SafeMath: division by zero'
                                                                    require poolInfo[idx].field_1280
                                                                    if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                                else:
                                                                    if 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                                    if poolInfo[idx].field_1280 <= 0:
                                                                        revert with 0, 'SafeMath: division by zero'
                                                                    require poolInfo[idx].field_1280
                                                                    if (10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    poolInfo[idx].field_768 += 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_1280
                                                        poolInfo[idx].field_512 = block.number
                                            else:
                                                if startBlock > block.number:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if 1 > block.number - startBlock:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if decayPeriod <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require decayPeriod
                                                if block.number + -startBlock - 1 / decayPeriod >= decayTable.length:
                                                    require decayTable.length - 1 < decayTable.length
                                                    if not decayTable[decayTable.length]:
                                                        decayTable.length++
                                                        decayTable[decayTable.length] = 0
                                                    else:
                                                        if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        decayTable.length++
                                                        decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                    require block.number + -startBlock - 1 / decayPeriod < decayTable.length
                                                mem[0] = 17
                                                if poolInfo[idx].field_512 > block.number:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if block.number - poolInfo[idx].field_512:
                                                    if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) / block.number - poolInfo[idx].field_512 != decayTable[block.number + -stor12 - 1 / stor15]:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) > 0:
                                                        if not (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15]):
                                                            if totalAllocPoint <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require totalAllocPoint
                                                            mem[100] = this.address
                                                            mem[132] = 0 / totalAllocPoint
                                                            require ext_code.size(bxhAddress)
                                                            call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                                 gas gas_remaining wei
                                                                args this.address, 0 / totalAllocPoint
                                                            mem[96] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if ext_call.return_data[0]:
                                                                if not 0 / totalAllocPoint:
                                                                    if poolInfo[idx].field_1280 <= 0:
                                                                        revert with 0, 'SafeMath: division by zero'
                                                                    require poolInfo[idx].field_1280
                                                                    if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                                else:
                                                                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                                    if poolInfo[idx].field_1280 <= 0:
                                                                        revert with 0, 'SafeMath: division by zero'
                                                                    require poolInfo[idx].field_1280
                                                                    if (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1280
                                                        else:
                                                            if (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) != poolInfo[idx].field_256:
                                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                            if totalAllocPoint <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require totalAllocPoint
                                                            mem[100] = this.address
                                                            mem[132] = (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint
                                                            require ext_code.size(bxhAddress)
                                                            call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                                 gas gas_remaining wei
                                                                args this.address, (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint
                                                            mem[96] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if ext_call.return_data[0]:
                                                                if not (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint:
                                                                    if poolInfo[idx].field_1280 <= 0:
                                                                        revert with 0, 'SafeMath: division by zero'
                                                                    require poolInfo[idx].field_1280
                                                                    if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                                else:
                                                                    if 10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint / (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                                    if poolInfo[idx].field_1280 <= 0:
                                                                        revert with 0, 'SafeMath: division by zero'
                                                                    require poolInfo[idx].field_1280
                                                                    if (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    poolInfo[idx].field_768 += 10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_1280
                                                        poolInfo[idx].field_512 = block.number
                                    else:
                                        if startBlock > block.number:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if 1 > block.number - startBlock:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if decayPeriod <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require decayPeriod
                                        s = 0
                                        t = poolInfo[idx].field_512
                                        while s < block.number + -startBlock - 1 / decayPeriod:
                                            if not s + 1:
                                                if startBlock < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if decayPeriod != 0:
                                                    if startBlock > startBlock:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                if 0 >= decayTable.length:
                                                    require decayTable.length - 1 < decayTable.length
                                                    if not decayTable[decayTable.length]:
                                                        decayTable.length++
                                                        decayTable[decayTable.length] = 0
                                                    else:
                                                        if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        decayTable.length++
                                                        decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                    require 0 < decayTable.length
                                                mem[0] = 17
                                                if t > startBlock:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if startBlock - t:
                                                    if (startBlock * decayTable) - (t * decayTable) / startBlock - t != decayTable:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (startBlock * decayTable) - (t * decayTable) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                s = s + 1
                                                t = startBlock
                                                continue 
                                            if decayPeriod + (s * decayPeriod) / s + 1 != decayPeriod:
                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            if startBlock < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if 0 == decayPeriod:
                                                if 0 >= decayTable.length:
                                                    require decayTable.length - 1 < decayTable.length
                                                    if not decayTable[decayTable.length]:
                                                        decayTable.length++
                                                        decayTable[decayTable.length] = 0
                                                    else:
                                                        if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        decayTable.length++
                                                        decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                    require 0 < decayTable.length
                                                mem[0] = 17
                                                if t > startBlock + decayPeriod + (s * decayPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if startBlock + decayPeriod + (s * decayPeriod) - t:
                                                    if (startBlock * decayTable) + (decayPeriod * decayTable) + (s * decayPeriod * decayTable) - (t * decayTable) / startBlock + decayPeriod + (s * decayPeriod) - t != decayTable:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (startBlock * decayTable) + (decayPeriod * decayTable) + (s * decayPeriod * decayTable) - (t * decayTable) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                            else:
                                                if startBlock + decayPeriod + (s * decayPeriod) <= startBlock:
                                                    if 0 >= decayTable.length:
                                                        require decayTable.length - 1 < decayTable.length
                                                        if not decayTable[decayTable.length]:
                                                            decayTable.length++
                                                            decayTable[decayTable.length] = 0
                                                        else:
                                                            if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                            decayTable.length++
                                                            decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                        require 0 < decayTable.length
                                                    mem[0] = 17
                                                    if t > startBlock + decayPeriod + (s * decayPeriod):
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if startBlock + decayPeriod + (s * decayPeriod) - t:
                                                        if (startBlock * decayTable) + (decayPeriod * decayTable) + (s * decayPeriod * decayTable) - (t * decayTable) / startBlock + decayPeriod + (s * decayPeriod) - t != decayTable:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if (startBlock * decayTable) + (decayPeriod * decayTable) + (s * decayPeriod * decayTable) - (t * decayTable) < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                else:
                                                    if startBlock > startBlock + decayPeriod + (s * decayPeriod):
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if 1 > decayPeriod + (s * decayPeriod):
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if decayPeriod <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require decayPeriod
                                                    if decayPeriod + (s * decayPeriod) - 1 / decayPeriod >= decayTable.length:
                                                        require decayTable.length - 1 < decayTable.length
                                                        if not decayTable[decayTable.length]:
                                                            decayTable.length++
                                                            decayTable[decayTable.length] = 0
                                                        else:
                                                            if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                            decayTable.length++
                                                            decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                        require decayPeriod + (s * decayPeriod) - 1 / decayPeriod < decayTable.length
                                                    mem[0] = 17
                                                    if t > startBlock + decayPeriod + (s * decayPeriod):
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if startBlock + decayPeriod + (s * decayPeriod) - t:
                                                        if (startBlock * decayTable[stor15 + (s * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (s * stor15) - 1 / stor15]) + (s * decayPeriod * decayTable[stor15 + (s * stor15) - 1 / stor15]) - (t * decayTable[stor15 + (s * stor15) - 1 / stor15]) / startBlock + decayPeriod + (s * decayPeriod) - t != decayTable[stor15 + (s * stor15) - 1 / stor15]:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if (startBlock * decayTable[stor15 + (s * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (s * stor15) - 1 / stor15]) + (s * decayPeriod * decayTable[stor15 + (s * stor15) - 1 / stor15]) - (t * decayTable[stor15 + (s * stor15) - 1 / stor15]) < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                            s = s + 1
                                            t = startBlock + decayPeriod + (s * decayPeriod)
                                            continue 
                                        if 0 == decayPeriod:
                                            if 0 >= decayTable.length:
                                                require decayTable.length - 1 < decayTable.length
                                                if not decayTable[decayTable.length]:
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = 0
                                                else:
                                                    if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                require 0 < decayTable.length
                                            mem[0] = 17
                                            if t > block.number:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if block.number - t:
                                                if (block.number * decayTable) - (t * decayTable) / block.number - t != decayTable:
                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (block.number * decayTable) - (t * decayTable) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if (block.number * decayTable) - (t * decayTable) > 0:
                                                    if not (block.number * decayTable) - (t * decayTable):
                                                        if totalAllocPoint <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require totalAllocPoint
                                                        mem[100] = this.address
                                                        mem[132] = 0 / totalAllocPoint
                                                        require ext_code.size(bxhAddress)
                                                        call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args this.address, 0 / totalAllocPoint
                                                        mem[96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if ext_call.return_data[0]:
                                                            if not 0 / totalAllocPoint:
                                                                if poolInfo[idx].field_1280 <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require poolInfo[idx].field_1280
                                                                if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                            else:
                                                                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                                if poolInfo[idx].field_1280 <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require poolInfo[idx].field_1280
                                                                if (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1280
                                                    else:
                                                        if (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / (block.number * decayTable) - (t * decayTable) != poolInfo[idx].field_256:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if totalAllocPoint <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require totalAllocPoint
                                                        mem[100] = this.address
                                                        mem[132] = (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                                        require ext_code.size(bxhAddress)
                                                        call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args this.address, (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                                        mem[96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if ext_call.return_data[0]:
                                                            if not (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint:
                                                                if poolInfo[idx].field_1280 <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require poolInfo[idx].field_1280
                                                                if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                            else:
                                                                if 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                                if poolInfo[idx].field_1280 <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require poolInfo[idx].field_1280
                                                                if (10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_768 += 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_1280
                                                    poolInfo[idx].field_512 = block.number
                                        else:
                                            if block.number <= startBlock:
                                                if 0 >= decayTable.length:
                                                    require decayTable.length - 1 < decayTable.length
                                                    if not decayTable[decayTable.length]:
                                                        decayTable.length++
                                                        decayTable[decayTable.length] = 0
                                                    else:
                                                        if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        decayTable.length++
                                                        decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                    require 0 < decayTable.length
                                                mem[0] = 17
                                                if t > block.number:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if block.number - t:
                                                    if (block.number * decayTable) - (t * decayTable) / block.number - t != decayTable:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (block.number * decayTable) - (t * decayTable) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if (block.number * decayTable) - (t * decayTable) > 0:
                                                        if not (block.number * decayTable) - (t * decayTable):
                                                            if totalAllocPoint <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require totalAllocPoint
                                                            mem[100] = this.address
                                                            mem[132] = 0 / totalAllocPoint
                                                            require ext_code.size(bxhAddress)
                                                            call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                                 gas gas_remaining wei
                                                                args this.address, 0 / totalAllocPoint
                                                            mem[96] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if ext_call.return_data[0]:
                                                                if not 0 / totalAllocPoint:
                                                                    if poolInfo[idx].field_1280 <= 0:
                                                                        revert with 0, 'SafeMath: division by zero'
                                                                    require poolInfo[idx].field_1280
                                                                    if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                                else:
                                                                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                                    if poolInfo[idx].field_1280 <= 0:
                                                                        revert with 0, 'SafeMath: division by zero'
                                                                    require poolInfo[idx].field_1280
                                                                    if (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1280
                                                        else:
                                                            if (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / (block.number * decayTable) - (t * decayTable) != poolInfo[idx].field_256:
                                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                            if totalAllocPoint <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require totalAllocPoint
                                                            mem[100] = this.address
                                                            mem[132] = (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                                            require ext_code.size(bxhAddress)
                                                            call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                                 gas gas_remaining wei
                                                                args this.address, (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                                            mem[96] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if ext_call.return_data[0]:
                                                                if not (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint:
                                                                    if poolInfo[idx].field_1280 <= 0:
                                                                        revert with 0, 'SafeMath: division by zero'
                                                                    require poolInfo[idx].field_1280
                                                                    if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                                else:
                                                                    if 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                                    if poolInfo[idx].field_1280 <= 0:
                                                                        revert with 0, 'SafeMath: division by zero'
                                                                    require poolInfo[idx].field_1280
                                                                    if (10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    poolInfo[idx].field_768 += 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_1280
                                                        poolInfo[idx].field_512 = block.number
                                            else:
                                                if startBlock > block.number:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if 1 > block.number - startBlock:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if decayPeriod <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require decayPeriod
                                                if block.number + -startBlock - 1 / decayPeriod >= decayTable.length:
                                                    require decayTable.length - 1 < decayTable.length
                                                    if not decayTable[decayTable.length]:
                                                        decayTable.length++
                                                        decayTable[decayTable.length] = 0
                                                    else:
                                                        if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        decayTable.length++
                                                        decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                    require block.number + -startBlock - 1 / decayPeriod < decayTable.length
                                                mem[0] = 17
                                                if t > block.number:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if block.number - t:
                                                    if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (t * decayTable[block.number + -stor12 - 1 / stor15]) / block.number - t != decayTable[block.number + -stor12 - 1 / stor15]:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (t * decayTable[block.number + -stor12 - 1 / stor15]) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (t * decayTable[block.number + -stor12 - 1 / stor15]) > 0:
                                                        if not (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (t * decayTable[block.number + -stor12 - 1 / stor15]):
                                                            if totalAllocPoint <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require totalAllocPoint
                                                            mem[100] = this.address
                                                            mem[132] = 0 / totalAllocPoint
                                                            require ext_code.size(bxhAddress)
                                                            call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                                 gas gas_remaining wei
                                                                args this.address, 0 / totalAllocPoint
                                                            mem[96] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if ext_call.return_data[0]:
                                                                if not 0 / totalAllocPoint:
                                                                    if poolInfo[idx].field_1280 <= 0:
                                                                        revert with 0, 'SafeMath: division by zero'
                                                                    require poolInfo[idx].field_1280
                                                                    if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                                else:
                                                                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                                    if poolInfo[idx].field_1280 <= 0:
                                                                        revert with 0, 'SafeMath: division by zero'
                                                                    require poolInfo[idx].field_1280
                                                                    if (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1280
                                                        else:
                                                            if (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (t * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (t * decayTable[block.number + -stor12 - 1 / stor15]) != poolInfo[idx].field_256:
                                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                            if totalAllocPoint <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require totalAllocPoint
                                                            mem[100] = this.address
                                                            mem[132] = (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (t * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint
                                                            require ext_code.size(bxhAddress)
                                                            call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                                 gas gas_remaining wei
                                                                args this.address, (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (t * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint
                                                            mem[96] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if ext_call.return_data[0]:
                                                                if not (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (t * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint:
                                                                    if poolInfo[idx].field_1280 <= 0:
                                                                        revert with 0, 'SafeMath: division by zero'
                                                                    require poolInfo[idx].field_1280
                                                                    if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                                else:
                                                                    if 10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (t * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint / (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (t * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                                    if poolInfo[idx].field_1280 <= 0:
                                                                        revert with 0, 'SafeMath: division by zero'
                                                                    require poolInfo[idx].field_1280
                                                                    if (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (t * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    poolInfo[idx].field_768 += 10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (t * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_1280
                                                        poolInfo[idx].field_512 = block.number
                            else:
                                if startBlock > poolInfo[idx].field_512:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if 1 > poolInfo[idx].field_512 - startBlock:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if decayPeriod <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require decayPeriod
                                if 0 == decayPeriod:
                                    s = poolInfo[idx].field_512 + -startBlock - 1 / decayPeriod
                                    t = poolInfo[idx].field_512
                                    while s < 0:
                                        if not s + 1:
                                            if startBlock < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if decayPeriod != 0:
                                                if startBlock > startBlock:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                            if 0 >= decayTable.length:
                                                require decayTable.length - 1 < decayTable.length
                                                if not decayTable[decayTable.length]:
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = 0
                                                else:
                                                    if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                require 0 < decayTable.length
                                            mem[0] = 17
                                            if t > startBlock:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if startBlock - t:
                                                if (startBlock * decayTable) - (t * decayTable) / startBlock - t != decayTable:
                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (startBlock * decayTable) - (t * decayTable) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                            s = s + 1
                                            t = startBlock
                                            continue 
                                        if decayPeriod + (s * decayPeriod) / s + 1 != decayPeriod:
                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                        if startBlock < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if 0 == decayPeriod:
                                            if 0 >= decayTable.length:
                                                require decayTable.length - 1 < decayTable.length
                                                if not decayTable[decayTable.length]:
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = 0
                                                else:
                                                    if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                require 0 < decayTable.length
                                            mem[0] = 17
                                            if t > startBlock + decayPeriod + (s * decayPeriod):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if startBlock + decayPeriod + (s * decayPeriod) - t:
                                                if (startBlock * decayTable) + (decayPeriod * decayTable) + (s * decayPeriod * decayTable) - (t * decayTable) / startBlock + decayPeriod + (s * decayPeriod) - t != decayTable:
                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (startBlock * decayTable) + (decayPeriod * decayTable) + (s * decayPeriod * decayTable) - (t * decayTable) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                        else:
                                            if startBlock + decayPeriod + (s * decayPeriod) <= startBlock:
                                                if 0 >= decayTable.length:
                                                    require decayTable.length - 1 < decayTable.length
                                                    if not decayTable[decayTable.length]:
                                                        decayTable.length++
                                                        decayTable[decayTable.length] = 0
                                                    else:
                                                        if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        decayTable.length++
                                                        decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                    require 0 < decayTable.length
                                                mem[0] = 17
                                                if t > startBlock + decayPeriod + (s * decayPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if startBlock + decayPeriod + (s * decayPeriod) - t:
                                                    if (startBlock * decayTable) + (decayPeriod * decayTable) + (s * decayPeriod * decayTable) - (t * decayTable) / startBlock + decayPeriod + (s * decayPeriod) - t != decayTable:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (startBlock * decayTable) + (decayPeriod * decayTable) + (s * decayPeriod * decayTable) - (t * decayTable) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                            else:
                                                if startBlock > startBlock + decayPeriod + (s * decayPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if 1 > decayPeriod + (s * decayPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if decayPeriod <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require decayPeriod
                                                if decayPeriod + (s * decayPeriod) - 1 / decayPeriod >= decayTable.length:
                                                    require decayTable.length - 1 < decayTable.length
                                                    if not decayTable[decayTable.length]:
                                                        decayTable.length++
                                                        decayTable[decayTable.length] = 0
                                                    else:
                                                        if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        decayTable.length++
                                                        decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                    require decayPeriod + (s * decayPeriod) - 1 / decayPeriod < decayTable.length
                                                mem[0] = 17
                                                if t > startBlock + decayPeriod + (s * decayPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if startBlock + decayPeriod + (s * decayPeriod) - t:
                                                    if (startBlock * decayTable[stor15 + (s * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (s * stor15) - 1 / stor15]) + (s * decayPeriod * decayTable[stor15 + (s * stor15) - 1 / stor15]) - (t * decayTable[stor15 + (s * stor15) - 1 / stor15]) / startBlock + decayPeriod + (s * decayPeriod) - t != decayTable[stor15 + (s * stor15) - 1 / stor15]:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (startBlock * decayTable[stor15 + (s * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (s * stor15) - 1 / stor15]) + (s * decayPeriod * decayTable[stor15 + (s * stor15) - 1 / stor15]) - (t * decayTable[stor15 + (s * stor15) - 1 / stor15]) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                        s = s + 1
                                        t = startBlock + decayPeriod + (s * decayPeriod)
                                        continue 
                                else:
                                    if block.number <= startBlock:
                                        s = poolInfo[idx].field_512 + -startBlock - 1 / decayPeriod
                                        t = poolInfo[idx].field_512
                                        while s < 0:
                                            if not s + 1:
                                                if startBlock < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if decayPeriod != 0:
                                                    if startBlock > startBlock:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                if 0 >= decayTable.length:
                                                    require decayTable.length - 1 < decayTable.length
                                                    if not decayTable[decayTable.length]:
                                                        decayTable.length++
                                                        decayTable[decayTable.length] = 0
                                                    else:
                                                        if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        decayTable.length++
                                                        decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                    require 0 < decayTable.length
                                                mem[0] = 17
                                                if t > startBlock:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if startBlock - t:
                                                    if (startBlock * decayTable) - (t * decayTable) / startBlock - t != decayTable:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (startBlock * decayTable) - (t * decayTable) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                s = s + 1
                                                t = startBlock
                                                continue 
                                            if decayPeriod + (s * decayPeriod) / s + 1 != decayPeriod:
                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            if startBlock < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if 0 == decayPeriod:
                                                if 0 >= decayTable.length:
                                                    require decayTable.length - 1 < decayTable.length
                                                    if not decayTable[decayTable.length]:
                                                        decayTable.length++
                                                        decayTable[decayTable.length] = 0
                                                    else:
                                                        if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        decayTable.length++
                                                        decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                    require 0 < decayTable.length
                                                mem[0] = 17
                                                if t > startBlock + decayPeriod + (s * decayPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if startBlock + decayPeriod + (s * decayPeriod) - t:
                                                    if (startBlock * decayTable) + (decayPeriod * decayTable) + (s * decayPeriod * decayTable) - (t * decayTable) / startBlock + decayPeriod + (s * decayPeriod) - t != decayTable:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (startBlock * decayTable) + (decayPeriod * decayTable) + (s * decayPeriod * decayTable) - (t * decayTable) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                            else:
                                                if startBlock + decayPeriod + (s * decayPeriod) <= startBlock:
                                                    if 0 >= decayTable.length:
                                                        require decayTable.length - 1 < decayTable.length
                                                        if not decayTable[decayTable.length]:
                                                            decayTable.length++
                                                            decayTable[decayTable.length] = 0
                                                        else:
                                                            if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                            decayTable.length++
                                                            decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                        require 0 < decayTable.length
                                                    mem[0] = 17
                                                    if t > startBlock + decayPeriod + (s * decayPeriod):
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if startBlock + decayPeriod + (s * decayPeriod) - t:
                                                        if (startBlock * decayTable) + (decayPeriod * decayTable) + (s * decayPeriod * decayTable) - (t * decayTable) / startBlock + decayPeriod + (s * decayPeriod) - t != decayTable:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if (startBlock * decayTable) + (decayPeriod * decayTable) + (s * decayPeriod * decayTable) - (t * decayTable) < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                else:
                                                    if startBlock > startBlock + decayPeriod + (s * decayPeriod):
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if 1 > decayPeriod + (s * decayPeriod):
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if decayPeriod <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require decayPeriod
                                                    if decayPeriod + (s * decayPeriod) - 1 / decayPeriod >= decayTable.length:
                                                        require decayTable.length - 1 < decayTable.length
                                                        if not decayTable[decayTable.length]:
                                                            decayTable.length++
                                                            decayTable[decayTable.length] = 0
                                                        else:
                                                            if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                            decayTable.length++
                                                            decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                        require decayPeriod + (s * decayPeriod) - 1 / decayPeriod < decayTable.length
                                                    mem[0] = 17
                                                    if t > startBlock + decayPeriod + (s * decayPeriod):
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if startBlock + decayPeriod + (s * decayPeriod) - t:
                                                        if (startBlock * decayTable[stor15 + (s * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (s * stor15) - 1 / stor15]) + (s * decayPeriod * decayTable[stor15 + (s * stor15) - 1 / stor15]) - (t * decayTable[stor15 + (s * stor15) - 1 / stor15]) / startBlock + decayPeriod + (s * decayPeriod) - t != decayTable[stor15 + (s * stor15) - 1 / stor15]:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if (startBlock * decayTable[stor15 + (s * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (s * stor15) - 1 / stor15]) + (s * decayPeriod * decayTable[stor15 + (s * stor15) - 1 / stor15]) - (t * decayTable[stor15 + (s * stor15) - 1 / stor15]) < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                            s = s + 1
                                            t = startBlock + decayPeriod + (s * decayPeriod)
                                            continue 
                                    else:
                                        if startBlock > block.number:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if 1 > block.number - startBlock:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if decayPeriod <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require decayPeriod
                                        s = poolInfo[idx].field_512 + -startBlock - 1 / decayPeriod
                                        t = poolInfo[idx].field_512
                                        while s < block.number + -startBlock - 1 / decayPeriod:
                                            if not s + 1:
                                                if startBlock < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if decayPeriod != 0:
                                                    if startBlock > startBlock:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                if 0 >= decayTable.length:
                                                    require decayTable.length - 1 < decayTable.length
                                                    if not decayTable[decayTable.length]:
                                                        decayTable.length++
                                                        decayTable[decayTable.length] = 0
                                                    else:
                                                        if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        decayTable.length++
                                                        decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                    require 0 < decayTable.length
                                                mem[0] = 17
                                                if t > startBlock:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if startBlock - t:
                                                    if (startBlock * decayTable) - (t * decayTable) / startBlock - t != decayTable:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (startBlock * decayTable) - (t * decayTable) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                s = s + 1
                                                t = startBlock
                                                continue 
                                            if decayPeriod + (s * decayPeriod) / s + 1 != decayPeriod:
                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            if startBlock < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if 0 == decayPeriod:
                                                if 0 >= decayTable.length:
                                                    require decayTable.length - 1 < decayTable.length
                                                    if not decayTable[decayTable.length]:
                                                        decayTable.length++
                                                        decayTable[decayTable.length] = 0
                                                    else:
                                                        if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        decayTable.length++
                                                        decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                    require 0 < decayTable.length
                                                mem[0] = 17
                                                if t > startBlock + decayPeriod + (s * decayPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if startBlock + decayPeriod + (s * decayPeriod) - t:
                                                    if (startBlock * decayTable) + (decayPeriod * decayTable) + (s * decayPeriod * decayTable) - (t * decayTable) / startBlock + decayPeriod + (s * decayPeriod) - t != decayTable:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (startBlock * decayTable) + (decayPeriod * decayTable) + (s * decayPeriod * decayTable) - (t * decayTable) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                            else:
                                                if startBlock + decayPeriod + (s * decayPeriod) <= startBlock:
                                                    if 0 >= decayTable.length:
                                                        require decayTable.length - 1 < decayTable.length
                                                        if not decayTable[decayTable.length]:
                                                            decayTable.length++
                                                            decayTable[decayTable.length] = 0
                                                        else:
                                                            if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                            decayTable.length++
                                                            decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                        require 0 < decayTable.length
                                                    mem[0] = 17
                                                    if t > startBlock + decayPeriod + (s * decayPeriod):
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if startBlock + decayPeriod + (s * decayPeriod) - t:
                                                        if (startBlock * decayTable) + (decayPeriod * decayTable) + (s * decayPeriod * decayTable) - (t * decayTable) / startBlock + decayPeriod + (s * decayPeriod) - t != decayTable:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if (startBlock * decayTable) + (decayPeriod * decayTable) + (s * decayPeriod * decayTable) - (t * decayTable) < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                else:
                                                    if startBlock > startBlock + decayPeriod + (s * decayPeriod):
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if 1 > decayPeriod + (s * decayPeriod):
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if decayPeriod <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require decayPeriod
                                                    if decayPeriod + (s * decayPeriod) - 1 / decayPeriod >= decayTable.length:
                                                        require decayTable.length - 1 < decayTable.length
                                                        if not decayTable[decayTable.length]:
                                                            decayTable.length++
                                                            decayTable[decayTable.length] = 0
                                                        else:
                                                            if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                            decayTable.length++
                                                            decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                        require decayPeriod + (s * decayPeriod) - 1 / decayPeriod < decayTable.length
                                                    mem[0] = 17
                                                    if t > startBlock + decayPeriod + (s * decayPeriod):
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if startBlock + decayPeriod + (s * decayPeriod) - t:
                                                        if (startBlock * decayTable[stor15 + (s * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (s * stor15) - 1 / stor15]) + (s * decayPeriod * decayTable[stor15 + (s * stor15) - 1 / stor15]) - (t * decayTable[stor15 + (s * stor15) - 1 / stor15]) / startBlock + decayPeriod + (s * decayPeriod) - t != decayTable[stor15 + (s * stor15) - 1 / stor15]:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if (startBlock * decayTable[stor15 + (s * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (s * stor15) - 1 / stor15]) + (s * decayPeriod * decayTable[stor15 + (s * stor15) - 1 / stor15]) - (t * decayTable[stor15 + (s * stor15) - 1 / stor15]) < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                            s = s + 1
                                            t = startBlock + decayPeriod + (s * decayPeriod)
                                            continue 
                                if 0 == decayPeriod:
                                    if 0 >= decayTable.length:
                                        require decayTable.length - 1 < decayTable.length
                                        if not decayTable[decayTable.length]:
                                            decayTable.length++
                                            decayTable[decayTable.length] = 0
                                        else:
                                            if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            decayTable.length++
                                            decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                        require 0 < decayTable.length
                                    mem[0] = 17
                                    if t > block.number:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if block.number - t:
                                        if (block.number * decayTable) - (t * decayTable) / block.number - t != decayTable:
                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                        if (block.number * decayTable) - (t * decayTable) < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (block.number * decayTable) - (t * decayTable) > 0:
                                            if not (block.number * decayTable) - (t * decayTable):
                                                if totalAllocPoint <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalAllocPoint
                                                mem[100] = this.address
                                                mem[132] = 0 / totalAllocPoint
                                                require ext_code.size(bxhAddress)
                                                call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args this.address, 0 / totalAllocPoint
                                                mem[96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if ext_call.return_data[0]:
                                                    if not 0 / totalAllocPoint:
                                                        if poolInfo[idx].field_1280 <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require poolInfo[idx].field_1280
                                                        if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                    else:
                                                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if poolInfo[idx].field_1280 <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require poolInfo[idx].field_1280
                                                        if (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1280
                                            else:
                                                if (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / (block.number * decayTable) - (t * decayTable) != poolInfo[idx].field_256:
                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if totalAllocPoint <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalAllocPoint
                                                mem[100] = this.address
                                                mem[132] = (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                                require ext_code.size(bxhAddress)
                                                call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args this.address, (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                                mem[96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if ext_call.return_data[0]:
                                                    if not (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint:
                                                        if poolInfo[idx].field_1280 <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require poolInfo[idx].field_1280
                                                        if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                    else:
                                                        if 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if poolInfo[idx].field_1280 <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require poolInfo[idx].field_1280
                                                        if (10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_768 += 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_1280
                                            poolInfo[idx].field_512 = block.number
                                else:
                                    if block.number <= startBlock:
                                        if 0 >= decayTable.length:
                                            require decayTable.length - 1 < decayTable.length
                                            if not decayTable[decayTable.length]:
                                                decayTable.length++
                                                decayTable[decayTable.length] = 0
                                            else:
                                                if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                decayTable.length++
                                                decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                            require 0 < decayTable.length
                                        mem[0] = 17
                                        if t > block.number:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if block.number - t:
                                            if (block.number * decayTable) - (t * decayTable) / block.number - t != decayTable:
                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            if (block.number * decayTable) - (t * decayTable) < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (block.number * decayTable) - (t * decayTable) > 0:
                                                if not (block.number * decayTable) - (t * decayTable):
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    mem[100] = this.address
                                                    mem[132] = 0 / totalAllocPoint
                                                    require ext_code.size(bxhAddress)
                                                    call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, 0 / totalAllocPoint
                                                    mem[96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if ext_call.return_data[0]:
                                                        if not 0 / totalAllocPoint:
                                                            if poolInfo[idx].field_1280 <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require poolInfo[idx].field_1280
                                                            if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                        else:
                                                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                            if poolInfo[idx].field_1280 <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require poolInfo[idx].field_1280
                                                            if (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1280
                                                else:
                                                    if (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / (block.number * decayTable) - (t * decayTable) != poolInfo[idx].field_256:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    mem[100] = this.address
                                                    mem[132] = (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                                    require ext_code.size(bxhAddress)
                                                    call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                                    mem[96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if ext_call.return_data[0]:
                                                        if not (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint:
                                                            if poolInfo[idx].field_1280 <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require poolInfo[idx].field_1280
                                                            if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                        else:
                                                            if 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                            if poolInfo[idx].field_1280 <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require poolInfo[idx].field_1280
                                                            if (10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_768 += 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_1280
                                                poolInfo[idx].field_512 = block.number
                                    else:
                                        if startBlock > block.number:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if 1 > block.number - startBlock:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if decayPeriod <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require decayPeriod
                                        if block.number + -startBlock - 1 / decayPeriod >= decayTable.length:
                                            require decayTable.length - 1 < decayTable.length
                                            if not decayTable[decayTable.length]:
                                                decayTable.length++
                                                decayTable[decayTable.length] = 0
                                            else:
                                                if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                decayTable.length++
                                                decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                            require block.number + -startBlock - 1 / decayPeriod < decayTable.length
                                        mem[0] = 17
                                        if t > block.number:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if block.number - t:
                                            if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (t * decayTable[block.number + -stor12 - 1 / stor15]) / block.number - t != decayTable[block.number + -stor12 - 1 / stor15]:
                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (t * decayTable[block.number + -stor12 - 1 / stor15]) < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (t * decayTable[block.number + -stor12 - 1 / stor15]) > 0:
                                                if not (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (t * decayTable[block.number + -stor12 - 1 / stor15]):
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    mem[100] = this.address
                                                    mem[132] = 0 / totalAllocPoint
                                                    require ext_code.size(bxhAddress)
                                                    call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, 0 / totalAllocPoint
                                                    mem[96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if ext_call.return_data[0]:
                                                        if not 0 / totalAllocPoint:
                                                            if poolInfo[idx].field_1280 <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require poolInfo[idx].field_1280
                                                            if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                        else:
                                                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                            if poolInfo[idx].field_1280 <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require poolInfo[idx].field_1280
                                                            if (10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / poolInfo[idx].field_1280
                                                else:
                                                    if (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (t * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (t * decayTable[block.number + -stor12 - 1 / stor15]) != poolInfo[idx].field_256:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    mem[100] = this.address
                                                    mem[132] = (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (t * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint
                                                    require ext_code.size(bxhAddress)
                                                    call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (t * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint
                                                    mem[96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if ext_call.return_data[0]:
                                                        if not (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (t * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint:
                                                            if poolInfo[idx].field_1280 <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require poolInfo[idx].field_1280
                                                            if (0 / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_768 += 0 / poolInfo[idx].field_1280
                                                        else:
                                                            if 10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (t * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint / (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (t * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                            if poolInfo[idx].field_1280 <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require poolInfo[idx].field_1280
                                                            if (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (t * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_1280) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_768 += 10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (t * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint / poolInfo[idx].field_1280
                                                poolInfo[idx].field_512 = block.number
                else:
                    mem[100] = this.address
                    require ext_code.size(poolInfo[idx].field_0)
                    staticcall poolInfo[idx].field_0.0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if not ext_call.return_data[0]:
                        poolInfo[idx].field_512 = block.number
                    else:
                        if 0 == decayPeriod:
                            if 0 == decayPeriod:
                                if 0 >= decayTable.length:
                                    require decayTable.length - 1 < decayTable.length
                                    if not decayTable[decayTable.length]:
                                        decayTable.length++
                                        decayTable[decayTable.length] = 0
                                    else:
                                        if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                        decayTable.length++
                                        decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                    require 0 < decayTable.length
                                mem[0] = 17
                                if poolInfo[idx].field_512 > block.number:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if block.number - poolInfo[idx].field_512:
                                    if (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) / block.number - poolInfo[idx].field_512 != decayTable:
                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                    if (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) > 0:
                                        if not (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable):
                                            if totalAllocPoint <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalAllocPoint
                                            mem[100] = this.address
                                            mem[132] = 0 / totalAllocPoint
                                            require ext_code.size(bxhAddress)
                                            call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                 gas gas_remaining wei
                                                args this.address, 0 / totalAllocPoint
                                            mem[96] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if ext_call.return_data[0]:
                                                if not 0 / totalAllocPoint:
                                                    if ext_call.return_data[0] <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require ext_call.return_data[0]
                                                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                else:
                                                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if ext_call.return_data[0] <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require ext_call.return_data[0]
                                                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                        else:
                                            if (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) != poolInfo[idx].field_256:
                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            if totalAllocPoint <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalAllocPoint
                                            mem[100] = this.address
                                            mem[132] = (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                            require ext_code.size(bxhAddress)
                                            call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                 gas gas_remaining wei
                                                args this.address, (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                            mem[96] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if ext_call.return_data[0]:
                                                if not (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint:
                                                    if ext_call.return_data[0] <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require ext_call.return_data[0]
                                                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                else:
                                                    if 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if ext_call.return_data[0] <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require ext_call.return_data[0]
                                                    if (10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                            else:
                                if block.number <= startBlock:
                                    if 0 >= decayTable.length:
                                        require decayTable.length - 1 < decayTable.length
                                        if not decayTable[decayTable.length]:
                                            decayTable.length++
                                            decayTable[decayTable.length] = 0
                                        else:
                                            if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            decayTable.length++
                                            decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                        require 0 < decayTable.length
                                    mem[0] = 17
                                    if poolInfo[idx].field_512 > block.number:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if block.number - poolInfo[idx].field_512:
                                        if (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) / block.number - poolInfo[idx].field_512 != decayTable:
                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                        if (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) > 0:
                                            if not (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable):
                                                if totalAllocPoint <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalAllocPoint
                                                mem[100] = this.address
                                                mem[132] = 0 / totalAllocPoint
                                                require ext_code.size(bxhAddress)
                                                call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args this.address, 0 / totalAllocPoint
                                                mem[96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if ext_call.return_data[0]:
                                                    if not 0 / totalAllocPoint:
                                                        if ext_call.return_data[0] <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require ext_call.return_data[0]
                                                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                    else:
                                                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if ext_call.return_data[0] <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require ext_call.return_data[0]
                                                        if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                            else:
                                                if (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) != poolInfo[idx].field_256:
                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if totalAllocPoint <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalAllocPoint
                                                mem[100] = this.address
                                                mem[132] = (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                                require ext_code.size(bxhAddress)
                                                call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args this.address, (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                                mem[96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if ext_call.return_data[0]:
                                                    if not (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint:
                                                        if ext_call.return_data[0] <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require ext_call.return_data[0]
                                                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                    else:
                                                        if 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if ext_call.return_data[0] <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require ext_call.return_data[0]
                                                        if (10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_768 += 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                else:
                                    if startBlock > block.number:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if 1 > block.number - startBlock:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if decayPeriod <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require decayPeriod
                                    if block.number + -startBlock - 1 / decayPeriod >= decayTable.length:
                                        require decayTable.length - 1 < decayTable.length
                                        if not decayTable[decayTable.length]:
                                            decayTable.length++
                                            decayTable[decayTable.length] = 0
                                        else:
                                            if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            decayTable.length++
                                            decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                        require block.number + -startBlock - 1 / decayPeriod < decayTable.length
                                    mem[0] = 17
                                    if poolInfo[idx].field_512 > block.number:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if block.number - poolInfo[idx].field_512:
                                        if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) / block.number - poolInfo[idx].field_512 != decayTable[block.number + -stor12 - 1 / stor15]:
                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                        if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) > 0:
                                            if not (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15]):
                                                if totalAllocPoint <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalAllocPoint
                                                mem[100] = this.address
                                                mem[132] = 0 / totalAllocPoint
                                                require ext_code.size(bxhAddress)
                                                call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args this.address, 0 / totalAllocPoint
                                                mem[96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if ext_call.return_data[0]:
                                                    if not 0 / totalAllocPoint:
                                                        if ext_call.return_data[0] <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require ext_call.return_data[0]
                                                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                    else:
                                                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if ext_call.return_data[0] <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require ext_call.return_data[0]
                                                        if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                            else:
                                                if (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) != poolInfo[idx].field_256:
                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if totalAllocPoint <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalAllocPoint
                                                mem[100] = this.address
                                                mem[132] = (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint
                                                require ext_code.size(bxhAddress)
                                                call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args this.address, (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint
                                                mem[96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if ext_call.return_data[0]:
                                                    if not (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint:
                                                        if ext_call.return_data[0] <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require ext_call.return_data[0]
                                                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                    else:
                                                        if 10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint / (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if ext_call.return_data[0] <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require ext_call.return_data[0]
                                                        if (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_768 += 10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                        else:
                            if poolInfo[idx].field_512 <= startBlock:
                                if 0 == decayPeriod:
                                    if 0 == decayPeriod:
                                        if 0 >= decayTable.length:
                                            require decayTable.length - 1 < decayTable.length
                                            if not decayTable[decayTable.length]:
                                                decayTable.length++
                                                decayTable[decayTable.length] = 0
                                            else:
                                                if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                decayTable.length++
                                                decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                            require 0 < decayTable.length
                                        mem[0] = 17
                                        if poolInfo[idx].field_512 > block.number:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if block.number - poolInfo[idx].field_512:
                                            if (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) / block.number - poolInfo[idx].field_512 != decayTable:
                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            if (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) > 0:
                                                if not (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable):
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    mem[100] = this.address
                                                    mem[132] = 0 / totalAllocPoint
                                                    require ext_code.size(bxhAddress)
                                                    call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, 0 / totalAllocPoint
                                                    mem[96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if ext_call.return_data[0]:
                                                        if not 0 / totalAllocPoint:
                                                            if ext_call.return_data[0] <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require ext_call.return_data[0]
                                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                        else:
                                                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                            if ext_call.return_data[0] <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require ext_call.return_data[0]
                                                            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                                else:
                                                    if (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) != poolInfo[idx].field_256:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    mem[100] = this.address
                                                    mem[132] = (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                                    require ext_code.size(bxhAddress)
                                                    call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                                    mem[96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if ext_call.return_data[0]:
                                                        if not (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint:
                                                            if ext_call.return_data[0] <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require ext_call.return_data[0]
                                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                        else:
                                                            if 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                            if ext_call.return_data[0] <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require ext_call.return_data[0]
                                                            if (10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_768 += 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                    else:
                                        if block.number <= startBlock:
                                            if 0 >= decayTable.length:
                                                require decayTable.length - 1 < decayTable.length
                                                if not decayTable[decayTable.length]:
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = 0
                                                else:
                                                    if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                require 0 < decayTable.length
                                            mem[0] = 17
                                            if poolInfo[idx].field_512 > block.number:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if block.number - poolInfo[idx].field_512:
                                                if (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) / block.number - poolInfo[idx].field_512 != decayTable:
                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) > 0:
                                                    if not (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable):
                                                        if totalAllocPoint <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require totalAllocPoint
                                                        mem[100] = this.address
                                                        mem[132] = 0 / totalAllocPoint
                                                        require ext_code.size(bxhAddress)
                                                        call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args this.address, 0 / totalAllocPoint
                                                        mem[96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if ext_call.return_data[0]:
                                                            if not 0 / totalAllocPoint:
                                                                if ext_call.return_data[0] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require ext_call.return_data[0]
                                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                            else:
                                                                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                                if ext_call.return_data[0] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require ext_call.return_data[0]
                                                                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                                    else:
                                                        if (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) != poolInfo[idx].field_256:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if totalAllocPoint <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require totalAllocPoint
                                                        mem[100] = this.address
                                                        mem[132] = (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                                        require ext_code.size(bxhAddress)
                                                        call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args this.address, (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                                        mem[96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if ext_call.return_data[0]:
                                                            if not (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint:
                                                                if ext_call.return_data[0] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require ext_call.return_data[0]
                                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                            else:
                                                                if 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                                if ext_call.return_data[0] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require ext_call.return_data[0]
                                                                if (10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_768 += 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                                                    poolInfo[idx].field_512 = block.number
                                        else:
                                            if startBlock > block.number:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if 1 > block.number - startBlock:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if decayPeriod <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require decayPeriod
                                            if block.number + -startBlock - 1 / decayPeriod >= decayTable.length:
                                                require decayTable.length - 1 < decayTable.length
                                                if not decayTable[decayTable.length]:
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = 0
                                                else:
                                                    if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                require block.number + -startBlock - 1 / decayPeriod < decayTable.length
                                            mem[0] = 17
                                            if poolInfo[idx].field_512 > block.number:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if block.number - poolInfo[idx].field_512:
                                                if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) / block.number - poolInfo[idx].field_512 != decayTable[block.number + -stor12 - 1 / stor15]:
                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) > 0:
                                                    if not (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15]):
                                                        if totalAllocPoint <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require totalAllocPoint
                                                        mem[100] = this.address
                                                        mem[132] = 0 / totalAllocPoint
                                                        require ext_code.size(bxhAddress)
                                                        call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args this.address, 0 / totalAllocPoint
                                                        mem[96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if ext_call.return_data[0]:
                                                            if not 0 / totalAllocPoint:
                                                                if ext_call.return_data[0] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require ext_call.return_data[0]
                                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                            else:
                                                                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                                if ext_call.return_data[0] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require ext_call.return_data[0]
                                                                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                                    else:
                                                        if (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) != poolInfo[idx].field_256:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if totalAllocPoint <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require totalAllocPoint
                                                        mem[100] = this.address
                                                        mem[132] = (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint
                                                        require ext_code.size(bxhAddress)
                                                        call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args this.address, (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint
                                                        mem[96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if ext_call.return_data[0]:
                                                            if not (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint:
                                                                if ext_call.return_data[0] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require ext_call.return_data[0]
                                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                            else:
                                                                if 10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint / (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                                if ext_call.return_data[0] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require ext_call.return_data[0]
                                                                if (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_768 += 10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                                                    poolInfo[idx].field_512 = block.number
                                else:
                                    if block.number <= startBlock:
                                        if 0 == decayPeriod:
                                            if 0 >= decayTable.length:
                                                require decayTable.length - 1 < decayTable.length
                                                if not decayTable[decayTable.length]:
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = 0
                                                else:
                                                    if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                require 0 < decayTable.length
                                            mem[0] = 17
                                            if poolInfo[idx].field_512 > block.number:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if block.number - poolInfo[idx].field_512:
                                                if (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) / block.number - poolInfo[idx].field_512 != decayTable:
                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) > 0:
                                                    if not (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable):
                                                        if totalAllocPoint <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require totalAllocPoint
                                                        mem[100] = this.address
                                                        mem[132] = 0 / totalAllocPoint
                                                        require ext_code.size(bxhAddress)
                                                        call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args this.address, 0 / totalAllocPoint
                                                        mem[96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if ext_call.return_data[0]:
                                                            if not 0 / totalAllocPoint:
                                                                if ext_call.return_data[0] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require ext_call.return_data[0]
                                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                            else:
                                                                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                                if ext_call.return_data[0] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require ext_call.return_data[0]
                                                                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                                    else:
                                                        if (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) != poolInfo[idx].field_256:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if totalAllocPoint <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require totalAllocPoint
                                                        mem[100] = this.address
                                                        mem[132] = (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                                        require ext_code.size(bxhAddress)
                                                        call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args this.address, (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                                        mem[96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if ext_call.return_data[0]:
                                                            if not (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint:
                                                                if ext_call.return_data[0] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require ext_call.return_data[0]
                                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                            else:
                                                                if 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                                if ext_call.return_data[0] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require ext_call.return_data[0]
                                                                if (10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_768 += 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                                                    poolInfo[idx].field_512 = block.number
                                        else:
                                            if block.number <= startBlock:
                                                if 0 >= decayTable.length:
                                                    require decayTable.length - 1 < decayTable.length
                                                    if not decayTable[decayTable.length]:
                                                        decayTable.length++
                                                        decayTable[decayTable.length] = 0
                                                    else:
                                                        if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        decayTable.length++
                                                        decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                    require 0 < decayTable.length
                                                mem[0] = 17
                                                if poolInfo[idx].field_512 > block.number:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if block.number - poolInfo[idx].field_512:
                                                    if (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) / block.number - poolInfo[idx].field_512 != decayTable:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) > 0:
                                                        if not (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable):
                                                            if totalAllocPoint <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require totalAllocPoint
                                                            mem[100] = this.address
                                                            mem[132] = 0 / totalAllocPoint
                                                            require ext_code.size(bxhAddress)
                                                            call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                                 gas gas_remaining wei
                                                                args this.address, 0 / totalAllocPoint
                                                            mem[96] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if ext_call.return_data[0]:
                                                                if not 0 / totalAllocPoint:
                                                                    if ext_call.return_data[0] <= 0:
                                                                        revert with 0, 'SafeMath: division by zero'
                                                                    require ext_call.return_data[0]
                                                                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                                else:
                                                                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                                    if ext_call.return_data[0] <= 0:
                                                                        revert with 0, 'SafeMath: division by zero'
                                                                    require ext_call.return_data[0]
                                                                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                                        else:
                                                            if (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / (block.number * decayTable) - (poolInfo[idx].field_512 * decayTable) != poolInfo[idx].field_256:
                                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                            if totalAllocPoint <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require totalAllocPoint
                                                            mem[100] = this.address
                                                            mem[132] = (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                                            require ext_code.size(bxhAddress)
                                                            call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                                 gas gas_remaining wei
                                                                args this.address, (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                                            mem[96] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if ext_call.return_data[0]:
                                                                if not (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint:
                                                                    if ext_call.return_data[0] <= 0:
                                                                        revert with 0, 'SafeMath: division by zero'
                                                                    require ext_call.return_data[0]
                                                                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                                else:
                                                                    if 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                                    if ext_call.return_data[0] <= 0:
                                                                        revert with 0, 'SafeMath: division by zero'
                                                                    require ext_call.return_data[0]
                                                                    if (10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    poolInfo[idx].field_768 += 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                                                        poolInfo[idx].field_512 = block.number
                                            else:
                                                if startBlock > block.number:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if 1 > block.number - startBlock:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if decayPeriod <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require decayPeriod
                                                if block.number + -startBlock - 1 / decayPeriod >= decayTable.length:
                                                    require decayTable.length - 1 < decayTable.length
                                                    if not decayTable[decayTable.length]:
                                                        decayTable.length++
                                                        decayTable[decayTable.length] = 0
                                                    else:
                                                        if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        decayTable.length++
                                                        decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                    require block.number + -startBlock - 1 / decayPeriod < decayTable.length
                                                mem[0] = 17
                                                if poolInfo[idx].field_512 > block.number:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if block.number - poolInfo[idx].field_512:
                                                    if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) / block.number - poolInfo[idx].field_512 != decayTable[block.number + -stor12 - 1 / stor15]:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) > 0:
                                                        if not (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15]):
                                                            if totalAllocPoint <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require totalAllocPoint
                                                            mem[100] = this.address
                                                            mem[132] = 0 / totalAllocPoint
                                                            require ext_code.size(bxhAddress)
                                                            call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                                 gas gas_remaining wei
                                                                args this.address, 0 / totalAllocPoint
                                                            mem[96] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if ext_call.return_data[0]:
                                                                if not 0 / totalAllocPoint:
                                                                    if ext_call.return_data[0] <= 0:
                                                                        revert with 0, 'SafeMath: division by zero'
                                                                    require ext_call.return_data[0]
                                                                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                                else:
                                                                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                                    if ext_call.return_data[0] <= 0:
                                                                        revert with 0, 'SafeMath: division by zero'
                                                                    require ext_call.return_data[0]
                                                                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                                        else:
                                                            if (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) != poolInfo[idx].field_256:
                                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                            if totalAllocPoint <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require totalAllocPoint
                                                            mem[100] = this.address
                                                            mem[132] = (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint
                                                            require ext_code.size(bxhAddress)
                                                            call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                                 gas gas_remaining wei
                                                                args this.address, (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint
                                                            mem[96] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if ext_call.return_data[0]:
                                                                if not (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint:
                                                                    if ext_call.return_data[0] <= 0:
                                                                        revert with 0, 'SafeMath: division by zero'
                                                                    require ext_call.return_data[0]
                                                                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                                else:
                                                                    if 10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint / (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                                    if ext_call.return_data[0] <= 0:
                                                                        revert with 0, 'SafeMath: division by zero'
                                                                    require ext_call.return_data[0]
                                                                    if (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    poolInfo[idx].field_768 += 10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                                                        poolInfo[idx].field_512 = block.number
                                    else:
                                        if startBlock > block.number:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if 1 > block.number - startBlock:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if decayPeriod <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require decayPeriod
                                        s = 0
                                        t = poolInfo[idx].field_512
                                        while s < block.number + -startBlock - 1 / decayPeriod:
                                            if not s + 1:
                                                if startBlock < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if decayPeriod != 0:
                                                    if startBlock > startBlock:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                if 0 >= decayTable.length:
                                                    require decayTable.length - 1 < decayTable.length
                                                    if not decayTable[decayTable.length]:
                                                        decayTable.length++
                                                        decayTable[decayTable.length] = 0
                                                    else:
                                                        if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        decayTable.length++
                                                        decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                    require 0 < decayTable.length
                                                mem[0] = 17
                                                if t > startBlock:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if startBlock - t:
                                                    if (startBlock * decayTable) - (t * decayTable) / startBlock - t != decayTable:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (startBlock * decayTable) - (t * decayTable) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                s = s + 1
                                                t = startBlock
                                                continue 
                                            if decayPeriod + (s * decayPeriod) / s + 1 != decayPeriod:
                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            if startBlock < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if 0 == decayPeriod:
                                                if 0 >= decayTable.length:
                                                    require decayTable.length - 1 < decayTable.length
                                                    if not decayTable[decayTable.length]:
                                                        decayTable.length++
                                                        decayTable[decayTable.length] = 0
                                                    else:
                                                        if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        decayTable.length++
                                                        decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                    require 0 < decayTable.length
                                                mem[0] = 17
                                                if t > startBlock + decayPeriod + (s * decayPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if startBlock + decayPeriod + (s * decayPeriod) - t:
                                                    if (startBlock * decayTable) + (decayPeriod * decayTable) + (s * decayPeriod * decayTable) - (t * decayTable) / startBlock + decayPeriod + (s * decayPeriod) - t != decayTable:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (startBlock * decayTable) + (decayPeriod * decayTable) + (s * decayPeriod * decayTable) - (t * decayTable) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                            else:
                                                if startBlock + decayPeriod + (s * decayPeriod) <= startBlock:
                                                    if 0 >= decayTable.length:
                                                        require decayTable.length - 1 < decayTable.length
                                                        if not decayTable[decayTable.length]:
                                                            decayTable.length++
                                                            decayTable[decayTable.length] = 0
                                                        else:
                                                            if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                            decayTable.length++
                                                            decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                        require 0 < decayTable.length
                                                    mem[0] = 17
                                                    if t > startBlock + decayPeriod + (s * decayPeriod):
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if startBlock + decayPeriod + (s * decayPeriod) - t:
                                                        if (startBlock * decayTable) + (decayPeriod * decayTable) + (s * decayPeriod * decayTable) - (t * decayTable) / startBlock + decayPeriod + (s * decayPeriod) - t != decayTable:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if (startBlock * decayTable) + (decayPeriod * decayTable) + (s * decayPeriod * decayTable) - (t * decayTable) < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                else:
                                                    if startBlock > startBlock + decayPeriod + (s * decayPeriod):
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if 1 > decayPeriod + (s * decayPeriod):
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if decayPeriod <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require decayPeriod
                                                    if decayPeriod + (s * decayPeriod) - 1 / decayPeriod >= decayTable.length:
                                                        require decayTable.length - 1 < decayTable.length
                                                        if not decayTable[decayTable.length]:
                                                            decayTable.length++
                                                            decayTable[decayTable.length] = 0
                                                        else:
                                                            if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                            decayTable.length++
                                                            decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                        require decayPeriod + (s * decayPeriod) - 1 / decayPeriod < decayTable.length
                                                    mem[0] = 17
                                                    if t > startBlock + decayPeriod + (s * decayPeriod):
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if startBlock + decayPeriod + (s * decayPeriod) - t:
                                                        if (startBlock * decayTable[stor15 + (s * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (s * stor15) - 1 / stor15]) + (s * decayPeriod * decayTable[stor15 + (s * stor15) - 1 / stor15]) - (t * decayTable[stor15 + (s * stor15) - 1 / stor15]) / startBlock + decayPeriod + (s * decayPeriod) - t != decayTable[stor15 + (s * stor15) - 1 / stor15]:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if (startBlock * decayTable[stor15 + (s * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (s * stor15) - 1 / stor15]) + (s * decayPeriod * decayTable[stor15 + (s * stor15) - 1 / stor15]) - (t * decayTable[stor15 + (s * stor15) - 1 / stor15]) < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                            s = s + 1
                                            t = startBlock + decayPeriod + (s * decayPeriod)
                                            continue 
                                        if 0 == decayPeriod:
                                            if 0 >= decayTable.length:
                                                require decayTable.length - 1 < decayTable.length
                                                if not decayTable[decayTable.length]:
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = 0
                                                else:
                                                    if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                require 0 < decayTable.length
                                            mem[0] = 17
                                            if t > block.number:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if block.number - t:
                                                if (block.number * decayTable) - (t * decayTable) / block.number - t != decayTable:
                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (block.number * decayTable) - (t * decayTable) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if (block.number * decayTable) - (t * decayTable) > 0:
                                                    if not (block.number * decayTable) - (t * decayTable):
                                                        if totalAllocPoint <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require totalAllocPoint
                                                        mem[100] = this.address
                                                        mem[132] = 0 / totalAllocPoint
                                                        require ext_code.size(bxhAddress)
                                                        call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args this.address, 0 / totalAllocPoint
                                                        mem[96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if ext_call.return_data[0]:
                                                            if not 0 / totalAllocPoint:
                                                                if ext_call.return_data[0] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require ext_call.return_data[0]
                                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                            else:
                                                                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                                if ext_call.return_data[0] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require ext_call.return_data[0]
                                                                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                                    else:
                                                        if (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / (block.number * decayTable) - (t * decayTable) != poolInfo[idx].field_256:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if totalAllocPoint <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require totalAllocPoint
                                                        mem[100] = this.address
                                                        mem[132] = (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                                        require ext_code.size(bxhAddress)
                                                        call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args this.address, (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                                        mem[96] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        require return_data.size >= 32
                                                        if ext_call.return_data[0]:
                                                            if not (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint:
                                                                if ext_call.return_data[0] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require ext_call.return_data[0]
                                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                            else:
                                                                if 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                                if ext_call.return_data[0] <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                require ext_call.return_data[0]
                                                                if (10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                poolInfo[idx].field_768 += 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                                                    poolInfo[idx].field_512 = block.number
                                        else:
                                            if block.number <= startBlock:
                                                if 0 >= decayTable.length:
                                                    require decayTable.length - 1 < decayTable.length
                                                    if not decayTable[decayTable.length]:
                                                        decayTable.length++
                                                        decayTable[decayTable.length] = 0
                                                    else:
                                                        if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        decayTable.length++
                                                        decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                    require 0 < decayTable.length
                                                mem[0] = 17
                                                if t > block.number:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if block.number - t:
                                                    if (block.number * decayTable) - (t * decayTable) / block.number - t != decayTable:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (block.number * decayTable) - (t * decayTable) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if (block.number * decayTable) - (t * decayTable) > 0:
                                                        if not (block.number * decayTable) - (t * decayTable):
                                                            if totalAllocPoint <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require totalAllocPoint
                                                            mem[100] = this.address
                                                            mem[132] = 0 / totalAllocPoint
                                                            require ext_code.size(bxhAddress)
                                                            call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                                 gas gas_remaining wei
                                                                args this.address, 0 / totalAllocPoint
                                                            mem[96] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if ext_call.return_data[0]:
                                                                if not 0 / totalAllocPoint:
                                                                    if ext_call.return_data[0] <= 0:
                                                                        revert with 0, 'SafeMath: division by zero'
                                                                    require ext_call.return_data[0]
                                                                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                                else:
                                                                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                                    if ext_call.return_data[0] <= 0:
                                                                        revert with 0, 'SafeMath: division by zero'
                                                                    require ext_call.return_data[0]
                                                                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                                        else:
                                                            if (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / (block.number * decayTable) - (t * decayTable) != poolInfo[idx].field_256:
                                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                            if totalAllocPoint <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require totalAllocPoint
                                                            mem[100] = this.address
                                                            mem[132] = (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                                            require ext_code.size(bxhAddress)
                                                            call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                                 gas gas_remaining wei
                                                                args this.address, (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                                            mem[96] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if ext_call.return_data[0]:
                                                                if not (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint:
                                                                    if ext_call.return_data[0] <= 0:
                                                                        revert with 0, 'SafeMath: division by zero'
                                                                    require ext_call.return_data[0]
                                                                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                                else:
                                                                    if 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                                    if ext_call.return_data[0] <= 0:
                                                                        revert with 0, 'SafeMath: division by zero'
                                                                    require ext_call.return_data[0]
                                                                    if (10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    poolInfo[idx].field_768 += 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                                                        poolInfo[idx].field_512 = block.number
                                            else:
                                                if startBlock > block.number:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if 1 > block.number - startBlock:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if decayPeriod <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require decayPeriod
                                                if block.number + -startBlock - 1 / decayPeriod >= decayTable.length:
                                                    require decayTable.length - 1 < decayTable.length
                                                    if not decayTable[decayTable.length]:
                                                        decayTable.length++
                                                        decayTable[decayTable.length] = 0
                                                    else:
                                                        if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        decayTable.length++
                                                        decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                    require block.number + -startBlock - 1 / decayPeriod < decayTable.length
                                                mem[0] = 17
                                                if t > block.number:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if block.number - t:
                                                    if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (t * decayTable[block.number + -stor12 - 1 / stor15]) / block.number - t != decayTable[block.number + -stor12 - 1 / stor15]:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (t * decayTable[block.number + -stor12 - 1 / stor15]) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (t * decayTable[block.number + -stor12 - 1 / stor15]) > 0:
                                                        if not (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (t * decayTable[block.number + -stor12 - 1 / stor15]):
                                                            if totalAllocPoint <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require totalAllocPoint
                                                            mem[100] = this.address
                                                            mem[132] = 0 / totalAllocPoint
                                                            require ext_code.size(bxhAddress)
                                                            call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                                 gas gas_remaining wei
                                                                args this.address, 0 / totalAllocPoint
                                                            mem[96] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if ext_call.return_data[0]:
                                                                if not 0 / totalAllocPoint:
                                                                    if ext_call.return_data[0] <= 0:
                                                                        revert with 0, 'SafeMath: division by zero'
                                                                    require ext_call.return_data[0]
                                                                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                                else:
                                                                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                                    if ext_call.return_data[0] <= 0:
                                                                        revert with 0, 'SafeMath: division by zero'
                                                                    require ext_call.return_data[0]
                                                                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                                        else:
                                                            if (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (t * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (t * decayTable[block.number + -stor12 - 1 / stor15]) != poolInfo[idx].field_256:
                                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                            if totalAllocPoint <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require totalAllocPoint
                                                            mem[100] = this.address
                                                            mem[132] = (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (t * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint
                                                            require ext_code.size(bxhAddress)
                                                            call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                                 gas gas_remaining wei
                                                                args this.address, (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (t * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint
                                                            mem[96] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            require return_data.size >= 32
                                                            if ext_call.return_data[0]:
                                                                if not (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (t * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint:
                                                                    if ext_call.return_data[0] <= 0:
                                                                        revert with 0, 'SafeMath: division by zero'
                                                                    require ext_call.return_data[0]
                                                                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                                else:
                                                                    if 10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (t * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint / (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (t * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                                    if ext_call.return_data[0] <= 0:
                                                                        revert with 0, 'SafeMath: division by zero'
                                                                    require ext_call.return_data[0]
                                                                    if (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (t * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    poolInfo[idx].field_768 += 10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (t * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                                                        poolInfo[idx].field_512 = block.number
                            else:
                                if startBlock > poolInfo[idx].field_512:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if 1 > poolInfo[idx].field_512 - startBlock:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if decayPeriod <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require decayPeriod
                                if 0 == decayPeriod:
                                    s = poolInfo[idx].field_512 + -startBlock - 1 / decayPeriod
                                    t = poolInfo[idx].field_512
                                    while s < 0:
                                        if not s + 1:
                                            if startBlock < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if decayPeriod != 0:
                                                if startBlock > startBlock:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                            if 0 >= decayTable.length:
                                                require decayTable.length - 1 < decayTable.length
                                                if not decayTable[decayTable.length]:
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = 0
                                                else:
                                                    if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                require 0 < decayTable.length
                                            mem[0] = 17
                                            if t > startBlock:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if startBlock - t:
                                                if (startBlock * decayTable) - (t * decayTable) / startBlock - t != decayTable:
                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (startBlock * decayTable) - (t * decayTable) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                            s = s + 1
                                            t = startBlock
                                            continue 
                                        if decayPeriod + (s * decayPeriod) / s + 1 != decayPeriod:
                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                        if startBlock < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if 0 == decayPeriod:
                                            if 0 >= decayTable.length:
                                                require decayTable.length - 1 < decayTable.length
                                                if not decayTable[decayTable.length]:
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = 0
                                                else:
                                                    if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                require 0 < decayTable.length
                                            mem[0] = 17
                                            if t > startBlock + decayPeriod + (s * decayPeriod):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if startBlock + decayPeriod + (s * decayPeriod) - t:
                                                if (startBlock * decayTable) + (decayPeriod * decayTable) + (s * decayPeriod * decayTable) - (t * decayTable) / startBlock + decayPeriod + (s * decayPeriod) - t != decayTable:
                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if (startBlock * decayTable) + (decayPeriod * decayTable) + (s * decayPeriod * decayTable) - (t * decayTable) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                        else:
                                            if startBlock + decayPeriod + (s * decayPeriod) <= startBlock:
                                                if 0 >= decayTable.length:
                                                    require decayTable.length - 1 < decayTable.length
                                                    if not decayTable[decayTable.length]:
                                                        decayTable.length++
                                                        decayTable[decayTable.length] = 0
                                                    else:
                                                        if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        decayTable.length++
                                                        decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                    require 0 < decayTable.length
                                                mem[0] = 17
                                                if t > startBlock + decayPeriod + (s * decayPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if startBlock + decayPeriod + (s * decayPeriod) - t:
                                                    if (startBlock * decayTable) + (decayPeriod * decayTable) + (s * decayPeriod * decayTable) - (t * decayTable) / startBlock + decayPeriod + (s * decayPeriod) - t != decayTable:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (startBlock * decayTable) + (decayPeriod * decayTable) + (s * decayPeriod * decayTable) - (t * decayTable) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                            else:
                                                if startBlock > startBlock + decayPeriod + (s * decayPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if 1 > decayPeriod + (s * decayPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if decayPeriod <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require decayPeriod
                                                if decayPeriod + (s * decayPeriod) - 1 / decayPeriod >= decayTable.length:
                                                    require decayTable.length - 1 < decayTable.length
                                                    if not decayTable[decayTable.length]:
                                                        decayTable.length++
                                                        decayTable[decayTable.length] = 0
                                                    else:
                                                        if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        decayTable.length++
                                                        decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                    require decayPeriod + (s * decayPeriod) - 1 / decayPeriod < decayTable.length
                                                mem[0] = 17
                                                if t > startBlock + decayPeriod + (s * decayPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if startBlock + decayPeriod + (s * decayPeriod) - t:
                                                    if (startBlock * decayTable[stor15 + (s * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (s * stor15) - 1 / stor15]) + (s * decayPeriod * decayTable[stor15 + (s * stor15) - 1 / stor15]) - (t * decayTable[stor15 + (s * stor15) - 1 / stor15]) / startBlock + decayPeriod + (s * decayPeriod) - t != decayTable[stor15 + (s * stor15) - 1 / stor15]:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (startBlock * decayTable[stor15 + (s * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (s * stor15) - 1 / stor15]) + (s * decayPeriod * decayTable[stor15 + (s * stor15) - 1 / stor15]) - (t * decayTable[stor15 + (s * stor15) - 1 / stor15]) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                        s = s + 1
                                        t = startBlock + decayPeriod + (s * decayPeriod)
                                        continue 
                                else:
                                    if block.number <= startBlock:
                                        s = poolInfo[idx].field_512 + -startBlock - 1 / decayPeriod
                                        t = poolInfo[idx].field_512
                                        while s < 0:
                                            if not s + 1:
                                                if startBlock < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if decayPeriod != 0:
                                                    if startBlock > startBlock:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                if 0 >= decayTable.length:
                                                    require decayTable.length - 1 < decayTable.length
                                                    if not decayTable[decayTable.length]:
                                                        decayTable.length++
                                                        decayTable[decayTable.length] = 0
                                                    else:
                                                        if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        decayTable.length++
                                                        decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                    require 0 < decayTable.length
                                                mem[0] = 17
                                                if t > startBlock:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if startBlock - t:
                                                    if (startBlock * decayTable) - (t * decayTable) / startBlock - t != decayTable:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (startBlock * decayTable) - (t * decayTable) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                s = s + 1
                                                t = startBlock
                                                continue 
                                            if decayPeriod + (s * decayPeriod) / s + 1 != decayPeriod:
                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            if startBlock < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if 0 == decayPeriod:
                                                if 0 >= decayTable.length:
                                                    require decayTable.length - 1 < decayTable.length
                                                    if not decayTable[decayTable.length]:
                                                        decayTable.length++
                                                        decayTable[decayTable.length] = 0
                                                    else:
                                                        if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        decayTable.length++
                                                        decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                    require 0 < decayTable.length
                                                mem[0] = 17
                                                if t > startBlock + decayPeriod + (s * decayPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if startBlock + decayPeriod + (s * decayPeriod) - t:
                                                    if (startBlock * decayTable) + (decayPeriod * decayTable) + (s * decayPeriod * decayTable) - (t * decayTable) / startBlock + decayPeriod + (s * decayPeriod) - t != decayTable:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (startBlock * decayTable) + (decayPeriod * decayTable) + (s * decayPeriod * decayTable) - (t * decayTable) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                            else:
                                                if startBlock + decayPeriod + (s * decayPeriod) <= startBlock:
                                                    if 0 >= decayTable.length:
                                                        require decayTable.length - 1 < decayTable.length
                                                        if not decayTable[decayTable.length]:
                                                            decayTable.length++
                                                            decayTable[decayTable.length] = 0
                                                        else:
                                                            if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                            decayTable.length++
                                                            decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                        require 0 < decayTable.length
                                                    mem[0] = 17
                                                    if t > startBlock + decayPeriod + (s * decayPeriod):
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if startBlock + decayPeriod + (s * decayPeriod) - t:
                                                        if (startBlock * decayTable) + (decayPeriod * decayTable) + (s * decayPeriod * decayTable) - (t * decayTable) / startBlock + decayPeriod + (s * decayPeriod) - t != decayTable:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if (startBlock * decayTable) + (decayPeriod * decayTable) + (s * decayPeriod * decayTable) - (t * decayTable) < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                else:
                                                    if startBlock > startBlock + decayPeriod + (s * decayPeriod):
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if 1 > decayPeriod + (s * decayPeriod):
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if decayPeriod <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require decayPeriod
                                                    if decayPeriod + (s * decayPeriod) - 1 / decayPeriod >= decayTable.length:
                                                        require decayTable.length - 1 < decayTable.length
                                                        if not decayTable[decayTable.length]:
                                                            decayTable.length++
                                                            decayTable[decayTable.length] = 0
                                                        else:
                                                            if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                            decayTable.length++
                                                            decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                        require decayPeriod + (s * decayPeriod) - 1 / decayPeriod < decayTable.length
                                                    mem[0] = 17
                                                    if t > startBlock + decayPeriod + (s * decayPeriod):
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if startBlock + decayPeriod + (s * decayPeriod) - t:
                                                        if (startBlock * decayTable[stor15 + (s * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (s * stor15) - 1 / stor15]) + (s * decayPeriod * decayTable[stor15 + (s * stor15) - 1 / stor15]) - (t * decayTable[stor15 + (s * stor15) - 1 / stor15]) / startBlock + decayPeriod + (s * decayPeriod) - t != decayTable[stor15 + (s * stor15) - 1 / stor15]:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if (startBlock * decayTable[stor15 + (s * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (s * stor15) - 1 / stor15]) + (s * decayPeriod * decayTable[stor15 + (s * stor15) - 1 / stor15]) - (t * decayTable[stor15 + (s * stor15) - 1 / stor15]) < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                            s = s + 1
                                            t = startBlock + decayPeriod + (s * decayPeriod)
                                            continue 
                                    else:
                                        if startBlock > block.number:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if 1 > block.number - startBlock:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if decayPeriod <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require decayPeriod
                                        s = poolInfo[idx].field_512 + -startBlock - 1 / decayPeriod
                                        t = poolInfo[idx].field_512
                                        while s < block.number + -startBlock - 1 / decayPeriod:
                                            if not s + 1:
                                                if startBlock < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if decayPeriod != 0:
                                                    if startBlock > startBlock:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                if 0 >= decayTable.length:
                                                    require decayTable.length - 1 < decayTable.length
                                                    if not decayTable[decayTable.length]:
                                                        decayTable.length++
                                                        decayTable[decayTable.length] = 0
                                                    else:
                                                        if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        decayTable.length++
                                                        decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                    require 0 < decayTable.length
                                                mem[0] = 17
                                                if t > startBlock:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if startBlock - t:
                                                    if (startBlock * decayTable) - (t * decayTable) / startBlock - t != decayTable:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (startBlock * decayTable) - (t * decayTable) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                s = s + 1
                                                t = startBlock
                                                continue 
                                            if decayPeriod + (s * decayPeriod) / s + 1 != decayPeriod:
                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            if startBlock < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if 0 == decayPeriod:
                                                if 0 >= decayTable.length:
                                                    require decayTable.length - 1 < decayTable.length
                                                    if not decayTable[decayTable.length]:
                                                        decayTable.length++
                                                        decayTable[decayTable.length] = 0
                                                    else:
                                                        if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        decayTable.length++
                                                        decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                    require 0 < decayTable.length
                                                mem[0] = 17
                                                if t > startBlock + decayPeriod + (s * decayPeriod):
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if startBlock + decayPeriod + (s * decayPeriod) - t:
                                                    if (startBlock * decayTable) + (decayPeriod * decayTable) + (s * decayPeriod * decayTable) - (t * decayTable) / startBlock + decayPeriod + (s * decayPeriod) - t != decayTable:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if (startBlock * decayTable) + (decayPeriod * decayTable) + (s * decayPeriod * decayTable) - (t * decayTable) < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                            else:
                                                if startBlock + decayPeriod + (s * decayPeriod) <= startBlock:
                                                    if 0 >= decayTable.length:
                                                        require decayTable.length - 1 < decayTable.length
                                                        if not decayTable[decayTable.length]:
                                                            decayTable.length++
                                                            decayTable[decayTable.length] = 0
                                                        else:
                                                            if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                            decayTable.length++
                                                            decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                        require 0 < decayTable.length
                                                    mem[0] = 17
                                                    if t > startBlock + decayPeriod + (s * decayPeriod):
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if startBlock + decayPeriod + (s * decayPeriod) - t:
                                                        if (startBlock * decayTable) + (decayPeriod * decayTable) + (s * decayPeriod * decayTable) - (t * decayTable) / startBlock + decayPeriod + (s * decayPeriod) - t != decayTable:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if (startBlock * decayTable) + (decayPeriod * decayTable) + (s * decayPeriod * decayTable) - (t * decayTable) < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                else:
                                                    if startBlock > startBlock + decayPeriod + (s * decayPeriod):
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if 1 > decayPeriod + (s * decayPeriod):
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if decayPeriod <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require decayPeriod
                                                    if decayPeriod + (s * decayPeriod) - 1 / decayPeriod >= decayTable.length:
                                                        require decayTable.length - 1 < decayTable.length
                                                        if not decayTable[decayTable.length]:
                                                            decayTable.length++
                                                            decayTable[decayTable.length] = 0
                                                        else:
                                                            if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                            decayTable.length++
                                                            decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                        require decayPeriod + (s * decayPeriod) - 1 / decayPeriod < decayTable.length
                                                    mem[0] = 17
                                                    if t > startBlock + decayPeriod + (s * decayPeriod):
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if startBlock + decayPeriod + (s * decayPeriod) - t:
                                                        if (startBlock * decayTable[stor15 + (s * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (s * stor15) - 1 / stor15]) + (s * decayPeriod * decayTable[stor15 + (s * stor15) - 1 / stor15]) - (t * decayTable[stor15 + (s * stor15) - 1 / stor15]) / startBlock + decayPeriod + (s * decayPeriod) - t != decayTable[stor15 + (s * stor15) - 1 / stor15]:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if (startBlock * decayTable[stor15 + (s * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (s * stor15) - 1 / stor15]) + (s * decayPeriod * decayTable[stor15 + (s * stor15) - 1 / stor15]) - (t * decayTable[stor15 + (s * stor15) - 1 / stor15]) < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                            s = s + 1
                                            t = startBlock + decayPeriod + (s * decayPeriod)
                                            continue 
                                if 0 == decayPeriod:
                                    if 0 >= decayTable.length:
                                        require decayTable.length - 1 < decayTable.length
                                        if not decayTable[decayTable.length]:
                                            decayTable.length++
                                            decayTable[decayTable.length] = 0
                                        else:
                                            if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            decayTable.length++
                                            decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                        require 0 < decayTable.length
                                    mem[0] = 17
                                    if t > block.number:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if block.number - t:
                                        if (block.number * decayTable) - (t * decayTable) / block.number - t != decayTable:
                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                        if (block.number * decayTable) - (t * decayTable) < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (block.number * decayTable) - (t * decayTable) > 0:
                                            if not (block.number * decayTable) - (t * decayTable):
                                                if totalAllocPoint <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalAllocPoint
                                                mem[100] = this.address
                                                mem[132] = 0 / totalAllocPoint
                                                require ext_code.size(bxhAddress)
                                                call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args this.address, 0 / totalAllocPoint
                                                mem[96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if ext_call.return_data[0]:
                                                    if not 0 / totalAllocPoint:
                                                        if ext_call.return_data[0] <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require ext_call.return_data[0]
                                                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                    else:
                                                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if ext_call.return_data[0] <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require ext_call.return_data[0]
                                                        if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                            else:
                                                if (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / (block.number * decayTable) - (t * decayTable) != poolInfo[idx].field_256:
                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                if totalAllocPoint <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalAllocPoint
                                                mem[100] = this.address
                                                mem[132] = (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                                require ext_code.size(bxhAddress)
                                                call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args this.address, (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                                mem[96] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if ext_call.return_data[0]:
                                                    if not (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint:
                                                        if ext_call.return_data[0] <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require ext_call.return_data[0]
                                                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                    else:
                                                        if 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                                                            revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                        if ext_call.return_data[0] <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require ext_call.return_data[0]
                                                        if (10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[idx].field_768 += 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                else:
                                    if block.number <= startBlock:
                                        if 0 >= decayTable.length:
                                            require decayTable.length - 1 < decayTable.length
                                            if not decayTable[decayTable.length]:
                                                decayTable.length++
                                                decayTable[decayTable.length] = 0
                                            else:
                                                if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                decayTable.length++
                                                decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                            require 0 < decayTable.length
                                        mem[0] = 17
                                        if t > block.number:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if block.number - t:
                                            if (block.number * decayTable) - (t * decayTable) / block.number - t != decayTable:
                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            if (block.number * decayTable) - (t * decayTable) < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (block.number * decayTable) - (t * decayTable) > 0:
                                                if not (block.number * decayTable) - (t * decayTable):
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    mem[100] = this.address
                                                    mem[132] = 0 / totalAllocPoint
                                                    require ext_code.size(bxhAddress)
                                                    call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, 0 / totalAllocPoint
                                                    mem[96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if ext_call.return_data[0]:
                                                        if not 0 / totalAllocPoint:
                                                            if ext_call.return_data[0] <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require ext_call.return_data[0]
                                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                        else:
                                                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                            if ext_call.return_data[0] <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require ext_call.return_data[0]
                                                            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                                else:
                                                    if (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / (block.number * decayTable) - (t * decayTable) != poolInfo[idx].field_256:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    mem[100] = this.address
                                                    mem[132] = (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                                    require ext_code.size(bxhAddress)
                                                    call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint
                                                    mem[96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if ext_call.return_data[0]:
                                                        if not (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint:
                                                            if ext_call.return_data[0] <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require ext_call.return_data[0]
                                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                        else:
                                                            if 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                            if ext_call.return_data[0] <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require ext_call.return_data[0]
                                                            if (10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_768 += 10^12 * (block.number * decayTable * poolInfo[idx].field_256) - (t * decayTable * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                    else:
                                        if startBlock > block.number:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if 1 > block.number - startBlock:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if decayPeriod <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require decayPeriod
                                        if block.number + -startBlock - 1 / decayPeriod >= decayTable.length:
                                            require decayTable.length - 1 < decayTable.length
                                            if not decayTable[decayTable.length]:
                                                decayTable.length++
                                                decayTable[decayTable.length] = 0
                                            else:
                                                if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                    revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                decayTable.length++
                                                decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                            require block.number + -startBlock - 1 / decayPeriod < decayTable.length
                                        mem[0] = 17
                                        if t > block.number:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if block.number - t:
                                            if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (t * decayTable[block.number + -stor12 - 1 / stor15]) / block.number - t != decayTable[block.number + -stor12 - 1 / stor15]:
                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                            if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (t * decayTable[block.number + -stor12 - 1 / stor15]) < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (t * decayTable[block.number + -stor12 - 1 / stor15]) > 0:
                                                if not (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (t * decayTable[block.number + -stor12 - 1 / stor15]):
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    mem[100] = this.address
                                                    mem[132] = 0 / totalAllocPoint
                                                    require ext_code.size(bxhAddress)
                                                    call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, 0 / totalAllocPoint
                                                    mem[96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if ext_call.return_data[0]:
                                                        if not 0 / totalAllocPoint:
                                                            if ext_call.return_data[0] <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require ext_call.return_data[0]
                                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                        else:
                                                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                            if ext_call.return_data[0] <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require ext_call.return_data[0]
                                                            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                                else:
                                                    if (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (t * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (t * decayTable[block.number + -stor12 - 1 / stor15]) != poolInfo[idx].field_256:
                                                        revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    mem[100] = this.address
                                                    mem[132] = (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (t * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint
                                                    require ext_code.size(bxhAddress)
                                                    call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (t * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint
                                                    mem[96] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if ext_call.return_data[0]:
                                                        if not (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (t * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint:
                                                            if ext_call.return_data[0] <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require ext_call.return_data[0]
                                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                        else:
                                                            if 10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (t * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint / (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (t * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                                                                revert with 0, 32, 33, 0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                                            if ext_call.return_data[0] <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require ext_call.return_data[0]
                                                            if (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (t * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[idx].field_768 += 10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) - (t * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
            idx = idx + 1
            continue 
    idx = 0
    while idx < poolInfo.length:
        mem[0] = 6
        if poolInfo[idx].field_0 == arg2:
            revert with 0, 'add: existing pool?'
        idx = idx + 1
        continue 
    if arg1 + totalAllocPoint < totalAllocPoint:
        revert with 0, 'SafeMath: addition overflow'
    totalAllocPoint += arg1
    poolInfo.length++
    poolInfo[poolInfo.length].field_0 = arg2
    storF652[stor6.length] = arg1
    if block.number > startBlock:
        storF652[stor6.length] = block.number
    else:
        storF652[stor6.length] = startBlock
    storF652[stor6.length] = 0
    storF652[stor6.length] = 0
    storF652[stor6.length] = 0
    lpOfPid[address(arg2)] = poolInfo.length - 1
}

function updatePool(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 < poolInfo.length
    if block.number > poolInfo[arg1].field_512:
        if stor3[stor6[arg1].field_0]:
            if not poolInfo[arg1].field_1280:
                poolInfo[arg1].field_512 = block.number
            else:
                if 0 == decayPeriod:
                    if 0 == decayPeriod:
                        if 0 >= decayTable.length:
                            require decayTable.length - 1 < decayTable.length
                            if not decayTable[decayTable.length]:
                                decayTable.length++
                                decayTable[decayTable.length] = 0
                            else:
                                if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                decayTable.length++
                                decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                            require 0 < decayTable.length
                        if poolInfo[arg1].field_512 > block.number:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if block.number - poolInfo[arg1].field_512:
                            if (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) / block.number - poolInfo[arg1].field_512 != decayTable:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) > 0:
                                if not (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable):
                                    if totalAllocPoint <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require totalAllocPoint
                                    require ext_code.size(bxhAddress)
                                    call bxhAddress.mint(address arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args this.address, 0 / totalAllocPoint
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if ext_call.return_data[0]:
                                        if not 0 / totalAllocPoint:
                                            if poolInfo[arg1].field_1280 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require poolInfo[arg1].field_1280
                                            if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 0 / poolInfo[arg1].field_1280
                                        else:
                                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                            32,
                                                            33,
                                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[197 len 31]
                                            if poolInfo[arg1].field_1280 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require poolInfo[arg1].field_1280
                                            if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280
                                else:
                                    if (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) != poolInfo[arg1].field_256:
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                    32,
                                                    33,
                                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[197 len 31]
                                    if totalAllocPoint <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require totalAllocPoint
                                    require ext_code.size(bxhAddress)
                                    call bxhAddress.mint(address arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args this.address, (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if ext_call.return_data[0]:
                                        if not (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint:
                                            if poolInfo[arg1].field_1280 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require poolInfo[arg1].field_1280
                                            if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 0 / poolInfo[arg1].field_1280
                                        else:
                                            if 10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                            32,
                                                            33,
                                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[197 len 31]
                                            if poolInfo[arg1].field_1280 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require poolInfo[arg1].field_1280
                                            if (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280
                                poolInfo[arg1].field_512 = block.number
                    else:
                        if block.number <= startBlock:
                            if 0 >= decayTable.length:
                                require decayTable.length - 1 < decayTable.length
                                if not decayTable[decayTable.length]:
                                    decayTable.length++
                                    decayTable[decayTable.length] = 0
                                else:
                                    if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                    32,
                                                    33,
                                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[197 len 31]
                                    decayTable.length++
                                    decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                require 0 < decayTable.length
                            if poolInfo[arg1].field_512 > block.number:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if block.number - poolInfo[arg1].field_512:
                                if (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) / block.number - poolInfo[arg1].field_512 != decayTable:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                if (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) > 0:
                                    if not (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable):
                                        if totalAllocPoint <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalAllocPoint
                                        require ext_code.size(bxhAddress)
                                        call bxhAddress.mint(address arg1, uint256 arg2) with:
                                             gas gas_remaining wei
                                            args this.address, 0 / totalAllocPoint
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0]:
                                            if not 0 / totalAllocPoint:
                                                if poolInfo[arg1].field_1280 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require poolInfo[arg1].field_1280
                                                if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 0 / poolInfo[arg1].field_1280
                                            else:
                                                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                32,
                                                                33,
                                                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[197 len 31]
                                                if poolInfo[arg1].field_1280 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require poolInfo[arg1].field_1280
                                                if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280
                                    else:
                                        if (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) != poolInfo[arg1].field_256:
                                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                        32,
                                                        33,
                                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[197 len 31]
                                        if totalAllocPoint <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalAllocPoint
                                        require ext_code.size(bxhAddress)
                                        call bxhAddress.mint(address arg1, uint256 arg2) with:
                                             gas gas_remaining wei
                                            args this.address, (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0]:
                                            if not (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint:
                                                if poolInfo[arg1].field_1280 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require poolInfo[arg1].field_1280
                                                if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 0 / poolInfo[arg1].field_1280
                                            else:
                                                if 10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                32,
                                                                33,
                                                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[197 len 31]
                                                if poolInfo[arg1].field_1280 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require poolInfo[arg1].field_1280
                                                if (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280
                                    poolInfo[arg1].field_512 = block.number
                        else:
                            if startBlock > block.number:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if 1 > block.number - startBlock:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if decayPeriod <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require decayPeriod
                            if block.number + -startBlock - 1 / decayPeriod >= decayTable.length:
                                require decayTable.length - 1 < decayTable.length
                                if not decayTable[decayTable.length]:
                                    decayTable.length++
                                    decayTable[decayTable.length] = 0
                                else:
                                    if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                    32,
                                                    33,
                                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[197 len 31]
                                    decayTable.length++
                                    decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                require block.number + -startBlock - 1 / decayPeriod < decayTable.length
                            if poolInfo[arg1].field_512 > block.number:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if block.number - poolInfo[arg1].field_512:
                                if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) / block.number - poolInfo[arg1].field_512 != decayTable[block.number + -stor12 - 1 / stor15]:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) > 0:
                                    if not (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15]):
                                        if totalAllocPoint <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalAllocPoint
                                        require ext_code.size(bxhAddress)
                                        call bxhAddress.mint(address arg1, uint256 arg2) with:
                                             gas gas_remaining wei
                                            args this.address, 0 / totalAllocPoint
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0]:
                                            if not 0 / totalAllocPoint:
                                                if poolInfo[arg1].field_1280 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require poolInfo[arg1].field_1280
                                                if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 0 / poolInfo[arg1].field_1280
                                            else:
                                                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                32,
                                                                33,
                                                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[197 len 31]
                                                if poolInfo[arg1].field_1280 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require poolInfo[arg1].field_1280
                                                if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280
                                    else:
                                        if (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) != poolInfo[arg1].field_256:
                                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                        32,
                                                        33,
                                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[197 len 31]
                                        if totalAllocPoint <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalAllocPoint
                                        require ext_code.size(bxhAddress)
                                        call bxhAddress.mint(address arg1, uint256 arg2) with:
                                             gas gas_remaining wei
                                            args this.address, (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0]:
                                            if not (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint:
                                                if poolInfo[arg1].field_1280 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require poolInfo[arg1].field_1280
                                                if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 0 / poolInfo[arg1].field_1280
                                            else:
                                                if 10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                32,
                                                                33,
                                                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[197 len 31]
                                                if poolInfo[arg1].field_1280 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require poolInfo[arg1].field_1280
                                                if (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280
                                    poolInfo[arg1].field_512 = block.number
                else:
                    if poolInfo[arg1].field_512 <= startBlock:
                        if 0 == decayPeriod:
                            if 0 == decayPeriod:
                                if 0 >= decayTable.length:
                                    require decayTable.length - 1 < decayTable.length
                                    if not decayTable[decayTable.length]:
                                        decayTable.length++
                                        decayTable[decayTable.length] = 0
                                    else:
                                        if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                        32,
                                                        33,
                                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[197 len 31]
                                        decayTable.length++
                                        decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                    require 0 < decayTable.length
                                if poolInfo[arg1].field_512 > block.number:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if block.number - poolInfo[arg1].field_512:
                                    if (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) / block.number - poolInfo[arg1].field_512 != decayTable:
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                    32,
                                                    33,
                                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[197 len 31]
                                    if (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) > 0:
                                        if not (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable):
                                            if totalAllocPoint <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalAllocPoint
                                            require ext_code.size(bxhAddress)
                                            call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                 gas gas_remaining wei
                                                args this.address, 0 / totalAllocPoint
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if ext_call.return_data[0]:
                                                if not 0 / totalAllocPoint:
                                                    if poolInfo[arg1].field_1280 <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require poolInfo[arg1].field_1280
                                                    if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_768 += 0 / poolInfo[arg1].field_1280
                                                else:
                                                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                    32,
                                                                    33,
                                                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[197 len 31]
                                                    if poolInfo[arg1].field_1280 <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require poolInfo[arg1].field_1280
                                                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280
                                        else:
                                            if (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) != poolInfo[arg1].field_256:
                                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                            32,
                                                            33,
                                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[197 len 31]
                                            if totalAllocPoint <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalAllocPoint
                                            require ext_code.size(bxhAddress)
                                            call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                 gas gas_remaining wei
                                                args this.address, (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if ext_call.return_data[0]:
                                                if not (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint:
                                                    if poolInfo[arg1].field_1280 <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require poolInfo[arg1].field_1280
                                                    if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_768 += 0 / poolInfo[arg1].field_1280
                                                else:
                                                    if 10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                    32,
                                                                    33,
                                                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[197 len 31]
                                                    if poolInfo[arg1].field_1280 <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require poolInfo[arg1].field_1280
                                                    if (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_768 += 10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280
                                        poolInfo[arg1].field_512 = block.number
                            else:
                                if block.number <= startBlock:
                                    if 0 >= decayTable.length:
                                        require decayTable.length - 1 < decayTable.length
                                        if not decayTable[decayTable.length]:
                                            decayTable.length++
                                            decayTable[decayTable.length] = 0
                                        else:
                                            if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                            32,
                                                            33,
                                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[197 len 31]
                                            decayTable.length++
                                            decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                        require 0 < decayTable.length
                                    if poolInfo[arg1].field_512 > block.number:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if block.number - poolInfo[arg1].field_512:
                                        if (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) / block.number - poolInfo[arg1].field_512 != decayTable:
                                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                        32,
                                                        33,
                                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[197 len 31]
                                        if (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) > 0:
                                            if not (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable):
                                                if totalAllocPoint <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalAllocPoint
                                                require ext_code.size(bxhAddress)
                                                call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args this.address, 0 / totalAllocPoint
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if ext_call.return_data[0]:
                                                    if not 0 / totalAllocPoint:
                                                        if poolInfo[arg1].field_1280 <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require poolInfo[arg1].field_1280
                                                        if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[arg1].field_768 += 0 / poolInfo[arg1].field_1280
                                                    else:
                                                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                        32,
                                                                        33,
                                                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[197 len 31]
                                                        if poolInfo[arg1].field_1280 <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require poolInfo[arg1].field_1280
                                                        if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280
                                            else:
                                                if (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) != poolInfo[arg1].field_256:
                                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                32,
                                                                33,
                                                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[197 len 31]
                                                if totalAllocPoint <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalAllocPoint
                                                require ext_code.size(bxhAddress)
                                                call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args this.address, (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if ext_call.return_data[0]:
                                                    if not (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint:
                                                        if poolInfo[arg1].field_1280 <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require poolInfo[arg1].field_1280
                                                        if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[arg1].field_768 += 0 / poolInfo[arg1].field_1280
                                                    else:
                                                        if 10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                                                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                        32,
                                                                        33,
                                                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[197 len 31]
                                                        if poolInfo[arg1].field_1280 <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require poolInfo[arg1].field_1280
                                                        if (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[arg1].field_768 += 10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280
                                            poolInfo[arg1].field_512 = block.number
                                else:
                                    if startBlock > block.number:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if 1 > block.number - startBlock:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if decayPeriod <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require decayPeriod
                                    if block.number + -startBlock - 1 / decayPeriod >= decayTable.length:
                                        require decayTable.length - 1 < decayTable.length
                                        if not decayTable[decayTable.length]:
                                            decayTable.length++
                                            decayTable[decayTable.length] = 0
                                        else:
                                            if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                            32,
                                                            33,
                                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[197 len 31]
                                            decayTable.length++
                                            decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                        require block.number + -startBlock - 1 / decayPeriod < decayTable.length
                                    if poolInfo[arg1].field_512 > block.number:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if block.number - poolInfo[arg1].field_512:
                                        if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) / block.number - poolInfo[arg1].field_512 != decayTable[block.number + -stor12 - 1 / stor15]:
                                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                        32,
                                                        33,
                                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[197 len 31]
                                        if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) > 0:
                                            if not (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15]):
                                                if totalAllocPoint <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalAllocPoint
                                                require ext_code.size(bxhAddress)
                                                call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args this.address, 0 / totalAllocPoint
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if ext_call.return_data[0]:
                                                    if not 0 / totalAllocPoint:
                                                        if poolInfo[arg1].field_1280 <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require poolInfo[arg1].field_1280
                                                        if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[arg1].field_768 += 0 / poolInfo[arg1].field_1280
                                                    else:
                                                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                        32,
                                                                        33,
                                                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[197 len 31]
                                                        if poolInfo[arg1].field_1280 <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require poolInfo[arg1].field_1280
                                                        if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280
                                            else:
                                                if (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) != poolInfo[arg1].field_256:
                                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                32,
                                                                33,
                                                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[197 len 31]
                                                if totalAllocPoint <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalAllocPoint
                                                require ext_code.size(bxhAddress)
                                                call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args this.address, (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if ext_call.return_data[0]:
                                                    if not (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint:
                                                        if poolInfo[arg1].field_1280 <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require poolInfo[arg1].field_1280
                                                        if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[arg1].field_768 += 0 / poolInfo[arg1].field_1280
                                                    else:
                                                        if 10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                                                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                        32,
                                                                        33,
                                                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[197 len 31]
                                                        if poolInfo[arg1].field_1280 <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require poolInfo[arg1].field_1280
                                                        if (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[arg1].field_768 += 10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280
                                            poolInfo[arg1].field_512 = block.number
                        else:
                            if block.number <= startBlock:
                                if 0 == decayPeriod:
                                    if 0 >= decayTable.length:
                                        require decayTable.length - 1 < decayTable.length
                                        if not decayTable[decayTable.length]:
                                            decayTable.length++
                                            decayTable[decayTable.length] = 0
                                        else:
                                            if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                            32,
                                                            33,
                                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[197 len 31]
                                            decayTable.length++
                                            decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                        require 0 < decayTable.length
                                    if poolInfo[arg1].field_512 > block.number:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if block.number - poolInfo[arg1].field_512:
                                        if (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) / block.number - poolInfo[arg1].field_512 != decayTable:
                                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                        32,
                                                        33,
                                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[197 len 31]
                                        if (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) > 0:
                                            if not (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable):
                                                if totalAllocPoint <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalAllocPoint
                                                require ext_code.size(bxhAddress)
                                                call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args this.address, 0 / totalAllocPoint
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if ext_call.return_data[0]:
                                                    if not 0 / totalAllocPoint:
                                                        if poolInfo[arg1].field_1280 <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require poolInfo[arg1].field_1280
                                                        if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[arg1].field_768 += 0 / poolInfo[arg1].field_1280
                                                    else:
                                                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                        32,
                                                                        33,
                                                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[197 len 31]
                                                        if poolInfo[arg1].field_1280 <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require poolInfo[arg1].field_1280
                                                        if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280
                                            else:
                                                if (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) != poolInfo[arg1].field_256:
                                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                32,
                                                                33,
                                                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[197 len 31]
                                                if totalAllocPoint <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalAllocPoint
                                                require ext_code.size(bxhAddress)
                                                call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args this.address, (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if ext_call.return_data[0]:
                                                    if not (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint:
                                                        if poolInfo[arg1].field_1280 <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require poolInfo[arg1].field_1280
                                                        if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[arg1].field_768 += 0 / poolInfo[arg1].field_1280
                                                    else:
                                                        if 10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                                                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                        32,
                                                                        33,
                                                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[197 len 31]
                                                        if poolInfo[arg1].field_1280 <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require poolInfo[arg1].field_1280
                                                        if (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[arg1].field_768 += 10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280
                                            poolInfo[arg1].field_512 = block.number
                                else:
                                    if block.number <= startBlock:
                                        if 0 >= decayTable.length:
                                            require decayTable.length - 1 < decayTable.length
                                            if not decayTable[decayTable.length]:
                                                decayTable.length++
                                                decayTable[decayTable.length] = 0
                                            else:
                                                if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                32,
                                                                33,
                                                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[197 len 31]
                                                decayTable.length++
                                                decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                            require 0 < decayTable.length
                                        if poolInfo[arg1].field_512 > block.number:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if block.number - poolInfo[arg1].field_512:
                                            if (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) / block.number - poolInfo[arg1].field_512 != decayTable:
                                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                            32,
                                                            33,
                                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[197 len 31]
                                            if (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) > 0:
                                                if not (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable):
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    require ext_code.size(bxhAddress)
                                                    call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, 0 / totalAllocPoint
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if ext_call.return_data[0]:
                                                        if not 0 / totalAllocPoint:
                                                            if poolInfo[arg1].field_1280 <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require poolInfo[arg1].field_1280
                                                            if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[arg1].field_768 += 0 / poolInfo[arg1].field_1280
                                                        else:
                                                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                            32,
                                                                            33,
                                                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                            mem[197 len 31]
                                                            if poolInfo[arg1].field_1280 <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require poolInfo[arg1].field_1280
                                                            if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280
                                                else:
                                                    if (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) != poolInfo[arg1].field_256:
                                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                    32,
                                                                    33,
                                                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[197 len 31]
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    require ext_code.size(bxhAddress)
                                                    call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if ext_call.return_data[0]:
                                                        if not (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint:
                                                            if poolInfo[arg1].field_1280 <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require poolInfo[arg1].field_1280
                                                            if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[arg1].field_768 += 0 / poolInfo[arg1].field_1280
                                                        else:
                                                            if 10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                                                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                            32,
                                                                            33,
                                                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                            mem[197 len 31]
                                                            if poolInfo[arg1].field_1280 <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require poolInfo[arg1].field_1280
                                                            if (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[arg1].field_768 += 10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280
                                                poolInfo[arg1].field_512 = block.number
                                    else:
                                        if startBlock > block.number:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if 1 > block.number - startBlock:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if decayPeriod <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require decayPeriod
                                        if block.number + -startBlock - 1 / decayPeriod >= decayTable.length:
                                            require decayTable.length - 1 < decayTable.length
                                            if not decayTable[decayTable.length]:
                                                decayTable.length++
                                                decayTable[decayTable.length] = 0
                                            else:
                                                if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                32,
                                                                33,
                                                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[197 len 31]
                                                decayTable.length++
                                                decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                            require block.number + -startBlock - 1 / decayPeriod < decayTable.length
                                        if poolInfo[arg1].field_512 > block.number:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if block.number - poolInfo[arg1].field_512:
                                            if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) / block.number - poolInfo[arg1].field_512 != decayTable[block.number + -stor12 - 1 / stor15]:
                                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                            32,
                                                            33,
                                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[197 len 31]
                                            if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) > 0:
                                                if not (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15]):
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    require ext_code.size(bxhAddress)
                                                    call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, 0 / totalAllocPoint
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if ext_call.return_data[0]:
                                                        if not 0 / totalAllocPoint:
                                                            if poolInfo[arg1].field_1280 <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require poolInfo[arg1].field_1280
                                                            if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[arg1].field_768 += 0 / poolInfo[arg1].field_1280
                                                        else:
                                                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                            32,
                                                                            33,
                                                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                            mem[197 len 31]
                                                            if poolInfo[arg1].field_1280 <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require poolInfo[arg1].field_1280
                                                            if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280
                                                else:
                                                    if (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) != poolInfo[arg1].field_256:
                                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                    32,
                                                                    33,
                                                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[197 len 31]
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    require ext_code.size(bxhAddress)
                                                    call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if ext_call.return_data[0]:
                                                        if not (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint:
                                                            if poolInfo[arg1].field_1280 <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require poolInfo[arg1].field_1280
                                                            if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[arg1].field_768 += 0 / poolInfo[arg1].field_1280
                                                        else:
                                                            if 10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                                                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                            32,
                                                                            33,
                                                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                            mem[197 len 31]
                                                            if poolInfo[arg1].field_1280 <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require poolInfo[arg1].field_1280
                                                            if (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[arg1].field_768 += 10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280
                                                poolInfo[arg1].field_512 = block.number
                            else:
                                if startBlock > block.number:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if 1 > block.number - startBlock:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if decayPeriod <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require decayPeriod
                                idx = 0
                                s = poolInfo[arg1].field_512
                                while idx < block.number + -startBlock - 1 / decayPeriod:
                                    if not idx + 1:
                                        if startBlock < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if decayPeriod != 0:
                                            if startBlock > startBlock:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        if 0 >= decayTable.length:
                                            require decayTable.length - 1 < decayTable.length
                                            if not decayTable[decayTable.length]:
                                                decayTable.length++
                                                decayTable[decayTable.length] = 0
                                            else:
                                                if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                32,
                                                                33,
                                                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[197 len 31]
                                                decayTable.length++
                                                decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                            require 0 < decayTable.length
                                        mem[0] = 17
                                        if s > startBlock:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if startBlock - s:
                                            if (startBlock * decayTable) - (s * decayTable) / startBlock - s != decayTable:
                                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                            32,
                                                            33,
                                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[197 len 31]
                                            if (startBlock * decayTable) - (s * decayTable) < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                        idx = idx + 1
                                        s = startBlock
                                        continue 
                                    if decayPeriod + (idx * decayPeriod) / idx + 1 != decayPeriod:
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                    32,
                                                    33,
                                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[197 len 31]
                                    if startBlock < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if 0 == decayPeriod:
                                        if 0 >= decayTable.length:
                                            require decayTable.length - 1 < decayTable.length
                                            if not decayTable[decayTable.length]:
                                                decayTable.length++
                                                decayTable[decayTable.length] = 0
                                            else:
                                                if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                32,
                                                                33,
                                                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[197 len 31]
                                                decayTable.length++
                                                decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                            require 0 < decayTable.length
                                        mem[0] = 17
                                        if s > startBlock + decayPeriod + (idx * decayPeriod):
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if startBlock + decayPeriod + (idx * decayPeriod) - s:
                                            if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) / startBlock + decayPeriod + (idx * decayPeriod) - s != decayTable:
                                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                            32,
                                                            33,
                                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[197 len 31]
                                            if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                    else:
                                        if startBlock + decayPeriod + (idx * decayPeriod) <= startBlock:
                                            if 0 >= decayTable.length:
                                                require decayTable.length - 1 < decayTable.length
                                                if not decayTable[decayTable.length]:
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = 0
                                                else:
                                                    if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                    32,
                                                                    33,
                                                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[197 len 31]
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                require 0 < decayTable.length
                                            mem[0] = 17
                                            if s > startBlock + decayPeriod + (idx * decayPeriod):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if startBlock + decayPeriod + (idx * decayPeriod) - s:
                                                if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) / startBlock + decayPeriod + (idx * decayPeriod) - s != decayTable:
                                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                32,
                                                                33,
                                                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[197 len 31]
                                                if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                        else:
                                            if startBlock > startBlock + decayPeriod + (idx * decayPeriod):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if 1 > decayPeriod + (idx * decayPeriod):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if decayPeriod <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require decayPeriod
                                            if decayPeriod + (idx * decayPeriod) - 1 / decayPeriod >= decayTable.length:
                                                require decayTable.length - 1 < decayTable.length
                                                if not decayTable[decayTable.length]:
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = 0
                                                else:
                                                    if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                    32,
                                                                    33,
                                                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[197 len 31]
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                require decayPeriod + (idx * decayPeriod) - 1 / decayPeriod < decayTable.length
                                            mem[0] = 17
                                            if s > startBlock + decayPeriod + (idx * decayPeriod):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if startBlock + decayPeriod + (idx * decayPeriod) - s:
                                                if (startBlock * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (idx * decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) - (s * decayTable[stor15 + (idx * stor15) - 1 / stor15]) / startBlock + decayPeriod + (idx * decayPeriod) - s != decayTable[stor15 + (idx * stor15) - 1 / stor15]:
                                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                32,
                                                                33,
                                                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[197 len 31]
                                                if (startBlock * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (idx * decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) - (s * decayTable[stor15 + (idx * stor15) - 1 / stor15]) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                    idx = idx + 1
                                    s = startBlock + decayPeriod + (idx * decayPeriod)
                                    continue 
                                if 0 == decayPeriod:
                                    if 0 >= decayTable.length:
                                        require decayTable.length - 1 < decayTable.length
                                        if not decayTable[decayTable.length]:
                                            decayTable.length++
                                            decayTable[decayTable.length] = 0
                                        else:
                                            if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                            32,
                                                            33,
                                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[197 len 31]
                                            decayTable.length++
                                            decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                        require 0 < decayTable.length
                                    if s > block.number:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if block.number - s:
                                        if (block.number * decayTable) - (s * decayTable) / block.number - s != decayTable:
                                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                        32,
                                                        33,
                                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[197 len 31]
                                        if (block.number * decayTable) - (s * decayTable) < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (block.number * decayTable) - (s * decayTable) > 0:
                                            if not (block.number * decayTable) - (s * decayTable):
                                                if totalAllocPoint <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalAllocPoint
                                                require ext_code.size(bxhAddress)
                                                call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args this.address, 0 / totalAllocPoint
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if ext_call.return_data[0]:
                                                    if not 0 / totalAllocPoint:
                                                        if poolInfo[arg1].field_1280 <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require poolInfo[arg1].field_1280
                                                        if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[arg1].field_768 += 0 / poolInfo[arg1].field_1280
                                                    else:
                                                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                        32,
                                                                        33,
                                                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[197 len 31]
                                                        if poolInfo[arg1].field_1280 <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require poolInfo[arg1].field_1280
                                                        if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280
                                            else:
                                                if (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / (block.number * decayTable) - (s * decayTable) != poolInfo[arg1].field_256:
                                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                32,
                                                                33,
                                                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[197 len 31]
                                                if totalAllocPoint <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalAllocPoint
                                                require ext_code.size(bxhAddress)
                                                call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args this.address, (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if ext_call.return_data[0]:
                                                    if not (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint:
                                                        if poolInfo[arg1].field_1280 <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require poolInfo[arg1].field_1280
                                                        if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[arg1].field_768 += 0 / poolInfo[arg1].field_1280
                                                    else:
                                                        if 10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                                                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                        32,
                                                                        33,
                                                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[197 len 31]
                                                        if poolInfo[arg1].field_1280 <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require poolInfo[arg1].field_1280
                                                        if (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[arg1].field_768 += 10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280
                                            poolInfo[arg1].field_512 = block.number
                                else:
                                    if block.number <= startBlock:
                                        if 0 >= decayTable.length:
                                            require decayTable.length - 1 < decayTable.length
                                            if not decayTable[decayTable.length]:
                                                decayTable.length++
                                                decayTable[decayTable.length] = 0
                                            else:
                                                if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                32,
                                                                33,
                                                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[197 len 31]
                                                decayTable.length++
                                                decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                            require 0 < decayTable.length
                                        if s > block.number:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if block.number - s:
                                            if (block.number * decayTable) - (s * decayTable) / block.number - s != decayTable:
                                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                            32,
                                                            33,
                                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[197 len 31]
                                            if (block.number * decayTable) - (s * decayTable) < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (block.number * decayTable) - (s * decayTable) > 0:
                                                if not (block.number * decayTable) - (s * decayTable):
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    require ext_code.size(bxhAddress)
                                                    call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, 0 / totalAllocPoint
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if ext_call.return_data[0]:
                                                        if not 0 / totalAllocPoint:
                                                            if poolInfo[arg1].field_1280 <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require poolInfo[arg1].field_1280
                                                            if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[arg1].field_768 += 0 / poolInfo[arg1].field_1280
                                                        else:
                                                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                            32,
                                                                            33,
                                                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                            mem[197 len 31]
                                                            if poolInfo[arg1].field_1280 <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require poolInfo[arg1].field_1280
                                                            if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280
                                                else:
                                                    if (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / (block.number * decayTable) - (s * decayTable) != poolInfo[arg1].field_256:
                                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                    32,
                                                                    33,
                                                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[197 len 31]
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    require ext_code.size(bxhAddress)
                                                    call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if ext_call.return_data[0]:
                                                        if not (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint:
                                                            if poolInfo[arg1].field_1280 <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require poolInfo[arg1].field_1280
                                                            if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[arg1].field_768 += 0 / poolInfo[arg1].field_1280
                                                        else:
                                                            if 10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                                                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                            32,
                                                                            33,
                                                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                            mem[197 len 31]
                                                            if poolInfo[arg1].field_1280 <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require poolInfo[arg1].field_1280
                                                            if (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[arg1].field_768 += 10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280
                                                poolInfo[arg1].field_512 = block.number
                                    else:
                                        if startBlock > block.number:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if 1 > block.number - startBlock:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if decayPeriod <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require decayPeriod
                                        if block.number + -startBlock - 1 / decayPeriod >= decayTable.length:
                                            require decayTable.length - 1 < decayTable.length
                                            if not decayTable[decayTable.length]:
                                                decayTable.length++
                                                decayTable[decayTable.length] = 0
                                            else:
                                                if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                32,
                                                                33,
                                                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[197 len 31]
                                                decayTable.length++
                                                decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                            require block.number + -startBlock - 1 / decayPeriod < decayTable.length
                                        if s > block.number:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if block.number - s:
                                            if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (s * decayTable[block.number + -stor12 - 1 / stor15]) / block.number - s != decayTable[block.number + -stor12 - 1 / stor15]:
                                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                            32,
                                                            33,
                                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[197 len 31]
                                            if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (s * decayTable[block.number + -stor12 - 1 / stor15]) < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (s * decayTable[block.number + -stor12 - 1 / stor15]) > 0:
                                                if not (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (s * decayTable[block.number + -stor12 - 1 / stor15]):
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    require ext_code.size(bxhAddress)
                                                    call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, 0 / totalAllocPoint
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if ext_call.return_data[0]:
                                                        if not 0 / totalAllocPoint:
                                                            if poolInfo[arg1].field_1280 <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require poolInfo[arg1].field_1280
                                                            if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[arg1].field_768 += 0 / poolInfo[arg1].field_1280
                                                        else:
                                                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                            32,
                                                                            33,
                                                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                            mem[197 len 31]
                                                            if poolInfo[arg1].field_1280 <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require poolInfo[arg1].field_1280
                                                            if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280
                                                else:
                                                    if (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (s * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (s * decayTable[block.number + -stor12 - 1 / stor15]) != poolInfo[arg1].field_256:
                                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                    32,
                                                                    33,
                                                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[197 len 31]
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    require ext_code.size(bxhAddress)
                                                    call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (s * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if ext_call.return_data[0]:
                                                        if not (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (s * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint:
                                                            if poolInfo[arg1].field_1280 <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require poolInfo[arg1].field_1280
                                                            if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[arg1].field_768 += 0 / poolInfo[arg1].field_1280
                                                        else:
                                                            if 10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (s * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (s * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                                                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                            32,
                                                                            33,
                                                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                            mem[197 len 31]
                                                            if poolInfo[arg1].field_1280 <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require poolInfo[arg1].field_1280
                                                            if (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (s * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[arg1].field_768 += 10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (s * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280
                                                poolInfo[arg1].field_512 = block.number
                    else:
                        if startBlock > poolInfo[arg1].field_512:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if 1 > poolInfo[arg1].field_512 - startBlock:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if decayPeriod <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require decayPeriod
                        if 0 == decayPeriod:
                            idx = poolInfo[arg1].field_512 + -startBlock - 1 / decayPeriod
                            s = poolInfo[arg1].field_512
                            while idx < 0:
                                if not idx + 1:
                                    if startBlock < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if decayPeriod != 0:
                                        if startBlock > startBlock:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    if 0 >= decayTable.length:
                                        require decayTable.length - 1 < decayTable.length
                                        if not decayTable[decayTable.length]:
                                            decayTable.length++
                                            decayTable[decayTable.length] = 0
                                        else:
                                            if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                            32,
                                                            33,
                                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[197 len 31]
                                            decayTable.length++
                                            decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                        require 0 < decayTable.length
                                    mem[0] = 17
                                    if s > startBlock:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if startBlock - s:
                                        if (startBlock * decayTable) - (s * decayTable) / startBlock - s != decayTable:
                                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                        32,
                                                        33,
                                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[197 len 31]
                                        if (startBlock * decayTable) - (s * decayTable) < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                    idx = idx + 1
                                    s = startBlock
                                    continue 
                                if decayPeriod + (idx * decayPeriod) / idx + 1 != decayPeriod:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                if startBlock < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if 0 == decayPeriod:
                                    if 0 >= decayTable.length:
                                        require decayTable.length - 1 < decayTable.length
                                        if not decayTable[decayTable.length]:
                                            decayTable.length++
                                            decayTable[decayTable.length] = 0
                                        else:
                                            if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                            32,
                                                            33,
                                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[197 len 31]
                                            decayTable.length++
                                            decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                        require 0 < decayTable.length
                                    mem[0] = 17
                                    if s > startBlock + decayPeriod + (idx * decayPeriod):
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if startBlock + decayPeriod + (idx * decayPeriod) - s:
                                        if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) / startBlock + decayPeriod + (idx * decayPeriod) - s != decayTable:
                                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                        32,
                                                        33,
                                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[197 len 31]
                                        if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                else:
                                    if startBlock + decayPeriod + (idx * decayPeriod) <= startBlock:
                                        if 0 >= decayTable.length:
                                            require decayTable.length - 1 < decayTable.length
                                            if not decayTable[decayTable.length]:
                                                decayTable.length++
                                                decayTable[decayTable.length] = 0
                                            else:
                                                if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                32,
                                                                33,
                                                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[197 len 31]
                                                decayTable.length++
                                                decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                            require 0 < decayTable.length
                                        mem[0] = 17
                                        if s > startBlock + decayPeriod + (idx * decayPeriod):
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if startBlock + decayPeriod + (idx * decayPeriod) - s:
                                            if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) / startBlock + decayPeriod + (idx * decayPeriod) - s != decayTable:
                                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                            32,
                                                            33,
                                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[197 len 31]
                                            if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                    else:
                                        if startBlock > startBlock + decayPeriod + (idx * decayPeriod):
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if 1 > decayPeriod + (idx * decayPeriod):
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if decayPeriod <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require decayPeriod
                                        if decayPeriod + (idx * decayPeriod) - 1 / decayPeriod >= decayTable.length:
                                            require decayTable.length - 1 < decayTable.length
                                            if not decayTable[decayTable.length]:
                                                decayTable.length++
                                                decayTable[decayTable.length] = 0
                                            else:
                                                if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                32,
                                                                33,
                                                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[197 len 31]
                                                decayTable.length++
                                                decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                            require decayPeriod + (idx * decayPeriod) - 1 / decayPeriod < decayTable.length
                                        mem[0] = 17
                                        if s > startBlock + decayPeriod + (idx * decayPeriod):
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if startBlock + decayPeriod + (idx * decayPeriod) - s:
                                            if (startBlock * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (idx * decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) - (s * decayTable[stor15 + (idx * stor15) - 1 / stor15]) / startBlock + decayPeriod + (idx * decayPeriod) - s != decayTable[stor15 + (idx * stor15) - 1 / stor15]:
                                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                            32,
                                                            33,
                                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[197 len 31]
                                            if (startBlock * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (idx * decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) - (s * decayTable[stor15 + (idx * stor15) - 1 / stor15]) < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                idx = idx + 1
                                s = startBlock + decayPeriod + (idx * decayPeriod)
                                continue 
                        else:
                            if block.number <= startBlock:
                                idx = poolInfo[arg1].field_512 + -startBlock - 1 / decayPeriod
                                s = poolInfo[arg1].field_512
                                while idx < 0:
                                    if not idx + 1:
                                        if startBlock < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if decayPeriod != 0:
                                            if startBlock > startBlock:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        if 0 >= decayTable.length:
                                            require decayTable.length - 1 < decayTable.length
                                            if not decayTable[decayTable.length]:
                                                decayTable.length++
                                                decayTable[decayTable.length] = 0
                                            else:
                                                if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                32,
                                                                33,
                                                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[197 len 31]
                                                decayTable.length++
                                                decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                            require 0 < decayTable.length
                                        mem[0] = 17
                                        if s > startBlock:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if startBlock - s:
                                            if (startBlock * decayTable) - (s * decayTable) / startBlock - s != decayTable:
                                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                            32,
                                                            33,
                                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[197 len 31]
                                            if (startBlock * decayTable) - (s * decayTable) < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                        idx = idx + 1
                                        s = startBlock
                                        continue 
                                    if decayPeriod + (idx * decayPeriod) / idx + 1 != decayPeriod:
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                    32,
                                                    33,
                                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[197 len 31]
                                    if startBlock < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if 0 == decayPeriod:
                                        if 0 >= decayTable.length:
                                            require decayTable.length - 1 < decayTable.length
                                            if not decayTable[decayTable.length]:
                                                decayTable.length++
                                                decayTable[decayTable.length] = 0
                                            else:
                                                if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                32,
                                                                33,
                                                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[197 len 31]
                                                decayTable.length++
                                                decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                            require 0 < decayTable.length
                                        mem[0] = 17
                                        if s > startBlock + decayPeriod + (idx * decayPeriod):
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if startBlock + decayPeriod + (idx * decayPeriod) - s:
                                            if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) / startBlock + decayPeriod + (idx * decayPeriod) - s != decayTable:
                                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                            32,
                                                            33,
                                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[197 len 31]
                                            if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                    else:
                                        if startBlock + decayPeriod + (idx * decayPeriod) <= startBlock:
                                            if 0 >= decayTable.length:
                                                require decayTable.length - 1 < decayTable.length
                                                if not decayTable[decayTable.length]:
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = 0
                                                else:
                                                    if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                    32,
                                                                    33,
                                                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[197 len 31]
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                require 0 < decayTable.length
                                            mem[0] = 17
                                            if s > startBlock + decayPeriod + (idx * decayPeriod):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if startBlock + decayPeriod + (idx * decayPeriod) - s:
                                                if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) / startBlock + decayPeriod + (idx * decayPeriod) - s != decayTable:
                                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                32,
                                                                33,
                                                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[197 len 31]
                                                if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                        else:
                                            if startBlock > startBlock + decayPeriod + (idx * decayPeriod):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if 1 > decayPeriod + (idx * decayPeriod):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if decayPeriod <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require decayPeriod
                                            if decayPeriod + (idx * decayPeriod) - 1 / decayPeriod >= decayTable.length:
                                                require decayTable.length - 1 < decayTable.length
                                                if not decayTable[decayTable.length]:
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = 0
                                                else:
                                                    if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                    32,
                                                                    33,
                                                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[197 len 31]
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                require decayPeriod + (idx * decayPeriod) - 1 / decayPeriod < decayTable.length
                                            mem[0] = 17
                                            if s > startBlock + decayPeriod + (idx * decayPeriod):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if startBlock + decayPeriod + (idx * decayPeriod) - s:
                                                if (startBlock * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (idx * decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) - (s * decayTable[stor15 + (idx * stor15) - 1 / stor15]) / startBlock + decayPeriod + (idx * decayPeriod) - s != decayTable[stor15 + (idx * stor15) - 1 / stor15]:
                                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                32,
                                                                33,
                                                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[197 len 31]
                                                if (startBlock * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (idx * decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) - (s * decayTable[stor15 + (idx * stor15) - 1 / stor15]) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                    idx = idx + 1
                                    s = startBlock + decayPeriod + (idx * decayPeriod)
                                    continue 
                            else:
                                if startBlock > block.number:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if 1 > block.number - startBlock:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if decayPeriod <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require decayPeriod
                                idx = poolInfo[arg1].field_512 + -startBlock - 1 / decayPeriod
                                s = poolInfo[arg1].field_512
                                while idx < block.number + -startBlock - 1 / decayPeriod:
                                    if not idx + 1:
                                        if startBlock < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if decayPeriod != 0:
                                            if startBlock > startBlock:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        if 0 >= decayTable.length:
                                            require decayTable.length - 1 < decayTable.length
                                            if not decayTable[decayTable.length]:
                                                decayTable.length++
                                                decayTable[decayTable.length] = 0
                                            else:
                                                if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                32,
                                                                33,
                                                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[197 len 31]
                                                decayTable.length++
                                                decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                            require 0 < decayTable.length
                                        mem[0] = 17
                                        if s > startBlock:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if startBlock - s:
                                            if (startBlock * decayTable) - (s * decayTable) / startBlock - s != decayTable:
                                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                            32,
                                                            33,
                                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[197 len 31]
                                            if (startBlock * decayTable) - (s * decayTable) < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                        idx = idx + 1
                                        s = startBlock
                                        continue 
                                    if decayPeriod + (idx * decayPeriod) / idx + 1 != decayPeriod:
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                    32,
                                                    33,
                                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[197 len 31]
                                    if startBlock < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if 0 == decayPeriod:
                                        if 0 >= decayTable.length:
                                            require decayTable.length - 1 < decayTable.length
                                            if not decayTable[decayTable.length]:
                                                decayTable.length++
                                                decayTable[decayTable.length] = 0
                                            else:
                                                if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                32,
                                                                33,
                                                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[197 len 31]
                                                decayTable.length++
                                                decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                            require 0 < decayTable.length
                                        mem[0] = 17
                                        if s > startBlock + decayPeriod + (idx * decayPeriod):
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if startBlock + decayPeriod + (idx * decayPeriod) - s:
                                            if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) / startBlock + decayPeriod + (idx * decayPeriod) - s != decayTable:
                                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                            32,
                                                            33,
                                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[197 len 31]
                                            if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                    else:
                                        if startBlock + decayPeriod + (idx * decayPeriod) <= startBlock:
                                            if 0 >= decayTable.length:
                                                require decayTable.length - 1 < decayTable.length
                                                if not decayTable[decayTable.length]:
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = 0
                                                else:
                                                    if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                    32,
                                                                    33,
                                                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[197 len 31]
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                require 0 < decayTable.length
                                            mem[0] = 17
                                            if s > startBlock + decayPeriod + (idx * decayPeriod):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if startBlock + decayPeriod + (idx * decayPeriod) - s:
                                                if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) / startBlock + decayPeriod + (idx * decayPeriod) - s != decayTable:
                                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                32,
                                                                33,
                                                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[197 len 31]
                                                if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                        else:
                                            if startBlock > startBlock + decayPeriod + (idx * decayPeriod):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if 1 > decayPeriod + (idx * decayPeriod):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if decayPeriod <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require decayPeriod
                                            if decayPeriod + (idx * decayPeriod) - 1 / decayPeriod >= decayTable.length:
                                                require decayTable.length - 1 < decayTable.length
                                                if not decayTable[decayTable.length]:
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = 0
                                                else:
                                                    if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                    32,
                                                                    33,
                                                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[197 len 31]
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                require decayPeriod + (idx * decayPeriod) - 1 / decayPeriod < decayTable.length
                                            mem[0] = 17
                                            if s > startBlock + decayPeriod + (idx * decayPeriod):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if startBlock + decayPeriod + (idx * decayPeriod) - s:
                                                if (startBlock * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (idx * decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) - (s * decayTable[stor15 + (idx * stor15) - 1 / stor15]) / startBlock + decayPeriod + (idx * decayPeriod) - s != decayTable[stor15 + (idx * stor15) - 1 / stor15]:
                                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                32,
                                                                33,
                                                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[197 len 31]
                                                if (startBlock * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (idx * decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) - (s * decayTable[stor15 + (idx * stor15) - 1 / stor15]) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                    idx = idx + 1
                                    s = startBlock + decayPeriod + (idx * decayPeriod)
                                    continue 
                        if 0 == decayPeriod:
                            if 0 >= decayTable.length:
                                require decayTable.length - 1 < decayTable.length
                                if not decayTable[decayTable.length]:
                                    decayTable.length++
                                    decayTable[decayTable.length] = 0
                                else:
                                    if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                    32,
                                                    33,
                                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[197 len 31]
                                    decayTable.length++
                                    decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                require 0 < decayTable.length
                            if s > block.number:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if block.number - s:
                                if (block.number * decayTable) - (s * decayTable) / block.number - s != decayTable:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                if (block.number * decayTable) - (s * decayTable) < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if (block.number * decayTable) - (s * decayTable) > 0:
                                    if not (block.number * decayTable) - (s * decayTable):
                                        if totalAllocPoint <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalAllocPoint
                                        require ext_code.size(bxhAddress)
                                        call bxhAddress.mint(address arg1, uint256 arg2) with:
                                             gas gas_remaining wei
                                            args this.address, 0 / totalAllocPoint
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0]:
                                            if not 0 / totalAllocPoint:
                                                if poolInfo[arg1].field_1280 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require poolInfo[arg1].field_1280
                                                if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 0 / poolInfo[arg1].field_1280
                                            else:
                                                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                32,
                                                                33,
                                                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[197 len 31]
                                                if poolInfo[arg1].field_1280 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require poolInfo[arg1].field_1280
                                                if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280
                                    else:
                                        if (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / (block.number * decayTable) - (s * decayTable) != poolInfo[arg1].field_256:
                                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                        32,
                                                        33,
                                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[197 len 31]
                                        if totalAllocPoint <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalAllocPoint
                                        require ext_code.size(bxhAddress)
                                        call bxhAddress.mint(address arg1, uint256 arg2) with:
                                             gas gas_remaining wei
                                            args this.address, (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0]:
                                            if not (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint:
                                                if poolInfo[arg1].field_1280 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require poolInfo[arg1].field_1280
                                                if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 0 / poolInfo[arg1].field_1280
                                            else:
                                                if 10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                32,
                                                                33,
                                                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[197 len 31]
                                                if poolInfo[arg1].field_1280 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require poolInfo[arg1].field_1280
                                                if (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280
                                    poolInfo[arg1].field_512 = block.number
                        else:
                            if block.number <= startBlock:
                                if 0 >= decayTable.length:
                                    require decayTable.length - 1 < decayTable.length
                                    if not decayTable[decayTable.length]:
                                        decayTable.length++
                                        decayTable[decayTable.length] = 0
                                    else:
                                        if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                        32,
                                                        33,
                                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[197 len 31]
                                        decayTable.length++
                                        decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                    require 0 < decayTable.length
                                if s > block.number:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if block.number - s:
                                    if (block.number * decayTable) - (s * decayTable) / block.number - s != decayTable:
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                    32,
                                                    33,
                                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[197 len 31]
                                    if (block.number * decayTable) - (s * decayTable) < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (block.number * decayTable) - (s * decayTable) > 0:
                                        if not (block.number * decayTable) - (s * decayTable):
                                            if totalAllocPoint <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalAllocPoint
                                            require ext_code.size(bxhAddress)
                                            call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                 gas gas_remaining wei
                                                args this.address, 0 / totalAllocPoint
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if ext_call.return_data[0]:
                                                if not 0 / totalAllocPoint:
                                                    if poolInfo[arg1].field_1280 <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require poolInfo[arg1].field_1280
                                                    if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_768 += 0 / poolInfo[arg1].field_1280
                                                else:
                                                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                    32,
                                                                    33,
                                                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[197 len 31]
                                                    if poolInfo[arg1].field_1280 <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require poolInfo[arg1].field_1280
                                                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280
                                        else:
                                            if (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / (block.number * decayTable) - (s * decayTable) != poolInfo[arg1].field_256:
                                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                            32,
                                                            33,
                                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[197 len 31]
                                            if totalAllocPoint <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalAllocPoint
                                            require ext_code.size(bxhAddress)
                                            call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                 gas gas_remaining wei
                                                args this.address, (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if ext_call.return_data[0]:
                                                if not (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint:
                                                    if poolInfo[arg1].field_1280 <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require poolInfo[arg1].field_1280
                                                    if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_768 += 0 / poolInfo[arg1].field_1280
                                                else:
                                                    if 10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                    32,
                                                                    33,
                                                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[197 len 31]
                                                    if poolInfo[arg1].field_1280 <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require poolInfo[arg1].field_1280
                                                    if (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_768 += 10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280
                                        poolInfo[arg1].field_512 = block.number
                            else:
                                if startBlock > block.number:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if 1 > block.number - startBlock:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if decayPeriod <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require decayPeriod
                                if block.number + -startBlock - 1 / decayPeriod >= decayTable.length:
                                    require decayTable.length - 1 < decayTable.length
                                    if not decayTable[decayTable.length]:
                                        decayTable.length++
                                        decayTable[decayTable.length] = 0
                                    else:
                                        if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                        32,
                                                        33,
                                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[197 len 31]
                                        decayTable.length++
                                        decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                    require block.number + -startBlock - 1 / decayPeriod < decayTable.length
                                if s > block.number:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if block.number - s:
                                    if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (s * decayTable[block.number + -stor12 - 1 / stor15]) / block.number - s != decayTable[block.number + -stor12 - 1 / stor15]:
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                    32,
                                                    33,
                                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[197 len 31]
                                    if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (s * decayTable[block.number + -stor12 - 1 / stor15]) < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (s * decayTable[block.number + -stor12 - 1 / stor15]) > 0:
                                        if not (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (s * decayTable[block.number + -stor12 - 1 / stor15]):
                                            if totalAllocPoint <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalAllocPoint
                                            require ext_code.size(bxhAddress)
                                            call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                 gas gas_remaining wei
                                                args this.address, 0 / totalAllocPoint
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if ext_call.return_data[0]:
                                                if not 0 / totalAllocPoint:
                                                    if poolInfo[arg1].field_1280 <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require poolInfo[arg1].field_1280
                                                    if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_768 += 0 / poolInfo[arg1].field_1280
                                                else:
                                                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                    32,
                                                                    33,
                                                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[197 len 31]
                                                    if poolInfo[arg1].field_1280 <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require poolInfo[arg1].field_1280
                                                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280
                                        else:
                                            if (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (s * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (s * decayTable[block.number + -stor12 - 1 / stor15]) != poolInfo[arg1].field_256:
                                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                            32,
                                                            33,
                                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[197 len 31]
                                            if totalAllocPoint <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalAllocPoint
                                            require ext_code.size(bxhAddress)
                                            call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                 gas gas_remaining wei
                                                args this.address, (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (s * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if ext_call.return_data[0]:
                                                if not (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (s * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint:
                                                    if poolInfo[arg1].field_1280 <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require poolInfo[arg1].field_1280
                                                    if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_768 += 0 / poolInfo[arg1].field_1280
                                                else:
                                                    if 10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (s * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (s * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                    32,
                                                                    33,
                                                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[197 len 31]
                                                    if poolInfo[arg1].field_1280 <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require poolInfo[arg1].field_1280
                                                    if (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (s * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_768 += 10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (s * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280
                                        poolInfo[arg1].field_512 = block.number
        else:
            require ext_code.size(poolInfo[arg1].field_0)
            staticcall poolInfo[arg1].field_0.0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if not ext_call.return_data[0]:
                poolInfo[arg1].field_512 = block.number
            else:
                if 0 == decayPeriod:
                    if 0 == decayPeriod:
                        if 0 >= decayTable.length:
                            require decayTable.length - 1 < decayTable.length
                            if not decayTable[decayTable.length]:
                                decayTable.length++
                                decayTable[decayTable.length] = 0
                            else:
                                if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                decayTable.length++
                                decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                            require 0 < decayTable.length
                        if poolInfo[arg1].field_512 > block.number:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if block.number - poolInfo[arg1].field_512:
                            if (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) / block.number - poolInfo[arg1].field_512 != decayTable:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) > 0:
                                if not (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable):
                                    if totalAllocPoint <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require totalAllocPoint
                                    require ext_code.size(bxhAddress)
                                    call bxhAddress.mint(address arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args this.address, 0 / totalAllocPoint
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if ext_call.return_data[0]:
                                        if not 0 / totalAllocPoint:
                                            if ext_call.return_data[0] <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require ext_call.return_data[0]
                                            if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                        else:
                                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                            32,
                                                            33,
                                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[197 len 31]
                                            if ext_call.return_data[0] <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require ext_call.return_data[0]
                                            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                else:
                                    if (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) != poolInfo[arg1].field_256:
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                    32,
                                                    33,
                                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[197 len 31]
                                    if totalAllocPoint <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require totalAllocPoint
                                    require ext_code.size(bxhAddress)
                                    call bxhAddress.mint(address arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args this.address, (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if ext_call.return_data[0]:
                                        if not (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint:
                                            if ext_call.return_data[0] <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require ext_call.return_data[0]
                                            if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                        else:
                                            if 10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                            32,
                                                            33,
                                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[197 len 31]
                                            if ext_call.return_data[0] <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require ext_call.return_data[0]
                                            if (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]
                                poolInfo[arg1].field_512 = block.number
                    else:
                        if block.number <= startBlock:
                            if 0 >= decayTable.length:
                                require decayTable.length - 1 < decayTable.length
                                if not decayTable[decayTable.length]:
                                    decayTable.length++
                                    decayTable[decayTable.length] = 0
                                else:
                                    if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                    32,
                                                    33,
                                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[197 len 31]
                                    decayTable.length++
                                    decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                require 0 < decayTable.length
                            if poolInfo[arg1].field_512 > block.number:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if block.number - poolInfo[arg1].field_512:
                                if (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) / block.number - poolInfo[arg1].field_512 != decayTable:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                if (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) > 0:
                                    if not (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable):
                                        if totalAllocPoint <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalAllocPoint
                                        require ext_code.size(bxhAddress)
                                        call bxhAddress.mint(address arg1, uint256 arg2) with:
                                             gas gas_remaining wei
                                            args this.address, 0 / totalAllocPoint
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0]:
                                            if not 0 / totalAllocPoint:
                                                if ext_call.return_data[0] <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require ext_call.return_data[0]
                                                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                            else:
                                                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                32,
                                                                33,
                                                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[197 len 31]
                                                if ext_call.return_data[0] <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require ext_call.return_data[0]
                                                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                    else:
                                        if (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) != poolInfo[arg1].field_256:
                                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                        32,
                                                        33,
                                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[197 len 31]
                                        if totalAllocPoint <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalAllocPoint
                                        require ext_code.size(bxhAddress)
                                        call bxhAddress.mint(address arg1, uint256 arg2) with:
                                             gas gas_remaining wei
                                            args this.address, (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0]:
                                            if not (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint:
                                                if ext_call.return_data[0] <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require ext_call.return_data[0]
                                                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                            else:
                                                if 10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                32,
                                                                33,
                                                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[197 len 31]
                                                if ext_call.return_data[0] <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require ext_call.return_data[0]
                                                if (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]
                                    poolInfo[arg1].field_512 = block.number
                        else:
                            if startBlock > block.number:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if 1 > block.number - startBlock:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if decayPeriod <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require decayPeriod
                            if block.number + -startBlock - 1 / decayPeriod >= decayTable.length:
                                require decayTable.length - 1 < decayTable.length
                                if not decayTable[decayTable.length]:
                                    decayTable.length++
                                    decayTable[decayTable.length] = 0
                                else:
                                    if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                    32,
                                                    33,
                                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[197 len 31]
                                    decayTable.length++
                                    decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                require block.number + -startBlock - 1 / decayPeriod < decayTable.length
                            if poolInfo[arg1].field_512 > block.number:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if block.number - poolInfo[arg1].field_512:
                                if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) / block.number - poolInfo[arg1].field_512 != decayTable[block.number + -stor12 - 1 / stor15]:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) > 0:
                                    if not (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15]):
                                        if totalAllocPoint <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalAllocPoint
                                        require ext_code.size(bxhAddress)
                                        call bxhAddress.mint(address arg1, uint256 arg2) with:
                                             gas gas_remaining wei
                                            args this.address, 0 / totalAllocPoint
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0]:
                                            if not 0 / totalAllocPoint:
                                                if ext_call.return_data[0] <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require ext_call.return_data[0]
                                                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                            else:
                                                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                32,
                                                                33,
                                                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[197 len 31]
                                                if ext_call.return_data[0] <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require ext_call.return_data[0]
                                                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                    else:
                                        if (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) != poolInfo[arg1].field_256:
                                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                        32,
                                                        33,
                                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[197 len 31]
                                        if totalAllocPoint <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalAllocPoint
                                        require ext_code.size(bxhAddress)
                                        call bxhAddress.mint(address arg1, uint256 arg2) with:
                                             gas gas_remaining wei
                                            args this.address, (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0]:
                                            if not (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint:
                                                if ext_call.return_data[0] <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require ext_call.return_data[0]
                                                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                            else:
                                                if 10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                32,
                                                                33,
                                                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[197 len 31]
                                                if ext_call.return_data[0] <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require ext_call.return_data[0]
                                                if (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]
                                    poolInfo[arg1].field_512 = block.number
                else:
                    if poolInfo[arg1].field_512 <= startBlock:
                        if 0 == decayPeriod:
                            if 0 == decayPeriod:
                                if 0 >= decayTable.length:
                                    require decayTable.length - 1 < decayTable.length
                                    if not decayTable[decayTable.length]:
                                        decayTable.length++
                                        decayTable[decayTable.length] = 0
                                    else:
                                        if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                        32,
                                                        33,
                                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[197 len 31]
                                        decayTable.length++
                                        decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                    require 0 < decayTable.length
                                if poolInfo[arg1].field_512 > block.number:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if block.number - poolInfo[arg1].field_512:
                                    if (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) / block.number - poolInfo[arg1].field_512 != decayTable:
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                    32,
                                                    33,
                                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[197 len 31]
                                    if (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) > 0:
                                        if not (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable):
                                            if totalAllocPoint <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalAllocPoint
                                            require ext_code.size(bxhAddress)
                                            call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                 gas gas_remaining wei
                                                args this.address, 0 / totalAllocPoint
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if ext_call.return_data[0]:
                                                if not 0 / totalAllocPoint:
                                                    if ext_call.return_data[0] <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require ext_call.return_data[0]
                                                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                                else:
                                                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                    32,
                                                                    33,
                                                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[197 len 31]
                                                    if ext_call.return_data[0] <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require ext_call.return_data[0]
                                                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                        else:
                                            if (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) != poolInfo[arg1].field_256:
                                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                            32,
                                                            33,
                                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[197 len 31]
                                            if totalAllocPoint <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalAllocPoint
                                            require ext_code.size(bxhAddress)
                                            call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                 gas gas_remaining wei
                                                args this.address, (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if ext_call.return_data[0]:
                                                if not (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint:
                                                    if ext_call.return_data[0] <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require ext_call.return_data[0]
                                                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                                else:
                                                    if 10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                    32,
                                                                    33,
                                                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[197 len 31]
                                                    if ext_call.return_data[0] <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require ext_call.return_data[0]
                                                    if (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_768 += 10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]
                                        poolInfo[arg1].field_512 = block.number
                            else:
                                if block.number <= startBlock:
                                    if 0 >= decayTable.length:
                                        require decayTable.length - 1 < decayTable.length
                                        if not decayTable[decayTable.length]:
                                            decayTable.length++
                                            decayTable[decayTable.length] = 0
                                        else:
                                            if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                            32,
                                                            33,
                                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[197 len 31]
                                            decayTable.length++
                                            decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                        require 0 < decayTable.length
                                    if poolInfo[arg1].field_512 > block.number:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if block.number - poolInfo[arg1].field_512:
                                        if (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) / block.number - poolInfo[arg1].field_512 != decayTable:
                                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                        32,
                                                        33,
                                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[197 len 31]
                                        if (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) > 0:
                                            if not (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable):
                                                if totalAllocPoint <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalAllocPoint
                                                require ext_code.size(bxhAddress)
                                                call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args this.address, 0 / totalAllocPoint
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if ext_call.return_data[0]:
                                                    if not 0 / totalAllocPoint:
                                                        if ext_call.return_data[0] <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require ext_call.return_data[0]
                                                        if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                                    else:
                                                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                        32,
                                                                        33,
                                                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[197 len 31]
                                                        if ext_call.return_data[0] <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require ext_call.return_data[0]
                                                        if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                            else:
                                                if (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) != poolInfo[arg1].field_256:
                                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                32,
                                                                33,
                                                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[197 len 31]
                                                if totalAllocPoint <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalAllocPoint
                                                require ext_code.size(bxhAddress)
                                                call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args this.address, (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if ext_call.return_data[0]:
                                                    if not (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint:
                                                        if ext_call.return_data[0] <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require ext_call.return_data[0]
                                                        if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                                    else:
                                                        if 10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                                                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                        32,
                                                                        33,
                                                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[197 len 31]
                                                        if ext_call.return_data[0] <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require ext_call.return_data[0]
                                                        if (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[arg1].field_768 += 10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]
                                            poolInfo[arg1].field_512 = block.number
                                else:
                                    if startBlock > block.number:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if 1 > block.number - startBlock:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if decayPeriod <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require decayPeriod
                                    if block.number + -startBlock - 1 / decayPeriod >= decayTable.length:
                                        require decayTable.length - 1 < decayTable.length
                                        if not decayTable[decayTable.length]:
                                            decayTable.length++
                                            decayTable[decayTable.length] = 0
                                        else:
                                            if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                            32,
                                                            33,
                                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[197 len 31]
                                            decayTable.length++
                                            decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                        require block.number + -startBlock - 1 / decayPeriod < decayTable.length
                                    if poolInfo[arg1].field_512 > block.number:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if block.number - poolInfo[arg1].field_512:
                                        if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) / block.number - poolInfo[arg1].field_512 != decayTable[block.number + -stor12 - 1 / stor15]:
                                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                        32,
                                                        33,
                                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[197 len 31]
                                        if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) > 0:
                                            if not (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15]):
                                                if totalAllocPoint <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalAllocPoint
                                                require ext_code.size(bxhAddress)
                                                call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args this.address, 0 / totalAllocPoint
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if ext_call.return_data[0]:
                                                    if not 0 / totalAllocPoint:
                                                        if ext_call.return_data[0] <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require ext_call.return_data[0]
                                                        if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                                    else:
                                                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                        32,
                                                                        33,
                                                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[197 len 31]
                                                        if ext_call.return_data[0] <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require ext_call.return_data[0]
                                                        if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                            else:
                                                if (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) != poolInfo[arg1].field_256:
                                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                32,
                                                                33,
                                                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[197 len 31]
                                                if totalAllocPoint <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalAllocPoint
                                                require ext_code.size(bxhAddress)
                                                call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args this.address, (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if ext_call.return_data[0]:
                                                    if not (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint:
                                                        if ext_call.return_data[0] <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require ext_call.return_data[0]
                                                        if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                                    else:
                                                        if 10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                                                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                        32,
                                                                        33,
                                                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[197 len 31]
                                                        if ext_call.return_data[0] <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require ext_call.return_data[0]
                                                        if (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[arg1].field_768 += 10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]
                                            poolInfo[arg1].field_512 = block.number
                        else:
                            if block.number <= startBlock:
                                if 0 == decayPeriod:
                                    if 0 >= decayTable.length:
                                        require decayTable.length - 1 < decayTable.length
                                        if not decayTable[decayTable.length]:
                                            decayTable.length++
                                            decayTable[decayTable.length] = 0
                                        else:
                                            if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                            32,
                                                            33,
                                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[197 len 31]
                                            decayTable.length++
                                            decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                        require 0 < decayTable.length
                                    if poolInfo[arg1].field_512 > block.number:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if block.number - poolInfo[arg1].field_512:
                                        if (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) / block.number - poolInfo[arg1].field_512 != decayTable:
                                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                        32,
                                                        33,
                                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[197 len 31]
                                        if (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) > 0:
                                            if not (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable):
                                                if totalAllocPoint <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalAllocPoint
                                                require ext_code.size(bxhAddress)
                                                call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args this.address, 0 / totalAllocPoint
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if ext_call.return_data[0]:
                                                    if not 0 / totalAllocPoint:
                                                        if ext_call.return_data[0] <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require ext_call.return_data[0]
                                                        if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                                    else:
                                                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                        32,
                                                                        33,
                                                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[197 len 31]
                                                        if ext_call.return_data[0] <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require ext_call.return_data[0]
                                                        if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                            else:
                                                if (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) != poolInfo[arg1].field_256:
                                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                32,
                                                                33,
                                                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[197 len 31]
                                                if totalAllocPoint <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalAllocPoint
                                                require ext_code.size(bxhAddress)
                                                call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args this.address, (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if ext_call.return_data[0]:
                                                    if not (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint:
                                                        if ext_call.return_data[0] <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require ext_call.return_data[0]
                                                        if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                                    else:
                                                        if 10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                                                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                        32,
                                                                        33,
                                                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[197 len 31]
                                                        if ext_call.return_data[0] <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require ext_call.return_data[0]
                                                        if (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[arg1].field_768 += 10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]
                                            poolInfo[arg1].field_512 = block.number
                                else:
                                    if block.number <= startBlock:
                                        if 0 >= decayTable.length:
                                            require decayTable.length - 1 < decayTable.length
                                            if not decayTable[decayTable.length]:
                                                decayTable.length++
                                                decayTable[decayTable.length] = 0
                                            else:
                                                if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                32,
                                                                33,
                                                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[197 len 31]
                                                decayTable.length++
                                                decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                            require 0 < decayTable.length
                                        if poolInfo[arg1].field_512 > block.number:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if block.number - poolInfo[arg1].field_512:
                                            if (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) / block.number - poolInfo[arg1].field_512 != decayTable:
                                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                            32,
                                                            33,
                                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[197 len 31]
                                            if (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) > 0:
                                                if not (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable):
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    require ext_code.size(bxhAddress)
                                                    call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, 0 / totalAllocPoint
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if ext_call.return_data[0]:
                                                        if not 0 / totalAllocPoint:
                                                            if ext_call.return_data[0] <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require ext_call.return_data[0]
                                                            if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                                        else:
                                                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                            32,
                                                                            33,
                                                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                            mem[197 len 31]
                                                            if ext_call.return_data[0] <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require ext_call.return_data[0]
                                                            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                                else:
                                                    if (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) != poolInfo[arg1].field_256:
                                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                    32,
                                                                    33,
                                                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[197 len 31]
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    require ext_code.size(bxhAddress)
                                                    call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if ext_call.return_data[0]:
                                                        if not (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint:
                                                            if ext_call.return_data[0] <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require ext_call.return_data[0]
                                                            if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                                        else:
                                                            if 10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                                                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                            32,
                                                                            33,
                                                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                            mem[197 len 31]
                                                            if ext_call.return_data[0] <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require ext_call.return_data[0]
                                                            if (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[arg1].field_768 += 10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]
                                                poolInfo[arg1].field_512 = block.number
                                    else:
                                        if startBlock > block.number:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if 1 > block.number - startBlock:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if decayPeriod <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require decayPeriod
                                        if block.number + -startBlock - 1 / decayPeriod >= decayTable.length:
                                            require decayTable.length - 1 < decayTable.length
                                            if not decayTable[decayTable.length]:
                                                decayTable.length++
                                                decayTable[decayTable.length] = 0
                                            else:
                                                if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                32,
                                                                33,
                                                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[197 len 31]
                                                decayTable.length++
                                                decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                            require block.number + -startBlock - 1 / decayPeriod < decayTable.length
                                        if poolInfo[arg1].field_512 > block.number:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if block.number - poolInfo[arg1].field_512:
                                            if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) / block.number - poolInfo[arg1].field_512 != decayTable[block.number + -stor12 - 1 / stor15]:
                                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                            32,
                                                            33,
                                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[197 len 31]
                                            if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) > 0:
                                                if not (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15]):
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    require ext_code.size(bxhAddress)
                                                    call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, 0 / totalAllocPoint
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if ext_call.return_data[0]:
                                                        if not 0 / totalAllocPoint:
                                                            if ext_call.return_data[0] <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require ext_call.return_data[0]
                                                            if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                                        else:
                                                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                            32,
                                                                            33,
                                                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                            mem[197 len 31]
                                                            if ext_call.return_data[0] <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require ext_call.return_data[0]
                                                            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                                else:
                                                    if (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) != poolInfo[arg1].field_256:
                                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                    32,
                                                                    33,
                                                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[197 len 31]
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    require ext_code.size(bxhAddress)
                                                    call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if ext_call.return_data[0]:
                                                        if not (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint:
                                                            if ext_call.return_data[0] <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require ext_call.return_data[0]
                                                            if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                                        else:
                                                            if 10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                                                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                            32,
                                                                            33,
                                                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                            mem[197 len 31]
                                                            if ext_call.return_data[0] <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require ext_call.return_data[0]
                                                            if (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[arg1].field_768 += 10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]
                                                poolInfo[arg1].field_512 = block.number
                            else:
                                if startBlock > block.number:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if 1 > block.number - startBlock:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if decayPeriod <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require decayPeriod
                                idx = 0
                                s = poolInfo[arg1].field_512
                                while idx < block.number + -startBlock - 1 / decayPeriod:
                                    if not idx + 1:
                                        if startBlock < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if decayPeriod != 0:
                                            if startBlock > startBlock:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        if 0 >= decayTable.length:
                                            require decayTable.length - 1 < decayTable.length
                                            if not decayTable[decayTable.length]:
                                                decayTable.length++
                                                decayTable[decayTable.length] = 0
                                            else:
                                                if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                32,
                                                                33,
                                                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[197 len 31]
                                                decayTable.length++
                                                decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                            require 0 < decayTable.length
                                        mem[0] = 17
                                        if s > startBlock:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if startBlock - s:
                                            if (startBlock * decayTable) - (s * decayTable) / startBlock - s != decayTable:
                                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                            32,
                                                            33,
                                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[197 len 31]
                                            if (startBlock * decayTable) - (s * decayTable) < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                        idx = idx + 1
                                        s = startBlock
                                        continue 
                                    if decayPeriod + (idx * decayPeriod) / idx + 1 != decayPeriod:
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                    32,
                                                    33,
                                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[197 len 31]
                                    if startBlock < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if 0 == decayPeriod:
                                        if 0 >= decayTable.length:
                                            require decayTable.length - 1 < decayTable.length
                                            if not decayTable[decayTable.length]:
                                                decayTable.length++
                                                decayTable[decayTable.length] = 0
                                            else:
                                                if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                32,
                                                                33,
                                                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[197 len 31]
                                                decayTable.length++
                                                decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                            require 0 < decayTable.length
                                        mem[0] = 17
                                        if s > startBlock + decayPeriod + (idx * decayPeriod):
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if startBlock + decayPeriod + (idx * decayPeriod) - s:
                                            if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) / startBlock + decayPeriod + (idx * decayPeriod) - s != decayTable:
                                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                            32,
                                                            33,
                                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[197 len 31]
                                            if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                    else:
                                        if startBlock + decayPeriod + (idx * decayPeriod) <= startBlock:
                                            if 0 >= decayTable.length:
                                                require decayTable.length - 1 < decayTable.length
                                                if not decayTable[decayTable.length]:
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = 0
                                                else:
                                                    if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                    32,
                                                                    33,
                                                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[197 len 31]
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                require 0 < decayTable.length
                                            mem[0] = 17
                                            if s > startBlock + decayPeriod + (idx * decayPeriod):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if startBlock + decayPeriod + (idx * decayPeriod) - s:
                                                if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) / startBlock + decayPeriod + (idx * decayPeriod) - s != decayTable:
                                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                32,
                                                                33,
                                                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[197 len 31]
                                                if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                        else:
                                            if startBlock > startBlock + decayPeriod + (idx * decayPeriod):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if 1 > decayPeriod + (idx * decayPeriod):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if decayPeriod <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require decayPeriod
                                            if decayPeriod + (idx * decayPeriod) - 1 / decayPeriod >= decayTable.length:
                                                require decayTable.length - 1 < decayTable.length
                                                if not decayTable[decayTable.length]:
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = 0
                                                else:
                                                    if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                    32,
                                                                    33,
                                                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[197 len 31]
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                require decayPeriod + (idx * decayPeriod) - 1 / decayPeriod < decayTable.length
                                            mem[0] = 17
                                            if s > startBlock + decayPeriod + (idx * decayPeriod):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if startBlock + decayPeriod + (idx * decayPeriod) - s:
                                                if (startBlock * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (idx * decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) - (s * decayTable[stor15 + (idx * stor15) - 1 / stor15]) / startBlock + decayPeriod + (idx * decayPeriod) - s != decayTable[stor15 + (idx * stor15) - 1 / stor15]:
                                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                32,
                                                                33,
                                                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[197 len 31]
                                                if (startBlock * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (idx * decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) - (s * decayTable[stor15 + (idx * stor15) - 1 / stor15]) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                    idx = idx + 1
                                    s = startBlock + decayPeriod + (idx * decayPeriod)
                                    continue 
                                if 0 == decayPeriod:
                                    if 0 >= decayTable.length:
                                        require decayTable.length - 1 < decayTable.length
                                        if not decayTable[decayTable.length]:
                                            decayTable.length++
                                            decayTable[decayTable.length] = 0
                                        else:
                                            if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                            32,
                                                            33,
                                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[197 len 31]
                                            decayTable.length++
                                            decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                        require 0 < decayTable.length
                                    if s > block.number:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if block.number - s:
                                        if (block.number * decayTable) - (s * decayTable) / block.number - s != decayTable:
                                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                        32,
                                                        33,
                                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[197 len 31]
                                        if (block.number * decayTable) - (s * decayTable) < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (block.number * decayTable) - (s * decayTable) > 0:
                                            if not (block.number * decayTable) - (s * decayTable):
                                                if totalAllocPoint <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalAllocPoint
                                                require ext_code.size(bxhAddress)
                                                call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args this.address, 0 / totalAllocPoint
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if ext_call.return_data[0]:
                                                    if not 0 / totalAllocPoint:
                                                        if ext_call.return_data[0] <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require ext_call.return_data[0]
                                                        if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                                    else:
                                                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                        32,
                                                                        33,
                                                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[197 len 31]
                                                        if ext_call.return_data[0] <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require ext_call.return_data[0]
                                                        if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                            else:
                                                if (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / (block.number * decayTable) - (s * decayTable) != poolInfo[arg1].field_256:
                                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                32,
                                                                33,
                                                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[197 len 31]
                                                if totalAllocPoint <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalAllocPoint
                                                require ext_code.size(bxhAddress)
                                                call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args this.address, (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if ext_call.return_data[0]:
                                                    if not (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint:
                                                        if ext_call.return_data[0] <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require ext_call.return_data[0]
                                                        if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                                    else:
                                                        if 10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                                                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                        32,
                                                                        33,
                                                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[197 len 31]
                                                        if ext_call.return_data[0] <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        require ext_call.return_data[0]
                                                        if (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        poolInfo[arg1].field_768 += 10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]
                                            poolInfo[arg1].field_512 = block.number
                                else:
                                    if block.number <= startBlock:
                                        if 0 >= decayTable.length:
                                            require decayTable.length - 1 < decayTable.length
                                            if not decayTable[decayTable.length]:
                                                decayTable.length++
                                                decayTable[decayTable.length] = 0
                                            else:
                                                if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                32,
                                                                33,
                                                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[197 len 31]
                                                decayTable.length++
                                                decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                            require 0 < decayTable.length
                                        if s > block.number:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if block.number - s:
                                            if (block.number * decayTable) - (s * decayTable) / block.number - s != decayTable:
                                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                            32,
                                                            33,
                                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[197 len 31]
                                            if (block.number * decayTable) - (s * decayTable) < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (block.number * decayTable) - (s * decayTable) > 0:
                                                if not (block.number * decayTable) - (s * decayTable):
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    require ext_code.size(bxhAddress)
                                                    call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, 0 / totalAllocPoint
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if ext_call.return_data[0]:
                                                        if not 0 / totalAllocPoint:
                                                            if ext_call.return_data[0] <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require ext_call.return_data[0]
                                                            if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                                        else:
                                                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                            32,
                                                                            33,
                                                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                            mem[197 len 31]
                                                            if ext_call.return_data[0] <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require ext_call.return_data[0]
                                                            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                                else:
                                                    if (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / (block.number * decayTable) - (s * decayTable) != poolInfo[arg1].field_256:
                                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                    32,
                                                                    33,
                                                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[197 len 31]
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    require ext_code.size(bxhAddress)
                                                    call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if ext_call.return_data[0]:
                                                        if not (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint:
                                                            if ext_call.return_data[0] <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require ext_call.return_data[0]
                                                            if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                                        else:
                                                            if 10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                                                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                            32,
                                                                            33,
                                                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                            mem[197 len 31]
                                                            if ext_call.return_data[0] <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require ext_call.return_data[0]
                                                            if (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[arg1].field_768 += 10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]
                                                poolInfo[arg1].field_512 = block.number
                                    else:
                                        if startBlock > block.number:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if 1 > block.number - startBlock:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if decayPeriod <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require decayPeriod
                                        if block.number + -startBlock - 1 / decayPeriod >= decayTable.length:
                                            require decayTable.length - 1 < decayTable.length
                                            if not decayTable[decayTable.length]:
                                                decayTable.length++
                                                decayTable[decayTable.length] = 0
                                            else:
                                                if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                32,
                                                                33,
                                                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[197 len 31]
                                                decayTable.length++
                                                decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                            require block.number + -startBlock - 1 / decayPeriod < decayTable.length
                                        if s > block.number:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if block.number - s:
                                            if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (s * decayTable[block.number + -stor12 - 1 / stor15]) / block.number - s != decayTable[block.number + -stor12 - 1 / stor15]:
                                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                            32,
                                                            33,
                                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[197 len 31]
                                            if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (s * decayTable[block.number + -stor12 - 1 / stor15]) < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (s * decayTable[block.number + -stor12 - 1 / stor15]) > 0:
                                                if not (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (s * decayTable[block.number + -stor12 - 1 / stor15]):
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    require ext_code.size(bxhAddress)
                                                    call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, 0 / totalAllocPoint
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if ext_call.return_data[0]:
                                                        if not 0 / totalAllocPoint:
                                                            if ext_call.return_data[0] <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require ext_call.return_data[0]
                                                            if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                                        else:
                                                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                            32,
                                                                            33,
                                                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                            mem[197 len 31]
                                                            if ext_call.return_data[0] <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require ext_call.return_data[0]
                                                            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                                else:
                                                    if (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (s * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (s * decayTable[block.number + -stor12 - 1 / stor15]) != poolInfo[arg1].field_256:
                                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                    32,
                                                                    33,
                                                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[197 len 31]
                                                    if totalAllocPoint <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require totalAllocPoint
                                                    require ext_code.size(bxhAddress)
                                                    call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args this.address, (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (s * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    require return_data.size >= 32
                                                    if ext_call.return_data[0]:
                                                        if not (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (s * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint:
                                                            if ext_call.return_data[0] <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require ext_call.return_data[0]
                                                            if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                                        else:
                                                            if 10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (s * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (s * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                                                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                            32,
                                                                            33,
                                                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                            mem[197 len 31]
                                                            if ext_call.return_data[0] <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            require ext_call.return_data[0]
                                                            if (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (s * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            poolInfo[arg1].field_768 += 10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (s * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]
                                                poolInfo[arg1].field_512 = block.number
                    else:
                        if startBlock > poolInfo[arg1].field_512:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if 1 > poolInfo[arg1].field_512 - startBlock:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if decayPeriod <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require decayPeriod
                        if 0 == decayPeriod:
                            idx = poolInfo[arg1].field_512 + -startBlock - 1 / decayPeriod
                            s = poolInfo[arg1].field_512
                            while idx < 0:
                                if not idx + 1:
                                    if startBlock < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if decayPeriod != 0:
                                        if startBlock > startBlock:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    if 0 >= decayTable.length:
                                        require decayTable.length - 1 < decayTable.length
                                        if not decayTable[decayTable.length]:
                                            decayTable.length++
                                            decayTable[decayTable.length] = 0
                                        else:
                                            if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                            32,
                                                            33,
                                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[197 len 31]
                                            decayTable.length++
                                            decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                        require 0 < decayTable.length
                                    mem[0] = 17
                                    if s > startBlock:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if startBlock - s:
                                        if (startBlock * decayTable) - (s * decayTable) / startBlock - s != decayTable:
                                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                        32,
                                                        33,
                                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[197 len 31]
                                        if (startBlock * decayTable) - (s * decayTable) < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                    idx = idx + 1
                                    s = startBlock
                                    continue 
                                if decayPeriod + (idx * decayPeriod) / idx + 1 != decayPeriod:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                if startBlock < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if 0 == decayPeriod:
                                    if 0 >= decayTable.length:
                                        require decayTable.length - 1 < decayTable.length
                                        if not decayTable[decayTable.length]:
                                            decayTable.length++
                                            decayTable[decayTable.length] = 0
                                        else:
                                            if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                            32,
                                                            33,
                                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[197 len 31]
                                            decayTable.length++
                                            decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                        require 0 < decayTable.length
                                    mem[0] = 17
                                    if s > startBlock + decayPeriod + (idx * decayPeriod):
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if startBlock + decayPeriod + (idx * decayPeriod) - s:
                                        if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) / startBlock + decayPeriod + (idx * decayPeriod) - s != decayTable:
                                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                        32,
                                                        33,
                                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[197 len 31]
                                        if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                else:
                                    if startBlock + decayPeriod + (idx * decayPeriod) <= startBlock:
                                        if 0 >= decayTable.length:
                                            require decayTable.length - 1 < decayTable.length
                                            if not decayTable[decayTable.length]:
                                                decayTable.length++
                                                decayTable[decayTable.length] = 0
                                            else:
                                                if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                32,
                                                                33,
                                                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[197 len 31]
                                                decayTable.length++
                                                decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                            require 0 < decayTable.length
                                        mem[0] = 17
                                        if s > startBlock + decayPeriod + (idx * decayPeriod):
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if startBlock + decayPeriod + (idx * decayPeriod) - s:
                                            if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) / startBlock + decayPeriod + (idx * decayPeriod) - s != decayTable:
                                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                            32,
                                                            33,
                                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[197 len 31]
                                            if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                    else:
                                        if startBlock > startBlock + decayPeriod + (idx * decayPeriod):
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if 1 > decayPeriod + (idx * decayPeriod):
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if decayPeriod <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require decayPeriod
                                        if decayPeriod + (idx * decayPeriod) - 1 / decayPeriod >= decayTable.length:
                                            require decayTable.length - 1 < decayTable.length
                                            if not decayTable[decayTable.length]:
                                                decayTable.length++
                                                decayTable[decayTable.length] = 0
                                            else:
                                                if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                32,
                                                                33,
                                                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[197 len 31]
                                                decayTable.length++
                                                decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                            require decayPeriod + (idx * decayPeriod) - 1 / decayPeriod < decayTable.length
                                        mem[0] = 17
                                        if s > startBlock + decayPeriod + (idx * decayPeriod):
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if startBlock + decayPeriod + (idx * decayPeriod) - s:
                                            if (startBlock * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (idx * decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) - (s * decayTable[stor15 + (idx * stor15) - 1 / stor15]) / startBlock + decayPeriod + (idx * decayPeriod) - s != decayTable[stor15 + (idx * stor15) - 1 / stor15]:
                                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                            32,
                                                            33,
                                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[197 len 31]
                                            if (startBlock * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (idx * decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) - (s * decayTable[stor15 + (idx * stor15) - 1 / stor15]) < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                idx = idx + 1
                                s = startBlock + decayPeriod + (idx * decayPeriod)
                                continue 
                        else:
                            if block.number <= startBlock:
                                idx = poolInfo[arg1].field_512 + -startBlock - 1 / decayPeriod
                                s = poolInfo[arg1].field_512
                                while idx < 0:
                                    if not idx + 1:
                                        if startBlock < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if decayPeriod != 0:
                                            if startBlock > startBlock:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        if 0 >= decayTable.length:
                                            require decayTable.length - 1 < decayTable.length
                                            if not decayTable[decayTable.length]:
                                                decayTable.length++
                                                decayTable[decayTable.length] = 0
                                            else:
                                                if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                32,
                                                                33,
                                                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[197 len 31]
                                                decayTable.length++
                                                decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                            require 0 < decayTable.length
                                        mem[0] = 17
                                        if s > startBlock:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if startBlock - s:
                                            if (startBlock * decayTable) - (s * decayTable) / startBlock - s != decayTable:
                                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                            32,
                                                            33,
                                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[197 len 31]
                                            if (startBlock * decayTable) - (s * decayTable) < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                        idx = idx + 1
                                        s = startBlock
                                        continue 
                                    if decayPeriod + (idx * decayPeriod) / idx + 1 != decayPeriod:
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                    32,
                                                    33,
                                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[197 len 31]
                                    if startBlock < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if 0 == decayPeriod:
                                        if 0 >= decayTable.length:
                                            require decayTable.length - 1 < decayTable.length
                                            if not decayTable[decayTable.length]:
                                                decayTable.length++
                                                decayTable[decayTable.length] = 0
                                            else:
                                                if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                32,
                                                                33,
                                                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[197 len 31]
                                                decayTable.length++
                                                decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                            require 0 < decayTable.length
                                        mem[0] = 17
                                        if s > startBlock + decayPeriod + (idx * decayPeriod):
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if startBlock + decayPeriod + (idx * decayPeriod) - s:
                                            if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) / startBlock + decayPeriod + (idx * decayPeriod) - s != decayTable:
                                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                            32,
                                                            33,
                                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[197 len 31]
                                            if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                    else:
                                        if startBlock + decayPeriod + (idx * decayPeriod) <= startBlock:
                                            if 0 >= decayTable.length:
                                                require decayTable.length - 1 < decayTable.length
                                                if not decayTable[decayTable.length]:
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = 0
                                                else:
                                                    if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                    32,
                                                                    33,
                                                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[197 len 31]
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                require 0 < decayTable.length
                                            mem[0] = 17
                                            if s > startBlock + decayPeriod + (idx * decayPeriod):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if startBlock + decayPeriod + (idx * decayPeriod) - s:
                                                if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) / startBlock + decayPeriod + (idx * decayPeriod) - s != decayTable:
                                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                32,
                                                                33,
                                                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[197 len 31]
                                                if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                        else:
                                            if startBlock > startBlock + decayPeriod + (idx * decayPeriod):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if 1 > decayPeriod + (idx * decayPeriod):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if decayPeriod <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require decayPeriod
                                            if decayPeriod + (idx * decayPeriod) - 1 / decayPeriod >= decayTable.length:
                                                require decayTable.length - 1 < decayTable.length
                                                if not decayTable[decayTable.length]:
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = 0
                                                else:
                                                    if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                    32,
                                                                    33,
                                                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[197 len 31]
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                require decayPeriod + (idx * decayPeriod) - 1 / decayPeriod < decayTable.length
                                            mem[0] = 17
                                            if s > startBlock + decayPeriod + (idx * decayPeriod):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if startBlock + decayPeriod + (idx * decayPeriod) - s:
                                                if (startBlock * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (idx * decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) - (s * decayTable[stor15 + (idx * stor15) - 1 / stor15]) / startBlock + decayPeriod + (idx * decayPeriod) - s != decayTable[stor15 + (idx * stor15) - 1 / stor15]:
                                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                32,
                                                                33,
                                                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[197 len 31]
                                                if (startBlock * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (idx * decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) - (s * decayTable[stor15 + (idx * stor15) - 1 / stor15]) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                    idx = idx + 1
                                    s = startBlock + decayPeriod + (idx * decayPeriod)
                                    continue 
                            else:
                                if startBlock > block.number:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if 1 > block.number - startBlock:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if decayPeriod <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require decayPeriod
                                idx = poolInfo[arg1].field_512 + -startBlock - 1 / decayPeriod
                                s = poolInfo[arg1].field_512
                                while idx < block.number + -startBlock - 1 / decayPeriod:
                                    if not idx + 1:
                                        if startBlock < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if decayPeriod != 0:
                                            if startBlock > startBlock:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        if 0 >= decayTable.length:
                                            require decayTable.length - 1 < decayTable.length
                                            if not decayTable[decayTable.length]:
                                                decayTable.length++
                                                decayTable[decayTable.length] = 0
                                            else:
                                                if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                32,
                                                                33,
                                                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[197 len 31]
                                                decayTable.length++
                                                decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                            require 0 < decayTable.length
                                        mem[0] = 17
                                        if s > startBlock:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if startBlock - s:
                                            if (startBlock * decayTable) - (s * decayTable) / startBlock - s != decayTable:
                                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                            32,
                                                            33,
                                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[197 len 31]
                                            if (startBlock * decayTable) - (s * decayTable) < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                        idx = idx + 1
                                        s = startBlock
                                        continue 
                                    if decayPeriod + (idx * decayPeriod) / idx + 1 != decayPeriod:
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                    32,
                                                    33,
                                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[197 len 31]
                                    if startBlock < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if 0 == decayPeriod:
                                        if 0 >= decayTable.length:
                                            require decayTable.length - 1 < decayTable.length
                                            if not decayTable[decayTable.length]:
                                                decayTable.length++
                                                decayTable[decayTable.length] = 0
                                            else:
                                                if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                32,
                                                                33,
                                                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[197 len 31]
                                                decayTable.length++
                                                decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                            require 0 < decayTable.length
                                        mem[0] = 17
                                        if s > startBlock + decayPeriod + (idx * decayPeriod):
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if startBlock + decayPeriod + (idx * decayPeriod) - s:
                                            if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) / startBlock + decayPeriod + (idx * decayPeriod) - s != decayTable:
                                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                            32,
                                                            33,
                                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[197 len 31]
                                            if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                    else:
                                        if startBlock + decayPeriod + (idx * decayPeriod) <= startBlock:
                                            if 0 >= decayTable.length:
                                                require decayTable.length - 1 < decayTable.length
                                                if not decayTable[decayTable.length]:
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = 0
                                                else:
                                                    if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                    32,
                                                                    33,
                                                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[197 len 31]
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                require 0 < decayTable.length
                                            mem[0] = 17
                                            if s > startBlock + decayPeriod + (idx * decayPeriod):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if startBlock + decayPeriod + (idx * decayPeriod) - s:
                                                if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) / startBlock + decayPeriod + (idx * decayPeriod) - s != decayTable:
                                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                32,
                                                                33,
                                                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[197 len 31]
                                                if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                        else:
                                            if startBlock > startBlock + decayPeriod + (idx * decayPeriod):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if 1 > decayPeriod + (idx * decayPeriod):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if decayPeriod <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require decayPeriod
                                            if decayPeriod + (idx * decayPeriod) - 1 / decayPeriod >= decayTable.length:
                                                require decayTable.length - 1 < decayTable.length
                                                if not decayTable[decayTable.length]:
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = 0
                                                else:
                                                    if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                    32,
                                                                    33,
                                                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[197 len 31]
                                                    decayTable.length++
                                                    decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                                require decayPeriod + (idx * decayPeriod) - 1 / decayPeriod < decayTable.length
                                            mem[0] = 17
                                            if s > startBlock + decayPeriod + (idx * decayPeriod):
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if startBlock + decayPeriod + (idx * decayPeriod) - s:
                                                if (startBlock * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (idx * decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) - (s * decayTable[stor15 + (idx * stor15) - 1 / stor15]) / startBlock + decayPeriod + (idx * decayPeriod) - s != decayTable[stor15 + (idx * stor15) - 1 / stor15]:
                                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                32,
                                                                33,
                                                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[197 len 31]
                                                if (startBlock * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (idx * decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) - (s * decayTable[stor15 + (idx * stor15) - 1 / stor15]) < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                    idx = idx + 1
                                    s = startBlock + decayPeriod + (idx * decayPeriod)
                                    continue 
                        if 0 == decayPeriod:
                            if 0 >= decayTable.length:
                                require decayTable.length - 1 < decayTable.length
                                if not decayTable[decayTable.length]:
                                    decayTable.length++
                                    decayTable[decayTable.length] = 0
                                else:
                                    if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                    32,
                                                    33,
                                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[197 len 31]
                                    decayTable.length++
                                    decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                require 0 < decayTable.length
                            if s > block.number:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if block.number - s:
                                if (block.number * decayTable) - (s * decayTable) / block.number - s != decayTable:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                if (block.number * decayTable) - (s * decayTable) < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if (block.number * decayTable) - (s * decayTable) > 0:
                                    if not (block.number * decayTable) - (s * decayTable):
                                        if totalAllocPoint <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalAllocPoint
                                        require ext_code.size(bxhAddress)
                                        call bxhAddress.mint(address arg1, uint256 arg2) with:
                                             gas gas_remaining wei
                                            args this.address, 0 / totalAllocPoint
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0]:
                                            if not 0 / totalAllocPoint:
                                                if ext_call.return_data[0] <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require ext_call.return_data[0]
                                                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                            else:
                                                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                32,
                                                                33,
                                                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[197 len 31]
                                                if ext_call.return_data[0] <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require ext_call.return_data[0]
                                                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                    else:
                                        if (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / (block.number * decayTable) - (s * decayTable) != poolInfo[arg1].field_256:
                                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                        32,
                                                        33,
                                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[197 len 31]
                                        if totalAllocPoint <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalAllocPoint
                                        require ext_code.size(bxhAddress)
                                        call bxhAddress.mint(address arg1, uint256 arg2) with:
                                             gas gas_remaining wei
                                            args this.address, (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if ext_call.return_data[0]:
                                            if not (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint:
                                                if ext_call.return_data[0] <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require ext_call.return_data[0]
                                                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                            else:
                                                if 10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                32,
                                                                33,
                                                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[197 len 31]
                                                if ext_call.return_data[0] <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require ext_call.return_data[0]
                                                if (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[arg1].field_768 += 10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]
                                    poolInfo[arg1].field_512 = block.number
                        else:
                            if block.number <= startBlock:
                                if 0 >= decayTable.length:
                                    require decayTable.length - 1 < decayTable.length
                                    if not decayTable[decayTable.length]:
                                        decayTable.length++
                                        decayTable[decayTable.length] = 0
                                    else:
                                        if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                        32,
                                                        33,
                                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[197 len 31]
                                        decayTable.length++
                                        decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                    require 0 < decayTable.length
                                if s > block.number:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if block.number - s:
                                    if (block.number * decayTable) - (s * decayTable) / block.number - s != decayTable:
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                    32,
                                                    33,
                                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[197 len 31]
                                    if (block.number * decayTable) - (s * decayTable) < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (block.number * decayTable) - (s * decayTable) > 0:
                                        if not (block.number * decayTable) - (s * decayTable):
                                            if totalAllocPoint <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalAllocPoint
                                            require ext_code.size(bxhAddress)
                                            call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                 gas gas_remaining wei
                                                args this.address, 0 / totalAllocPoint
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if ext_call.return_data[0]:
                                                if not 0 / totalAllocPoint:
                                                    if ext_call.return_data[0] <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require ext_call.return_data[0]
                                                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                                else:
                                                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                    32,
                                                                    33,
                                                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[197 len 31]
                                                    if ext_call.return_data[0] <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require ext_call.return_data[0]
                                                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                        else:
                                            if (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / (block.number * decayTable) - (s * decayTable) != poolInfo[arg1].field_256:
                                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                            32,
                                                            33,
                                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[197 len 31]
                                            if totalAllocPoint <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalAllocPoint
                                            require ext_code.size(bxhAddress)
                                            call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                 gas gas_remaining wei
                                                args this.address, (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if ext_call.return_data[0]:
                                                if not (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint:
                                                    if ext_call.return_data[0] <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require ext_call.return_data[0]
                                                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                                else:
                                                    if 10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                    32,
                                                                    33,
                                                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[197 len 31]
                                                    if ext_call.return_data[0] <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require ext_call.return_data[0]
                                                    if (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_768 += 10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]
                                        poolInfo[arg1].field_512 = block.number
                            else:
                                if startBlock > block.number:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if 1 > block.number - startBlock:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if decayPeriod <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require decayPeriod
                                if block.number + -startBlock - 1 / decayPeriod >= decayTable.length:
                                    require decayTable.length - 1 < decayTable.length
                                    if not decayTable[decayTable.length]:
                                        decayTable.length++
                                        decayTable[decayTable.length] = 0
                                    else:
                                        if decayRatio * decayTable[decayTable.length] / decayTable[decayTable.length] != decayRatio:
                                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                        32,
                                                        33,
                                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[197 len 31]
                                        decayTable.length++
                                        decayTable[decayTable.length] = decayRatio * decayTable[decayTable.length] / 1000
                                    require block.number + -startBlock - 1 / decayPeriod < decayTable.length
                                if s > block.number:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if block.number - s:
                                    if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (s * decayTable[block.number + -stor12 - 1 / stor15]) / block.number - s != decayTable[block.number + -stor12 - 1 / stor15]:
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                    32,
                                                    33,
                                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[197 len 31]
                                    if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (s * decayTable[block.number + -stor12 - 1 / stor15]) < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (s * decayTable[block.number + -stor12 - 1 / stor15]) > 0:
                                        if not (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (s * decayTable[block.number + -stor12 - 1 / stor15]):
                                            if totalAllocPoint <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalAllocPoint
                                            require ext_code.size(bxhAddress)
                                            call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                 gas gas_remaining wei
                                                args this.address, 0 / totalAllocPoint
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if ext_call.return_data[0]:
                                                if not 0 / totalAllocPoint:
                                                    if ext_call.return_data[0] <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require ext_call.return_data[0]
                                                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                                else:
                                                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                    32,
                                                                    33,
                                                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[197 len 31]
                                                    if ext_call.return_data[0] <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require ext_call.return_data[0]
                                                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                        else:
                                            if (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (s * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (s * decayTable[block.number + -stor12 - 1 / stor15]) != poolInfo[arg1].field_256:
                                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                            32,
                                                            33,
                                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[197 len 31]
                                            if totalAllocPoint <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalAllocPoint
                                            require ext_code.size(bxhAddress)
                                            call bxhAddress.mint(address arg1, uint256 arg2) with:
                                                 gas gas_remaining wei
                                                args this.address, (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (s * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if ext_call.return_data[0]:
                                                if not (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (s * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint:
                                                    if ext_call.return_data[0] <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require ext_call.return_data[0]
                                                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                                else:
                                                    if 10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (s * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (s * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                                    32,
                                                                    33,
                                                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[197 len 31]
                                                    if ext_call.return_data[0] <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    require ext_call.return_data[0]
                                                    if (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (s * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[arg1].field_768 += 10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (s * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]
                                        poolInfo[arg1].field_512 = block.number
}

function pending(uint256 arg1, address arg2) payable {
    require calldata.size - 4 >= 64
    require arg1 < poolInfo.length
    require arg1 < poolInfo.length
    if not stor3[stor6[arg1].field_0]:
        require ext_code.size(poolInfo[arg1].field_0)
        staticcall poolInfo[arg1].field_0.0x70a08231 with:
                gas gas_remaining wei
               args this.address
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if not userInfo[arg1][address(arg2)].field_0:
            return 0
        if block.number <= poolInfo[arg1].field_512:
            if poolInfo[arg1].field_512 != block.number:
                return 0
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256, 0
            if poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0 / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if userInfo[arg1][address(arg2)].field_256 > poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0 / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0 / 10^12) - userInfo[arg1][address(arg2)].field_256, 0
        if 0 == decayPeriod:
            if 0 == decayPeriod:
                if 0 >= decayTable.length:
                    revert with 0, 'phase not ready'
                if poolInfo[arg1].field_512 > block.number:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not block.number - poolInfo[arg1].field_512:
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not 0 / totalAllocPoint:
                        if ext_call.return_data[0] <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require ext_call.return_data[0]
                        if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, 0
                        if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               0
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if ext_call.return_data[0] <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require ext_call.return_data[0]
                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 0
                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           0
                if (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) / block.number - poolInfo[arg1].field_512 != decayTable:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) < 0:
                    revert with 0, 'SafeMath: addition overflow'
                if not (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable):
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not 0 / totalAllocPoint:
                        if ext_call.return_data[0] <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require ext_call.return_data[0]
                        if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, 0
                        if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               0
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if ext_call.return_data[0] <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require ext_call.return_data[0]
                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 0
                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           0
                if (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) != poolInfo[arg1].field_256:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if totalAllocPoint <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require totalAllocPoint
                if not (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint:
                    if ext_call.return_data[0] <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require ext_call.return_data[0]
                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 0
                    if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           0
                if 10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if ext_call.return_data[0] <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require ext_call.return_data[0]
                if (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, 0
                if (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       0
            if block.number <= startBlock:
                if 0 >= decayTable.length:
                    revert with 0, 'phase not ready'
                if poolInfo[arg1].field_512 > block.number:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not block.number - poolInfo[arg1].field_512:
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not 0 / totalAllocPoint:
                        if ext_call.return_data[0] <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require ext_call.return_data[0]
                        if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, 0
                        if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               0
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if ext_call.return_data[0] <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require ext_call.return_data[0]
                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 0
                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           0
                if (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) / block.number - poolInfo[arg1].field_512 != decayTable:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) < 0:
                    revert with 0, 'SafeMath: addition overflow'
                if not (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable):
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not 0 / totalAllocPoint:
                        if ext_call.return_data[0] <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require ext_call.return_data[0]
                        if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, 0
                        if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               0
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if ext_call.return_data[0] <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require ext_call.return_data[0]
                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 0
                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           0
                if (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) != poolInfo[arg1].field_256:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if totalAllocPoint <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require totalAllocPoint
                if not (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint:
                    if ext_call.return_data[0] <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require ext_call.return_data[0]
                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 0
                    if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           0
                if 10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if ext_call.return_data[0] <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require ext_call.return_data[0]
                if (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, 0
                if (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       0
            if startBlock > block.number:
                revert with 0, 'SafeMath: subtraction overflow'
            if 1 > block.number - startBlock:
                revert with 0, 'SafeMath: subtraction overflow'
            if decayPeriod <= 0:
                revert with 0, 'SafeMath: division by zero'
            require decayPeriod
            if block.number + -startBlock - 1 / decayPeriod >= decayTable.length:
                revert with 0, 'phase not ready'
            if poolInfo[arg1].field_512 > block.number:
                revert with 0, 'SafeMath: subtraction overflow'
            if not block.number - poolInfo[arg1].field_512:
                if totalAllocPoint <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require totalAllocPoint
                if not 0 / totalAllocPoint:
                    if ext_call.return_data[0] <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require ext_call.return_data[0]
                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 0
                    if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           0
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if ext_call.return_data[0] <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require ext_call.return_data[0]
                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, 0
                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       0
            if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) / block.number - poolInfo[arg1].field_512 != decayTable[block.number + -stor12 - 1 / stor15]:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) < 0:
                revert with 0, 'SafeMath: addition overflow'
            if not (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15]):
                if totalAllocPoint <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require totalAllocPoint
                if not 0 / totalAllocPoint:
                    if ext_call.return_data[0] <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require ext_call.return_data[0]
                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 0
                    if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           0
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if ext_call.return_data[0] <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require ext_call.return_data[0]
                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, 0
                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       0
            if (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) != poolInfo[arg1].field_256:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if totalAllocPoint <= 0:
                revert with 0, 'SafeMath: division by zero'
            require totalAllocPoint
            if not (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint:
                if ext_call.return_data[0] <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require ext_call.return_data[0]
                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, 0
                if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       0
            if 10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if ext_call.return_data[0] <= 0:
                revert with 0, 'SafeMath: division by zero'
            require ext_call.return_data[0]
            if (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256, 0
            if (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return ((10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                   0
        if poolInfo[arg1].field_512 <= startBlock:
            if 0 == decayPeriod:
                if 0 == decayPeriod:
                    if 0 >= decayTable.length:
                        revert with 0, 'phase not ready'
                    if poolInfo[arg1].field_512 > block.number:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not block.number - poolInfo[arg1].field_512:
                        if totalAllocPoint <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require totalAllocPoint
                        if not 0 / totalAllocPoint:
                            if ext_call.return_data[0] <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require ext_call.return_data[0]
                            if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            if not userInfo[arg1][address(arg2)].field_0:
                                if userInfo[arg1][address(arg2)].field_256 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return -userInfo[arg1][address(arg2)].field_256, 0
                            if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return ((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                                   0
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if ext_call.return_data[0] <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require ext_call.return_data[0]
                        if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, 0
                        if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               0
                    if (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) / block.number - poolInfo[arg1].field_512 != decayTable:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    if not (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable):
                        if totalAllocPoint <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require totalAllocPoint
                        if not 0 / totalAllocPoint:
                            if ext_call.return_data[0] <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require ext_call.return_data[0]
                            if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            if not userInfo[arg1][address(arg2)].field_0:
                                if userInfo[arg1][address(arg2)].field_256 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return -userInfo[arg1][address(arg2)].field_256, 0
                            if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return ((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                                   0
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if ext_call.return_data[0] <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require ext_call.return_data[0]
                        if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, 0
                        if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               0
                    if (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) != poolInfo[arg1].field_256:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint:
                        if ext_call.return_data[0] <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require ext_call.return_data[0]
                        if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, 0
                        if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               0
                    if 10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if ext_call.return_data[0] <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require ext_call.return_data[0]
                    if (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 0
                    if (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           0
                if block.number <= startBlock:
                    if 0 >= decayTable.length:
                        revert with 0, 'phase not ready'
                    if poolInfo[arg1].field_512 > block.number:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not block.number - poolInfo[arg1].field_512:
                        if totalAllocPoint <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require totalAllocPoint
                        if not 0 / totalAllocPoint:
                            if ext_call.return_data[0] <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require ext_call.return_data[0]
                            if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            if not userInfo[arg1][address(arg2)].field_0:
                                if userInfo[arg1][address(arg2)].field_256 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return -userInfo[arg1][address(arg2)].field_256, 0
                            if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return ((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                                   0
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if ext_call.return_data[0] <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require ext_call.return_data[0]
                        if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, 0
                        if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               0
                    if (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) / block.number - poolInfo[arg1].field_512 != decayTable:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    if not (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable):
                        if totalAllocPoint <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require totalAllocPoint
                        if not 0 / totalAllocPoint:
                            if ext_call.return_data[0] <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require ext_call.return_data[0]
                            if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            if not userInfo[arg1][address(arg2)].field_0:
                                if userInfo[arg1][address(arg2)].field_256 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return -userInfo[arg1][address(arg2)].field_256, 0
                            if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return ((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                                   0
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if ext_call.return_data[0] <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require ext_call.return_data[0]
                        if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, 0
                        if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               0
                    if (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) != poolInfo[arg1].field_256:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint:
                        if ext_call.return_data[0] <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require ext_call.return_data[0]
                        if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, 0
                        if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               0
                    if 10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if ext_call.return_data[0] <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require ext_call.return_data[0]
                    if (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 0
                    if (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           0
                if startBlock > block.number:
                    revert with 0, 'SafeMath: subtraction overflow'
                if 1 > block.number - startBlock:
                    revert with 0, 'SafeMath: subtraction overflow'
                if decayPeriod <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require decayPeriod
                if block.number + -startBlock - 1 / decayPeriod >= decayTable.length:
                    revert with 0, 'phase not ready'
                if poolInfo[arg1].field_512 > block.number:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not block.number - poolInfo[arg1].field_512:
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not 0 / totalAllocPoint:
                        if ext_call.return_data[0] <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require ext_call.return_data[0]
                        if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, 0
                        if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               0
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if ext_call.return_data[0] <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require ext_call.return_data[0]
                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 0
                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           0
                if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) / block.number - poolInfo[arg1].field_512 != decayTable[block.number + -stor12 - 1 / stor15]:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) < 0:
                    revert with 0, 'SafeMath: addition overflow'
                if not (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15]):
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not 0 / totalAllocPoint:
                        if ext_call.return_data[0] <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require ext_call.return_data[0]
                        if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, 0
                        if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               0
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if ext_call.return_data[0] <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require ext_call.return_data[0]
                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 0
                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           0
                if (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) != poolInfo[arg1].field_256:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if totalAllocPoint <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require totalAllocPoint
                if not (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint:
                    if ext_call.return_data[0] <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require ext_call.return_data[0]
                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 0
                    if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           0
                if 10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if ext_call.return_data[0] <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require ext_call.return_data[0]
                if (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, 0
                if (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       0
            if block.number <= startBlock:
                if 0 == decayPeriod:
                    if 0 >= decayTable.length:
                        revert with 0, 'phase not ready'
                    if poolInfo[arg1].field_512 > block.number:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not block.number - poolInfo[arg1].field_512:
                        if totalAllocPoint <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require totalAllocPoint
                        if not 0 / totalAllocPoint:
                            if ext_call.return_data[0] <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require ext_call.return_data[0]
                            if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            if not userInfo[arg1][address(arg2)].field_0:
                                if userInfo[arg1][address(arg2)].field_256 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return -userInfo[arg1][address(arg2)].field_256, 0
                            if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return ((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                                   0
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if ext_call.return_data[0] <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require ext_call.return_data[0]
                        if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, 0
                        if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               0
                    if (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) / block.number - poolInfo[arg1].field_512 != decayTable:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    if not (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable):
                        if totalAllocPoint <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require totalAllocPoint
                        if not 0 / totalAllocPoint:
                            if ext_call.return_data[0] <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require ext_call.return_data[0]
                            if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            if not userInfo[arg1][address(arg2)].field_0:
                                if userInfo[arg1][address(arg2)].field_256 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return -userInfo[arg1][address(arg2)].field_256, 0
                            if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return ((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                                   0
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if ext_call.return_data[0] <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require ext_call.return_data[0]
                        if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, 0
                        if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               0
                    if (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) != poolInfo[arg1].field_256:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint:
                        if ext_call.return_data[0] <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require ext_call.return_data[0]
                        if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, 0
                        if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               0
                    if 10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if ext_call.return_data[0] <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require ext_call.return_data[0]
                    if (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 0
                    if (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           0
                if block.number <= startBlock:
                    if 0 >= decayTable.length:
                        revert with 0, 'phase not ready'
                    if poolInfo[arg1].field_512 > block.number:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not block.number - poolInfo[arg1].field_512:
                        if totalAllocPoint <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require totalAllocPoint
                        if not 0 / totalAllocPoint:
                            if ext_call.return_data[0] <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require ext_call.return_data[0]
                            if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            if not userInfo[arg1][address(arg2)].field_0:
                                if userInfo[arg1][address(arg2)].field_256 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return -userInfo[arg1][address(arg2)].field_256, 0
                            if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return ((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                                   0
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if ext_call.return_data[0] <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require ext_call.return_data[0]
                        if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, 0
                        if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               0
                    if (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) / block.number - poolInfo[arg1].field_512 != decayTable:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    if not (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable):
                        if totalAllocPoint <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require totalAllocPoint
                        if not 0 / totalAllocPoint:
                            if ext_call.return_data[0] <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require ext_call.return_data[0]
                            if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            if not userInfo[arg1][address(arg2)].field_0:
                                if userInfo[arg1][address(arg2)].field_256 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return -userInfo[arg1][address(arg2)].field_256, 0
                            if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return ((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                                   0
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if ext_call.return_data[0] <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require ext_call.return_data[0]
                        if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, 0
                        if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               0
                    if (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) != poolInfo[arg1].field_256:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint:
                        if ext_call.return_data[0] <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require ext_call.return_data[0]
                        if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, 0
                        if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               0
                    if 10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if ext_call.return_data[0] <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require ext_call.return_data[0]
                    if (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 0
                    if (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           0
                if startBlock > block.number:
                    revert with 0, 'SafeMath: subtraction overflow'
                if 1 > block.number - startBlock:
                    revert with 0, 'SafeMath: subtraction overflow'
                if decayPeriod <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require decayPeriod
                if block.number + -startBlock - 1 / decayPeriod >= decayTable.length:
                    revert with 0, 'phase not ready'
                if poolInfo[arg1].field_512 > block.number:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not block.number - poolInfo[arg1].field_512:
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not 0 / totalAllocPoint:
                        if ext_call.return_data[0] <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require ext_call.return_data[0]
                        if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, 0
                        if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               0
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if ext_call.return_data[0] <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require ext_call.return_data[0]
                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 0
                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           0
                if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) / block.number - poolInfo[arg1].field_512 != decayTable[block.number + -stor12 - 1 / stor15]:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) < 0:
                    revert with 0, 'SafeMath: addition overflow'
                if not (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15]):
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not 0 / totalAllocPoint:
                        if ext_call.return_data[0] <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require ext_call.return_data[0]
                        if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, 0
                        if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               0
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if ext_call.return_data[0] <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require ext_call.return_data[0]
                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 0
                    if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           0
                if (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) != poolInfo[arg1].field_256:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if totalAllocPoint <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require totalAllocPoint
                if not (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint:
                    if ext_call.return_data[0] <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require ext_call.return_data[0]
                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 0
                    if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           0
                if 10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if ext_call.return_data[0] <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require ext_call.return_data[0]
                if (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, 0
                if (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       0
            if startBlock > block.number:
                revert with 0, 'SafeMath: subtraction overflow'
            if 1 > block.number - startBlock:
                revert with 0, 'SafeMath: subtraction overflow'
            if decayPeriod <= 0:
                revert with 0, 'SafeMath: division by zero'
            require decayPeriod
            idx = 0
            s = poolInfo[arg1].field_512
            while idx < block.number + -startBlock - 1 / decayPeriod:
                if not idx + 1:
                    if startBlock < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    if decayPeriod != 0:
                        if startBlock > startBlock:
                            revert with 0, 'SafeMath: subtraction overflow'
                    if 0 >= decayTable.length:
                        revert with 0, 'phase not ready'
                    mem[0] = 17
                    if s > startBlock:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if startBlock - s:
                        if (startBlock * decayTable) - (s * decayTable) / startBlock - s != decayTable:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if (startBlock * decayTable) - (s * decayTable) < 0:
                            revert with 0, 'SafeMath: addition overflow'
                    idx = idx + 1
                    s = startBlock
                    continue 
                if decayPeriod + (idx * decayPeriod) / idx + 1 != decayPeriod:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if startBlock < 0:
                    revert with 0, 'SafeMath: addition overflow'
                if 0 == decayPeriod:
                    if 0 >= decayTable.length:
                        revert with 0, 'phase not ready'
                    mem[0] = 17
                    if s > startBlock + decayPeriod + (idx * decayPeriod):
                        revert with 0, 'SafeMath: subtraction overflow'
                    if startBlock + decayPeriod + (idx * decayPeriod) - s:
                        if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) / startBlock + decayPeriod + (idx * decayPeriod) - s != decayTable:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) < 0:
                            revert with 0, 'SafeMath: addition overflow'
                else:
                    if startBlock + decayPeriod + (idx * decayPeriod) <= startBlock:
                        if 0 >= decayTable.length:
                            revert with 0, 'phase not ready'
                        mem[0] = 17
                        if s > startBlock + decayPeriod + (idx * decayPeriod):
                            revert with 0, 'SafeMath: subtraction overflow'
                        if startBlock + decayPeriod + (idx * decayPeriod) - s:
                            if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) / startBlock + decayPeriod + (idx * decayPeriod) - s != decayTable:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) < 0:
                                revert with 0, 'SafeMath: addition overflow'
                    else:
                        if startBlock > startBlock + decayPeriod + (idx * decayPeriod):
                            revert with 0, 'SafeMath: subtraction overflow'
                        if 1 > decayPeriod + (idx * decayPeriod):
                            revert with 0, 'SafeMath: subtraction overflow'
                        if decayPeriod <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require decayPeriod
                        if decayPeriod + (idx * decayPeriod) - 1 / decayPeriod >= decayTable.length:
                            revert with 0, 'phase not ready'
                        mem[0] = 17
                        if s > startBlock + decayPeriod + (idx * decayPeriod):
                            revert with 0, 'SafeMath: subtraction overflow'
                        if startBlock + decayPeriod + (idx * decayPeriod) - s:
                            if (startBlock * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (idx * decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) - (s * decayTable[stor15 + (idx * stor15) - 1 / stor15]) / startBlock + decayPeriod + (idx * decayPeriod) - s != decayTable[stor15 + (idx * stor15) - 1 / stor15]:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if (startBlock * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (idx * decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) - (s * decayTable[stor15 + (idx * stor15) - 1 / stor15]) < 0:
                                revert with 0, 'SafeMath: addition overflow'
                idx = idx + 1
                s = startBlock + decayPeriod + (idx * decayPeriod)
                continue 
        else:
            if startBlock > poolInfo[arg1].field_512:
                revert with 0, 'SafeMath: subtraction overflow'
            if 1 > poolInfo[arg1].field_512 - startBlock:
                revert with 0, 'SafeMath: subtraction overflow'
            if decayPeriod <= 0:
                revert with 0, 'SafeMath: division by zero'
            require decayPeriod
            if 0 == decayPeriod:
                idx = poolInfo[arg1].field_512 + -startBlock - 1 / decayPeriod
                s = poolInfo[arg1].field_512
                while idx < 0:
                    if not idx + 1:
                        if startBlock < 0:
                            revert with 0, 'SafeMath: addition overflow'
                        if decayPeriod != 0:
                            if startBlock > startBlock:
                                revert with 0, 'SafeMath: subtraction overflow'
                        if 0 >= decayTable.length:
                            revert with 0, 'phase not ready'
                        mem[0] = 17
                        if s > startBlock:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if startBlock - s:
                            if (startBlock * decayTable) - (s * decayTable) / startBlock - s != decayTable:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if (startBlock * decayTable) - (s * decayTable) < 0:
                                revert with 0, 'SafeMath: addition overflow'
                        idx = idx + 1
                        s = startBlock
                        continue 
                    if decayPeriod + (idx * decayPeriod) / idx + 1 != decayPeriod:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if startBlock < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    if 0 == decayPeriod:
                        if 0 >= decayTable.length:
                            revert with 0, 'phase not ready'
                        mem[0] = 17
                        if s > startBlock + decayPeriod + (idx * decayPeriod):
                            revert with 0, 'SafeMath: subtraction overflow'
                        if startBlock + decayPeriod + (idx * decayPeriod) - s:
                            if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) / startBlock + decayPeriod + (idx * decayPeriod) - s != decayTable:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) < 0:
                                revert with 0, 'SafeMath: addition overflow'
                    else:
                        if startBlock + decayPeriod + (idx * decayPeriod) <= startBlock:
                            if 0 >= decayTable.length:
                                revert with 0, 'phase not ready'
                            mem[0] = 17
                            if s > startBlock + decayPeriod + (idx * decayPeriod):
                                revert with 0, 'SafeMath: subtraction overflow'
                            if startBlock + decayPeriod + (idx * decayPeriod) - s:
                                if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) / startBlock + decayPeriod + (idx * decayPeriod) - s != decayTable:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                        else:
                            if startBlock > startBlock + decayPeriod + (idx * decayPeriod):
                                revert with 0, 'SafeMath: subtraction overflow'
                            if 1 > decayPeriod + (idx * decayPeriod):
                                revert with 0, 'SafeMath: subtraction overflow'
                            if decayPeriod <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require decayPeriod
                            if decayPeriod + (idx * decayPeriod) - 1 / decayPeriod >= decayTable.length:
                                revert with 0, 'phase not ready'
                            mem[0] = 17
                            if s > startBlock + decayPeriod + (idx * decayPeriod):
                                revert with 0, 'SafeMath: subtraction overflow'
                            if startBlock + decayPeriod + (idx * decayPeriod) - s:
                                if (startBlock * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (idx * decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) - (s * decayTable[stor15 + (idx * stor15) - 1 / stor15]) / startBlock + decayPeriod + (idx * decayPeriod) - s != decayTable[stor15 + (idx * stor15) - 1 / stor15]:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                if (startBlock * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (idx * decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) - (s * decayTable[stor15 + (idx * stor15) - 1 / stor15]) < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                    idx = idx + 1
                    s = startBlock + decayPeriod + (idx * decayPeriod)
                    continue 
            else:
                if block.number <= startBlock:
                    idx = poolInfo[arg1].field_512 + -startBlock - 1 / decayPeriod
                    s = poolInfo[arg1].field_512
                    while idx < 0:
                        if not idx + 1:
                            if startBlock < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if decayPeriod != 0:
                                if startBlock > startBlock:
                                    revert with 0, 'SafeMath: subtraction overflow'
                            if 0 >= decayTable.length:
                                revert with 0, 'phase not ready'
                            mem[0] = 17
                            if s > startBlock:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if startBlock - s:
                                if (startBlock * decayTable) - (s * decayTable) / startBlock - s != decayTable:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                if (startBlock * decayTable) - (s * decayTable) < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                            idx = idx + 1
                            s = startBlock
                            continue 
                        if decayPeriod + (idx * decayPeriod) / idx + 1 != decayPeriod:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if startBlock < 0:
                            revert with 0, 'SafeMath: addition overflow'
                        if 0 == decayPeriod:
                            if 0 >= decayTable.length:
                                revert with 0, 'phase not ready'
                            mem[0] = 17
                            if s > startBlock + decayPeriod + (idx * decayPeriod):
                                revert with 0, 'SafeMath: subtraction overflow'
                            if startBlock + decayPeriod + (idx * decayPeriod) - s:
                                if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) / startBlock + decayPeriod + (idx * decayPeriod) - s != decayTable:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                        else:
                            if startBlock + decayPeriod + (idx * decayPeriod) <= startBlock:
                                if 0 >= decayTable.length:
                                    revert with 0, 'phase not ready'
                                mem[0] = 17
                                if s > startBlock + decayPeriod + (idx * decayPeriod):
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if startBlock + decayPeriod + (idx * decayPeriod) - s:
                                    if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) / startBlock + decayPeriod + (idx * decayPeriod) - s != decayTable:
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                    32,
                                                    33,
                                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[197 len 31]
                                    if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                            else:
                                if startBlock > startBlock + decayPeriod + (idx * decayPeriod):
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if 1 > decayPeriod + (idx * decayPeriod):
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if decayPeriod <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require decayPeriod
                                if decayPeriod + (idx * decayPeriod) - 1 / decayPeriod >= decayTable.length:
                                    revert with 0, 'phase not ready'
                                mem[0] = 17
                                if s > startBlock + decayPeriod + (idx * decayPeriod):
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if startBlock + decayPeriod + (idx * decayPeriod) - s:
                                    if (startBlock * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (idx * decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) - (s * decayTable[stor15 + (idx * stor15) - 1 / stor15]) / startBlock + decayPeriod + (idx * decayPeriod) - s != decayTable[stor15 + (idx * stor15) - 1 / stor15]:
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                    32,
                                                    33,
                                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[197 len 31]
                                    if (startBlock * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (idx * decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) - (s * decayTable[stor15 + (idx * stor15) - 1 / stor15]) < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                        idx = idx + 1
                        s = startBlock + decayPeriod + (idx * decayPeriod)
                        continue 
                else:
                    if startBlock > block.number:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if 1 > block.number - startBlock:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if decayPeriod <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require decayPeriod
                    idx = poolInfo[arg1].field_512 + -startBlock - 1 / decayPeriod
                    s = poolInfo[arg1].field_512
                    while idx < block.number + -startBlock - 1 / decayPeriod:
                        if not idx + 1:
                            if startBlock < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if decayPeriod != 0:
                                if startBlock > startBlock:
                                    revert with 0, 'SafeMath: subtraction overflow'
                            if 0 >= decayTable.length:
                                revert with 0, 'phase not ready'
                            mem[0] = 17
                            if s > startBlock:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if startBlock - s:
                                if (startBlock * decayTable) - (s * decayTable) / startBlock - s != decayTable:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                if (startBlock * decayTable) - (s * decayTable) < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                            idx = idx + 1
                            s = startBlock
                            continue 
                        if decayPeriod + (idx * decayPeriod) / idx + 1 != decayPeriod:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if startBlock < 0:
                            revert with 0, 'SafeMath: addition overflow'
                        if 0 == decayPeriod:
                            if 0 >= decayTable.length:
                                revert with 0, 'phase not ready'
                            mem[0] = 17
                            if s > startBlock + decayPeriod + (idx * decayPeriod):
                                revert with 0, 'SafeMath: subtraction overflow'
                            if startBlock + decayPeriod + (idx * decayPeriod) - s:
                                if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) / startBlock + decayPeriod + (idx * decayPeriod) - s != decayTable:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                        else:
                            if startBlock + decayPeriod + (idx * decayPeriod) <= startBlock:
                                if 0 >= decayTable.length:
                                    revert with 0, 'phase not ready'
                                mem[0] = 17
                                if s > startBlock + decayPeriod + (idx * decayPeriod):
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if startBlock + decayPeriod + (idx * decayPeriod) - s:
                                    if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) / startBlock + decayPeriod + (idx * decayPeriod) - s != decayTable:
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                    32,
                                                    33,
                                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[197 len 31]
                                    if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                            else:
                                if startBlock > startBlock + decayPeriod + (idx * decayPeriod):
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if 1 > decayPeriod + (idx * decayPeriod):
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if decayPeriod <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require decayPeriod
                                if decayPeriod + (idx * decayPeriod) - 1 / decayPeriod >= decayTable.length:
                                    revert with 0, 'phase not ready'
                                mem[0] = 17
                                if s > startBlock + decayPeriod + (idx * decayPeriod):
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if startBlock + decayPeriod + (idx * decayPeriod) - s:
                                    if (startBlock * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (idx * decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) - (s * decayTable[stor15 + (idx * stor15) - 1 / stor15]) / startBlock + decayPeriod + (idx * decayPeriod) - s != decayTable[stor15 + (idx * stor15) - 1 / stor15]:
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                    32,
                                                    33,
                                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[197 len 31]
                                    if (startBlock * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (idx * decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) - (s * decayTable[stor15 + (idx * stor15) - 1 / stor15]) < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                        idx = idx + 1
                        s = startBlock + decayPeriod + (idx * decayPeriod)
                        continue 
        if 0 == decayPeriod:
            if 0 >= decayTable.length:
                revert with 0, 'phase not ready'
            if s > block.number:
                revert with 0, 'SafeMath: subtraction overflow'
            if not block.number - s:
                if totalAllocPoint <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require totalAllocPoint
                if not 0 / totalAllocPoint:
                    if ext_call.return_data[0] <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require ext_call.return_data[0]
                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 0
                    if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           0
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if ext_call.return_data[0] <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require ext_call.return_data[0]
                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, 0
                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       0
            if (block.number * decayTable) - (s * decayTable) / block.number - s != decayTable:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if (block.number * decayTable) - (s * decayTable) < 0:
                revert with 0, 'SafeMath: addition overflow'
            if not (block.number * decayTable) - (s * decayTable):
                if totalAllocPoint <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require totalAllocPoint
                if not 0 / totalAllocPoint:
                    if ext_call.return_data[0] <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require ext_call.return_data[0]
                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 0
                    if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           0
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if ext_call.return_data[0] <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require ext_call.return_data[0]
                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, 0
                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       0
            if (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / (block.number * decayTable) - (s * decayTable) != poolInfo[arg1].field_256:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if totalAllocPoint <= 0:
                revert with 0, 'SafeMath: division by zero'
            require totalAllocPoint
            if not (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint:
                if ext_call.return_data[0] <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require ext_call.return_data[0]
                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, 0
                if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       0
            if 10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if ext_call.return_data[0] <= 0:
                revert with 0, 'SafeMath: division by zero'
            require ext_call.return_data[0]
            if (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256, 0
            if (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return ((10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                   0
        if block.number <= startBlock:
            if 0 >= decayTable.length:
                revert with 0, 'phase not ready'
            if s > block.number:
                revert with 0, 'SafeMath: subtraction overflow'
            if not block.number - s:
                if totalAllocPoint <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require totalAllocPoint
                if not 0 / totalAllocPoint:
                    if ext_call.return_data[0] <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require ext_call.return_data[0]
                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 0
                    if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           0
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if ext_call.return_data[0] <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require ext_call.return_data[0]
                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, 0
                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       0
            if (block.number * decayTable) - (s * decayTable) / block.number - s != decayTable:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if (block.number * decayTable) - (s * decayTable) < 0:
                revert with 0, 'SafeMath: addition overflow'
            if not (block.number * decayTable) - (s * decayTable):
                if totalAllocPoint <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require totalAllocPoint
                if not 0 / totalAllocPoint:
                    if ext_call.return_data[0] <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require ext_call.return_data[0]
                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 0
                    if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           0
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if ext_call.return_data[0] <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require ext_call.return_data[0]
                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, 0
                if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       0
            if (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / (block.number * decayTable) - (s * decayTable) != poolInfo[arg1].field_256:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if totalAllocPoint <= 0:
                revert with 0, 'SafeMath: division by zero'
            require totalAllocPoint
            if not (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint:
                if ext_call.return_data[0] <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require ext_call.return_data[0]
                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, 0
                if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       0
            if 10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if ext_call.return_data[0] <= 0:
                revert with 0, 'SafeMath: division by zero'
            require ext_call.return_data[0]
            if (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256, 0
            if (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return ((10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                   0
        if startBlock > block.number:
            revert with 0, 'SafeMath: subtraction overflow'
        if 1 > block.number - startBlock:
            revert with 0, 'SafeMath: subtraction overflow'
        if decayPeriod <= 0:
            revert with 0, 'SafeMath: division by zero'
        require decayPeriod
        if block.number + -startBlock - 1 / decayPeriod >= decayTable.length:
            revert with 0, 'phase not ready'
        if s > block.number:
            revert with 0, 'SafeMath: subtraction overflow'
        if not block.number - s:
            if totalAllocPoint <= 0:
                revert with 0, 'SafeMath: division by zero'
            require totalAllocPoint
            if not 0 / totalAllocPoint:
                if ext_call.return_data[0] <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require ext_call.return_data[0]
                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, 0
                if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       0
            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if ext_call.return_data[0] <= 0:
                revert with 0, 'SafeMath: division by zero'
            require ext_call.return_data[0]
            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256, 0
            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return ((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                   0
        if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (s * decayTable[block.number + -stor12 - 1 / stor15]) / block.number - s != decayTable[block.number + -stor12 - 1 / stor15]:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        33,
                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[197 len 31]
        if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (s * decayTable[block.number + -stor12 - 1 / stor15]) < 0:
            revert with 0, 'SafeMath: addition overflow'
        if not (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (s * decayTable[block.number + -stor12 - 1 / stor15]):
            if totalAllocPoint <= 0:
                revert with 0, 'SafeMath: division by zero'
            require totalAllocPoint
            if not 0 / totalAllocPoint:
                if ext_call.return_data[0] <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require ext_call.return_data[0]
                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, 0
                if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       0
            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if ext_call.return_data[0] <= 0:
                revert with 0, 'SafeMath: division by zero'
            require ext_call.return_data[0]
            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256, 0
            if (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return ((10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                   0
        if (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (s * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (s * decayTable[block.number + -stor12 - 1 / stor15]) != poolInfo[arg1].field_256:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        33,
                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[197 len 31]
        if totalAllocPoint <= 0:
            revert with 0, 'SafeMath: division by zero'
        require totalAllocPoint
        if not (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (s * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint:
            if ext_call.return_data[0] <= 0:
                revert with 0, 'SafeMath: division by zero'
            require ext_call.return_data[0]
            if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256, 0
            if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return ((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                   0
        if 10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (s * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (s * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        33,
                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[197 len 31]
        if ext_call.return_data[0] <= 0:
            revert with 0, 'SafeMath: division by zero'
        require ext_call.return_data[0]
        if (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (s * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
            revert with 0, 'SafeMath: addition overflow'
        if not userInfo[arg1][address(arg2)].field_0:
            if userInfo[arg1][address(arg2)].field_256 > 0:
                revert with 0, 'SafeMath: subtraction overflow'
            return -userInfo[arg1][address(arg2)].field_256, 0
        if (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (s * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (s * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) + poolInfo[arg1].field_768:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        33,
                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[197 len 31]
        if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (s * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
            revert with 0, 'SafeMath: subtraction overflow'
        return ((10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (s * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
               0
    if not userInfo[arg1][address(arg2)].field_0:
        return 0
    require ext_code.size(multLpChefAddress)
    staticcall multLpChefAddress.0xe4c75c27 with:
            gas gas_remaining wei
           args poolCorrespond[arg1], this.address
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if not ext_call.return_data[0]:
        if poolInfo[arg1].field_1280 <= 0:
            revert with 0, 'SafeMath: division by zero'
        require poolInfo[arg1].field_1280
        if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_1024 < poolInfo[arg1].field_1024:
            revert with 0, 'SafeMath: addition overflow'
        if not userInfo[arg1][address(arg2)].field_0:
            if userInfo[arg1][address(arg2)].field_512 > 0:
                revert with 0, 'SafeMath: subtraction overflow'
            if block.number <= poolInfo[arg1].field_512:
                if poolInfo[arg1].field_512 != block.number:
                    return 0
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                if poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0 / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0 / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0 / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       -userInfo[arg1][address(arg2)].field_512
            if 0 == decayPeriod:
                if 0 == decayPeriod:
                    if 0 >= decayTable.length:
                        revert with 0, 'phase not ready'
                    if poolInfo[arg1].field_512 > block.number:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not block.number - poolInfo[arg1].field_512:
                        if totalAllocPoint <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require totalAllocPoint
                        if not 0 / totalAllocPoint:
                            if poolInfo[arg1].field_1280 <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require poolInfo[arg1].field_1280
                            if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            if not userInfo[arg1][address(arg2)].field_0:
                                if userInfo[arg1][address(arg2)].field_256 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                            if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                                   -userInfo[arg1][address(arg2)].field_512
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                        if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               -userInfo[arg1][address(arg2)].field_512
                    if (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) / block.number - poolInfo[arg1].field_512 != decayTable:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    if not (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable):
                        if totalAllocPoint <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require totalAllocPoint
                        if not 0 / totalAllocPoint:
                            if poolInfo[arg1].field_1280 <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require poolInfo[arg1].field_1280
                            if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            if not userInfo[arg1][address(arg2)].field_0:
                                if userInfo[arg1][address(arg2)].field_256 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                            if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                                   -userInfo[arg1][address(arg2)].field_512
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                        if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               -userInfo[arg1][address(arg2)].field_512
                    if (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) != poolInfo[arg1].field_256:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint:
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                        if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               -userInfo[arg1][address(arg2)].field_512
                    if 10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                    if (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           -userInfo[arg1][address(arg2)].field_512
                if block.number <= startBlock:
                    if 0 >= decayTable.length:
                        revert with 0, 'phase not ready'
                    if poolInfo[arg1].field_512 > block.number:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not block.number - poolInfo[arg1].field_512:
                        if totalAllocPoint <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require totalAllocPoint
                        if not 0 / totalAllocPoint:
                            if poolInfo[arg1].field_1280 <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require poolInfo[arg1].field_1280
                            if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            if not userInfo[arg1][address(arg2)].field_0:
                                if userInfo[arg1][address(arg2)].field_256 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                            if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                                   -userInfo[arg1][address(arg2)].field_512
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                        if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               -userInfo[arg1][address(arg2)].field_512
                    if (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) / block.number - poolInfo[arg1].field_512 != decayTable:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    if not (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable):
                        if totalAllocPoint <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require totalAllocPoint
                        if not 0 / totalAllocPoint:
                            if poolInfo[arg1].field_1280 <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require poolInfo[arg1].field_1280
                            if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            if not userInfo[arg1][address(arg2)].field_0:
                                if userInfo[arg1][address(arg2)].field_256 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                            if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                                   -userInfo[arg1][address(arg2)].field_512
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                        if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               -userInfo[arg1][address(arg2)].field_512
                    if (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) != poolInfo[arg1].field_256:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint:
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                        if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               -userInfo[arg1][address(arg2)].field_512
                    if 10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                    if (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           -userInfo[arg1][address(arg2)].field_512
                if startBlock > block.number:
                    revert with 0, 'SafeMath: subtraction overflow'
                if 1 > block.number - startBlock:
                    revert with 0, 'SafeMath: subtraction overflow'
                if decayPeriod <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require decayPeriod
                if block.number + -startBlock - 1 / decayPeriod >= decayTable.length:
                    revert with 0, 'phase not ready'
                if poolInfo[arg1].field_512 > block.number:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not block.number - poolInfo[arg1].field_512:
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not 0 / totalAllocPoint:
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                        if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               -userInfo[arg1][address(arg2)].field_512
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           -userInfo[arg1][address(arg2)].field_512
                if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) / block.number - poolInfo[arg1].field_512 != decayTable[block.number + -stor12 - 1 / stor15]:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) < 0:
                    revert with 0, 'SafeMath: addition overflow'
                if not (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15]):
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not 0 / totalAllocPoint:
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                        if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               -userInfo[arg1][address(arg2)].field_512
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           -userInfo[arg1][address(arg2)].field_512
                if (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) != poolInfo[arg1].field_256:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if totalAllocPoint <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require totalAllocPoint
                if not (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint:
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                    if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           -userInfo[arg1][address(arg2)].field_512
                if 10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if poolInfo[arg1].field_1280 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require poolInfo[arg1].field_1280
                if (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                if (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       -userInfo[arg1][address(arg2)].field_512
            if poolInfo[arg1].field_512 <= startBlock:
                if 0 == decayPeriod:
                    if 0 == decayPeriod:
                        if 0 >= decayTable.length:
                            revert with 0, 'phase not ready'
                        if poolInfo[arg1].field_512 > block.number:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not block.number - poolInfo[arg1].field_512:
                            if totalAllocPoint <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require totalAllocPoint
                            if not 0 / totalAllocPoint:
                                if poolInfo[arg1].field_1280 <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require poolInfo[arg1].field_1280
                                if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not userInfo[arg1][address(arg2)].field_0:
                                    if userInfo[arg1][address(arg2)].field_256 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                                if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                                       -userInfo[arg1][address(arg2)].field_512
                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if poolInfo[arg1].field_1280 <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require poolInfo[arg1].field_1280
                            if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            if not userInfo[arg1][address(arg2)].field_0:
                                if userInfo[arg1][address(arg2)].field_256 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                            if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                                   -userInfo[arg1][address(arg2)].field_512
                        if (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) / block.number - poolInfo[arg1].field_512 != decayTable:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) < 0:
                            revert with 0, 'SafeMath: addition overflow'
                        if not (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable):
                            if totalAllocPoint <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require totalAllocPoint
                            if not 0 / totalAllocPoint:
                                if poolInfo[arg1].field_1280 <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require poolInfo[arg1].field_1280
                                if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not userInfo[arg1][address(arg2)].field_0:
                                    if userInfo[arg1][address(arg2)].field_256 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                                if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                                       -userInfo[arg1][address(arg2)].field_512
                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if poolInfo[arg1].field_1280 <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require poolInfo[arg1].field_1280
                            if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            if not userInfo[arg1][address(arg2)].field_0:
                                if userInfo[arg1][address(arg2)].field_256 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                            if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                                   -userInfo[arg1][address(arg2)].field_512
                        if (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) != poolInfo[arg1].field_256:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if totalAllocPoint <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require totalAllocPoint
                        if not (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint:
                            if poolInfo[arg1].field_1280 <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require poolInfo[arg1].field_1280
                            if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            if not userInfo[arg1][address(arg2)].field_0:
                                if userInfo[arg1][address(arg2)].field_256 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                            if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                                   -userInfo[arg1][address(arg2)].field_512
                        if 10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                        if (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               -userInfo[arg1][address(arg2)].field_512
                    if block.number <= startBlock:
                        if 0 >= decayTable.length:
                            revert with 0, 'phase not ready'
                        if poolInfo[arg1].field_512 > block.number:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not block.number - poolInfo[arg1].field_512:
                            if totalAllocPoint <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require totalAllocPoint
                            if not 0 / totalAllocPoint:
                                if poolInfo[arg1].field_1280 <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require poolInfo[arg1].field_1280
                                if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not userInfo[arg1][address(arg2)].field_0:
                                    if userInfo[arg1][address(arg2)].field_256 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                                if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                                       -userInfo[arg1][address(arg2)].field_512
                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if poolInfo[arg1].field_1280 <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require poolInfo[arg1].field_1280
                            if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            if not userInfo[arg1][address(arg2)].field_0:
                                if userInfo[arg1][address(arg2)].field_256 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                            if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                                   -userInfo[arg1][address(arg2)].field_512
                        if (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) / block.number - poolInfo[arg1].field_512 != decayTable:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) < 0:
                            revert with 0, 'SafeMath: addition overflow'
                        if not (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable):
                            if totalAllocPoint <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require totalAllocPoint
                            if not 0 / totalAllocPoint:
                                if poolInfo[arg1].field_1280 <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require poolInfo[arg1].field_1280
                                if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not userInfo[arg1][address(arg2)].field_0:
                                    if userInfo[arg1][address(arg2)].field_256 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                                if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                                       -userInfo[arg1][address(arg2)].field_512
                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if poolInfo[arg1].field_1280 <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require poolInfo[arg1].field_1280
                            if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            if not userInfo[arg1][address(arg2)].field_0:
                                if userInfo[arg1][address(arg2)].field_256 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                            if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                                   -userInfo[arg1][address(arg2)].field_512
                        if (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) != poolInfo[arg1].field_256:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if totalAllocPoint <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require totalAllocPoint
                        if not (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint:
                            if poolInfo[arg1].field_1280 <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require poolInfo[arg1].field_1280
                            if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            if not userInfo[arg1][address(arg2)].field_0:
                                if userInfo[arg1][address(arg2)].field_256 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                            if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                                   -userInfo[arg1][address(arg2)].field_512
                        if 10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                        if (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               -userInfo[arg1][address(arg2)].field_512
                    if startBlock > block.number:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if 1 > block.number - startBlock:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if decayPeriod <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require decayPeriod
                    if block.number + -startBlock - 1 / decayPeriod >= decayTable.length:
                        revert with 0, 'phase not ready'
                    if poolInfo[arg1].field_512 > block.number:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not block.number - poolInfo[arg1].field_512:
                        if totalAllocPoint <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require totalAllocPoint
                        if not 0 / totalAllocPoint:
                            if poolInfo[arg1].field_1280 <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require poolInfo[arg1].field_1280
                            if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            if not userInfo[arg1][address(arg2)].field_0:
                                if userInfo[arg1][address(arg2)].field_256 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                            if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                                   -userInfo[arg1][address(arg2)].field_512
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                        if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               -userInfo[arg1][address(arg2)].field_512
                    if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) / block.number - poolInfo[arg1].field_512 != decayTable[block.number + -stor12 - 1 / stor15]:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    if not (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15]):
                        if totalAllocPoint <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require totalAllocPoint
                        if not 0 / totalAllocPoint:
                            if poolInfo[arg1].field_1280 <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require poolInfo[arg1].field_1280
                            if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            if not userInfo[arg1][address(arg2)].field_0:
                                if userInfo[arg1][address(arg2)].field_256 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                            if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                                   -userInfo[arg1][address(arg2)].field_512
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                        if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               -userInfo[arg1][address(arg2)].field_512
                    if (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) != poolInfo[arg1].field_256:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint:
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                        if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               -userInfo[arg1][address(arg2)].field_512
                    if 10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                    if (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           -userInfo[arg1][address(arg2)].field_512
                if block.number <= startBlock:
                    if 0 == decayPeriod:
                        if 0 >= decayTable.length:
                            revert with 0, 'phase not ready'
                        if poolInfo[arg1].field_512 > block.number:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not block.number - poolInfo[arg1].field_512:
                            if totalAllocPoint <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require totalAllocPoint
                            if not 0 / totalAllocPoint:
                                if poolInfo[arg1].field_1280 <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require poolInfo[arg1].field_1280
                                if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not userInfo[arg1][address(arg2)].field_0:
                                    if userInfo[arg1][address(arg2)].field_256 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                                if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                                       -userInfo[arg1][address(arg2)].field_512
                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if poolInfo[arg1].field_1280 <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require poolInfo[arg1].field_1280
                            if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            if not userInfo[arg1][address(arg2)].field_0:
                                if userInfo[arg1][address(arg2)].field_256 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                            if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                                   -userInfo[arg1][address(arg2)].field_512
                        if (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) / block.number - poolInfo[arg1].field_512 != decayTable:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) < 0:
                            revert with 0, 'SafeMath: addition overflow'
                        if not (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable):
                            if totalAllocPoint <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require totalAllocPoint
                            if not 0 / totalAllocPoint:
                                if poolInfo[arg1].field_1280 <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require poolInfo[arg1].field_1280
                                if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not userInfo[arg1][address(arg2)].field_0:
                                    if userInfo[arg1][address(arg2)].field_256 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                                if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                                       -userInfo[arg1][address(arg2)].field_512
                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if poolInfo[arg1].field_1280 <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require poolInfo[arg1].field_1280
                            if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            if not userInfo[arg1][address(arg2)].field_0:
                                if userInfo[arg1][address(arg2)].field_256 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                            if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                                   -userInfo[arg1][address(arg2)].field_512
                        if (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) != poolInfo[arg1].field_256:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if totalAllocPoint <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require totalAllocPoint
                        if not (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint:
                            if poolInfo[arg1].field_1280 <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require poolInfo[arg1].field_1280
                            if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            if not userInfo[arg1][address(arg2)].field_0:
                                if userInfo[arg1][address(arg2)].field_256 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                            if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                                   -userInfo[arg1][address(arg2)].field_512
                        if 10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                        if (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               -userInfo[arg1][address(arg2)].field_512
                    if block.number <= startBlock:
                        if 0 >= decayTable.length:
                            revert with 0, 'phase not ready'
                        if poolInfo[arg1].field_512 > block.number:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not block.number - poolInfo[arg1].field_512:
                            if totalAllocPoint <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require totalAllocPoint
                            if not 0 / totalAllocPoint:
                                if poolInfo[arg1].field_1280 <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require poolInfo[arg1].field_1280
                                if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not userInfo[arg1][address(arg2)].field_0:
                                    if userInfo[arg1][address(arg2)].field_256 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                                if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                                       -userInfo[arg1][address(arg2)].field_512
                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if poolInfo[arg1].field_1280 <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require poolInfo[arg1].field_1280
                            if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            if not userInfo[arg1][address(arg2)].field_0:
                                if userInfo[arg1][address(arg2)].field_256 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                            if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                                   -userInfo[arg1][address(arg2)].field_512
                        if (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) / block.number - poolInfo[arg1].field_512 != decayTable:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) < 0:
                            revert with 0, 'SafeMath: addition overflow'
                        if not (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable):
                            if totalAllocPoint <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require totalAllocPoint
                            if not 0 / totalAllocPoint:
                                if poolInfo[arg1].field_1280 <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require poolInfo[arg1].field_1280
                                if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not userInfo[arg1][address(arg2)].field_0:
                                    if userInfo[arg1][address(arg2)].field_256 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                                if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                                       -userInfo[arg1][address(arg2)].field_512
                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if poolInfo[arg1].field_1280 <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require poolInfo[arg1].field_1280
                            if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            if not userInfo[arg1][address(arg2)].field_0:
                                if userInfo[arg1][address(arg2)].field_256 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                            if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                                   -userInfo[arg1][address(arg2)].field_512
                        if (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) != poolInfo[arg1].field_256:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if totalAllocPoint <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require totalAllocPoint
                        if not (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint:
                            if poolInfo[arg1].field_1280 <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require poolInfo[arg1].field_1280
                            if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            if not userInfo[arg1][address(arg2)].field_0:
                                if userInfo[arg1][address(arg2)].field_256 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                            if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                                   -userInfo[arg1][address(arg2)].field_512
                        if 10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                        if (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               -userInfo[arg1][address(arg2)].field_512
                    if startBlock > block.number:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if 1 > block.number - startBlock:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if decayPeriod <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require decayPeriod
                    if block.number + -startBlock - 1 / decayPeriod >= decayTable.length:
                        revert with 0, 'phase not ready'
                    if poolInfo[arg1].field_512 > block.number:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not block.number - poolInfo[arg1].field_512:
                        if totalAllocPoint <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require totalAllocPoint
                        if not 0 / totalAllocPoint:
                            if poolInfo[arg1].field_1280 <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require poolInfo[arg1].field_1280
                            if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            if not userInfo[arg1][address(arg2)].field_0:
                                if userInfo[arg1][address(arg2)].field_256 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                            if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                                   -userInfo[arg1][address(arg2)].field_512
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                        if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               -userInfo[arg1][address(arg2)].field_512
                    if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) / block.number - poolInfo[arg1].field_512 != decayTable[block.number + -stor12 - 1 / stor15]:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    if not (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15]):
                        if totalAllocPoint <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require totalAllocPoint
                        if not 0 / totalAllocPoint:
                            if poolInfo[arg1].field_1280 <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require poolInfo[arg1].field_1280
                            if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            if not userInfo[arg1][address(arg2)].field_0:
                                if userInfo[arg1][address(arg2)].field_256 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                            if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                                   -userInfo[arg1][address(arg2)].field_512
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                        if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               -userInfo[arg1][address(arg2)].field_512
                    if (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) != poolInfo[arg1].field_256:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint:
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                        if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               -userInfo[arg1][address(arg2)].field_512
                    if 10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                    if (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           -userInfo[arg1][address(arg2)].field_512
                if startBlock > block.number:
                    revert with 0, 'SafeMath: subtraction overflow'
                if 1 > block.number - startBlock:
                    revert with 0, 'SafeMath: subtraction overflow'
                if decayPeriod <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require decayPeriod
                idx = 0
                s = poolInfo[arg1].field_512
                while idx < block.number + -startBlock - 1 / decayPeriod:
                    if not idx + 1:
                        if startBlock < 0:
                            revert with 0, 'SafeMath: addition overflow'
                        if decayPeriod != 0:
                            if startBlock > startBlock:
                                revert with 0, 'SafeMath: subtraction overflow'
                        if 0 >= decayTable.length:
                            revert with 0, 'phase not ready'
                        mem[0] = 17
                        if s > startBlock:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if startBlock - s:
                            if (startBlock * decayTable) - (s * decayTable) / startBlock - s != decayTable:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if (startBlock * decayTable) - (s * decayTable) < 0:
                                revert with 0, 'SafeMath: addition overflow'
                        idx = idx + 1
                        s = startBlock
                        continue 
                    if decayPeriod + (idx * decayPeriod) / idx + 1 != decayPeriod:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if startBlock < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    if 0 == decayPeriod:
                        if 0 >= decayTable.length:
                            revert with 0, 'phase not ready'
                        mem[0] = 17
                        if s > startBlock + decayPeriod + (idx * decayPeriod):
                            revert with 0, 'SafeMath: subtraction overflow'
                        if startBlock + decayPeriod + (idx * decayPeriod) - s:
                            if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) / startBlock + decayPeriod + (idx * decayPeriod) - s != decayTable:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) < 0:
                                revert with 0, 'SafeMath: addition overflow'
                    else:
                        if startBlock + decayPeriod + (idx * decayPeriod) <= startBlock:
                            if 0 >= decayTable.length:
                                revert with 0, 'phase not ready'
                            mem[0] = 17
                            if s > startBlock + decayPeriod + (idx * decayPeriod):
                                revert with 0, 'SafeMath: subtraction overflow'
                            if startBlock + decayPeriod + (idx * decayPeriod) - s:
                                if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) / startBlock + decayPeriod + (idx * decayPeriod) - s != decayTable:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                        else:
                            if startBlock > startBlock + decayPeriod + (idx * decayPeriod):
                                revert with 0, 'SafeMath: subtraction overflow'
                            if 1 > decayPeriod + (idx * decayPeriod):
                                revert with 0, 'SafeMath: subtraction overflow'
                            if decayPeriod <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require decayPeriod
                            if decayPeriod + (idx * decayPeriod) - 1 / decayPeriod >= decayTable.length:
                                revert with 0, 'phase not ready'
                            mem[0] = 17
                            if s > startBlock + decayPeriod + (idx * decayPeriod):
                                revert with 0, 'SafeMath: subtraction overflow'
                            if startBlock + decayPeriod + (idx * decayPeriod) - s:
                                if (startBlock * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (idx * decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) - (s * decayTable[stor15 + (idx * stor15) - 1 / stor15]) / startBlock + decayPeriod + (idx * decayPeriod) - s != decayTable[stor15 + (idx * stor15) - 1 / stor15]:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                if (startBlock * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (idx * decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) - (s * decayTable[stor15 + (idx * stor15) - 1 / stor15]) < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                    idx = idx + 1
                    s = startBlock + decayPeriod + (idx * decayPeriod)
                    continue 
            else:
                if startBlock > poolInfo[arg1].field_512:
                    revert with 0, 'SafeMath: subtraction overflow'
                if 1 > poolInfo[arg1].field_512 - startBlock:
                    revert with 0, 'SafeMath: subtraction overflow'
                if decayPeriod <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require decayPeriod
                if 0 == decayPeriod:
                    idx = poolInfo[arg1].field_512 + -startBlock - 1 / decayPeriod
                    s = poolInfo[arg1].field_512
                    while idx < 0:
                        if not idx + 1:
                            if startBlock < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if decayPeriod != 0:
                                if startBlock > startBlock:
                                    revert with 0, 'SafeMath: subtraction overflow'
                            if 0 >= decayTable.length:
                                revert with 0, 'phase not ready'
                            mem[0] = 17
                            if s > startBlock:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if startBlock - s:
                                if (startBlock * decayTable) - (s * decayTable) / startBlock - s != decayTable:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                if (startBlock * decayTable) - (s * decayTable) < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                            idx = idx + 1
                            s = startBlock
                            continue 
                        if decayPeriod + (idx * decayPeriod) / idx + 1 != decayPeriod:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if startBlock < 0:
                            revert with 0, 'SafeMath: addition overflow'
                        if 0 == decayPeriod:
                            if 0 >= decayTable.length:
                                revert with 0, 'phase not ready'
                            mem[0] = 17
                            if s > startBlock + decayPeriod + (idx * decayPeriod):
                                revert with 0, 'SafeMath: subtraction overflow'
                            if startBlock + decayPeriod + (idx * decayPeriod) - s:
                                if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) / startBlock + decayPeriod + (idx * decayPeriod) - s != decayTable:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                        else:
                            if startBlock + decayPeriod + (idx * decayPeriod) <= startBlock:
                                if 0 >= decayTable.length:
                                    revert with 0, 'phase not ready'
                                mem[0] = 17
                                if s > startBlock + decayPeriod + (idx * decayPeriod):
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if startBlock + decayPeriod + (idx * decayPeriod) - s:
                                    if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) / startBlock + decayPeriod + (idx * decayPeriod) - s != decayTable:
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                    32,
                                                    33,
                                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[197 len 31]
                                    if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                            else:
                                if startBlock > startBlock + decayPeriod + (idx * decayPeriod):
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if 1 > decayPeriod + (idx * decayPeriod):
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if decayPeriod <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require decayPeriod
                                if decayPeriod + (idx * decayPeriod) - 1 / decayPeriod >= decayTable.length:
                                    revert with 0, 'phase not ready'
                                mem[0] = 17
                                if s > startBlock + decayPeriod + (idx * decayPeriod):
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if startBlock + decayPeriod + (idx * decayPeriod) - s:
                                    if (startBlock * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (idx * decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) - (s * decayTable[stor15 + (idx * stor15) - 1 / stor15]) / startBlock + decayPeriod + (idx * decayPeriod) - s != decayTable[stor15 + (idx * stor15) - 1 / stor15]:
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                    32,
                                                    33,
                                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[197 len 31]
                                    if (startBlock * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (idx * decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) - (s * decayTable[stor15 + (idx * stor15) - 1 / stor15]) < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                        idx = idx + 1
                        s = startBlock + decayPeriod + (idx * decayPeriod)
                        continue 
                else:
                    if block.number <= startBlock:
                        idx = poolInfo[arg1].field_512 + -startBlock - 1 / decayPeriod
                        s = poolInfo[arg1].field_512
                        while idx < 0:
                            if not idx + 1:
                                if startBlock < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if decayPeriod != 0:
                                    if startBlock > startBlock:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                if 0 >= decayTable.length:
                                    revert with 0, 'phase not ready'
                                mem[0] = 17
                                if s > startBlock:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if startBlock - s:
                                    if (startBlock * decayTable) - (s * decayTable) / startBlock - s != decayTable:
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                    32,
                                                    33,
                                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[197 len 31]
                                    if (startBlock * decayTable) - (s * decayTable) < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                idx = idx + 1
                                s = startBlock
                                continue 
                            if decayPeriod + (idx * decayPeriod) / idx + 1 != decayPeriod:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if startBlock < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if 0 == decayPeriod:
                                if 0 >= decayTable.length:
                                    revert with 0, 'phase not ready'
                                mem[0] = 17
                                if s > startBlock + decayPeriod + (idx * decayPeriod):
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if startBlock + decayPeriod + (idx * decayPeriod) - s:
                                    if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) / startBlock + decayPeriod + (idx * decayPeriod) - s != decayTable:
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                    32,
                                                    33,
                                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[197 len 31]
                                    if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                            else:
                                if startBlock + decayPeriod + (idx * decayPeriod) <= startBlock:
                                    if 0 >= decayTable.length:
                                        revert with 0, 'phase not ready'
                                    mem[0] = 17
                                    if s > startBlock + decayPeriod + (idx * decayPeriod):
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if startBlock + decayPeriod + (idx * decayPeriod) - s:
                                        if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) / startBlock + decayPeriod + (idx * decayPeriod) - s != decayTable:
                                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                        32,
                                                        33,
                                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[197 len 31]
                                        if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                else:
                                    if startBlock > startBlock + decayPeriod + (idx * decayPeriod):
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if 1 > decayPeriod + (idx * decayPeriod):
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if decayPeriod <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require decayPeriod
                                    if decayPeriod + (idx * decayPeriod) - 1 / decayPeriod >= decayTable.length:
                                        revert with 0, 'phase not ready'
                                    mem[0] = 17
                                    if s > startBlock + decayPeriod + (idx * decayPeriod):
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if startBlock + decayPeriod + (idx * decayPeriod) - s:
                                        if (startBlock * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (idx * decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) - (s * decayTable[stor15 + (idx * stor15) - 1 / stor15]) / startBlock + decayPeriod + (idx * decayPeriod) - s != decayTable[stor15 + (idx * stor15) - 1 / stor15]:
                                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                        32,
                                                        33,
                                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[197 len 31]
                                        if (startBlock * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (idx * decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) - (s * decayTable[stor15 + (idx * stor15) - 1 / stor15]) < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                            idx = idx + 1
                            s = startBlock + decayPeriod + (idx * decayPeriod)
                            continue 
                    else:
                        if startBlock > block.number:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if 1 > block.number - startBlock:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if decayPeriod <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require decayPeriod
                        idx = poolInfo[arg1].field_512 + -startBlock - 1 / decayPeriod
                        s = poolInfo[arg1].field_512
                        while idx < block.number + -startBlock - 1 / decayPeriod:
                            if not idx + 1:
                                if startBlock < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if decayPeriod != 0:
                                    if startBlock > startBlock:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                if 0 >= decayTable.length:
                                    revert with 0, 'phase not ready'
                                mem[0] = 17
                                if s > startBlock:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if startBlock - s:
                                    if (startBlock * decayTable) - (s * decayTable) / startBlock - s != decayTable:
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                    32,
                                                    33,
                                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[197 len 31]
                                    if (startBlock * decayTable) - (s * decayTable) < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                idx = idx + 1
                                s = startBlock
                                continue 
                            if decayPeriod + (idx * decayPeriod) / idx + 1 != decayPeriod:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if startBlock < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if 0 == decayPeriod:
                                if 0 >= decayTable.length:
                                    revert with 0, 'phase not ready'
                                mem[0] = 17
                                if s > startBlock + decayPeriod + (idx * decayPeriod):
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if startBlock + decayPeriod + (idx * decayPeriod) - s:
                                    if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) / startBlock + decayPeriod + (idx * decayPeriod) - s != decayTable:
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                    32,
                                                    33,
                                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[197 len 31]
                                    if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                            else:
                                if startBlock + decayPeriod + (idx * decayPeriod) <= startBlock:
                                    if 0 >= decayTable.length:
                                        revert with 0, 'phase not ready'
                                    mem[0] = 17
                                    if s > startBlock + decayPeriod + (idx * decayPeriod):
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if startBlock + decayPeriod + (idx * decayPeriod) - s:
                                        if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) / startBlock + decayPeriod + (idx * decayPeriod) - s != decayTable:
                                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                        32,
                                                        33,
                                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[197 len 31]
                                        if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                else:
                                    if startBlock > startBlock + decayPeriod + (idx * decayPeriod):
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if 1 > decayPeriod + (idx * decayPeriod):
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if decayPeriod <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require decayPeriod
                                    if decayPeriod + (idx * decayPeriod) - 1 / decayPeriod >= decayTable.length:
                                        revert with 0, 'phase not ready'
                                    mem[0] = 17
                                    if s > startBlock + decayPeriod + (idx * decayPeriod):
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if startBlock + decayPeriod + (idx * decayPeriod) - s:
                                        if (startBlock * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (idx * decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) - (s * decayTable[stor15 + (idx * stor15) - 1 / stor15]) / startBlock + decayPeriod + (idx * decayPeriod) - s != decayTable[stor15 + (idx * stor15) - 1 / stor15]:
                                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                        32,
                                                        33,
                                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[197 len 31]
                                        if (startBlock * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (idx * decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) - (s * decayTable[stor15 + (idx * stor15) - 1 / stor15]) < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                            idx = idx + 1
                            s = startBlock + decayPeriod + (idx * decayPeriod)
                            continue 
            if 0 == decayPeriod:
                if 0 >= decayTable.length:
                    revert with 0, 'phase not ready'
                if s > block.number:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not block.number - s:
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not 0 / totalAllocPoint:
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                        if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               -userInfo[arg1][address(arg2)].field_512
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           -userInfo[arg1][address(arg2)].field_512
                if (block.number * decayTable) - (s * decayTable) / block.number - s != decayTable:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if (block.number * decayTable) - (s * decayTable) < 0:
                    revert with 0, 'SafeMath: addition overflow'
                if not (block.number * decayTable) - (s * decayTable):
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not 0 / totalAllocPoint:
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                        if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               -userInfo[arg1][address(arg2)].field_512
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           -userInfo[arg1][address(arg2)].field_512
                if (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / (block.number * decayTable) - (s * decayTable) != poolInfo[arg1].field_256:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if totalAllocPoint <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require totalAllocPoint
                if not (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint:
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                    if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           -userInfo[arg1][address(arg2)].field_512
                if 10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if poolInfo[arg1].field_1280 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require poolInfo[arg1].field_1280
                if (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                if (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       -userInfo[arg1][address(arg2)].field_512
            if block.number <= startBlock:
                if 0 >= decayTable.length:
                    revert with 0, 'phase not ready'
                if s > block.number:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not block.number - s:
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not 0 / totalAllocPoint:
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                        if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               -userInfo[arg1][address(arg2)].field_512
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           -userInfo[arg1][address(arg2)].field_512
                if (block.number * decayTable) - (s * decayTable) / block.number - s != decayTable:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if (block.number * decayTable) - (s * decayTable) < 0:
                    revert with 0, 'SafeMath: addition overflow'
                if not (block.number * decayTable) - (s * decayTable):
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not 0 / totalAllocPoint:
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                        if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               -userInfo[arg1][address(arg2)].field_512
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           -userInfo[arg1][address(arg2)].field_512
                if (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / (block.number * decayTable) - (s * decayTable) != poolInfo[arg1].field_256:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if totalAllocPoint <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require totalAllocPoint
                if not (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint:
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                    if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           -userInfo[arg1][address(arg2)].field_512
                if 10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if poolInfo[arg1].field_1280 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require poolInfo[arg1].field_1280
                if (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                if (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       -userInfo[arg1][address(arg2)].field_512
            if startBlock > block.number:
                revert with 0, 'SafeMath: subtraction overflow'
            if 1 > block.number - startBlock:
                revert with 0, 'SafeMath: subtraction overflow'
            if decayPeriod <= 0:
                revert with 0, 'SafeMath: division by zero'
            require decayPeriod
            if block.number + -startBlock - 1 / decayPeriod >= decayTable.length:
                revert with 0, 'phase not ready'
            if s > block.number:
                revert with 0, 'SafeMath: subtraction overflow'
            if not block.number - s:
                if totalAllocPoint <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require totalAllocPoint
                if not 0 / totalAllocPoint:
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                    if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           -userInfo[arg1][address(arg2)].field_512
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if poolInfo[arg1].field_1280 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require poolInfo[arg1].field_1280
                if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       -userInfo[arg1][address(arg2)].field_512
            if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (s * decayTable[block.number + -stor12 - 1 / stor15]) / block.number - s != decayTable[block.number + -stor12 - 1 / stor15]:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (s * decayTable[block.number + -stor12 - 1 / stor15]) < 0:
                revert with 0, 'SafeMath: addition overflow'
            if not (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (s * decayTable[block.number + -stor12 - 1 / stor15]):
                if totalAllocPoint <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require totalAllocPoint
                if not 0 / totalAllocPoint:
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                    if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           -userInfo[arg1][address(arg2)].field_512
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if poolInfo[arg1].field_1280 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require poolInfo[arg1].field_1280
                if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       -userInfo[arg1][address(arg2)].field_512
            if (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (s * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (s * decayTable[block.number + -stor12 - 1 / stor15]) != poolInfo[arg1].field_256:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if totalAllocPoint <= 0:
                revert with 0, 'SafeMath: division by zero'
            require totalAllocPoint
            if not (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (s * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint:
                if poolInfo[arg1].field_1280 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require poolInfo[arg1].field_1280
                if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       -userInfo[arg1][address(arg2)].field_512
            if 10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (s * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (s * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if poolInfo[arg1].field_1280 <= 0:
                revert with 0, 'SafeMath: division by zero'
            require poolInfo[arg1].field_1280
            if (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (s * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
            if (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (s * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (s * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (s * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return ((10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (s * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                   -userInfo[arg1][address(arg2)].field_512
        if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_1024:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        33,
                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[197 len 31]
        if userInfo[arg1][address(arg2)].field_512 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12:
            revert with 0, 'SafeMath: subtraction overflow'
        if block.number <= poolInfo[arg1].field_512:
            if poolInfo[arg1].field_512 != block.number:
                return 0
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256, 
                       ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0 / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if userInfo[arg1][address(arg2)].field_256 > poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0 / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0 / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                   ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
        if 0 == decayPeriod:
            if 0 == decayPeriod:
                if 0 >= decayTable.length:
                    revert with 0, 'phase not ready'
                if poolInfo[arg1].field_512 > block.number:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not block.number - poolInfo[arg1].field_512:
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not 0 / totalAllocPoint:
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, 
                                   ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                        if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 
                               ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) / block.number - poolInfo[arg1].field_512 != decayTable:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) < 0:
                    revert with 0, 'SafeMath: addition overflow'
                if not (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable):
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not 0 / totalAllocPoint:
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, 
                                   ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                        if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 
                               ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) != poolInfo[arg1].field_256:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if totalAllocPoint <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require totalAllocPoint
                if not (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint:
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 
                               ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if 10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if poolInfo[arg1].field_1280 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require poolInfo[arg1].field_1280
                if (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, 
                           ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if block.number <= startBlock:
                if 0 >= decayTable.length:
                    revert with 0, 'phase not ready'
                if poolInfo[arg1].field_512 > block.number:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not block.number - poolInfo[arg1].field_512:
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not 0 / totalAllocPoint:
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, 
                                   ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                        if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 
                               ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) / block.number - poolInfo[arg1].field_512 != decayTable:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) < 0:
                    revert with 0, 'SafeMath: addition overflow'
                if not (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable):
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not 0 / totalAllocPoint:
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, 
                                   ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                        if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 
                               ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) != poolInfo[arg1].field_256:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if totalAllocPoint <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require totalAllocPoint
                if not (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint:
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 
                               ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if 10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if poolInfo[arg1].field_1280 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require poolInfo[arg1].field_1280
                if (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, 
                           ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if startBlock > block.number:
                revert with 0, 'SafeMath: subtraction overflow'
            if 1 > block.number - startBlock:
                revert with 0, 'SafeMath: subtraction overflow'
            if decayPeriod <= 0:
                revert with 0, 'SafeMath: division by zero'
            require decayPeriod
            if block.number + -startBlock - 1 / decayPeriod >= decayTable.length:
                revert with 0, 'phase not ready'
            if poolInfo[arg1].field_512 > block.number:
                revert with 0, 'SafeMath: subtraction overflow'
            if not block.number - poolInfo[arg1].field_512:
                if totalAllocPoint <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require totalAllocPoint
                if not 0 / totalAllocPoint:
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 
                               ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if poolInfo[arg1].field_1280 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require poolInfo[arg1].field_1280
                if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, 
                           ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) / block.number - poolInfo[arg1].field_512 != decayTable[block.number + -stor12 - 1 / stor15]:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) < 0:
                revert with 0, 'SafeMath: addition overflow'
            if not (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15]):
                if totalAllocPoint <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require totalAllocPoint
                if not 0 / totalAllocPoint:
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 
                               ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if poolInfo[arg1].field_1280 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require poolInfo[arg1].field_1280
                if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, 
                           ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) != poolInfo[arg1].field_256:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if totalAllocPoint <= 0:
                revert with 0, 'SafeMath: division by zero'
            require totalAllocPoint
            if not (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint:
                if poolInfo[arg1].field_1280 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require poolInfo[arg1].field_1280
                if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, 
                           ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if 10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if poolInfo[arg1].field_1280 <= 0:
                revert with 0, 'SafeMath: division by zero'
            require poolInfo[arg1].field_1280
            if (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256, 
                       ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return ((10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                   ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
        if poolInfo[arg1].field_512 <= startBlock:
            if 0 == decayPeriod:
                if 0 == decayPeriod:
                    if 0 >= decayTable.length:
                        revert with 0, 'phase not ready'
                    if poolInfo[arg1].field_512 > block.number:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not block.number - poolInfo[arg1].field_512:
                        if totalAllocPoint <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require totalAllocPoint
                        if not 0 / totalAllocPoint:
                            if poolInfo[arg1].field_1280 <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require poolInfo[arg1].field_1280
                            if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            if not userInfo[arg1][address(arg2)].field_0:
                                if userInfo[arg1][address(arg2)].field_256 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return -userInfo[arg1][address(arg2)].field_256, 
                                       ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                            if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                                   ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, 
                                   ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                        if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) / block.number - poolInfo[arg1].field_512 != decayTable:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    if not (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable):
                        if totalAllocPoint <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require totalAllocPoint
                        if not 0 / totalAllocPoint:
                            if poolInfo[arg1].field_1280 <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require poolInfo[arg1].field_1280
                            if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            if not userInfo[arg1][address(arg2)].field_0:
                                if userInfo[arg1][address(arg2)].field_256 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return -userInfo[arg1][address(arg2)].field_256, 
                                       ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                            if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                                   ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, 
                                   ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                        if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) != poolInfo[arg1].field_256:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint:
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, 
                                   ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                        if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if 10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 
                               ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if block.number <= startBlock:
                    if 0 >= decayTable.length:
                        revert with 0, 'phase not ready'
                    if poolInfo[arg1].field_512 > block.number:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not block.number - poolInfo[arg1].field_512:
                        if totalAllocPoint <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require totalAllocPoint
                        if not 0 / totalAllocPoint:
                            if poolInfo[arg1].field_1280 <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require poolInfo[arg1].field_1280
                            if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            if not userInfo[arg1][address(arg2)].field_0:
                                if userInfo[arg1][address(arg2)].field_256 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return -userInfo[arg1][address(arg2)].field_256, 
                                       ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                            if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                                   ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, 
                                   ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                        if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) / block.number - poolInfo[arg1].field_512 != decayTable:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    if not (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable):
                        if totalAllocPoint <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require totalAllocPoint
                        if not 0 / totalAllocPoint:
                            if poolInfo[arg1].field_1280 <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require poolInfo[arg1].field_1280
                            if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            if not userInfo[arg1][address(arg2)].field_0:
                                if userInfo[arg1][address(arg2)].field_256 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return -userInfo[arg1][address(arg2)].field_256, 
                                       ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                            if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                                   ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, 
                                   ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                        if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) != poolInfo[arg1].field_256:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint:
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, 
                                   ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                        if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if 10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 
                               ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if startBlock > block.number:
                    revert with 0, 'SafeMath: subtraction overflow'
                if 1 > block.number - startBlock:
                    revert with 0, 'SafeMath: subtraction overflow'
                if decayPeriod <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require decayPeriod
                if block.number + -startBlock - 1 / decayPeriod >= decayTable.length:
                    revert with 0, 'phase not ready'
                if poolInfo[arg1].field_512 > block.number:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not block.number - poolInfo[arg1].field_512:
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not 0 / totalAllocPoint:
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, 
                                   ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                        if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 
                               ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) / block.number - poolInfo[arg1].field_512 != decayTable[block.number + -stor12 - 1 / stor15]:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) < 0:
                    revert with 0, 'SafeMath: addition overflow'
                if not (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15]):
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not 0 / totalAllocPoint:
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, 
                                   ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                        if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 
                               ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) != poolInfo[arg1].field_256:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if totalAllocPoint <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require totalAllocPoint
                if not (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint:
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 
                               ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if 10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if poolInfo[arg1].field_1280 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require poolInfo[arg1].field_1280
                if (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, 
                           ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if block.number <= startBlock:
                if 0 == decayPeriod:
                    if 0 >= decayTable.length:
                        revert with 0, 'phase not ready'
                    if poolInfo[arg1].field_512 > block.number:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not block.number - poolInfo[arg1].field_512:
                        if totalAllocPoint <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require totalAllocPoint
                        if not 0 / totalAllocPoint:
                            if poolInfo[arg1].field_1280 <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require poolInfo[arg1].field_1280
                            if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            if not userInfo[arg1][address(arg2)].field_0:
                                if userInfo[arg1][address(arg2)].field_256 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return -userInfo[arg1][address(arg2)].field_256, 
                                       ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                            if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                                   ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, 
                                   ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                        if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) / block.number - poolInfo[arg1].field_512 != decayTable:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    if not (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable):
                        if totalAllocPoint <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require totalAllocPoint
                        if not 0 / totalAllocPoint:
                            if poolInfo[arg1].field_1280 <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require poolInfo[arg1].field_1280
                            if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            if not userInfo[arg1][address(arg2)].field_0:
                                if userInfo[arg1][address(arg2)].field_256 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return -userInfo[arg1][address(arg2)].field_256, 
                                       ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                            if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                                   ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, 
                                   ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                        if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) != poolInfo[arg1].field_256:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint:
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, 
                                   ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                        if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if 10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 
                               ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if block.number <= startBlock:
                    if 0 >= decayTable.length:
                        revert with 0, 'phase not ready'
                    if poolInfo[arg1].field_512 > block.number:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not block.number - poolInfo[arg1].field_512:
                        if totalAllocPoint <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require totalAllocPoint
                        if not 0 / totalAllocPoint:
                            if poolInfo[arg1].field_1280 <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require poolInfo[arg1].field_1280
                            if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            if not userInfo[arg1][address(arg2)].field_0:
                                if userInfo[arg1][address(arg2)].field_256 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return -userInfo[arg1][address(arg2)].field_256, 
                                       ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                            if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                                   ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, 
                                   ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                        if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) / block.number - poolInfo[arg1].field_512 != decayTable:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    if not (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable):
                        if totalAllocPoint <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require totalAllocPoint
                        if not 0 / totalAllocPoint:
                            if poolInfo[arg1].field_1280 <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require poolInfo[arg1].field_1280
                            if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            if not userInfo[arg1][address(arg2)].field_0:
                                if userInfo[arg1][address(arg2)].field_256 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return -userInfo[arg1][address(arg2)].field_256, 
                                       ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                            if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                                   ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, 
                                   ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                        if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) != poolInfo[arg1].field_256:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint:
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, 
                                   ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                        if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if 10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 
                               ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if startBlock > block.number:
                    revert with 0, 'SafeMath: subtraction overflow'
                if 1 > block.number - startBlock:
                    revert with 0, 'SafeMath: subtraction overflow'
                if decayPeriod <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require decayPeriod
                if block.number + -startBlock - 1 / decayPeriod >= decayTable.length:
                    revert with 0, 'phase not ready'
                if poolInfo[arg1].field_512 > block.number:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not block.number - poolInfo[arg1].field_512:
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not 0 / totalAllocPoint:
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, 
                                   ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                        if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 
                               ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) / block.number - poolInfo[arg1].field_512 != decayTable[block.number + -stor12 - 1 / stor15]:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) < 0:
                    revert with 0, 'SafeMath: addition overflow'
                if not (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15]):
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not 0 / totalAllocPoint:
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, 
                                   ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                        if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 
                               ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) != poolInfo[arg1].field_256:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if totalAllocPoint <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require totalAllocPoint
                if not (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint:
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 
                               ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if 10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if poolInfo[arg1].field_1280 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require poolInfo[arg1].field_1280
                if (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, 
                           ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if startBlock > block.number:
                revert with 0, 'SafeMath: subtraction overflow'
            if 1 > block.number - startBlock:
                revert with 0, 'SafeMath: subtraction overflow'
            if decayPeriod <= 0:
                revert with 0, 'SafeMath: division by zero'
            require decayPeriod
            idx = 0
            s = poolInfo[arg1].field_512
            while idx < block.number + -startBlock - 1 / decayPeriod:
                if not idx + 1:
                    if startBlock < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    if decayPeriod != 0:
                        if startBlock > startBlock:
                            revert with 0, 'SafeMath: subtraction overflow'
                    if 0 >= decayTable.length:
                        revert with 0, 'phase not ready'
                    mem[0] = 17
                    if s > startBlock:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if startBlock - s:
                        if (startBlock * decayTable) - (s * decayTable) / startBlock - s != decayTable:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if (startBlock * decayTable) - (s * decayTable) < 0:
                            revert with 0, 'SafeMath: addition overflow'
                    idx = idx + 1
                    s = startBlock
                    continue 
                if decayPeriod + (idx * decayPeriod) / idx + 1 != decayPeriod:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if startBlock < 0:
                    revert with 0, 'SafeMath: addition overflow'
                if 0 == decayPeriod:
                    if 0 >= decayTable.length:
                        revert with 0, 'phase not ready'
                    mem[0] = 17
                    if s > startBlock + decayPeriod + (idx * decayPeriod):
                        revert with 0, 'SafeMath: subtraction overflow'
                    if startBlock + decayPeriod + (idx * decayPeriod) - s:
                        if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) / startBlock + decayPeriod + (idx * decayPeriod) - s != decayTable:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) < 0:
                            revert with 0, 'SafeMath: addition overflow'
                else:
                    if startBlock + decayPeriod + (idx * decayPeriod) <= startBlock:
                        if 0 >= decayTable.length:
                            revert with 0, 'phase not ready'
                        mem[0] = 17
                        if s > startBlock + decayPeriod + (idx * decayPeriod):
                            revert with 0, 'SafeMath: subtraction overflow'
                        if startBlock + decayPeriod + (idx * decayPeriod) - s:
                            if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) / startBlock + decayPeriod + (idx * decayPeriod) - s != decayTable:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) < 0:
                                revert with 0, 'SafeMath: addition overflow'
                    else:
                        if startBlock > startBlock + decayPeriod + (idx * decayPeriod):
                            revert with 0, 'SafeMath: subtraction overflow'
                        if 1 > decayPeriod + (idx * decayPeriod):
                            revert with 0, 'SafeMath: subtraction overflow'
                        if decayPeriod <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require decayPeriod
                        if decayPeriod + (idx * decayPeriod) - 1 / decayPeriod >= decayTable.length:
                            revert with 0, 'phase not ready'
                        mem[0] = 17
                        if s > startBlock + decayPeriod + (idx * decayPeriod):
                            revert with 0, 'SafeMath: subtraction overflow'
                        if startBlock + decayPeriod + (idx * decayPeriod) - s:
                            if (startBlock * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (idx * decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) - (s * decayTable[stor15 + (idx * stor15) - 1 / stor15]) / startBlock + decayPeriod + (idx * decayPeriod) - s != decayTable[stor15 + (idx * stor15) - 1 / stor15]:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if (startBlock * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (idx * decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) - (s * decayTable[stor15 + (idx * stor15) - 1 / stor15]) < 0:
                                revert with 0, 'SafeMath: addition overflow'
                idx = idx + 1
                s = startBlock + decayPeriod + (idx * decayPeriod)
                continue 
        else:
            if startBlock > poolInfo[arg1].field_512:
                revert with 0, 'SafeMath: subtraction overflow'
            if 1 > poolInfo[arg1].field_512 - startBlock:
                revert with 0, 'SafeMath: subtraction overflow'
            if decayPeriod <= 0:
                revert with 0, 'SafeMath: division by zero'
            require decayPeriod
            if 0 == decayPeriod:
                idx = poolInfo[arg1].field_512 + -startBlock - 1 / decayPeriod
                s = poolInfo[arg1].field_512
                while idx < 0:
                    if not idx + 1:
                        if startBlock < 0:
                            revert with 0, 'SafeMath: addition overflow'
                        if decayPeriod != 0:
                            if startBlock > startBlock:
                                revert with 0, 'SafeMath: subtraction overflow'
                        if 0 >= decayTable.length:
                            revert with 0, 'phase not ready'
                        mem[0] = 17
                        if s > startBlock:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if startBlock - s:
                            if (startBlock * decayTable) - (s * decayTable) / startBlock - s != decayTable:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if (startBlock * decayTable) - (s * decayTable) < 0:
                                revert with 0, 'SafeMath: addition overflow'
                        idx = idx + 1
                        s = startBlock
                        continue 
                    if decayPeriod + (idx * decayPeriod) / idx + 1 != decayPeriod:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if startBlock < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    if 0 == decayPeriod:
                        if 0 >= decayTable.length:
                            revert with 0, 'phase not ready'
                        mem[0] = 17
                        if s > startBlock + decayPeriod + (idx * decayPeriod):
                            revert with 0, 'SafeMath: subtraction overflow'
                        if startBlock + decayPeriod + (idx * decayPeriod) - s:
                            if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) / startBlock + decayPeriod + (idx * decayPeriod) - s != decayTable:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) < 0:
                                revert with 0, 'SafeMath: addition overflow'
                    else:
                        if startBlock + decayPeriod + (idx * decayPeriod) <= startBlock:
                            if 0 >= decayTable.length:
                                revert with 0, 'phase not ready'
                            mem[0] = 17
                            if s > startBlock + decayPeriod + (idx * decayPeriod):
                                revert with 0, 'SafeMath: subtraction overflow'
                            if startBlock + decayPeriod + (idx * decayPeriod) - s:
                                if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) / startBlock + decayPeriod + (idx * decayPeriod) - s != decayTable:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                        else:
                            if startBlock > startBlock + decayPeriod + (idx * decayPeriod):
                                revert with 0, 'SafeMath: subtraction overflow'
                            if 1 > decayPeriod + (idx * decayPeriod):
                                revert with 0, 'SafeMath: subtraction overflow'
                            if decayPeriod <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require decayPeriod
                            if decayPeriod + (idx * decayPeriod) - 1 / decayPeriod >= decayTable.length:
                                revert with 0, 'phase not ready'
                            mem[0] = 17
                            if s > startBlock + decayPeriod + (idx * decayPeriod):
                                revert with 0, 'SafeMath: subtraction overflow'
                            if startBlock + decayPeriod + (idx * decayPeriod) - s:
                                if (startBlock * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (idx * decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) - (s * decayTable[stor15 + (idx * stor15) - 1 / stor15]) / startBlock + decayPeriod + (idx * decayPeriod) - s != decayTable[stor15 + (idx * stor15) - 1 / stor15]:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                if (startBlock * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (idx * decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) - (s * decayTable[stor15 + (idx * stor15) - 1 / stor15]) < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                    idx = idx + 1
                    s = startBlock + decayPeriod + (idx * decayPeriod)
                    continue 
            else:
                if block.number <= startBlock:
                    idx = poolInfo[arg1].field_512 + -startBlock - 1 / decayPeriod
                    s = poolInfo[arg1].field_512
                    while idx < 0:
                        if not idx + 1:
                            if startBlock < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if decayPeriod != 0:
                                if startBlock > startBlock:
                                    revert with 0, 'SafeMath: subtraction overflow'
                            if 0 >= decayTable.length:
                                revert with 0, 'phase not ready'
                            mem[0] = 17
                            if s > startBlock:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if startBlock - s:
                                if (startBlock * decayTable) - (s * decayTable) / startBlock - s != decayTable:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                if (startBlock * decayTable) - (s * decayTable) < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                            idx = idx + 1
                            s = startBlock
                            continue 
                        if decayPeriod + (idx * decayPeriod) / idx + 1 != decayPeriod:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if startBlock < 0:
                            revert with 0, 'SafeMath: addition overflow'
                        if 0 == decayPeriod:
                            if 0 >= decayTable.length:
                                revert with 0, 'phase not ready'
                            mem[0] = 17
                            if s > startBlock + decayPeriod + (idx * decayPeriod):
                                revert with 0, 'SafeMath: subtraction overflow'
                            if startBlock + decayPeriod + (idx * decayPeriod) - s:
                                if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) / startBlock + decayPeriod + (idx * decayPeriod) - s != decayTable:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                        else:
                            if startBlock + decayPeriod + (idx * decayPeriod) <= startBlock:
                                if 0 >= decayTable.length:
                                    revert with 0, 'phase not ready'
                                mem[0] = 17
                                if s > startBlock + decayPeriod + (idx * decayPeriod):
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if startBlock + decayPeriod + (idx * decayPeriod) - s:
                                    if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) / startBlock + decayPeriod + (idx * decayPeriod) - s != decayTable:
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                    32,
                                                    33,
                                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[197 len 31]
                                    if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                            else:
                                if startBlock > startBlock + decayPeriod + (idx * decayPeriod):
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if 1 > decayPeriod + (idx * decayPeriod):
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if decayPeriod <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require decayPeriod
                                if decayPeriod + (idx * decayPeriod) - 1 / decayPeriod >= decayTable.length:
                                    revert with 0, 'phase not ready'
                                mem[0] = 17
                                if s > startBlock + decayPeriod + (idx * decayPeriod):
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if startBlock + decayPeriod + (idx * decayPeriod) - s:
                                    if (startBlock * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (idx * decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) - (s * decayTable[stor15 + (idx * stor15) - 1 / stor15]) / startBlock + decayPeriod + (idx * decayPeriod) - s != decayTable[stor15 + (idx * stor15) - 1 / stor15]:
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                    32,
                                                    33,
                                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[197 len 31]
                                    if (startBlock * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (idx * decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) - (s * decayTable[stor15 + (idx * stor15) - 1 / stor15]) < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                        idx = idx + 1
                        s = startBlock + decayPeriod + (idx * decayPeriod)
                        continue 
                else:
                    if startBlock > block.number:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if 1 > block.number - startBlock:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if decayPeriod <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require decayPeriod
                    idx = poolInfo[arg1].field_512 + -startBlock - 1 / decayPeriod
                    s = poolInfo[arg1].field_512
                    while idx < block.number + -startBlock - 1 / decayPeriod:
                        if not idx + 1:
                            if startBlock < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if decayPeriod != 0:
                                if startBlock > startBlock:
                                    revert with 0, 'SafeMath: subtraction overflow'
                            if 0 >= decayTable.length:
                                revert with 0, 'phase not ready'
                            mem[0] = 17
                            if s > startBlock:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if startBlock - s:
                                if (startBlock * decayTable) - (s * decayTable) / startBlock - s != decayTable:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                if (startBlock * decayTable) - (s * decayTable) < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                            idx = idx + 1
                            s = startBlock
                            continue 
                        if decayPeriod + (idx * decayPeriod) / idx + 1 != decayPeriod:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if startBlock < 0:
                            revert with 0, 'SafeMath: addition overflow'
                        if 0 == decayPeriod:
                            if 0 >= decayTable.length:
                                revert with 0, 'phase not ready'
                            mem[0] = 17
                            if s > startBlock + decayPeriod + (idx * decayPeriod):
                                revert with 0, 'SafeMath: subtraction overflow'
                            if startBlock + decayPeriod + (idx * decayPeriod) - s:
                                if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) / startBlock + decayPeriod + (idx * decayPeriod) - s != decayTable:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                        else:
                            if startBlock + decayPeriod + (idx * decayPeriod) <= startBlock:
                                if 0 >= decayTable.length:
                                    revert with 0, 'phase not ready'
                                mem[0] = 17
                                if s > startBlock + decayPeriod + (idx * decayPeriod):
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if startBlock + decayPeriod + (idx * decayPeriod) - s:
                                    if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) / startBlock + decayPeriod + (idx * decayPeriod) - s != decayTable:
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                    32,
                                                    33,
                                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[197 len 31]
                                    if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                            else:
                                if startBlock > startBlock + decayPeriod + (idx * decayPeriod):
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if 1 > decayPeriod + (idx * decayPeriod):
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if decayPeriod <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require decayPeriod
                                if decayPeriod + (idx * decayPeriod) - 1 / decayPeriod >= decayTable.length:
                                    revert with 0, 'phase not ready'
                                mem[0] = 17
                                if s > startBlock + decayPeriod + (idx * decayPeriod):
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if startBlock + decayPeriod + (idx * decayPeriod) - s:
                                    if (startBlock * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (idx * decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) - (s * decayTable[stor15 + (idx * stor15) - 1 / stor15]) / startBlock + decayPeriod + (idx * decayPeriod) - s != decayTable[stor15 + (idx * stor15) - 1 / stor15]:
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                    32,
                                                    33,
                                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[197 len 31]
                                    if (startBlock * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (idx * decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) - (s * decayTable[stor15 + (idx * stor15) - 1 / stor15]) < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                        idx = idx + 1
                        s = startBlock + decayPeriod + (idx * decayPeriod)
                        continue 
        if 0 == decayPeriod:
            if 0 >= decayTable.length:
                revert with 0, 'phase not ready'
            if s > block.number:
                revert with 0, 'SafeMath: subtraction overflow'
            if not block.number - s:
                if totalAllocPoint <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require totalAllocPoint
                if not 0 / totalAllocPoint:
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 
                               ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if poolInfo[arg1].field_1280 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require poolInfo[arg1].field_1280
                if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, 
                           ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if (block.number * decayTable) - (s * decayTable) / block.number - s != decayTable:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if (block.number * decayTable) - (s * decayTable) < 0:
                revert with 0, 'SafeMath: addition overflow'
            if not (block.number * decayTable) - (s * decayTable):
                if totalAllocPoint <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require totalAllocPoint
                if not 0 / totalAllocPoint:
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 
                               ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if poolInfo[arg1].field_1280 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require poolInfo[arg1].field_1280
                if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, 
                           ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / (block.number * decayTable) - (s * decayTable) != poolInfo[arg1].field_256:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if totalAllocPoint <= 0:
                revert with 0, 'SafeMath: division by zero'
            require totalAllocPoint
            if not (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint:
                if poolInfo[arg1].field_1280 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require poolInfo[arg1].field_1280
                if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, 
                           ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if 10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if poolInfo[arg1].field_1280 <= 0:
                revert with 0, 'SafeMath: division by zero'
            require poolInfo[arg1].field_1280
            if (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256, 
                       ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return ((10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                   ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
        if block.number <= startBlock:
            if 0 >= decayTable.length:
                revert with 0, 'phase not ready'
            if s > block.number:
                revert with 0, 'SafeMath: subtraction overflow'
            if not block.number - s:
                if totalAllocPoint <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require totalAllocPoint
                if not 0 / totalAllocPoint:
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 
                               ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if poolInfo[arg1].field_1280 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require poolInfo[arg1].field_1280
                if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, 
                           ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if (block.number * decayTable) - (s * decayTable) / block.number - s != decayTable:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if (block.number * decayTable) - (s * decayTable) < 0:
                revert with 0, 'SafeMath: addition overflow'
            if not (block.number * decayTable) - (s * decayTable):
                if totalAllocPoint <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require totalAllocPoint
                if not 0 / totalAllocPoint:
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 
                               ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if poolInfo[arg1].field_1280 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require poolInfo[arg1].field_1280
                if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, 
                           ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / (block.number * decayTable) - (s * decayTable) != poolInfo[arg1].field_256:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if totalAllocPoint <= 0:
                revert with 0, 'SafeMath: division by zero'
            require totalAllocPoint
            if not (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint:
                if poolInfo[arg1].field_1280 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require poolInfo[arg1].field_1280
                if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, 
                           ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if 10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if poolInfo[arg1].field_1280 <= 0:
                revert with 0, 'SafeMath: division by zero'
            require poolInfo[arg1].field_1280
            if (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256, 
                       ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return ((10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                   ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
        if startBlock > block.number:
            revert with 0, 'SafeMath: subtraction overflow'
        if 1 > block.number - startBlock:
            revert with 0, 'SafeMath: subtraction overflow'
        if decayPeriod <= 0:
            revert with 0, 'SafeMath: division by zero'
        require decayPeriod
        if block.number + -startBlock - 1 / decayPeriod >= decayTable.length:
            revert with 0, 'phase not ready'
        if s > block.number:
            revert with 0, 'SafeMath: subtraction overflow'
        if not block.number - s:
            if totalAllocPoint <= 0:
                revert with 0, 'SafeMath: division by zero'
            require totalAllocPoint
            if not 0 / totalAllocPoint:
                if poolInfo[arg1].field_1280 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require poolInfo[arg1].field_1280
                if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, 
                           ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if poolInfo[arg1].field_1280 <= 0:
                revert with 0, 'SafeMath: division by zero'
            require poolInfo[arg1].field_1280
            if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256, 
                       ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                   ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
        if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (s * decayTable[block.number + -stor12 - 1 / stor15]) / block.number - s != decayTable[block.number + -stor12 - 1 / stor15]:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        33,
                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[197 len 31]
        if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (s * decayTable[block.number + -stor12 - 1 / stor15]) < 0:
            revert with 0, 'SafeMath: addition overflow'
        if not (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (s * decayTable[block.number + -stor12 - 1 / stor15]):
            if totalAllocPoint <= 0:
                revert with 0, 'SafeMath: division by zero'
            require totalAllocPoint
            if not 0 / totalAllocPoint:
                if poolInfo[arg1].field_1280 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require poolInfo[arg1].field_1280
                if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, 
                           ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if poolInfo[arg1].field_1280 <= 0:
                revert with 0, 'SafeMath: division by zero'
            require poolInfo[arg1].field_1280
            if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256, 
                       ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                   ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
        if (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (s * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (s * decayTable[block.number + -stor12 - 1 / stor15]) != poolInfo[arg1].field_256:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        33,
                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[197 len 31]
        if totalAllocPoint <= 0:
            revert with 0, 'SafeMath: division by zero'
        require totalAllocPoint
        if not (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (s * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint:
            if poolInfo[arg1].field_1280 <= 0:
                revert with 0, 'SafeMath: division by zero'
            require poolInfo[arg1].field_1280
            if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256, 
                       ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                   ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
        if 10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (s * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (s * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        33,
                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[197 len 31]
        if poolInfo[arg1].field_1280 <= 0:
            revert with 0, 'SafeMath: division by zero'
        require poolInfo[arg1].field_1280
        if (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (s * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
            revert with 0, 'SafeMath: addition overflow'
        if not userInfo[arg1][address(arg2)].field_0:
            if userInfo[arg1][address(arg2)].field_256 > 0:
                revert with 0, 'SafeMath: subtraction overflow'
            return -userInfo[arg1][address(arg2)].field_256, 
                   ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
        if (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (s * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (s * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        33,
                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[197 len 31]
        if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (s * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
            revert with 0, 'SafeMath: subtraction overflow'
        return ((10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (s * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
               ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
    if 10^12 * ext_call.return_data[0] / ext_call.return_data[0] != 10^12:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    33,
                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                    mem[197 len 31]
    if poolInfo[arg1].field_1280 <= 0:
        revert with 0, 'SafeMath: division by zero'
    require poolInfo[arg1].field_1280
    if (10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280) + poolInfo[arg1].field_1024 < poolInfo[arg1].field_1024:
        revert with 0, 'SafeMath: addition overflow'
    if not userInfo[arg1][address(arg2)].field_0:
        if userInfo[arg1][address(arg2)].field_512 > 0:
            revert with 0, 'SafeMath: subtraction overflow'
        if block.number <= poolInfo[arg1].field_512:
            if poolInfo[arg1].field_512 != block.number:
                return 0
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
            if poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0 / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if userInfo[arg1][address(arg2)].field_256 > poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0 / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0 / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                   -userInfo[arg1][address(arg2)].field_512
        if 0 == decayPeriod:
            if 0 == decayPeriod:
                if 0 >= decayTable.length:
                    revert with 0, 'phase not ready'
                if poolInfo[arg1].field_512 > block.number:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not block.number - poolInfo[arg1].field_512:
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not 0 / totalAllocPoint:
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                        if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               -userInfo[arg1][address(arg2)].field_512
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           -userInfo[arg1][address(arg2)].field_512
                if (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) / block.number - poolInfo[arg1].field_512 != decayTable:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) < 0:
                    revert with 0, 'SafeMath: addition overflow'
                if not (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable):
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not 0 / totalAllocPoint:
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                        if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               -userInfo[arg1][address(arg2)].field_512
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           -userInfo[arg1][address(arg2)].field_512
                if (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) != poolInfo[arg1].field_256:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if totalAllocPoint <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require totalAllocPoint
                if not (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint:
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                    if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           -userInfo[arg1][address(arg2)].field_512
                if 10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if poolInfo[arg1].field_1280 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require poolInfo[arg1].field_1280
                if (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                if (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       -userInfo[arg1][address(arg2)].field_512
            if block.number <= startBlock:
                if 0 >= decayTable.length:
                    revert with 0, 'phase not ready'
                if poolInfo[arg1].field_512 > block.number:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not block.number - poolInfo[arg1].field_512:
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not 0 / totalAllocPoint:
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                        if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               -userInfo[arg1][address(arg2)].field_512
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           -userInfo[arg1][address(arg2)].field_512
                if (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) / block.number - poolInfo[arg1].field_512 != decayTable:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) < 0:
                    revert with 0, 'SafeMath: addition overflow'
                if not (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable):
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not 0 / totalAllocPoint:
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                        if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               -userInfo[arg1][address(arg2)].field_512
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           -userInfo[arg1][address(arg2)].field_512
                if (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) != poolInfo[arg1].field_256:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if totalAllocPoint <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require totalAllocPoint
                if not (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint:
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                    if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           -userInfo[arg1][address(arg2)].field_512
                if 10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if poolInfo[arg1].field_1280 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require poolInfo[arg1].field_1280
                if (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                if (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       -userInfo[arg1][address(arg2)].field_512
            if startBlock > block.number:
                revert with 0, 'SafeMath: subtraction overflow'
            if 1 > block.number - startBlock:
                revert with 0, 'SafeMath: subtraction overflow'
            if decayPeriod <= 0:
                revert with 0, 'SafeMath: division by zero'
            require decayPeriod
            if block.number + -startBlock - 1 / decayPeriod >= decayTable.length:
                revert with 0, 'phase not ready'
            if poolInfo[arg1].field_512 > block.number:
                revert with 0, 'SafeMath: subtraction overflow'
            if not block.number - poolInfo[arg1].field_512:
                if totalAllocPoint <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require totalAllocPoint
                if not 0 / totalAllocPoint:
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                    if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           -userInfo[arg1][address(arg2)].field_512
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if poolInfo[arg1].field_1280 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require poolInfo[arg1].field_1280
                if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       -userInfo[arg1][address(arg2)].field_512
            if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) / block.number - poolInfo[arg1].field_512 != decayTable[block.number + -stor12 - 1 / stor15]:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) < 0:
                revert with 0, 'SafeMath: addition overflow'
            if not (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15]):
                if totalAllocPoint <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require totalAllocPoint
                if not 0 / totalAllocPoint:
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                    if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           -userInfo[arg1][address(arg2)].field_512
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if poolInfo[arg1].field_1280 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require poolInfo[arg1].field_1280
                if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       -userInfo[arg1][address(arg2)].field_512
            if (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) != poolInfo[arg1].field_256:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if totalAllocPoint <= 0:
                revert with 0, 'SafeMath: division by zero'
            require totalAllocPoint
            if not (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint:
                if poolInfo[arg1].field_1280 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require poolInfo[arg1].field_1280
                if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       -userInfo[arg1][address(arg2)].field_512
            if 10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if poolInfo[arg1].field_1280 <= 0:
                revert with 0, 'SafeMath: division by zero'
            require poolInfo[arg1].field_1280
            if (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
            if (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return ((10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                   -userInfo[arg1][address(arg2)].field_512
        if poolInfo[arg1].field_512 <= startBlock:
            if 0 == decayPeriod:
                if 0 == decayPeriod:
                    if 0 >= decayTable.length:
                        revert with 0, 'phase not ready'
                    if poolInfo[arg1].field_512 > block.number:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not block.number - poolInfo[arg1].field_512:
                        if totalAllocPoint <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require totalAllocPoint
                        if not 0 / totalAllocPoint:
                            if poolInfo[arg1].field_1280 <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require poolInfo[arg1].field_1280
                            if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            if not userInfo[arg1][address(arg2)].field_0:
                                if userInfo[arg1][address(arg2)].field_256 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                            if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                                   -userInfo[arg1][address(arg2)].field_512
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                        if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               -userInfo[arg1][address(arg2)].field_512
                    if (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) / block.number - poolInfo[arg1].field_512 != decayTable:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    if not (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable):
                        if totalAllocPoint <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require totalAllocPoint
                        if not 0 / totalAllocPoint:
                            if poolInfo[arg1].field_1280 <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require poolInfo[arg1].field_1280
                            if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            if not userInfo[arg1][address(arg2)].field_0:
                                if userInfo[arg1][address(arg2)].field_256 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                            if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                                   -userInfo[arg1][address(arg2)].field_512
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                        if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               -userInfo[arg1][address(arg2)].field_512
                    if (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) != poolInfo[arg1].field_256:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint:
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                        if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               -userInfo[arg1][address(arg2)].field_512
                    if 10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                    if (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           -userInfo[arg1][address(arg2)].field_512
                if block.number <= startBlock:
                    if 0 >= decayTable.length:
                        revert with 0, 'phase not ready'
                    if poolInfo[arg1].field_512 > block.number:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not block.number - poolInfo[arg1].field_512:
                        if totalAllocPoint <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require totalAllocPoint
                        if not 0 / totalAllocPoint:
                            if poolInfo[arg1].field_1280 <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require poolInfo[arg1].field_1280
                            if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            if not userInfo[arg1][address(arg2)].field_0:
                                if userInfo[arg1][address(arg2)].field_256 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                            if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                                   -userInfo[arg1][address(arg2)].field_512
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                        if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               -userInfo[arg1][address(arg2)].field_512
                    if (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) / block.number - poolInfo[arg1].field_512 != decayTable:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    if not (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable):
                        if totalAllocPoint <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require totalAllocPoint
                        if not 0 / totalAllocPoint:
                            if poolInfo[arg1].field_1280 <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require poolInfo[arg1].field_1280
                            if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            if not userInfo[arg1][address(arg2)].field_0:
                                if userInfo[arg1][address(arg2)].field_256 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                            if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                                   -userInfo[arg1][address(arg2)].field_512
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                        if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               -userInfo[arg1][address(arg2)].field_512
                    if (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) != poolInfo[arg1].field_256:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint:
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                        if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               -userInfo[arg1][address(arg2)].field_512
                    if 10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                    if (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           -userInfo[arg1][address(arg2)].field_512
                if startBlock > block.number:
                    revert with 0, 'SafeMath: subtraction overflow'
                if 1 > block.number - startBlock:
                    revert with 0, 'SafeMath: subtraction overflow'
                if decayPeriod <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require decayPeriod
                if block.number + -startBlock - 1 / decayPeriod >= decayTable.length:
                    revert with 0, 'phase not ready'
                if poolInfo[arg1].field_512 > block.number:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not block.number - poolInfo[arg1].field_512:
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not 0 / totalAllocPoint:
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                        if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               -userInfo[arg1][address(arg2)].field_512
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           -userInfo[arg1][address(arg2)].field_512
                if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) / block.number - poolInfo[arg1].field_512 != decayTable[block.number + -stor12 - 1 / stor15]:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) < 0:
                    revert with 0, 'SafeMath: addition overflow'
                if not (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15]):
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not 0 / totalAllocPoint:
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                        if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               -userInfo[arg1][address(arg2)].field_512
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           -userInfo[arg1][address(arg2)].field_512
                if (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) != poolInfo[arg1].field_256:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if totalAllocPoint <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require totalAllocPoint
                if not (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint:
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                    if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           -userInfo[arg1][address(arg2)].field_512
                if 10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if poolInfo[arg1].field_1280 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require poolInfo[arg1].field_1280
                if (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                if (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       -userInfo[arg1][address(arg2)].field_512
            if block.number <= startBlock:
                if 0 == decayPeriod:
                    if 0 >= decayTable.length:
                        revert with 0, 'phase not ready'
                    if poolInfo[arg1].field_512 > block.number:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not block.number - poolInfo[arg1].field_512:
                        if totalAllocPoint <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require totalAllocPoint
                        if not 0 / totalAllocPoint:
                            if poolInfo[arg1].field_1280 <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require poolInfo[arg1].field_1280
                            if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            if not userInfo[arg1][address(arg2)].field_0:
                                if userInfo[arg1][address(arg2)].field_256 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                            if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                                   -userInfo[arg1][address(arg2)].field_512
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                        if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               -userInfo[arg1][address(arg2)].field_512
                    if (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) / block.number - poolInfo[arg1].field_512 != decayTable:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    if not (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable):
                        if totalAllocPoint <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require totalAllocPoint
                        if not 0 / totalAllocPoint:
                            if poolInfo[arg1].field_1280 <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require poolInfo[arg1].field_1280
                            if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            if not userInfo[arg1][address(arg2)].field_0:
                                if userInfo[arg1][address(arg2)].field_256 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                            if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                                   -userInfo[arg1][address(arg2)].field_512
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                        if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               -userInfo[arg1][address(arg2)].field_512
                    if (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) != poolInfo[arg1].field_256:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint:
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                        if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               -userInfo[arg1][address(arg2)].field_512
                    if 10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                    if (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           -userInfo[arg1][address(arg2)].field_512
                if block.number <= startBlock:
                    if 0 >= decayTable.length:
                        revert with 0, 'phase not ready'
                    if poolInfo[arg1].field_512 > block.number:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not block.number - poolInfo[arg1].field_512:
                        if totalAllocPoint <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require totalAllocPoint
                        if not 0 / totalAllocPoint:
                            if poolInfo[arg1].field_1280 <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require poolInfo[arg1].field_1280
                            if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            if not userInfo[arg1][address(arg2)].field_0:
                                if userInfo[arg1][address(arg2)].field_256 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                            if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                                   -userInfo[arg1][address(arg2)].field_512
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                        if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               -userInfo[arg1][address(arg2)].field_512
                    if (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) / block.number - poolInfo[arg1].field_512 != decayTable:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    if not (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable):
                        if totalAllocPoint <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require totalAllocPoint
                        if not 0 / totalAllocPoint:
                            if poolInfo[arg1].field_1280 <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require poolInfo[arg1].field_1280
                            if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            if not userInfo[arg1][address(arg2)].field_0:
                                if userInfo[arg1][address(arg2)].field_256 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                            if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                                   -userInfo[arg1][address(arg2)].field_512
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                        if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               -userInfo[arg1][address(arg2)].field_512
                    if (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) != poolInfo[arg1].field_256:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint:
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                        if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               -userInfo[arg1][address(arg2)].field_512
                    if 10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                    if (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           -userInfo[arg1][address(arg2)].field_512
                if startBlock > block.number:
                    revert with 0, 'SafeMath: subtraction overflow'
                if 1 > block.number - startBlock:
                    revert with 0, 'SafeMath: subtraction overflow'
                if decayPeriod <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require decayPeriod
                if block.number + -startBlock - 1 / decayPeriod >= decayTable.length:
                    revert with 0, 'phase not ready'
                if poolInfo[arg1].field_512 > block.number:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not block.number - poolInfo[arg1].field_512:
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not 0 / totalAllocPoint:
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                        if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               -userInfo[arg1][address(arg2)].field_512
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           -userInfo[arg1][address(arg2)].field_512
                if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) / block.number - poolInfo[arg1].field_512 != decayTable[block.number + -stor12 - 1 / stor15]:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) < 0:
                    revert with 0, 'SafeMath: addition overflow'
                if not (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15]):
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not 0 / totalAllocPoint:
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                        if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               -userInfo[arg1][address(arg2)].field_512
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           -userInfo[arg1][address(arg2)].field_512
                if (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) != poolInfo[arg1].field_256:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if totalAllocPoint <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require totalAllocPoint
                if not (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint:
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                    if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           -userInfo[arg1][address(arg2)].field_512
                if 10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if poolInfo[arg1].field_1280 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require poolInfo[arg1].field_1280
                if (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                if (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       -userInfo[arg1][address(arg2)].field_512
            if startBlock > block.number:
                revert with 0, 'SafeMath: subtraction overflow'
            if 1 > block.number - startBlock:
                revert with 0, 'SafeMath: subtraction overflow'
            if decayPeriod <= 0:
                revert with 0, 'SafeMath: division by zero'
            require decayPeriod
            idx = 0
            s = poolInfo[arg1].field_512
            while idx < block.number + -startBlock - 1 / decayPeriod:
                if not idx + 1:
                    if startBlock < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    if decayPeriod != 0:
                        if startBlock > startBlock:
                            revert with 0, 'SafeMath: subtraction overflow'
                    if 0 >= decayTable.length:
                        revert with 0, 'phase not ready'
                    mem[0] = 17
                    if s > startBlock:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if startBlock - s:
                        if (startBlock * decayTable) - (s * decayTable) / startBlock - s != decayTable:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if (startBlock * decayTable) - (s * decayTable) < 0:
                            revert with 0, 'SafeMath: addition overflow'
                    idx = idx + 1
                    s = startBlock
                    continue 
                if decayPeriod + (idx * decayPeriod) / idx + 1 != decayPeriod:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if startBlock < 0:
                    revert with 0, 'SafeMath: addition overflow'
                if 0 == decayPeriod:
                    if 0 >= decayTable.length:
                        revert with 0, 'phase not ready'
                    mem[0] = 17
                    if s > startBlock + decayPeriod + (idx * decayPeriod):
                        revert with 0, 'SafeMath: subtraction overflow'
                    if startBlock + decayPeriod + (idx * decayPeriod) - s:
                        if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) / startBlock + decayPeriod + (idx * decayPeriod) - s != decayTable:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) < 0:
                            revert with 0, 'SafeMath: addition overflow'
                else:
                    if startBlock + decayPeriod + (idx * decayPeriod) <= startBlock:
                        if 0 >= decayTable.length:
                            revert with 0, 'phase not ready'
                        mem[0] = 17
                        if s > startBlock + decayPeriod + (idx * decayPeriod):
                            revert with 0, 'SafeMath: subtraction overflow'
                        if startBlock + decayPeriod + (idx * decayPeriod) - s:
                            if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) / startBlock + decayPeriod + (idx * decayPeriod) - s != decayTable:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) < 0:
                                revert with 0, 'SafeMath: addition overflow'
                    else:
                        if startBlock > startBlock + decayPeriod + (idx * decayPeriod):
                            revert with 0, 'SafeMath: subtraction overflow'
                        if 1 > decayPeriod + (idx * decayPeriod):
                            revert with 0, 'SafeMath: subtraction overflow'
                        if decayPeriod <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require decayPeriod
                        if decayPeriod + (idx * decayPeriod) - 1 / decayPeriod >= decayTable.length:
                            revert with 0, 'phase not ready'
                        mem[0] = 17
                        if s > startBlock + decayPeriod + (idx * decayPeriod):
                            revert with 0, 'SafeMath: subtraction overflow'
                        if startBlock + decayPeriod + (idx * decayPeriod) - s:
                            if (startBlock * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (idx * decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) - (s * decayTable[stor15 + (idx * stor15) - 1 / stor15]) / startBlock + decayPeriod + (idx * decayPeriod) - s != decayTable[stor15 + (idx * stor15) - 1 / stor15]:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if (startBlock * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (idx * decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) - (s * decayTable[stor15 + (idx * stor15) - 1 / stor15]) < 0:
                                revert with 0, 'SafeMath: addition overflow'
                idx = idx + 1
                s = startBlock + decayPeriod + (idx * decayPeriod)
                continue 
        else:
            if startBlock > poolInfo[arg1].field_512:
                revert with 0, 'SafeMath: subtraction overflow'
            if 1 > poolInfo[arg1].field_512 - startBlock:
                revert with 0, 'SafeMath: subtraction overflow'
            if decayPeriod <= 0:
                revert with 0, 'SafeMath: division by zero'
            require decayPeriod
            if 0 == decayPeriod:
                idx = poolInfo[arg1].field_512 + -startBlock - 1 / decayPeriod
                s = poolInfo[arg1].field_512
                while idx < 0:
                    if not idx + 1:
                        if startBlock < 0:
                            revert with 0, 'SafeMath: addition overflow'
                        if decayPeriod != 0:
                            if startBlock > startBlock:
                                revert with 0, 'SafeMath: subtraction overflow'
                        if 0 >= decayTable.length:
                            revert with 0, 'phase not ready'
                        mem[0] = 17
                        if s > startBlock:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if startBlock - s:
                            if (startBlock * decayTable) - (s * decayTable) / startBlock - s != decayTable:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if (startBlock * decayTable) - (s * decayTable) < 0:
                                revert with 0, 'SafeMath: addition overflow'
                        idx = idx + 1
                        s = startBlock
                        continue 
                    if decayPeriod + (idx * decayPeriod) / idx + 1 != decayPeriod:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if startBlock < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    if 0 == decayPeriod:
                        if 0 >= decayTable.length:
                            revert with 0, 'phase not ready'
                        mem[0] = 17
                        if s > startBlock + decayPeriod + (idx * decayPeriod):
                            revert with 0, 'SafeMath: subtraction overflow'
                        if startBlock + decayPeriod + (idx * decayPeriod) - s:
                            if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) / startBlock + decayPeriod + (idx * decayPeriod) - s != decayTable:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) < 0:
                                revert with 0, 'SafeMath: addition overflow'
                    else:
                        if startBlock + decayPeriod + (idx * decayPeriod) <= startBlock:
                            if 0 >= decayTable.length:
                                revert with 0, 'phase not ready'
                            mem[0] = 17
                            if s > startBlock + decayPeriod + (idx * decayPeriod):
                                revert with 0, 'SafeMath: subtraction overflow'
                            if startBlock + decayPeriod + (idx * decayPeriod) - s:
                                if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) / startBlock + decayPeriod + (idx * decayPeriod) - s != decayTable:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                        else:
                            if startBlock > startBlock + decayPeriod + (idx * decayPeriod):
                                revert with 0, 'SafeMath: subtraction overflow'
                            if 1 > decayPeriod + (idx * decayPeriod):
                                revert with 0, 'SafeMath: subtraction overflow'
                            if decayPeriod <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require decayPeriod
                            if decayPeriod + (idx * decayPeriod) - 1 / decayPeriod >= decayTable.length:
                                revert with 0, 'phase not ready'
                            mem[0] = 17
                            if s > startBlock + decayPeriod + (idx * decayPeriod):
                                revert with 0, 'SafeMath: subtraction overflow'
                            if startBlock + decayPeriod + (idx * decayPeriod) - s:
                                if (startBlock * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (idx * decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) - (s * decayTable[stor15 + (idx * stor15) - 1 / stor15]) / startBlock + decayPeriod + (idx * decayPeriod) - s != decayTable[stor15 + (idx * stor15) - 1 / stor15]:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                if (startBlock * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (idx * decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) - (s * decayTable[stor15 + (idx * stor15) - 1 / stor15]) < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                    idx = idx + 1
                    s = startBlock + decayPeriod + (idx * decayPeriod)
                    continue 
            else:
                if block.number <= startBlock:
                    idx = poolInfo[arg1].field_512 + -startBlock - 1 / decayPeriod
                    s = poolInfo[arg1].field_512
                    while idx < 0:
                        if not idx + 1:
                            if startBlock < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if decayPeriod != 0:
                                if startBlock > startBlock:
                                    revert with 0, 'SafeMath: subtraction overflow'
                            if 0 >= decayTable.length:
                                revert with 0, 'phase not ready'
                            mem[0] = 17
                            if s > startBlock:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if startBlock - s:
                                if (startBlock * decayTable) - (s * decayTable) / startBlock - s != decayTable:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                if (startBlock * decayTable) - (s * decayTable) < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                            idx = idx + 1
                            s = startBlock
                            continue 
                        if decayPeriod + (idx * decayPeriod) / idx + 1 != decayPeriod:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if startBlock < 0:
                            revert with 0, 'SafeMath: addition overflow'
                        if 0 == decayPeriod:
                            if 0 >= decayTable.length:
                                revert with 0, 'phase not ready'
                            mem[0] = 17
                            if s > startBlock + decayPeriod + (idx * decayPeriod):
                                revert with 0, 'SafeMath: subtraction overflow'
                            if startBlock + decayPeriod + (idx * decayPeriod) - s:
                                if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) / startBlock + decayPeriod + (idx * decayPeriod) - s != decayTable:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                        else:
                            if startBlock + decayPeriod + (idx * decayPeriod) <= startBlock:
                                if 0 >= decayTable.length:
                                    revert with 0, 'phase not ready'
                                mem[0] = 17
                                if s > startBlock + decayPeriod + (idx * decayPeriod):
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if startBlock + decayPeriod + (idx * decayPeriod) - s:
                                    if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) / startBlock + decayPeriod + (idx * decayPeriod) - s != decayTable:
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                    32,
                                                    33,
                                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[197 len 31]
                                    if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                            else:
                                if startBlock > startBlock + decayPeriod + (idx * decayPeriod):
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if 1 > decayPeriod + (idx * decayPeriod):
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if decayPeriod <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require decayPeriod
                                if decayPeriod + (idx * decayPeriod) - 1 / decayPeriod >= decayTable.length:
                                    revert with 0, 'phase not ready'
                                mem[0] = 17
                                if s > startBlock + decayPeriod + (idx * decayPeriod):
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if startBlock + decayPeriod + (idx * decayPeriod) - s:
                                    if (startBlock * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (idx * decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) - (s * decayTable[stor15 + (idx * stor15) - 1 / stor15]) / startBlock + decayPeriod + (idx * decayPeriod) - s != decayTable[stor15 + (idx * stor15) - 1 / stor15]:
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                    32,
                                                    33,
                                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[197 len 31]
                                    if (startBlock * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (idx * decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) - (s * decayTable[stor15 + (idx * stor15) - 1 / stor15]) < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                        idx = idx + 1
                        s = startBlock + decayPeriod + (idx * decayPeriod)
                        continue 
                else:
                    if startBlock > block.number:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if 1 > block.number - startBlock:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if decayPeriod <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require decayPeriod
                    idx = poolInfo[arg1].field_512 + -startBlock - 1 / decayPeriod
                    s = poolInfo[arg1].field_512
                    while idx < block.number + -startBlock - 1 / decayPeriod:
                        if not idx + 1:
                            if startBlock < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if decayPeriod != 0:
                                if startBlock > startBlock:
                                    revert with 0, 'SafeMath: subtraction overflow'
                            if 0 >= decayTable.length:
                                revert with 0, 'phase not ready'
                            mem[0] = 17
                            if s > startBlock:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if startBlock - s:
                                if (startBlock * decayTable) - (s * decayTable) / startBlock - s != decayTable:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                if (startBlock * decayTable) - (s * decayTable) < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                            idx = idx + 1
                            s = startBlock
                            continue 
                        if decayPeriod + (idx * decayPeriod) / idx + 1 != decayPeriod:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if startBlock < 0:
                            revert with 0, 'SafeMath: addition overflow'
                        if 0 == decayPeriod:
                            if 0 >= decayTable.length:
                                revert with 0, 'phase not ready'
                            mem[0] = 17
                            if s > startBlock + decayPeriod + (idx * decayPeriod):
                                revert with 0, 'SafeMath: subtraction overflow'
                            if startBlock + decayPeriod + (idx * decayPeriod) - s:
                                if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) / startBlock + decayPeriod + (idx * decayPeriod) - s != decayTable:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                        else:
                            if startBlock + decayPeriod + (idx * decayPeriod) <= startBlock:
                                if 0 >= decayTable.length:
                                    revert with 0, 'phase not ready'
                                mem[0] = 17
                                if s > startBlock + decayPeriod + (idx * decayPeriod):
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if startBlock + decayPeriod + (idx * decayPeriod) - s:
                                    if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) / startBlock + decayPeriod + (idx * decayPeriod) - s != decayTable:
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                    32,
                                                    33,
                                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[197 len 31]
                                    if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                            else:
                                if startBlock > startBlock + decayPeriod + (idx * decayPeriod):
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if 1 > decayPeriod + (idx * decayPeriod):
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if decayPeriod <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require decayPeriod
                                if decayPeriod + (idx * decayPeriod) - 1 / decayPeriod >= decayTable.length:
                                    revert with 0, 'phase not ready'
                                mem[0] = 17
                                if s > startBlock + decayPeriod + (idx * decayPeriod):
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if startBlock + decayPeriod + (idx * decayPeriod) - s:
                                    if (startBlock * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (idx * decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) - (s * decayTable[stor15 + (idx * stor15) - 1 / stor15]) / startBlock + decayPeriod + (idx * decayPeriod) - s != decayTable[stor15 + (idx * stor15) - 1 / stor15]:
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                    32,
                                                    33,
                                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[197 len 31]
                                    if (startBlock * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (idx * decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) - (s * decayTable[stor15 + (idx * stor15) - 1 / stor15]) < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                        idx = idx + 1
                        s = startBlock + decayPeriod + (idx * decayPeriod)
                        continue 
        if 0 == decayPeriod:
            if 0 >= decayTable.length:
                revert with 0, 'phase not ready'
            if s > block.number:
                revert with 0, 'SafeMath: subtraction overflow'
            if not block.number - s:
                if totalAllocPoint <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require totalAllocPoint
                if not 0 / totalAllocPoint:
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                    if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           -userInfo[arg1][address(arg2)].field_512
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if poolInfo[arg1].field_1280 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require poolInfo[arg1].field_1280
                if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       -userInfo[arg1][address(arg2)].field_512
            if (block.number * decayTable) - (s * decayTable) / block.number - s != decayTable:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if (block.number * decayTable) - (s * decayTable) < 0:
                revert with 0, 'SafeMath: addition overflow'
            if not (block.number * decayTable) - (s * decayTable):
                if totalAllocPoint <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require totalAllocPoint
                if not 0 / totalAllocPoint:
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                    if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           -userInfo[arg1][address(arg2)].field_512
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if poolInfo[arg1].field_1280 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require poolInfo[arg1].field_1280
                if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       -userInfo[arg1][address(arg2)].field_512
            if (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / (block.number * decayTable) - (s * decayTable) != poolInfo[arg1].field_256:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if totalAllocPoint <= 0:
                revert with 0, 'SafeMath: division by zero'
            require totalAllocPoint
            if not (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint:
                if poolInfo[arg1].field_1280 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require poolInfo[arg1].field_1280
                if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       -userInfo[arg1][address(arg2)].field_512
            if 10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if poolInfo[arg1].field_1280 <= 0:
                revert with 0, 'SafeMath: division by zero'
            require poolInfo[arg1].field_1280
            if (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
            if (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return ((10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                   -userInfo[arg1][address(arg2)].field_512
        if block.number <= startBlock:
            if 0 >= decayTable.length:
                revert with 0, 'phase not ready'
            if s > block.number:
                revert with 0, 'SafeMath: subtraction overflow'
            if not block.number - s:
                if totalAllocPoint <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require totalAllocPoint
                if not 0 / totalAllocPoint:
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                    if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           -userInfo[arg1][address(arg2)].field_512
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if poolInfo[arg1].field_1280 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require poolInfo[arg1].field_1280
                if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       -userInfo[arg1][address(arg2)].field_512
            if (block.number * decayTable) - (s * decayTable) / block.number - s != decayTable:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if (block.number * decayTable) - (s * decayTable) < 0:
                revert with 0, 'SafeMath: addition overflow'
            if not (block.number * decayTable) - (s * decayTable):
                if totalAllocPoint <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require totalAllocPoint
                if not 0 / totalAllocPoint:
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                    if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           -userInfo[arg1][address(arg2)].field_512
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if poolInfo[arg1].field_1280 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require poolInfo[arg1].field_1280
                if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       -userInfo[arg1][address(arg2)].field_512
            if (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / (block.number * decayTable) - (s * decayTable) != poolInfo[arg1].field_256:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if totalAllocPoint <= 0:
                revert with 0, 'SafeMath: division by zero'
            require totalAllocPoint
            if not (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint:
                if poolInfo[arg1].field_1280 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require poolInfo[arg1].field_1280
                if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       -userInfo[arg1][address(arg2)].field_512
            if 10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if poolInfo[arg1].field_1280 <= 0:
                revert with 0, 'SafeMath: division by zero'
            require poolInfo[arg1].field_1280
            if (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
            if (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return ((10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                   -userInfo[arg1][address(arg2)].field_512
        if startBlock > block.number:
            revert with 0, 'SafeMath: subtraction overflow'
        if 1 > block.number - startBlock:
            revert with 0, 'SafeMath: subtraction overflow'
        if decayPeriod <= 0:
            revert with 0, 'SafeMath: division by zero'
        require decayPeriod
        if block.number + -startBlock - 1 / decayPeriod >= decayTable.length:
            revert with 0, 'phase not ready'
        if s > block.number:
            revert with 0, 'SafeMath: subtraction overflow'
        if not block.number - s:
            if totalAllocPoint <= 0:
                revert with 0, 'SafeMath: division by zero'
            require totalAllocPoint
            if not 0 / totalAllocPoint:
                if poolInfo[arg1].field_1280 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require poolInfo[arg1].field_1280
                if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       -userInfo[arg1][address(arg2)].field_512
            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if poolInfo[arg1].field_1280 <= 0:
                revert with 0, 'SafeMath: division by zero'
            require poolInfo[arg1].field_1280
            if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
            if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                   -userInfo[arg1][address(arg2)].field_512
        if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (s * decayTable[block.number + -stor12 - 1 / stor15]) / block.number - s != decayTable[block.number + -stor12 - 1 / stor15]:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        33,
                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[197 len 31]
        if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (s * decayTable[block.number + -stor12 - 1 / stor15]) < 0:
            revert with 0, 'SafeMath: addition overflow'
        if not (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (s * decayTable[block.number + -stor12 - 1 / stor15]):
            if totalAllocPoint <= 0:
                revert with 0, 'SafeMath: division by zero'
            require totalAllocPoint
            if not 0 / totalAllocPoint:
                if poolInfo[arg1].field_1280 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require poolInfo[arg1].field_1280
                if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
                if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       -userInfo[arg1][address(arg2)].field_512
            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if poolInfo[arg1].field_1280 <= 0:
                revert with 0, 'SafeMath: division by zero'
            require poolInfo[arg1].field_1280
            if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
            if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                   -userInfo[arg1][address(arg2)].field_512
        if (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (s * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (s * decayTable[block.number + -stor12 - 1 / stor15]) != poolInfo[arg1].field_256:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        33,
                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[197 len 31]
        if totalAllocPoint <= 0:
            revert with 0, 'SafeMath: division by zero'
        require totalAllocPoint
        if not (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (s * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint:
            if poolInfo[arg1].field_1280 <= 0:
                revert with 0, 'SafeMath: division by zero'
            require poolInfo[arg1].field_1280
            if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
            if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                   -userInfo[arg1][address(arg2)].field_512
        if 10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (s * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (s * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        33,
                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[197 len 31]
        if poolInfo[arg1].field_1280 <= 0:
            revert with 0, 'SafeMath: division by zero'
        require poolInfo[arg1].field_1280
        if (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (s * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
            revert with 0, 'SafeMath: addition overflow'
        if not userInfo[arg1][address(arg2)].field_0:
            if userInfo[arg1][address(arg2)].field_256 > 0:
                revert with 0, 'SafeMath: subtraction overflow'
            return -userInfo[arg1][address(arg2)].field_256, -userInfo[arg1][address(arg2)].field_512
        if (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (s * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (s * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        33,
                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[197 len 31]
        if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (s * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
            revert with 0, 'SafeMath: subtraction overflow'
        return ((10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (s * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
               -userInfo[arg1][address(arg2)].field_512
    if (10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280) + poolInfo[arg1].field_1024:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    33,
                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                    mem[197 len 31]
    if userInfo[arg1][address(arg2)].field_512 > (10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12:
        revert with 0, 'SafeMath: subtraction overflow'
    if block.number <= poolInfo[arg1].field_512:
        if poolInfo[arg1].field_512 != block.number:
            return 0
        if not userInfo[arg1][address(arg2)].field_0:
            if userInfo[arg1][address(arg2)].field_256 > 0:
                revert with 0, 'SafeMath: subtraction overflow'
            return -userInfo[arg1][address(arg2)].field_256, 
                   ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
        if poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0 / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        33,
                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[197 len 31]
        if userInfo[arg1][address(arg2)].field_256 > poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0 / 10^12:
            revert with 0, 'SafeMath: subtraction overflow'
        return (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0 / 10^12) - userInfo[arg1][address(arg2)].field_256, 
               ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
    if 0 == decayPeriod:
        if 0 == decayPeriod:
            if 0 >= decayTable.length:
                revert with 0, 'phase not ready'
            if poolInfo[arg1].field_512 > block.number:
                revert with 0, 'SafeMath: subtraction overflow'
            if not block.number - poolInfo[arg1].field_512:
                if totalAllocPoint <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require totalAllocPoint
                if not 0 / totalAllocPoint:
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 
                               ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if poolInfo[arg1].field_1280 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require poolInfo[arg1].field_1280
                if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, 
                           ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) / block.number - poolInfo[arg1].field_512 != decayTable:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) < 0:
                revert with 0, 'SafeMath: addition overflow'
            if not (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable):
                if totalAllocPoint <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require totalAllocPoint
                if not 0 / totalAllocPoint:
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 
                               ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if poolInfo[arg1].field_1280 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require poolInfo[arg1].field_1280
                if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, 
                           ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) != poolInfo[arg1].field_256:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if totalAllocPoint <= 0:
                revert with 0, 'SafeMath: division by zero'
            require totalAllocPoint
            if not (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint:
                if poolInfo[arg1].field_1280 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require poolInfo[arg1].field_1280
                if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, 
                           ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if 10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if poolInfo[arg1].field_1280 <= 0:
                revert with 0, 'SafeMath: division by zero'
            require poolInfo[arg1].field_1280
            if (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256, 
                       ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return ((10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                   ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
        if block.number <= startBlock:
            if 0 >= decayTable.length:
                revert with 0, 'phase not ready'
            if poolInfo[arg1].field_512 > block.number:
                revert with 0, 'SafeMath: subtraction overflow'
            if not block.number - poolInfo[arg1].field_512:
                if totalAllocPoint <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require totalAllocPoint
                if not 0 / totalAllocPoint:
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 
                               ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if poolInfo[arg1].field_1280 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require poolInfo[arg1].field_1280
                if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, 
                           ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) / block.number - poolInfo[arg1].field_512 != decayTable:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) < 0:
                revert with 0, 'SafeMath: addition overflow'
            if not (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable):
                if totalAllocPoint <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require totalAllocPoint
                if not 0 / totalAllocPoint:
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 
                               ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if poolInfo[arg1].field_1280 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require poolInfo[arg1].field_1280
                if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, 
                           ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) != poolInfo[arg1].field_256:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if totalAllocPoint <= 0:
                revert with 0, 'SafeMath: division by zero'
            require totalAllocPoint
            if not (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint:
                if poolInfo[arg1].field_1280 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require poolInfo[arg1].field_1280
                if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, 
                           ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if 10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if poolInfo[arg1].field_1280 <= 0:
                revert with 0, 'SafeMath: division by zero'
            require poolInfo[arg1].field_1280
            if (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256, 
                       ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return ((10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                   ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
        if startBlock > block.number:
            revert with 0, 'SafeMath: subtraction overflow'
        if 1 > block.number - startBlock:
            revert with 0, 'SafeMath: subtraction overflow'
        if decayPeriod <= 0:
            revert with 0, 'SafeMath: division by zero'
        require decayPeriod
        if block.number + -startBlock - 1 / decayPeriod >= decayTable.length:
            revert with 0, 'phase not ready'
        if poolInfo[arg1].field_512 > block.number:
            revert with 0, 'SafeMath: subtraction overflow'
        if not block.number - poolInfo[arg1].field_512:
            if totalAllocPoint <= 0:
                revert with 0, 'SafeMath: division by zero'
            require totalAllocPoint
            if not 0 / totalAllocPoint:
                if poolInfo[arg1].field_1280 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require poolInfo[arg1].field_1280
                if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, 
                           ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if poolInfo[arg1].field_1280 <= 0:
                revert with 0, 'SafeMath: division by zero'
            require poolInfo[arg1].field_1280
            if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256, 
                       ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                   ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
        if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) / block.number - poolInfo[arg1].field_512 != decayTable[block.number + -stor12 - 1 / stor15]:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        33,
                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[197 len 31]
        if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) < 0:
            revert with 0, 'SafeMath: addition overflow'
        if not (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15]):
            if totalAllocPoint <= 0:
                revert with 0, 'SafeMath: division by zero'
            require totalAllocPoint
            if not 0 / totalAllocPoint:
                if poolInfo[arg1].field_1280 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require poolInfo[arg1].field_1280
                if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, 
                           ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if poolInfo[arg1].field_1280 <= 0:
                revert with 0, 'SafeMath: division by zero'
            require poolInfo[arg1].field_1280
            if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256, 
                       ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                   ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
        if (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) != poolInfo[arg1].field_256:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        33,
                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[197 len 31]
        if totalAllocPoint <= 0:
            revert with 0, 'SafeMath: division by zero'
        require totalAllocPoint
        if not (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint:
            if poolInfo[arg1].field_1280 <= 0:
                revert with 0, 'SafeMath: division by zero'
            require poolInfo[arg1].field_1280
            if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256, 
                       ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                   ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
        if 10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        33,
                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[197 len 31]
        if poolInfo[arg1].field_1280 <= 0:
            revert with 0, 'SafeMath: division by zero'
        require poolInfo[arg1].field_1280
        if (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
            revert with 0, 'SafeMath: addition overflow'
        if not userInfo[arg1][address(arg2)].field_0:
            if userInfo[arg1][address(arg2)].field_256 > 0:
                revert with 0, 'SafeMath: subtraction overflow'
            return -userInfo[arg1][address(arg2)].field_256, 
                   ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
        if (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        33,
                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[197 len 31]
        if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
            revert with 0, 'SafeMath: subtraction overflow'
        return ((10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
               ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
    if poolInfo[arg1].field_512 <= startBlock:
        if 0 == decayPeriod:
            if 0 == decayPeriod:
                if 0 >= decayTable.length:
                    revert with 0, 'phase not ready'
                if poolInfo[arg1].field_512 > block.number:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not block.number - poolInfo[arg1].field_512:
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not 0 / totalAllocPoint:
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, 
                                   ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                        if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 
                               ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) / block.number - poolInfo[arg1].field_512 != decayTable:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) < 0:
                    revert with 0, 'SafeMath: addition overflow'
                if not (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable):
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not 0 / totalAllocPoint:
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, 
                                   ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                        if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 
                               ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) != poolInfo[arg1].field_256:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if totalAllocPoint <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require totalAllocPoint
                if not (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint:
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 
                               ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if 10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if poolInfo[arg1].field_1280 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require poolInfo[arg1].field_1280
                if (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, 
                           ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if block.number <= startBlock:
                if 0 >= decayTable.length:
                    revert with 0, 'phase not ready'
                if poolInfo[arg1].field_512 > block.number:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not block.number - poolInfo[arg1].field_512:
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not 0 / totalAllocPoint:
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, 
                                   ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                        if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 
                               ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) / block.number - poolInfo[arg1].field_512 != decayTable:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) < 0:
                    revert with 0, 'SafeMath: addition overflow'
                if not (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable):
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not 0 / totalAllocPoint:
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, 
                                   ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                        if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 
                               ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) != poolInfo[arg1].field_256:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if totalAllocPoint <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require totalAllocPoint
                if not (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint:
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 
                               ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if 10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if poolInfo[arg1].field_1280 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require poolInfo[arg1].field_1280
                if (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, 
                           ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if startBlock > block.number:
                revert with 0, 'SafeMath: subtraction overflow'
            if 1 > block.number - startBlock:
                revert with 0, 'SafeMath: subtraction overflow'
            if decayPeriod <= 0:
                revert with 0, 'SafeMath: division by zero'
            require decayPeriod
            if block.number + -startBlock - 1 / decayPeriod >= decayTable.length:
                revert with 0, 'phase not ready'
            if poolInfo[arg1].field_512 > block.number:
                revert with 0, 'SafeMath: subtraction overflow'
            if not block.number - poolInfo[arg1].field_512:
                if totalAllocPoint <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require totalAllocPoint
                if not 0 / totalAllocPoint:
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 
                               ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if poolInfo[arg1].field_1280 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require poolInfo[arg1].field_1280
                if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, 
                           ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) / block.number - poolInfo[arg1].field_512 != decayTable[block.number + -stor12 - 1 / stor15]:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) < 0:
                revert with 0, 'SafeMath: addition overflow'
            if not (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15]):
                if totalAllocPoint <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require totalAllocPoint
                if not 0 / totalAllocPoint:
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 
                               ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if poolInfo[arg1].field_1280 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require poolInfo[arg1].field_1280
                if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, 
                           ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) != poolInfo[arg1].field_256:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if totalAllocPoint <= 0:
                revert with 0, 'SafeMath: division by zero'
            require totalAllocPoint
            if not (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint:
                if poolInfo[arg1].field_1280 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require poolInfo[arg1].field_1280
                if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, 
                           ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if 10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if poolInfo[arg1].field_1280 <= 0:
                revert with 0, 'SafeMath: division by zero'
            require poolInfo[arg1].field_1280
            if (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256, 
                       ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return ((10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                   ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
        if block.number <= startBlock:
            if 0 == decayPeriod:
                if 0 >= decayTable.length:
                    revert with 0, 'phase not ready'
                if poolInfo[arg1].field_512 > block.number:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not block.number - poolInfo[arg1].field_512:
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not 0 / totalAllocPoint:
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, 
                                   ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                        if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 
                               ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) / block.number - poolInfo[arg1].field_512 != decayTable:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) < 0:
                    revert with 0, 'SafeMath: addition overflow'
                if not (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable):
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not 0 / totalAllocPoint:
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, 
                                   ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                        if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 
                               ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) != poolInfo[arg1].field_256:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if totalAllocPoint <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require totalAllocPoint
                if not (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint:
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 
                               ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if 10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if poolInfo[arg1].field_1280 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require poolInfo[arg1].field_1280
                if (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, 
                           ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if block.number <= startBlock:
                if 0 >= decayTable.length:
                    revert with 0, 'phase not ready'
                if poolInfo[arg1].field_512 > block.number:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not block.number - poolInfo[arg1].field_512:
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not 0 / totalAllocPoint:
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, 
                                   ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                        if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 
                               ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) / block.number - poolInfo[arg1].field_512 != decayTable:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) < 0:
                    revert with 0, 'SafeMath: addition overflow'
                if not (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable):
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not 0 / totalAllocPoint:
                        if poolInfo[arg1].field_1280 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require poolInfo[arg1].field_1280
                        if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256, 
                                   ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                        if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 
                               ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / (block.number * decayTable) - (poolInfo[arg1].field_512 * decayTable) != poolInfo[arg1].field_256:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if totalAllocPoint <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require totalAllocPoint
                if not (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint:
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 
                               ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if 10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if poolInfo[arg1].field_1280 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require poolInfo[arg1].field_1280
                if (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, 
                           ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if startBlock > block.number:
                revert with 0, 'SafeMath: subtraction overflow'
            if 1 > block.number - startBlock:
                revert with 0, 'SafeMath: subtraction overflow'
            if decayPeriod <= 0:
                revert with 0, 'SafeMath: division by zero'
            require decayPeriod
            if block.number + -startBlock - 1 / decayPeriod >= decayTable.length:
                revert with 0, 'phase not ready'
            if poolInfo[arg1].field_512 > block.number:
                revert with 0, 'SafeMath: subtraction overflow'
            if not block.number - poolInfo[arg1].field_512:
                if totalAllocPoint <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require totalAllocPoint
                if not 0 / totalAllocPoint:
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 
                               ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if poolInfo[arg1].field_1280 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require poolInfo[arg1].field_1280
                if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, 
                           ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) / block.number - poolInfo[arg1].field_512 != decayTable[block.number + -stor12 - 1 / stor15]:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) < 0:
                revert with 0, 'SafeMath: addition overflow'
            if not (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15]):
                if totalAllocPoint <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require totalAllocPoint
                if not 0 / totalAllocPoint:
                    if poolInfo[arg1].field_1280 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require poolInfo[arg1].field_1280
                    if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256, 
                               ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                    if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if poolInfo[arg1].field_1280 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require poolInfo[arg1].field_1280
                if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, 
                           ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15]) != poolInfo[arg1].field_256:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if totalAllocPoint <= 0:
                revert with 0, 'SafeMath: division by zero'
            require totalAllocPoint
            if not (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint:
                if poolInfo[arg1].field_1280 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require poolInfo[arg1].field_1280
                if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, 
                           ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if 10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if poolInfo[arg1].field_1280 <= 0:
                revert with 0, 'SafeMath: division by zero'
            require poolInfo[arg1].field_1280
            if (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256, 
                       ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return ((10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                   ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
        if startBlock > block.number:
            revert with 0, 'SafeMath: subtraction overflow'
        if 1 > block.number - startBlock:
            revert with 0, 'SafeMath: subtraction overflow'
        if decayPeriod <= 0:
            revert with 0, 'SafeMath: division by zero'
        require decayPeriod
        idx = 0
        s = poolInfo[arg1].field_512
        while idx < block.number + -startBlock - 1 / decayPeriod:
            if not idx + 1:
                if startBlock < 0:
                    revert with 0, 'SafeMath: addition overflow'
                if decayPeriod != 0:
                    if startBlock > startBlock:
                        revert with 0, 'SafeMath: subtraction overflow'
                if 0 >= decayTable.length:
                    revert with 0, 'phase not ready'
                mem[0] = 17
                if s > startBlock:
                    revert with 0, 'SafeMath: subtraction overflow'
                if startBlock - s:
                    if (startBlock * decayTable) - (s * decayTable) / startBlock - s != decayTable:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if (startBlock * decayTable) - (s * decayTable) < 0:
                        revert with 0, 'SafeMath: addition overflow'
                idx = idx + 1
                s = startBlock
                continue 
            if decayPeriod + (idx * decayPeriod) / idx + 1 != decayPeriod:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if startBlock < 0:
                revert with 0, 'SafeMath: addition overflow'
            if 0 == decayPeriod:
                if 0 >= decayTable.length:
                    revert with 0, 'phase not ready'
                mem[0] = 17
                if s > startBlock + decayPeriod + (idx * decayPeriod):
                    revert with 0, 'SafeMath: subtraction overflow'
                if startBlock + decayPeriod + (idx * decayPeriod) - s:
                    if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) / startBlock + decayPeriod + (idx * decayPeriod) - s != decayTable:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) < 0:
                        revert with 0, 'SafeMath: addition overflow'
            else:
                if startBlock + decayPeriod + (idx * decayPeriod) <= startBlock:
                    if 0 >= decayTable.length:
                        revert with 0, 'phase not ready'
                    mem[0] = 17
                    if s > startBlock + decayPeriod + (idx * decayPeriod):
                        revert with 0, 'SafeMath: subtraction overflow'
                    if startBlock + decayPeriod + (idx * decayPeriod) - s:
                        if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) / startBlock + decayPeriod + (idx * decayPeriod) - s != decayTable:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) < 0:
                            revert with 0, 'SafeMath: addition overflow'
                else:
                    if startBlock > startBlock + decayPeriod + (idx * decayPeriod):
                        revert with 0, 'SafeMath: subtraction overflow'
                    if 1 > decayPeriod + (idx * decayPeriod):
                        revert with 0, 'SafeMath: subtraction overflow'
                    if decayPeriod <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require decayPeriod
                    if decayPeriod + (idx * decayPeriod) - 1 / decayPeriod >= decayTable.length:
                        revert with 0, 'phase not ready'
                    mem[0] = 17
                    if s > startBlock + decayPeriod + (idx * decayPeriod):
                        revert with 0, 'SafeMath: subtraction overflow'
                    if startBlock + decayPeriod + (idx * decayPeriod) - s:
                        if (startBlock * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (idx * decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) - (s * decayTable[stor15 + (idx * stor15) - 1 / stor15]) / startBlock + decayPeriod + (idx * decayPeriod) - s != decayTable[stor15 + (idx * stor15) - 1 / stor15]:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if (startBlock * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (idx * decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) - (s * decayTable[stor15 + (idx * stor15) - 1 / stor15]) < 0:
                            revert with 0, 'SafeMath: addition overflow'
            idx = idx + 1
            s = startBlock + decayPeriod + (idx * decayPeriod)
            continue 
    else:
        if startBlock > poolInfo[arg1].field_512:
            revert with 0, 'SafeMath: subtraction overflow'
        if 1 > poolInfo[arg1].field_512 - startBlock:
            revert with 0, 'SafeMath: subtraction overflow'
        if decayPeriod <= 0:
            revert with 0, 'SafeMath: division by zero'
        require decayPeriod
        if 0 == decayPeriod:
            idx = poolInfo[arg1].field_512 + -startBlock - 1 / decayPeriod
            s = poolInfo[arg1].field_512
            while idx < 0:
                if not idx + 1:
                    if startBlock < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    if decayPeriod != 0:
                        if startBlock > startBlock:
                            revert with 0, 'SafeMath: subtraction overflow'
                    if 0 >= decayTable.length:
                        revert with 0, 'phase not ready'
                    mem[0] = 17
                    if s > startBlock:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if startBlock - s:
                        if (startBlock * decayTable) - (s * decayTable) / startBlock - s != decayTable:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if (startBlock * decayTable) - (s * decayTable) < 0:
                            revert with 0, 'SafeMath: addition overflow'
                    idx = idx + 1
                    s = startBlock
                    continue 
                if decayPeriod + (idx * decayPeriod) / idx + 1 != decayPeriod:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if startBlock < 0:
                    revert with 0, 'SafeMath: addition overflow'
                if 0 == decayPeriod:
                    if 0 >= decayTable.length:
                        revert with 0, 'phase not ready'
                    mem[0] = 17
                    if s > startBlock + decayPeriod + (idx * decayPeriod):
                        revert with 0, 'SafeMath: subtraction overflow'
                    if startBlock + decayPeriod + (idx * decayPeriod) - s:
                        if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) / startBlock + decayPeriod + (idx * decayPeriod) - s != decayTable:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) < 0:
                            revert with 0, 'SafeMath: addition overflow'
                else:
                    if startBlock + decayPeriod + (idx * decayPeriod) <= startBlock:
                        if 0 >= decayTable.length:
                            revert with 0, 'phase not ready'
                        mem[0] = 17
                        if s > startBlock + decayPeriod + (idx * decayPeriod):
                            revert with 0, 'SafeMath: subtraction overflow'
                        if startBlock + decayPeriod + (idx * decayPeriod) - s:
                            if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) / startBlock + decayPeriod + (idx * decayPeriod) - s != decayTable:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) < 0:
                                revert with 0, 'SafeMath: addition overflow'
                    else:
                        if startBlock > startBlock + decayPeriod + (idx * decayPeriod):
                            revert with 0, 'SafeMath: subtraction overflow'
                        if 1 > decayPeriod + (idx * decayPeriod):
                            revert with 0, 'SafeMath: subtraction overflow'
                        if decayPeriod <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require decayPeriod
                        if decayPeriod + (idx * decayPeriod) - 1 / decayPeriod >= decayTable.length:
                            revert with 0, 'phase not ready'
                        mem[0] = 17
                        if s > startBlock + decayPeriod + (idx * decayPeriod):
                            revert with 0, 'SafeMath: subtraction overflow'
                        if startBlock + decayPeriod + (idx * decayPeriod) - s:
                            if (startBlock * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (idx * decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) - (s * decayTable[stor15 + (idx * stor15) - 1 / stor15]) / startBlock + decayPeriod + (idx * decayPeriod) - s != decayTable[stor15 + (idx * stor15) - 1 / stor15]:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if (startBlock * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (idx * decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) - (s * decayTable[stor15 + (idx * stor15) - 1 / stor15]) < 0:
                                revert with 0, 'SafeMath: addition overflow'
                idx = idx + 1
                s = startBlock + decayPeriod + (idx * decayPeriod)
                continue 
        else:
            if block.number <= startBlock:
                idx = poolInfo[arg1].field_512 + -startBlock - 1 / decayPeriod
                s = poolInfo[arg1].field_512
                while idx < 0:
                    if not idx + 1:
                        if startBlock < 0:
                            revert with 0, 'SafeMath: addition overflow'
                        if decayPeriod != 0:
                            if startBlock > startBlock:
                                revert with 0, 'SafeMath: subtraction overflow'
                        if 0 >= decayTable.length:
                            revert with 0, 'phase not ready'
                        mem[0] = 17
                        if s > startBlock:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if startBlock - s:
                            if (startBlock * decayTable) - (s * decayTable) / startBlock - s != decayTable:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if (startBlock * decayTable) - (s * decayTable) < 0:
                                revert with 0, 'SafeMath: addition overflow'
                        idx = idx + 1
                        s = startBlock
                        continue 
                    if decayPeriod + (idx * decayPeriod) / idx + 1 != decayPeriod:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if startBlock < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    if 0 == decayPeriod:
                        if 0 >= decayTable.length:
                            revert with 0, 'phase not ready'
                        mem[0] = 17
                        if s > startBlock + decayPeriod + (idx * decayPeriod):
                            revert with 0, 'SafeMath: subtraction overflow'
                        if startBlock + decayPeriod + (idx * decayPeriod) - s:
                            if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) / startBlock + decayPeriod + (idx * decayPeriod) - s != decayTable:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) < 0:
                                revert with 0, 'SafeMath: addition overflow'
                    else:
                        if startBlock + decayPeriod + (idx * decayPeriod) <= startBlock:
                            if 0 >= decayTable.length:
                                revert with 0, 'phase not ready'
                            mem[0] = 17
                            if s > startBlock + decayPeriod + (idx * decayPeriod):
                                revert with 0, 'SafeMath: subtraction overflow'
                            if startBlock + decayPeriod + (idx * decayPeriod) - s:
                                if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) / startBlock + decayPeriod + (idx * decayPeriod) - s != decayTable:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                        else:
                            if startBlock > startBlock + decayPeriod + (idx * decayPeriod):
                                revert with 0, 'SafeMath: subtraction overflow'
                            if 1 > decayPeriod + (idx * decayPeriod):
                                revert with 0, 'SafeMath: subtraction overflow'
                            if decayPeriod <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require decayPeriod
                            if decayPeriod + (idx * decayPeriod) - 1 / decayPeriod >= decayTable.length:
                                revert with 0, 'phase not ready'
                            mem[0] = 17
                            if s > startBlock + decayPeriod + (idx * decayPeriod):
                                revert with 0, 'SafeMath: subtraction overflow'
                            if startBlock + decayPeriod + (idx * decayPeriod) - s:
                                if (startBlock * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (idx * decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) - (s * decayTable[stor15 + (idx * stor15) - 1 / stor15]) / startBlock + decayPeriod + (idx * decayPeriod) - s != decayTable[stor15 + (idx * stor15) - 1 / stor15]:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                if (startBlock * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (idx * decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) - (s * decayTable[stor15 + (idx * stor15) - 1 / stor15]) < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                    idx = idx + 1
                    s = startBlock + decayPeriod + (idx * decayPeriod)
                    continue 
            else:
                if startBlock > block.number:
                    revert with 0, 'SafeMath: subtraction overflow'
                if 1 > block.number - startBlock:
                    revert with 0, 'SafeMath: subtraction overflow'
                if decayPeriod <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require decayPeriod
                idx = poolInfo[arg1].field_512 + -startBlock - 1 / decayPeriod
                s = poolInfo[arg1].field_512
                while idx < block.number + -startBlock - 1 / decayPeriod:
                    if not idx + 1:
                        if startBlock < 0:
                            revert with 0, 'SafeMath: addition overflow'
                        if decayPeriod != 0:
                            if startBlock > startBlock:
                                revert with 0, 'SafeMath: subtraction overflow'
                        if 0 >= decayTable.length:
                            revert with 0, 'phase not ready'
                        mem[0] = 17
                        if s > startBlock:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if startBlock - s:
                            if (startBlock * decayTable) - (s * decayTable) / startBlock - s != decayTable:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if (startBlock * decayTable) - (s * decayTable) < 0:
                                revert with 0, 'SafeMath: addition overflow'
                        idx = idx + 1
                        s = startBlock
                        continue 
                    if decayPeriod + (idx * decayPeriod) / idx + 1 != decayPeriod:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if startBlock < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    if 0 == decayPeriod:
                        if 0 >= decayTable.length:
                            revert with 0, 'phase not ready'
                        mem[0] = 17
                        if s > startBlock + decayPeriod + (idx * decayPeriod):
                            revert with 0, 'SafeMath: subtraction overflow'
                        if startBlock + decayPeriod + (idx * decayPeriod) - s:
                            if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) / startBlock + decayPeriod + (idx * decayPeriod) - s != decayTable:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) < 0:
                                revert with 0, 'SafeMath: addition overflow'
                    else:
                        if startBlock + decayPeriod + (idx * decayPeriod) <= startBlock:
                            if 0 >= decayTable.length:
                                revert with 0, 'phase not ready'
                            mem[0] = 17
                            if s > startBlock + decayPeriod + (idx * decayPeriod):
                                revert with 0, 'SafeMath: subtraction overflow'
                            if startBlock + decayPeriod + (idx * decayPeriod) - s:
                                if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) / startBlock + decayPeriod + (idx * decayPeriod) - s != decayTable:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                if (startBlock * decayTable) + (decayPeriod * decayTable) + (idx * decayPeriod * decayTable) - (s * decayTable) < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                        else:
                            if startBlock > startBlock + decayPeriod + (idx * decayPeriod):
                                revert with 0, 'SafeMath: subtraction overflow'
                            if 1 > decayPeriod + (idx * decayPeriod):
                                revert with 0, 'SafeMath: subtraction overflow'
                            if decayPeriod <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require decayPeriod
                            if decayPeriod + (idx * decayPeriod) - 1 / decayPeriod >= decayTable.length:
                                revert with 0, 'phase not ready'
                            mem[0] = 17
                            if s > startBlock + decayPeriod + (idx * decayPeriod):
                                revert with 0, 'SafeMath: subtraction overflow'
                            if startBlock + decayPeriod + (idx * decayPeriod) - s:
                                if (startBlock * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (idx * decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) - (s * decayTable[stor15 + (idx * stor15) - 1 / stor15]) / startBlock + decayPeriod + (idx * decayPeriod) - s != decayTable[stor15 + (idx * stor15) - 1 / stor15]:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                if (startBlock * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) + (idx * decayPeriod * decayTable[stor15 + (idx * stor15) - 1 / stor15]) - (s * decayTable[stor15 + (idx * stor15) - 1 / stor15]) < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                    idx = idx + 1
                    s = startBlock + decayPeriod + (idx * decayPeriod)
                    continue 
    if 0 == decayPeriod:
        if 0 >= decayTable.length:
            revert with 0, 'phase not ready'
        if s > block.number:
            revert with 0, 'SafeMath: subtraction overflow'
        if not block.number - s:
            if totalAllocPoint <= 0:
                revert with 0, 'SafeMath: division by zero'
            require totalAllocPoint
            if not 0 / totalAllocPoint:
                if poolInfo[arg1].field_1280 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require poolInfo[arg1].field_1280
                if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, 
                           ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if poolInfo[arg1].field_1280 <= 0:
                revert with 0, 'SafeMath: division by zero'
            require poolInfo[arg1].field_1280
            if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256, 
                       ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                   ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
        if (block.number * decayTable) - (s * decayTable) / block.number - s != decayTable:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        33,
                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[197 len 31]
        if (block.number * decayTable) - (s * decayTable) < 0:
            revert with 0, 'SafeMath: addition overflow'
        if not (block.number * decayTable) - (s * decayTable):
            if totalAllocPoint <= 0:
                revert with 0, 'SafeMath: division by zero'
            require totalAllocPoint
            if not 0 / totalAllocPoint:
                if poolInfo[arg1].field_1280 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require poolInfo[arg1].field_1280
                if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, 
                           ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if poolInfo[arg1].field_1280 <= 0:
                revert with 0, 'SafeMath: division by zero'
            require poolInfo[arg1].field_1280
            if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256, 
                       ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                   ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
        if (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / (block.number * decayTable) - (s * decayTable) != poolInfo[arg1].field_256:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        33,
                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[197 len 31]
        if totalAllocPoint <= 0:
            revert with 0, 'SafeMath: division by zero'
        require totalAllocPoint
        if not (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint:
            if poolInfo[arg1].field_1280 <= 0:
                revert with 0, 'SafeMath: division by zero'
            require poolInfo[arg1].field_1280
            if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256, 
                       ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                   ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
        if 10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        33,
                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[197 len 31]
        if poolInfo[arg1].field_1280 <= 0:
            revert with 0, 'SafeMath: division by zero'
        require poolInfo[arg1].field_1280
        if (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
            revert with 0, 'SafeMath: addition overflow'
        if not userInfo[arg1][address(arg2)].field_0:
            if userInfo[arg1][address(arg2)].field_256 > 0:
                revert with 0, 'SafeMath: subtraction overflow'
            return -userInfo[arg1][address(arg2)].field_256, 
                   ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
        if (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        33,
                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[197 len 31]
        if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
            revert with 0, 'SafeMath: subtraction overflow'
        return ((10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
               ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
    if block.number <= startBlock:
        if 0 >= decayTable.length:
            revert with 0, 'phase not ready'
        if s > block.number:
            revert with 0, 'SafeMath: subtraction overflow'
        if not block.number - s:
            if totalAllocPoint <= 0:
                revert with 0, 'SafeMath: division by zero'
            require totalAllocPoint
            if not 0 / totalAllocPoint:
                if poolInfo[arg1].field_1280 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require poolInfo[arg1].field_1280
                if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, 
                           ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if poolInfo[arg1].field_1280 <= 0:
                revert with 0, 'SafeMath: division by zero'
            require poolInfo[arg1].field_1280
            if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256, 
                       ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                   ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
        if (block.number * decayTable) - (s * decayTable) / block.number - s != decayTable:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        33,
                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[197 len 31]
        if (block.number * decayTable) - (s * decayTable) < 0:
            revert with 0, 'SafeMath: addition overflow'
        if not (block.number * decayTable) - (s * decayTable):
            if totalAllocPoint <= 0:
                revert with 0, 'SafeMath: division by zero'
            require totalAllocPoint
            if not 0 / totalAllocPoint:
                if poolInfo[arg1].field_1280 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require poolInfo[arg1].field_1280
                if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256, 
                           ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
                if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if poolInfo[arg1].field_1280 <= 0:
                revert with 0, 'SafeMath: division by zero'
            require poolInfo[arg1].field_1280
            if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256, 
                       ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                   ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
        if (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / (block.number * decayTable) - (s * decayTable) != poolInfo[arg1].field_256:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        33,
                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[197 len 31]
        if totalAllocPoint <= 0:
            revert with 0, 'SafeMath: division by zero'
        require totalAllocPoint
        if not (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint:
            if poolInfo[arg1].field_1280 <= 0:
                revert with 0, 'SafeMath: division by zero'
            require poolInfo[arg1].field_1280
            if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256, 
                       ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                   ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
        if 10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        33,
                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[197 len 31]
        if poolInfo[arg1].field_1280 <= 0:
            revert with 0, 'SafeMath: division by zero'
        require poolInfo[arg1].field_1280
        if (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
            revert with 0, 'SafeMath: addition overflow'
        if not userInfo[arg1][address(arg2)].field_0:
            if userInfo[arg1][address(arg2)].field_256 > 0:
                revert with 0, 'SafeMath: subtraction overflow'
            return -userInfo[arg1][address(arg2)].field_256, 
                   ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
        if (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        33,
                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[197 len 31]
        if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
            revert with 0, 'SafeMath: subtraction overflow'
        return ((10^12 * (block.number * decayTable * poolInfo[arg1].field_256) - (s * decayTable * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
               ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
    if startBlock > block.number:
        revert with 0, 'SafeMath: subtraction overflow'
    if 1 > block.number - startBlock:
        revert with 0, 'SafeMath: subtraction overflow'
    if decayPeriod <= 0:
        revert with 0, 'SafeMath: division by zero'
    require decayPeriod
    if block.number + -startBlock - 1 / decayPeriod >= decayTable.length:
        revert with 0, 'phase not ready'
    if s > block.number:
        revert with 0, 'SafeMath: subtraction overflow'
    if not block.number - s:
        if totalAllocPoint <= 0:
            revert with 0, 'SafeMath: division by zero'
        require totalAllocPoint
        if not 0 / totalAllocPoint:
            if poolInfo[arg1].field_1280 <= 0:
                revert with 0, 'SafeMath: division by zero'
            require poolInfo[arg1].field_1280
            if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256, 
                       ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                   ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        33,
                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[197 len 31]
        if poolInfo[arg1].field_1280 <= 0:
            revert with 0, 'SafeMath: division by zero'
        require poolInfo[arg1].field_1280
        if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
            revert with 0, 'SafeMath: addition overflow'
        if not userInfo[arg1][address(arg2)].field_0:
            if userInfo[arg1][address(arg2)].field_256 > 0:
                revert with 0, 'SafeMath: subtraction overflow'
            return -userInfo[arg1][address(arg2)].field_256, 
                   ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
        if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        33,
                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[197 len 31]
        if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
            revert with 0, 'SafeMath: subtraction overflow'
        return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
               ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
    if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (s * decayTable[block.number + -stor12 - 1 / stor15]) / block.number - s != decayTable[block.number + -stor12 - 1 / stor15]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    33,
                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                    mem[197 len 31]
    if (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (s * decayTable[block.number + -stor12 - 1 / stor15]) < 0:
        revert with 0, 'SafeMath: addition overflow'
    if not (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (s * decayTable[block.number + -stor12 - 1 / stor15]):
        if totalAllocPoint <= 0:
            revert with 0, 'SafeMath: division by zero'
        require totalAllocPoint
        if not 0 / totalAllocPoint:
            if poolInfo[arg1].field_1280 <= 0:
                revert with 0, 'SafeMath: division by zero'
            require poolInfo[arg1].field_1280
            if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256, 
                       ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
            if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                   ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        33,
                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[197 len 31]
        if poolInfo[arg1].field_1280 <= 0:
            revert with 0, 'SafeMath: division by zero'
        require poolInfo[arg1].field_1280
        if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
            revert with 0, 'SafeMath: addition overflow'
        if not userInfo[arg1][address(arg2)].field_0:
            if userInfo[arg1][address(arg2)].field_256 > 0:
                revert with 0, 'SafeMath: subtraction overflow'
            return -userInfo[arg1][address(arg2)].field_256, 
                   ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
        if (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        33,
                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[197 len 31]
        if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
            revert with 0, 'SafeMath: subtraction overflow'
        return ((10^12 * 0 / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
               ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
    if (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (s * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / (block.number * decayTable[block.number + -stor12 - 1 / stor15]) - (s * decayTable[block.number + -stor12 - 1 / stor15]) != poolInfo[arg1].field_256:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    33,
                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                    mem[197 len 31]
    if totalAllocPoint <= 0:
        revert with 0, 'SafeMath: division by zero'
    require totalAllocPoint
    if not (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (s * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint:
        if poolInfo[arg1].field_1280 <= 0:
            revert with 0, 'SafeMath: division by zero'
        require poolInfo[arg1].field_1280
        if (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
            revert with 0, 'SafeMath: addition overflow'
        if not userInfo[arg1][address(arg2)].field_0:
            if userInfo[arg1][address(arg2)].field_256 > 0:
                revert with 0, 'SafeMath: subtraction overflow'
            return -userInfo[arg1][address(arg2)].field_256, 
                   ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
        if (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        33,
                        0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[197 len 31]
        if userInfo[arg1][address(arg2)].field_256 > (0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
            revert with 0, 'SafeMath: subtraction overflow'
        return ((0 / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
               ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
    if 10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (s * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (s * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    33,
                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                    mem[197 len 31]
    if poolInfo[arg1].field_1280 <= 0:
        revert with 0, 'SafeMath: division by zero'
    require poolInfo[arg1].field_1280
    if (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (s * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
        revert with 0, 'SafeMath: addition overflow'
    if not userInfo[arg1][address(arg2)].field_0:
        if userInfo[arg1][address(arg2)].field_256 > 0:
            revert with 0, 'SafeMath: subtraction overflow'
        return -userInfo[arg1][address(arg2)].field_256, 
               ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
    if (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (s * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (s * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280) + poolInfo[arg1].field_768:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    33,
                    0x34536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                    mem[197 len 31]
    if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (s * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
        revert with 0, 'SafeMath: subtraction overflow'
    return ((10^12 * (block.number * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) - (s * decayTable[block.number + -stor12 - 1 / stor15] * poolInfo[arg1].field_256) / totalAllocPoint / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
           ((10^12 * ext_call.return_data[0] / poolInfo[arg1].field_1280 * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_1024 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_512
}



}
